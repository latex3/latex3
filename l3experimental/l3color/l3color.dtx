% \iffalse meta-comment
%
%% File: l3color.dtx
%
% Copyright (C) 2017-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "l3experimental bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver|package>
\RequirePackage{expl3}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{l3color} package\\ Experimental color support^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2020-06-18}
%
% \maketitle
%
% \begin{documentation}
%
% \section{Color models}
%
% A color \emph{model} is a way to represent sets of colors. Different models
% are particularly suitable for different output methods, \emph{e.g.}~screen
% or print. Parameter-based models can describe a very large number of unique
% colors, and have a varying number of \emph{axes} which define a color
% space. In contrast, various proprietary models are available which define
% \emph{spot} colors.
%
% Core models are used to pass color information to output; these are
% \enquote{native} to \pkg{l3color}. Core models use real numbers in the range
% $[0,1]$ to represent values. The core models supported here are
% \begin{itemize}
%   \item \texttt{gray} Grayscale color, with a single axis running from
%     $0$ (fully black) to $1$ (fully white)
%   \item \texttt{rgb} Red-green-blue color, with three axes, one for each of
%     the components
%   \item \texttt{cmyk} Cyan-magenta-yellow-black color, with four axes, one for
%     each of the components
%   \item \texttt{spot} Spot color, with one value, the name of the color
%     (see \url{https://helpx.adobe.com/indesign/using/spot-process-colors.html}
%     for details of the use of spot colors in print)
% \end{itemize}
% There are also interface models: these are convenient for users but have
% to be manipulated before storing/passing to the backend. Interface models
% are primarily integer-based: see below for more detail. The supported
% interface models are
% \begin{itemize}
%   \item \texttt{Hsb} Hue-saturation-brightness color, with three axes, integer
%     in the range $[0,360]$ for hue, real values in the range $[0,1]$ for
%     saturation and brightness
%   \item \texttt{HSB} Hue-saturation-brightness color, with three axes, integer
%     in the range $[0,360]$ for hue, integer values in the range $[0,255]$ for
%     saturation and brightness
%   \item \texttt{HTML} HTML format representation of RGB color given as a
%     single six-digit hexadecimal number
%   \item \texttt{RGB} Red-green-blue color, with three axes, one for each of
%     the components, values as integers from $0$ to $255$
% \end{itemize}
% All interface models are internally stored as |rgb|.
% 
% Additional models may be created to allow mixing of spot colors
% with each other or with those from other models. See
% Section~\ref{l3color:sec:spot} for more detail of spot color support.
%
% When color is selected by model, the \meta{values} given are specified as
% a comma-separated list. The length of the list will therefore be determined
% by the detail of the model involved.
%
% Color models (and interconversion) are complex, and more details are given
% in the manual to the \LaTeXe{} \pkg{xcolor} package and in the
% \emph{PostScript Language Reference Manual}, published by Addison--Wesley.
%
% \section{Color expressions}
%
% In addition to allowing specification of color by model and values,
% \pkg{l3color} also supports color expressions. These are created
% by combining one or more color names, with the amount of each specified
% as a percentage. The latter is given between |!| symbols in the expression.
% Thus for example
% \begin{verbatim}
%   red!50!green
% \end{verbatim}
% is a mixture of $50\,\%$ red and $50\,\%$ green. A trailing percentage is
% interpreted as implicitly followed by |white|, and so 
% \begin{verbatim}
%   red!25
% \end{verbatim}
% specifies $25\,\%$ red mixed with $75\,\%$ white.
%
% Where the models for the mixed colors are different, the model of the first
% color is used. Thus
% \begin{verbatim}
%   red!50!cyan
% \end{verbatim}
% will result in a color specification using the |rgb| model, made up of
% $50\,\%$ red and  $50\,\%$ of cyan \emph{expressed in \texttt{rgb}}. As color
% model interconversion is not exact.
%
% The one exception to the above is where the first model in an expression is
% |gray|. In this case, the order of mixing is \enquote{swapped} internally, so
% that for example
% \begin{verbatim}
%   black!50!red
% \end{verbatim}
% has the same result as
% \begin{verbatim}
%   red!50!black
% \end{verbatim}
% (the predefined colors |black| and |white| use the |gray| model).
%
% Where more than two colors are mixed in an expression, evaluation takes place
% in a stepwise fashion. Thus in
% \begin{verbatim}
%   cyan!50!magenta!10!yellow
% \end{verbatim}
% the sub-expression
% \begin{verbatim}
%   cyan!50!magenta
% \end{verbatim}
% is first evaluated to give an intermediate color specification, before
% the second step
% \begin{verbatim}
%   <intermediate>!10!yellow
% \end{verbatim}
% where |<intermediate>| represents this transitory calculated value.
%
% Within a color expression, |.| may be used to represent the color active
% for typesetting (the current color). This allows for example
% \begin{verbatim}
%   .!50
% \end{verbatim}
% to mean a mixture of $50\,\%$ of current color with white.
%
% (Color expressions supported here are a subset of those provided by
% the \LaTeXe{} \pkg{xcolor} package. At present, only such features as are
% clearly useful have been added here.)
%
% \section{Named colors}
%
% Color names are stored in a single namespace, which makes them accessible
% as part of color expressions. Whilst they are not reserved in a technical
% sense, the names |black|, |white|, |red|, |green|, |blue|, |cyan|, |magenta|
% and |yellow| have special meaning and should not be redefined. Color names
% should be made up of letters, numbers and spaces only: other characters are
% reserved for use in color expressions. In particular, |.| represents the
% current color at the start of a color expression.
%
% \begin{function}{\color_set:nn}
%   \begin{syntax}
%     \cs{color_set:nn} \Arg{name} \Arg{color expression}
%   \end{syntax}
%   Evaluates the \meta{color expression} and stores the resulting
%   color specification as the \meta{name}.
% \end{function}
%
% \begin{function}{\color_set:nnn}
%   \begin{syntax}
%     \cs{color_set:nnn} \Arg{name} \Arg{model(s)} \Arg{value(s)}
%   \end{syntax}
%   Stores the color specification equivalent to the \meta{model(s)} and
%   \meta{values} as the \meta{name}.
% \end{function}
%
% \begin{function}{\color_set_eq:nn}
%   \begin{syntax}
%     \cs{color_set_eq:nn} \Arg{name1} \Arg{name2}
%   \end{syntax}
%   Copies the color specification in \meta{name2} to \meta{name1}. The
%   special name |.| may be used to represent the current color, allowing
%   it to be saved to a name.
% \end{function}
%
% \begin{function}{\color_show:n}
%   \begin{syntax}
%     \cs{color_show:n} \Arg{name}
%   \end{syntax}
%   Displays the color specification stored in the \meta{name} on the
%   terminal.
% \end{function}
%
% \section{Selecting colors}
%
% \begin{function}{\color_select:n}
%   \begin{syntax}
%     \cs{color_select:n} \Arg{color expression}
%   \end{syntax}
%   Parses the \meta{color expression} and then activates the resulting
%   color specification for typeset material.
% \end{function}
%
% \begin{function}{\color_select:nn}
%   \begin{syntax}
%     \cs{color_select:nn} \Arg{model(s)} \Arg{value(s)}
%   \end{syntax}
%   Activates the color specification equivalent to the \meta{model(s)} and
%   \meta{value(s)} for typeset material.
% \end{function}
%
% \begin{variable}{\l_color_fixed_model_tl}
%   When this is set to a non-empty value, colors will be converted to
%   the specified model when they are selected. Note that included images
%   and similar are not influenced by this setting.
% \end{variable}
%
% \section{Multiple color models}
%
% When selecting or setting a color with an explicit model, it is possible
% to give values for more than one model at one time. This is particularly
% useful where automated conversion between models does not give the desired
% outcome. To do this, the list of models and list of values are both subdivided
% using |/| characters (as for the similar function in \pkg{xcolor}). For
% example, to save a color with explicit |cmyk| and |rgb| values, one could
% use
% \begin{verbatim}
%   \color_set:nnn { foo } { cmyk / rgb }
%     { 0.1 , 0.2 , 0.3 , 0.4 / 0.1, 0.2 , 0.3 }
% \end{verbatim}
% The manually-specified conversion will be used in preference to automated
% calculation whenever the model(s) listed are used: both in expressions and
% when a fixed model is active.
% 
% Similarly, the same syntax can be applied to directly selecting a color.
% \begin{verbatim}
%   \color_select:nn { cmyk / rgb }
%     { 0.1 , 0.2 , 0.3 , 0.4 / 0.1, 0.2 , 0.3 }
% \end{verbatim}
% Again, this list is used when a fixed model is active: the first entry is used
% unless there is a fixed model matching one of the other entries.
%
% \section{Exporting color specifications}
%
% The major use of color expressions is in setting typesetting output, but there
% are other places in which some form of color information is required. These
% may need data in a different format or using a different model to the internal
% representation. Thus a set of functions are available to export colors in
% different formats.
%
% Valid export targets are
% \begin{itemize}
%    \item \texttt{backend} Two brace groups: the first containing the
%      model, the second containing space-separated values appropriate
%      for the model; this is the format required by backend functions
%      of \pkg{expl3}
%    \item \texttt{HTML} Uppercase two-digit hexadecimal values, expressing
%      a red-green-blue color; the digits are \emph{not} separated
%    \item \texttt{space-sep-cmyk} Space-separated cyan-magenta-yellow-black
%      values
%    \item \texttt{space-sep-rgb} Space-separated red-green-blue values
%      suitable for use as a PDF annotation color
% \end{itemize}
%
% \begin{function}{\color_export:nnN}
%   \begin{syntax}
%     \cs{color_export:nnN} \Arg{color expression} \Arg{format} \Arg{tl}
%   \end{syntax}
%   Parses the \meta{color expression} as described earlier,
%   then converts to the \meta{format} specified and assigns the data to the
%   \meta{tl}.
% \end{function}
%
% \begin{function}{\color_export:nnN}
%   \begin{syntax}
%     \cs{color_export:nnnN} \Arg{model} \Arg{value(s)} \Arg{format} \Arg{tl}
%   \end{syntax}
%   Expresses the combination of \meta{model} and \meta{value(s)} in an
%   internal representation, then converts to the \meta{format} specified and
%   assigns the data to the \meta{tl}.
% \end{function}
%
% \section{Spot colors}
% \label{l3color:sec:spot}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3color} Implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=color>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage{l3color}{2020-06-18}{}
  {L3 Experimental color support}
%</package>
%    \end{macrocode}
%
% \subsection{Predefined color names}
%
% The ability to predefine colors with a name is a key part of this module and
% means there has to be a method for storing the results. At first sight, it
% seems natural to follow the usual \pkg{expl3} model and create a
% \texttt{color} variable type for the process. That would then allow both
% local and global colors, constant colors and the like. However, these names
% need to be accessible in some form at the user level, for selection of colors
% either simply by name or as part of a more complex expression. This does not
% require that the full name is exposed but does require that they can be
% looked up in a predictable way. As such, it is more useful to expose just the
% color names as part of the interface, with the result that only local color
% names can be created. (This is also seen for example in key creation in
% \pkg{l3keys}.) As a result, color names are declarative (no \texttt{new}
% functions).
%
% Since there is no need to manipulate colors \emph{en masse}, each is stored
% in a two-part structure: a \texttt{prop} for the colors themselves, and a
% \texttt{tl} for the default model for each color.
%
% \subsection{Setup}
%
% \begin{variable}{\l_@@_internal_tl}
%    \begin{macrocode}
\tl_new:N \l_@@_internal_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\s_@@_mark}
%   Internal scan marks. \cs{s_@@_stop} is already defined in \pkg{l3color-base}.
%    \begin{macrocode}
\scan_new:N \s_@@_mark
%    \end{macrocode}
% \end{variable}
%
% \subsection{Utility functions}
%
% \begin{macro}[int, TF, EXP]{\@@_if_defined:n}
%   A simple wrapper to avoid needing to have the lookup repeated in too many
%   places.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_defined:n #1 { T, F, TF }
  {
    \prop_if_exist:cTF { l_@@_named_ #1 _prop }
      \prg_return_true:
      \prg_return_false:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_model:N, \@@_values:N}
%   Simple abstractions.
%    \begin{macrocode}
\cs_new:Npn \@@_model:N #1 { \exp_after:wN \use_i:nn #1 }
\cs_new:Npn \@@_values:N #1 { \exp_after:wN \use_ii:nn #1 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_extract:nNN, \@@_extract:VNN}
%   Recover the values for the standard model for a color.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_extract:nNN #1#2#3
  {
    \tl_set_eq:Nc #2 { l_@@_named_ #1 _tl }
    \prop_get:cVN { l_@@_named_ #1 _prop } #2 #3
  }
\cs_generate_variant:Nn \@@_extract:nNN { V }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Model conversion}
%
% \begin{macro}{\@@_convert:nnN, \@@_convert:VVN}
% \begin{macro}{\@@_convert:nnnN, \@@_convert:nVnN, \@@_convert:nnVN}
% \begin{macro}[aux, EXP]
%   {
%     \@@_convert_gray_rgb:w
%     \@@_convert_gray_cmyk:w
%     \@@_convert_cmyk_gray:w
%     \@@_convert_cmyk_rgb:w
%     \@@_convert_rgb_gray:w
%     \@@_convert_rgb_cmyk:w
%   }
%  \begin{macro}[aux, EXP]{\@@_convert_rgb_cmyk:nnnn}
%    Model conversion is carried out using standard formulae, as described in
%    the manual for \pkg{xcolor} (see also the \emph{PostScript Language
%    Reference Manual}).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_convert:nnN #1#2#3
  { \@@_convert:nnVN {#1} {#2} #3 #3 }
\cs_generate_variant:Nn \@@_convert:nnN { VV }
\cs_new_protected:Npn \@@_convert:nnnN #1#2#3#4
  {
    \str_if_eq:nnT {#1} { spot } % TO DO!!!
      { }
    \tl_set:Nx #4
      { \use:c { @@_convert_ #1 _ #2 :w } #3 ~ 0 ~ 0 ~ 0 \s_@@_stop }
  }
\cs_generate_variant:Nn \@@_convert:nnnN { nV , nnV }
\cs_new:Npn \@@_convert_gray_rgb:w #1 ~ #2 \s_@@_stop
  { #1 ~ #1 ~ #1 }
\cs_new:Npn \@@_convert_gray_cmyk:w #1 ~ #2 \s_@@_stop
  { 0 ~ 0 ~ 0 ~ \fp_eval:n { 1 - #1 } }
%    \end{macrocode}
%   These rather odd values are based on \textsc{ntsc} television: the set are
%   used for the |cmyk| conversion.
%    \begin{macrocode}
\cs_new:Npn \@@_convert_rgb_gray:w #1 ~ #2 ~ #3 ~ #4 \s_@@_stop
  { \fp_eval:n { 0.3 * #1 + 0.59 * #2 + 0.11 * #3 } }
%    \end{macrocode}
%   The conversion from |rgb| to |cmyk| is the most complex: a two-step
%   procedure which requires \emph{black generation} and \emph{undercolor
%   removal} functions. The PostScript reference describes them as
%   device-dependent, but following \pkg{xcolor} we assume they are linear.
%   Moreover, as the likelihood of anyone using a non-unitary matrix here is
%   tiny, we simplify and treat those two concepts as no-ops.
%    \begin{macrocode}
\cs_new:Npn \@@_convert_rgb_cmyk:w #1 ~ #2 ~ #3 ~ #4 \s_@@_stop
  {
    \exp_args:Nf \@@_convert_rgb_cmyk:nnnn
      { \fp_eval:n { min ( 1 - #1 , 1 - #2 , 1 - #3 ) } } {#1} {#2} {#3}
  }
\cs_new:Npn \@@_convert_rgb_cmyk:nnnn #1#2#3#4
  {
    \fp_eval:n { min ( 1 , max ( 0 , 1 - #2 - #1 ) ) } \c_space_tl
    \fp_eval:n { min ( 1 , max ( 0 , 1 - #3 - #1 ) ) } \c_space_tl
    \fp_eval:n { min ( 1 , max ( 0 , 1 - #4 - #1 ) ) } \c_space_tl
    #1
  }
\cs_new:Npn \@@_convert_cmyk_gray:w #1 ~ #2 ~ #3 ~ #4 ~ #5 \s_@@_stop
  { \fp_eval:n { 1 - min ( 1 , 0.3 * #1 + 0.59 * #2 + 0.11 * #3 + #4 ) } }
\cs_new:Npn \@@_convert_cmyk_rgb:w #1 ~ #2 ~ #3 ~ #4 ~ #5 \s_@@_stop
  {
    \fp_eval:n { 1 - min ( 1 , #1 + #4 ) } \c_space_tl
    \fp_eval:n { 1 - min ( 1 , #2 + #4 ) } \c_space_tl
    \fp_eval:n { 1 - min ( 1 , #3 + #4 ) }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Color expressions}
%
% \begin{variable}
%   {\l_@@_model_tl, \l_@@_value_tl, \l_@@_next_model_tl, \l_@@_next_value_tl}
%   Working space to store the color data whilst doing calculations: keeping
%   it on the stack is attractive but gets tricky (return is non-trivial).
%    \begin{macrocode}
\tl_new:N \l_@@_model_tl
\tl_new:N \l_@@_value_tl
\tl_new:N \l_@@_next_model_tl
\tl_new:N \l_@@_next_value_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_parse:nN}
% \begin{macro}{\@@_parse_aux:nN}
% \begin{macro}{\@@_parse_eq:Nn}
% \begin{macro}{\@@_parse_eq:nNn}
% \begin{macro}{\@@_parse:Nw}
% \begin{macro}{\@@_parse_loop_init:Nnn}
% \begin{macro}{\@@_parse_loop:w}
% \begin{macro}{\@@_parse_loop:nn}
% \begin{macro}{\@@_parse_gray:n, \@@_parse_std:n}
% \begin{macro}{\@@_parse_break:w}
% \begin{macro}{\@@_parse_end:}
% \begin{macro}[aux, EXP]{\@@_parse_mix:Nnnn, \@@_parse_mix:NVVn}
% \begin{macro}[aux, EXP]{\@@_parse_mix:nNnn}
% \begin{macro}[aux, EXP]
%   {
%     \@@_parse_mix_gray:nw ,
%     \@@_parse_mix_rgb:nw  ,
%     \@@_parse_mix_cmyk:nw
%   }
%   The main function for parsing color expressions removes actives but
%   otherwise expands, then starts working through the expression itself.
%   At the end, we apply the payload.
%    \begin{macrocode}
\cs_new_protected:Npx \@@_parse:nN #1#2
  {
%<*package>
    \exp_not:N \@@_backend_pickup:N \exp_not:N \l_@@_current_tl
    \tl_set:Nx \exp_not:c { l_@@_named_ . _tl }
      { \exp_not:N \@@_model:N \exp_not:N \l_@@_current_tl }
    \prop_put:NVx \exp_not:c { l_@@_named_ . _prop }
      \exp_not:c { l_@@_named_ . _tl }
      { \exp_not:N \@@_values:N \exp_not:N \l_@@_current_tl }
%</package>
    \exp_not:N \exp_args:Ne \exp_not:N \@@_parse_aux:nN
      { \exp_not:N \tl_to_str:n {#1} } #2
  }
%    \end{macrocode}
%   Before going to all of the effort of parsing an expression, these two
%   precursor functions look for a pre-defined name, either on its own or
%   with a trailing |!| (which is the same thing).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_aux:nN #1#2
  {
    \tl_if_exist:cTF { l_@@_named_ #1 _prop }
      { \@@_parse_set_eq:Nn #2 {#1} }
      { \@@_parse:Nw #2#1 ! \s_@@_stop }
    \@@_check_model:N #2
  }
\cs_new_protected:Npn \@@_parse_set_eq:Nn #1#2
  {
    \tl_if_empty:NTF \l_color_fixed_model_tl
       { \exp_args:Nv \@@_parse_set_eq:nNn { l_@@_named_ #2 _tl } }
       { \exp_args:NV \@@_parse_set_eq:nNn \l_color_fixed_model_tl }
         #1 {#2}
  }
%    \end{macrocode}
%    Here, we have to allow for the case where there is a fixed model:
%    that can't be swept up by generic conversion as we are dealing with a
%    named color.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_set_eq:nNn #1#2#3
  {
    \prop_get:cnNTF
      { l_@@_named_ #3 _prop } {#1}
      \l_@@_value_tl
      { \tl_set:Nx #2 { {#1} { \l_@@_value_tl } } }
      {
        \tl_set_eq:Nc \l_@@_model_tl { l_@@_named_ #3 _tl }
        \prop_get:cVN { l_@@_named_ #3 _prop } \l_@@_model_tl
          \l_@@_value_tl
         \@@_convert:nnN
           \l_@@_model_tl {#1} \l_@@_value_tl
        \tl_set:Nx #2
          {
            {#1}
            { \l_@@_value_tl }
          }
      }
  }
\cs_new_protected:Npn \@@_parse:Nw #1#2 ! #3 \s_@@_stop
  {
    \@@_if_defined:nTF {#2}
      {
        \tl_if_blank:nTF {#3}
          { \@@_parse_set_eq:Nn #1 {#2} }
          { \@@_parse_loop_init:Nnn #1 {#2} {#3} }
      }
      {
        \__kernel_msg_error:nnn { color } { unknown-color } {#2}
        \tl_set:Nn \l_@@_current_tl { { gray } { 0 } }
      }
  }
%    \end{macrocode}
%   Once we establish that a full parse is needed, the next job is to get the
%   detail of the first color. That will determine the model we use for the
%   calculation: splitting here makes checking that a bit easier.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_loop_init:Nnn #1#2#3
  {
    \group_begin:
      \@@_extract:nNN {#2} \l_@@_model_tl \l_@@_value_tl
      \@@_parse_loop:w #3 ! ! ! ! \s_@@_stop
      \tl_set:Nx \l_@@_internal_tl
        { { \l_@@_model_tl } { \l_@@_value_tl } }
    \exp_args:NNNV \group_end:
    \tl_set:Nn #1 \l_@@_internal_tl
  }
%    \end{macrocode}
%   This is the loop proper: there can be an open-ended set of colors to parse,
%   separated by |!| tokens. There are a few cases to look out for. At the end
%   of the expression and with we find a mix of $100$ then we simply skip the
%   next color entirely (we can't stop the loop as there might be a further
%   valid color to mix in). On the other hand, if we get a mix of $0$ then
%   drop everything so far and start again. There is also a trailing
%   |white| to \enquote{read in} if the final explicit data is a mix.
%   Those conditions are separate from actually looping, which is therefore
%   sorted out by checking if we have further data to process: in contrast
%   to \pkg{xcolor}, we don't allow |!!| so the test can be simplified.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_loop:w #1 ! #2 ! #3 ! #4 ! #5 \s_@@_stop
  {
    \bool_lazy_or:nnF
      { \tl_if_blank_p:n {#1} }
      { \int_compare_p:nNn {#1} = { 100 } }
      {
        \int_compare:nNnTF {#1} = { 0 }
          {
            \tl_if_blank:nTF {#2}
              { \@@_extract:nNN { white } }
              { \@@_extract:nNN {#2} }
                \l_@@_model_tl \l_@@_value_tl
          }
          {
            \use:x
              {
                \@@_parse_loop:nn {#1}
                  { \tl_if_blank:nTF {#2} { white } {#2} }
              }
          }
      }
    \tl_if_blank:nF {#3}
      { \@@_parse_loop:w #3 ! #4 ! #5 \s_@@_stop }
    \@@_parse_end:
  }
%    \end{macrocode}
%   The \enquote{payload} of calculation in the loop first. If the model for
%   the upcoming color is different from that of the existing (partial) color,
%   convert the model. For |gray| the two are flipped round so that the outcome
%   is something with \enquote{real} color. We are then in a position to do the
%   actual calculation itself. The two auxiliaries here give us a way to break
%   the loop should an invalid name be found.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_loop:nn #1#2
  {
    \@@_if_defined:nTF {#2}
      {
        \@@_extract:nNN {#2} \l_@@_next_model_tl \l_@@_next_value_tl
        \tl_if_eq:NNF \l_@@_model_tl \l_@@_next_model_tl
          {
            \str_if_eq:VnTF \l_@@_model_tl { gray }
              { \@@_parse_gray:n {#2} }
              { \@@_parse_std:n {#2} }
          }
        \tl_set:Nx \l_@@_value_tl
          {
            \@@_parse_mix:NVVn
              \l_@@_model_tl \l_@@_value_tl \l_@@_next_value_tl {#1}
          }
      }
      {
        \__kernel_msg_error:nnn { color } { unknown-color } {#2}
        \@@_extract:nNN { black } \l_@@_model_tl \l_@@_value_tl
        \@@_parse_break:w
      }
  }
%    \end{macrocode}
%   The \texttt{gray} model needs special handling: the models need to be
%   swapped: we do that using a dedicated function.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_gray:n #1
  {
    \tl_set_eq:NN \l_@@_model_tl \l_@@_next_model_tl
    \tl_set:Nn \l_@@_next_model_tl { gray }
    \exp_args:NnV \@@_convert:nnN { gray } \l_@@_model_tl
      \l_@@_value_tl
    \prop_get:cVN { l_@@_named_ #1 _prop } \l_@@_model_tl
      \l_@@_next_value_tl
  }
\cs_new_protected:Npn \@@_parse_std:n #1
  {
    \prop_get:cVNF { l_@@_named_ #1 _prop }
      \l_@@_model_tl
      \l_@@_next_value_tl
        {
          \@@_convert:VVN
            \l_@@_next_model_tl
            \l_@@_model_tl
            \l_@@_next_value_tl
        }
  }
\cs_new_protected:Npn \@@_parse_break:w #1 \@@_parse_end: { }
\cs_new_protected:Npn \@@_parse_end: { }
%    \end{macrocode}
%   Do the vector arithmetic: mainly a question of shuffling input, along
%   with one pre-calculation to keep down the use of division.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_mix:Nnnn #1#2#3#4
  {
    \exp_args:Nf \@@_parse_mix:nNnn
      { \fp_eval:n { #4 / 100 } }
      #1 {#2} {#3}
  }
\cs_generate_variant:Nn \@@_parse_mix:Nnnn { NVV }
\cs_new:Npn \@@_parse_mix:nNnn #1#2#3#4
  {
    \use:c { @@_parse_mix_ #2 :nw } {#1}
      #3 \s_@@_mark #4 \s_@@_stop
  }
\cs_new:Npn \@@_parse_mix_gray:nw #1#2 \s_@@_mark #3 \s_@@_stop
  { \fp_eval:n { #2 * #1 + #3 * ( 1 - #1 ) } }
\cs_new:Npn \@@_parse_mix_rgb:nw
  #1#2 ~ #3 ~ #4 \s_@@_mark #5 ~ #6 ~ #7 \s_@@_stop
  {
    \fp_eval:n { #2 * #1 + #5 * ( 1 - #1 ) } \c_space_tl
    \fp_eval:n { #3 * #1 + #6 * ( 1 - #1 ) } \c_space_tl
    \fp_eval:n { #4 * #1 + #7 * ( 1 - #1 ) }
  }
\cs_new:Npn \@@_parse_mix_cmyk:nw
  #1#2 ~ #3 ~ #4 ~ #5 \s_@@_mark #6 ~ #7 ~ #8 ~ #9 \s_@@_stop
  {
    \fp_eval:n { #2 * #1 + #6 * ( 1 - #1 ) } \c_space_tl
    \fp_eval:n { #3 * #1 + #7 * ( 1 - #1 ) } \c_space_tl
    \fp_eval:n { #4 * #1 + #8 * ( 1 - #1 ) } \c_space_tl
    \fp_eval:n { #5 * #1 + #9 * ( 1 - #1 ) }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]
%   {
%     \@@_parse_model_gray:w, \@@_parse_model_rgb:w,
%     \@@_parse_model_cmyk:w, \@@_parse_model_spot:w
%   }
% \begin{macro}[EXP]{\@@_parse_number:n}
% \begin{macro}[EXP]{\@@_parse_number:w}
% \begin{macro}[EXP]{\@@_parse_spot_aux:w}
%   Turn the input into internal form, also tidying up the number quickly.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_model_gray:w #1 , #2 \s_@@_stop
  { { gray } { \@@_parse_number:n {#1} } }
\cs_new:Npn \@@_parse_model_rgb:w #1 , #2 , #3 , #4 \s_@@_stop
  {
    { rgb }
    {
      \@@_parse_number:n {#1} ~
      \@@_parse_number:n {#2} ~
      \@@_parse_number:n {#3}
    }
  }
\cs_new:Npn \@@_parse_model_cmyk:w #1 , #2 , #3 , #4 , #5 \s_@@_stop
  {
    { cmyk }
    {
      \@@_parse_number:n {#1} ~
      \@@_parse_number:n {#2} ~
      \@@_parse_number:n {#3} ~
      \@@_parse_number:n {#4}
    }
  }
\cs_new:Npn \@@_parse_model_spot:w #1 , #2 \s_@@_stop
  {
    { spot }
    { \@@_parse_spot_aux:w #1 ! 100 ! \s_@@_stop }
  }
\cs_new:Npn \@@_parse_spot_aux:w #1 ! #2 ! #3 \s_@@_stop
  { #1 ~ \fp_eval:n { #2 / 100 } }
\cs_new:Npn \@@_parse_number:n #1
  {  \@@_parse_number:w #1 . 0 . \s_@@_stop }
\cs_new:Npn \@@_parse_number:w #1 . #2 . #3 \s_@@_stop
  { \tl_if_blank:nTF {#1} { 0 } {#1} . #2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]
%   {
%     \@@_parse_model_Hsb:w, \@@_parse_model_HSB:w,
%     \@@_parse_model_HTML:w, \@@_parse_model_RGB:w
%   }
%    \begin{macrocode}
\cs_new:Npn \@@_parse_model_Hsb:w #1 , #2 , #3 , #4 \s_@@_stop
  {
    \exp_args:Ne \@@_parse_model_hsb:nnn { \fp_eval:n { #1 / 360 } }
      {#2} {#3}
  }
%    \end{macrocode}
%   The conversion here is non-trivial but is described at length
%   in the \pkg{xcolor} manual. For ease, we calculate the integer
%   and fractional parts of the hue first, then use them to work out the
%   possible values for $r$, $g$ and $b$ before putting them in the correct
%   places.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_model_hsb:nnn #1#2#3
  {
    { rgb }
    {
      \exp_args:Ne \@@_parse_model_hsb_aux:nnn
        { \fp_eval:n { 6 * #1 } } {#2} {#3}
    }
  }
\cs_new:Npn \@@_parse_model_hsb_aux:nnn #1#2#3
  {
    \exp_args:Nee \@@_parse_model_hsb_aux:nnnn
      { \fp_eval:n { floor(#1) } } { \fp_eval:n { #1 - floor(#1) } }
      {#2} {#3}
  }
\cs_new:Npn \@@_parse_model_hsb_aux:nnnn #1#2#3#4
  {
    \use:e
      {
        \exp_not:N \@@_parse_model_hsb_aux:nnnnn
         { \@@_parse_number:n {#4} }
         { \fp_eval:n { round(#4 * (1 - #3) ,5) } }
         { \fp_eval:n { round(#4 * ( 1 - #3 * #2 ) ,5) } }
         { \fp_eval:n { round(#4 * ( 1 - #3 * (1 - #2) ) ,5) } }
         {#1}
      }
  }
\cs_new:Npn \@@_parse_model_hsb_aux:nnnnn #1#2#3#4#5
  { \use:c { @@_parse_model_hsb_ #5 :nnnn } {#1} {#2} {#3} {#4} }
\cs_new:cpn { @@_parse_model_hsb_0:nnnn } #1#2#3#4 { #1 ~ #4 ~ #2 }
\cs_new:cpn { @@_parse_model_hsb_1:nnnn } #1#2#3#4 { #3 ~ #1 ~ #2 }
\cs_new:cpn { @@_parse_model_hsb_2:nnnn } #1#2#3#4 { #2 ~ #1 ~ #4 }
\cs_new:cpn { @@_parse_model_hsb_3:nnnn } #1#2#3#4 { #2 ~ #3 ~ #1 }
\cs_new:cpn { @@_parse_model_hsb_4:nnnn } #1#2#3#4 { #4 ~ #2 ~ #1 }
\cs_new:cpn { @@_parse_model_hsb_5:nnnn } #1#2#3#4 { #1 ~ #2 ~ #3 }
\cs_new:cpn { @@_parse_model_hsb_6:nnnn } #1#2#3#4 { #1 ~ #2 ~ #2 }
\cs_new:Npn \@@_parse_model_HSB:w #1 , #2 , #3 , #4 \s_@@_stop
  {
    \exp_args:Neee \@@_parse_model_hsb:nnn
      { \fp_eval:n {#1 / 360} }
      { \fp_eval:n {#2 / 255} }
      { \fp_eval:n {#3 / 255} }
  }
\cs_new:Npn \@@_parse_model_HTML:w #1 , #2 \s_@@_stop
  { \@@_parse_model_HTML_aux:w #1 0 0 0 0 0 0 \s_@@_stop }
\cs_new:Npn \@@_parse_model_HTML_aux:w #1#2#3#4#5#6#7 \s_@@_stop
  {
    { rgb }
    {
      \fp_eval:n { round(\int_from_hex:n {#1#2} / 255,5) } ~
      \fp_eval:n { round(\int_from_hex:n {#3#4} / 255,5) } ~
      \fp_eval:n { round(\int_from_hex:n {#5#6} / 255,5) }
    }
  }
\cs_new:Npn \@@_parse_model_RGB:w #1 , #2 , #3 , #4 \s_@@_stop
  {
    { rgb }
    {
      \fp_eval:n { round(#1 / 255,5) } ~
      \fp_eval:n { round(#2 / 255,5) } ~
      \fp_eval:n { round(#3 / 255,5) }
    }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Selecting colors (and color models)}
%
% \begin{variable}{\l_color_fixed_model_tl}
%   For selecting a single fixed model.
%    \begin{macrocode}
\tl_new:N \l_color_fixed_model_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_check_model:N}
% \begin{macro}{\@@_check_model:nn}
%   Check that the model in use is the one required.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_check_model:N #1
  {
    \tl_if_empty:NF \l_color_fixed_model_tl
      {
        \exp_after:wN \@@_check_model:nn #1
        \tl_if_eq:NNF \l_@@_model_tl \l_color_fixed_model_tl
          {
            \@@_convert:VVN \l_@@_model_tl \l_color_fixed_model_tl
              \l_@@_value_tl
          }
        \tl_set:Nx #1
          { { \l_color_fixed_model_tl } { \l_@@_value_tl } }
      }
  }
\cs_new_protected:Npn \@@_check_model:nn #1#2
  {
    \tl_set:Nn \l_@@_model_tl {#1}
    \tl_set:Nn \l_@@_value_tl {#2}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_select:}
%   A backend-neutral location for \enquote{last minute} manipulations before
%   handing off to the backend code.  We set the special |.| syntax here: this
%   will therefore always be available. The finalisation is separate from the
%   main function so it can also be applied to \emph{e.g.}~page color.
%    \begin{macrocode}
\cs_new_protected:Npx \@@_select:
  {
    \tl_set:Nx \exp_not:c { l_@@_named_ . _tl }
      { \exp_not:N \@@_model:N \exp_not:N \l_@@_current_tl }
    \prop_clear:N \exp_not:c { l_@@_named_ . _prop }
    \prop_put:NVx \exp_not:c { l_@@_named_ . _prop }
      \exp_not:c { l_@@_named_ . _tl }
      { \exp_not:N \@@_values:N \exp_not:N \l_@@_current_tl }
    \@@_select:N \exp_not:N \l_@@_current_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\color_select:n}
% \begin{macro}{\color_select:nn}
% \begin{macro}{\@@_select_main:Nw, \@@_select_loop:Nw}
% \begin{macro}{\@@_select:nnN}
% \begin{macro}{\@@_select_swap:Nnn}
%   Parse the input expressions then get the backend to actually activate
%   them. The main complexity here is the need to check through multiple models.
%   That is done \enquote{locally} here as the approach is subtly different to
%   when different models are being stored.
%    \begin{macrocode}
\cs_new_protected:Npn \color_select:n #1
  {
    \@@_parse:nN {#1} \l_@@_current_tl
    \@@_select:
  }
\cs_new_protected:Npn \color_select:nn #1#2
  {
    \@@_select_main:Nw \l_@@_current_tl
      #1 / / \s_@@_mark #2 / / \s_@@_stop
    \@@_select:
  }
%    \end{macrocode}
%   If the first color model is the fixed one, or if there is no fixed
%   model, we don't need most of the data: just set up and apply the backend
%   function.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_select_main:Nw
  #1 #2 / #3 / #4 \s_@@_mark #5 / #6 / #7 \s_@@_stop
  {
    \@@_select:nnN {#2} {#5} #1
    \bool_lazy_or:nnF
      { \tl_if_empty_p:N \l_color_fixed_model_tl }
      { \str_if_eq_p:nV {#2} \l_color_fixed_model_tl }
      { \@@_select_loop:Nw #1 #3 / #4 \s_@@_mark #6 / #7 \s_@@_stop }
  }
%    \end{macrocode}
%   If a fixed model applies, we need to check each possible value in order.
%   If there is no hit at all, fall back on the generic formula-based
%   interchange.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_select_loop:Nw
  #1 #2 / #3 \s_@@_mark #4 / #5 \s_@@_stop
  {
    \str_if_eq:nVTF {#2} \l_color_fixed_model_tl
      { \@@_select:nnN {#2} {#4} #1 }
      {
        \tl_if_blank:nTF {#2}
          { \exp_after:wN \@@_select_swap:Nnn \exp_after:wN #1 #1 }
          { \@@_select_loop:Nw #1 #3 \s_@@_mark #5 \s_@@_stop }
      }
  }
\cs_new_protected:Npn \@@_select:nnN #1#2#3
  {
    \cs_if_exist:cTF { @@_parse_model_ #1 :w }
      {
        \tl_set:Nx #3
          { \use:c { @@_parse_model_ #1 :w } #2 , 0 , 0 , 0 , 0 \s_@@_stop }
      }
      { \__kernel_msg_error:nnn { color } { unknown-model } {#1} }
  }
\cs_new_protected:Npn \@@_select_swap:Nnn #1#2#3
  {
    \@@_convert:nVnN {#2} \l_color_fixed_model_tl {#3} \l_@@_value_tl
    \tl_set:Nx #1
      { { \l_color_fixed_model_tl } { \l_@@_value_tl } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Defining named colors}
%
% \begin{variable}{\l_@@_named_tl}
%   Space to store the detail of the named color.
%    \begin{macrocode}
\tl_new:N \l_@@_named_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\color_set:nn}
% \begin{macro}{\@@_set:nnn}
% \begin{macro}{\@@_set:nn}
% \begin{macro}{\@@_set:nnw}
% \begin{macro}{\color_set:nnn}
% \begin{macro}{\@@_set_loop:nw}
% \begin{macro}{\color_set_eq:nn}
%   Defining named colors means working through the model list and saving
%   both the \enquote{main} color and any equivalents in other models. Even
%   if there is only one model, we store a |prop| as well as a |tl|, as there
%   could be grouping weirdness, etc. When setting using an expression,
%   we need to avoid any fixed model issues, which is done without a group as
%   in \pkg{l3keys}.
%    \begin{macrocode}
\cs_new_protected:Npn \color_set:nn #1#2
  {
    \exp_args:NV \@@_set:nnn
      \l_color_fixed_model_tl {#1} {#2}
  }
\cs_new_protected:Npn \@@_set:nnn #1#2#3
  {
    \tl_clear:N \l_color_fixed_model_tl
    \@@_set:nn {#2} {#3}
    \tl_set:Nn \l_color_fixed_model_tl {#1}
  }
\cs_new_protected:Npn \@@_set:nn #1#2
  {
    \str_if_eq:nnF {#1} { . }
      {
        \@@_parse:nN {#2} \l_@@_named_tl
        \tl_clear_new:c { l_@@_named_ #1 _tl }
        \tl_set:cx { l_@@_named_ #1 _tl }
          { \@@_model:N \l_@@_named_tl }
        \prop_clear_new:c { l_@@_named_ #1 _prop }
        \prop_put:cvx { l_@@_named_ #1 _prop } { l_@@_named_ #1 _tl }
          { \@@_values:N \l_@@_named_tl }
        \@@_set:nnw {#1} {#2} #2 ! \s_@@_stop
      }
  }
%    \end{macrocode}
%   When setting an expression-based color, there could be multiple model
%   data available for one or more of the input colors. Where that is true for
%   the \emph{first} named color in an expression, we re-parse the expression
%   when they are also parameter-based: only |cmyk|, |gray| and |rgb| make
%   any sense here. There is a bit of a performance hit but this should be
%   rare and taking place during set-up.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set:nnw #1#2#3 ! #4 \s_@@_stop
  {
    \clist_map_inline:nn { cmyk , gray , rgb }
      {
        \prop_get:cnNT { l_@@_named_ #3 _prop } {##1} \l_@@_internal_tl
          {
            \prop_if_in:cnF { l_@@_named_ #1 _prop } {##1}
              {
                \group_begin:
                  \tl_set:cn { l_@@_named_ #3 _tl } {##1}
                  \@@_parse:nN {#2} \l_@@_internal_tl
                \exp_args:NNNV \group_end:
                \tl_set:Nn \l_@@_internal_tl \l_@@_internal_tl
                \prop_put:cxx { l_@@_named_ #1 _prop }
                  { \@@_model:N \l_@@_internal_tl }
                  { \@@_values:N \l_@@_internal_tl }
              }
          }
      }
  }
\cs_new_protected:Npn \color_set:nnn #1#2#3
  {
    \str_if_eq:nnF {#1} { . }
      {
        \tl_clear_new:c { l_@@_named_ #1 _tl }
        \prop_clear_new:c { l_@@_named_ #1 _prop }
        \@@_set_loop:nw {#1} #2 / / \s_@@_mark #3 / / \s_@@_stop
      }
  }
\cs_new_protected:Npn \@@_set_loop:nw
  #1#2 / #3 \s_@@_mark #4 / #5 \s_@@_stop
  {
    \tl_if_blank:nF {#2}
      {
        \@@_select:nnN {#2} {#4} \l_@@_named_tl
        \tl_set:Nx \l_@@_internal_tl { \@@_model:N \l_@@_named_tl }
        \tl_if_empty:cT { l_@@_named_ #1 _tl }
          { \tl_set_eq:cN { l_@@_named_ #1 _tl } \l_@@_internal_tl }
        \prop_put:cVx { l_@@_named_ #1 _prop } \l_@@_internal_tl
          { \@@_values:N \l_@@_named_tl }
        \@@_set_loop:nw {#1} #3 \s_@@_mark #5 \s_@@_stop
      }
  }
\cs_new_protected:Npn \color_set_eq:nn #1#2
  {
    \@@_if_defined:nTF {#2}
      {
        \tl_clear_new:c { l_@@_named_ #1 _tl }
        \prop_clear_new:c { l_@@_named_ #1 _prop }
        \str_if_eq:nnTF {#2} { . }
          {
            \tl_set:cx { l_@@_named_ #1 _tl }
              { \@@_model:N \l_@@_current_tl }
            \prop_put:cvx { l_@@_named_ #1 _prop } { l_@@_named_ #1 _tl }
              { \@@_values:N \l_@@_current_tl }
          }
          {
            \tl_set_eq:cc { l_@@_named_ #1 _tl } { l_@@_named_ #2 _tl }
            \prop_set_eq:cc { l_@@_named_ #1 _prop } { l_@@_named_ #2 _prop }
          }
      }
      {
        \__kernel_msg_error:nnn { color } { unknown-color } {#2}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% A small set of colors are always defined.
% \begin{macrocode}
\color_set:nnn { black } { gray } { 0 }
\color_set:nnn { white } { gray } { 1 }
\color_set:nnn { cyan }    { cmyk } { 1 , 0 , 0 , 0 }
\color_set:nnn { magenta } { cmyk } { 0 , 1 , 0 , 0 }
\color_set:nnn { yellow }  { cmyk } { 0 , 0 , 1 , 0 }
\color_set:nnn { red }   { rgb } { 1 , 0 , 0 }
\color_set:nnn { green } { rgb } { 0 , 1 , 0 }
\color_set:nnn { blue }  { rgb } { 0 , 0 , 1 }
% \end{macrocode}
%
% \begin{variable}{\l_@@_named_._prop, \l_@@_named_._tl}
%   A special named color: this is always defined though not fixed in
%   definition.
%    \begin{macrocode}
\prop_new:c { l_@@_named_._prop }
\tl_new:c { l_@@_named_._tl }
\tl_set:cx { l_@@_named_._tl } { \@@_model:N \l_@@_current_tl }
%    \end{macrocode}
% \end{variable}
%
% \subsection{Exporting colors}
%
% \begin{macro}{\color_export:nnN}
% \begin{macro}{\color_export:nnnN}
% \begin{macro}{\@@_export:nN}
% \begin{macro}{\@@_export:nnnN}
%    \begin{macrocode}
\cs_new_protected:Npn \color_export:nnN #1#2#3
  {
    \group_begin:
      \tl_if_exist:cT { c_@@_export_ #2 _tl }
        { \tl_set_eq:Nc \l_color_fixed_model_tl { c_@@_export_ #2 _tl } }
      \@@_parse:nN {#1} #3
      \@@_export:nN {#2} #3
    \exp_args:NNNV \group_end:
    \tl_set:Nn #3 #3
  }
\cs_new_protected:Npn \color_export:nnnN #1#2#3#4
  {
    \@@_select_main:Nw #4
      #1 / / \s_@@_mark #2 / / \s_@@_stop
    \@@_export:nN {#3} #4
  }
\cs_new_protected:Npn \@@_export:nN #1#2
  { \exp_after:wN \@@_export:nnnN #2 {#1} #2 }
\cs_new:Npn \@@_export:nnnN #1#2#3#4
  {
    \cs_if_exist_use:cF { @@_export_format_ #3 :nnN }
      {
        \__kernel_msg_error:nnn { color } { unknown-export-format } {#3}
        \use_none:nnn
      }
        {#1} {#2} #4
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_export_format_backend:nnN}
%   Simple.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_export_format_backend:nnN #1#2#3
  { \tl_set:Nn #3 { {#1} {#2} } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_export:nnnNN}
%   A generic auxiliary for cases where only one model is appropriate.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_export:nnnNN #1#2#3#4#5
  {
    \str_if_eq:nnTF {#2} {#1}
      { #5 #4 #3 \s_@@_stop }
      {
        \@@_convert:nnnN {#2} {#1} {#3} #4
        \exp_after:wN #5 \exp_after:wN #4
          #4 \s_@@_stop
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}
%   {
%     \c_@@_export_HTML_tl           ,
%     \c_@@_export_space-sep-cmyk_tl ,
%     \c_@@_export_space-sep-rgb_tl
%   }
%    \begin{macrocode}
\tl_const:Nn \c_@@_export_HTML_tl { rgb }
\tl_const:cn { c_@@_export_space-sep-cmyk_tl } { cmyk }
\tl_const:cn { c_@@_export_space-sep-rgb_tl } { rgb }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_export_format_space-sep-cmyk:nnN}
% \begin{macro}{\@@_export_space-sep-cmyk:Nw}
%    \begin{macrocode}
\cs_new_protected:cpx { @@_export_format_space-sep-cmyk:nnN } #1#2#3
  {
    \exp_not:N \@@_export:nnnNN { cmyk } {#1} {#2} #3
      \exp_not:c { @@_export_space-sep-cmyk:Nw }
  }
\cs_new_protected:cpn { @@_export_space-sep-cmyk:Nw } #1#2 \s_@@_stop
  { \tl_set:Nx #1 {#2} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_export_format_HTML:nnN          ,
%     \@@_export_format_space-sep-rgb:nnN
%   }
% \begin{macro}
%   {
%     \@@_export_HTML:Nw          ,
%     \@@_export_space-sep-rgb:Nw
%   }
% \begin{macro}[EXP]{\@@_export_HTML:n}
%   \textsc{html} values must be given in |rgb|: we force conversion if
%   required, then do some simple maths.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_export_format_HTML:nnN #1#2#3
  { \@@_export:nnnNN { rgb } {#1} {#2}#3 \@@_export_HTML:Nw }
\cs_new_protected:cpx { @@_export_format_space-sep-rgb:nnN } #1#2#3
  {
    \exp_not:N \@@_export:nnnNN { rgb } {#1} {#2} #3
      \exp_not:c { @@_export_space-sep-rgb:Nw }
  }
\cs_new_protected:Npn \@@_export_HTML:Nw #1#2 ~ #3 ~ #4 \s_@@_stop
  {
    \tl_set:Nx #1
      {
        \@@_export_HTML:n {#2}
        \@@_export_HTML:n {#3}
        \@@_export_HTML:n {#4}
      }
  }
\cs_new:Npn \@@_export_HTML:n #1
  {
    \fp_compare:nNnTF {#1} = { 0 }
      { 00 }
      { \int_to_Hex:n { \fp_to_int:n { #1 * 255 } } }
  }
\cs_new_protected:cpn { @@_export_space-sep-rgb:Nw } #1#2 \s_@@_stop
  { \tl_set:Nx #1 {#2} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Diagnostics}
%
% \begin{macro}{\color_show:n}
% \begin{macro}{\@@_show:n}
%   Extract the information about a color and format for the user: the approach
%   is similar to the keys module here.
%    \begin{macrocode}
\cs_new_protected:Npn \color_show:n #1
  {
    \msg_show:nnxxxx { LaTeX / color } { show }
      {#1}
      {
        \@@_if_defined:nT {#1}
          {
            \exp_args:Nv \@@_show:n { l_@@_named_ #1 _tl }
            \prop_map_function:cN
              { l_@@_named_ #1 _prop }
              \msg_show_item_unbraced:nn
          }
      }
      { }
      { }
  }
\cs_new:Npn \@@_show:n #1
  {
    \msg_show_item_unbraced:nn { model } {#1}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Messages}
%
% \begin{macrocode}
\__kernel_msg_new:nnnn { color } { unknown-color }
  { Unknown~color~'#1'. }
  {
    LaTeX~has~been~asked~to~use~a~color~named~'#1',~
    but~this~has~never~been~defined.
  }
\__kernel_msg_new:nnnn { color } { unknown-export-format }
  { Unknown~export~format~'#1'. }
  {
    LaTeX~has~been~asked~to~export~a~color~in~format~'#1',~
    but~this~has~never~been~defined.
  }
\__kernel_msg_new:nnnn { color } { unknown-model }
  { Unknown~color~model~'#1'. }
  {
    LaTeX~has~been~asked~to~use~a~color~model~called~'#1',~
    but~this~model~is~not~set~up.
  }
% \end{macrocode}
%
% \begin{macrocode}
\__kernel_msg_new:nnn { color } { show }
  {
    The~color~#1~
    \tl_if_empty:nTF {#2}
      { is~undefined. }
      { has~the~properties: #2 }
  }
% \end{macrocode}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
