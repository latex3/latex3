% \iffalse meta-comment
%
%% File: l3str.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3experimental bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental Strings}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \title{^^A
%   The \textsf{l3str} package: manipulating strings of characters^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \LaTeX3 provides a set of functions to manipulate token lists
% as strings of characters, ignoring the category codes of those
% characters.
%
% String variables are simply specialised token lists, but by convention
% should be named with the suffix \texttt{\ldots str}. Such variables should
% contain characters with category code $12$ (other), except spaces, which
% have category code $10$ (blank space). All the functions in
% this module first convert their argument to a string for internal processing,
% and will not treat a token list or the corresponding string representation
% differently.
%
% Most functions in this module come in three flavours:
% \begin{itemize}
%   \item \cs{str_...:N...}, which expect a token list or string
%     variable as their argument;
%   \item \cs{str_...:n...}, taking any token list (or string) as an argument;
%   \item \cs{str_..._ignore_spaces:n...}, which ignores any space encountered
%     during the operation: these functions are faster than those
%     which take care of escaping spaces appropriately;
% \end{itemize}
% When performance is critical, the internal \cs{str_..._unsafe:n...}
% functions, which expect an \enquote{other string} in which spaces
% have category code $12$ instead of $10$, might be useful.
%
% \section{Building strings}
%
% \begin{variable}
%   {
%     \c_backslash_str,
%     \c_lbrace_str,
%     \c_rbrace_str,
%     \c_hash_str,
%     \c_tilde_str,
%     \c_percent_str
%   }
%   Constant strings, containing a single character, with category code $12$.
%   Other characters can be accessed as \cs{iow_char:N} |\|\meta{character}.
% \end{variable}
%
% \begin{function}[EXP]{\tl_to_str:N, \tl_to_str:n}
%   \begin{syntax}
%     \cs{tl_to_str:N} \meta{tl var}
%     \cs{tl_to_str:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, leaving the resulting
%   tokens in the input stream.
% \end{function}
%
% \begin{function}{\str_const:Nn, \str_const:Nx, \str_const:cn, \str_const:cx}
%   \begin{syntax}
%     \cs{str_const:Nn} \meta{str~var} \Arg{token list}
%   \end{syntax}
%   Creates a new constant \meta{str~var} or raises an error
%   if the name is already taken. The value of the
%   \meta{str~var} will be set globally to the
%   \meta{token list}, converted to a string.
% \end{function}
%
% \begin{function}
%   {
%     \str_set:Nn,  \str_set:Nx,  \str_set:cn,  \str_set:cx,
%     \str_gset:Nn, \str_gset:Nx, \str_gset:cn, \str_gset:cx
%   }
%   \begin{syntax}
%     \cs{str_set:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and stores the result in \meta{str var}.
% \end{function}
%
% \begin{function}
%   {
%     \str_put_left:Nn,  \str_put_left:Nx,
%     \str_put_left:cn,  \str_put_left:cx,
%     \str_gput_left:Nn, \str_gput_left:Nx,
%     \str_gput_left:cn, \str_gput_left:cx
%   }
%   \begin{syntax}
%     \cs{str_put_left:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and prepends the result to \meta{str var}.
%   The current contents of the \meta{str var} are not
%   automatically converted to a string.
% \end{function}
%
% \begin{function}
%   {
%     \str_put_right:Nn,  \str_put_right:Nx,
%     \str_put_right:cn,  \str_put_right:cx,
%     \str_gput_right:Nn, \str_gput_right:Nx,
%     \str_gput_right:cn, \str_gput_right:cx
%   }
%   \begin{syntax}
%     \cs{str_put_right:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and appends the result to \meta{str var}.
%   The current contents of the \meta{str var} are not
%   automatically converted to a string.
% \end{function}
%
% \begin{function}{\str_input:Nn, \str_ginput:Nn}
%   \begin{syntax}
%     \cs{str_input:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} into a \meta{string}, and stores
%   it in the \meta{str var}.
%   Special characters can be input by
%   escaping them with a backslash.
%   \begin{itemize}
%     \item Spaces are ignored unless escaped with a backslash.
%     \item |\xhh| produces the character with code \texttt{hh}
%       in hexadecimal: when |\x| is encountered, up to two hexadecimal digits
%       (\texttt{0}--\texttt{9}, \texttt{a}--\texttt{f},
%       \texttt{A}--\texttt{F})
%       are read to give a number between $0$ and $255$.
%     \item |\x{hh...}| produces the character with code \texttt{hh...}
%       (an arbitrary number of hexadecimal digits are read):
%       this is mostly useful for Unicode-aware engines.
%     \item |\a|, |\e|, |\f|, |\n|, |\r|, |\t| stand for specific characters:
%     \begin{center}
%       \begin{tabular}{cccc}
%         |\a| & |\^^G| & alarm  & hex \texttt{07} \\
%         |\e| & |\^^[| & escape & hex \texttt{1B} \\
%         |\f| & |\^^L| & form feed & hex \texttt{0C} \\
%         |\n| & |\^^J| & new line  & hex \texttt{0A} \\
%         |\r| & |\^^M| & carriage return & hex \texttt{0D} \\
%         |\t| & |\^^I| & horizontal tab  & hex \texttt{09} \\
%       \end{tabular}
%     \end{center}
%   \end{itemize}
%   For instance,
%   \begin{quote}
%     \cs{tl_new:N} \cs{l_my_str} \\
%     \cs{str_input:Nn} \cs{l_my_str} |{\x3C \\ \# abc\ def\^\n}|
%   \end{quote}
%   results in \cs{l_my_str} containing the characters |<\#abc def^|,
%   followed by a newline character (hex \texttt{0A})
%   since |<| has \textsc{ascii} code \texttt{3C} (in hexadecimal).
% \end{function}
%
% \section{Characters given by their position}
%
% \begin{function}[EXP]
%   {\str_length:N, \str_length:n, \str_length_ignore_spaces:n}
%   \begin{syntax}
%     \cs{str_length:n} \Arg{token list}
%   \end{syntax}
%   Leaves the length of the string representation of \meta{token list}
%   in the input stream as an integer denotation. The functions differ in
%   their treatment of spaces.
%   In the case of \cs{str_length:N} and \cs{str_length:n},
%   all characters including spaces are counted.
%   The \cs{str_length_ignore_spaces:n} leaves the number of non-space
%   characters in the input stream.
%   \begin{texnote}
%     The \cs{str_length:n} of a given token list may depend
%     on the category codes in effect when it is measured,
%     and the value of the \tn{escapechar}: for instance
%     |\str_length:n {\a}| may return $1$, $2$ or $3$ depending
%     on the escape character, and the category code of \texttt{a}.
%   \end{texnote}
% \end{function}
%
% \begin{function}[EXP]{\str_head:N, \str_head:n, \str_head_ignore_spaces:n}
%   \begin{syntax}
%     \cs{str_head:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} into a \meta{string}.
%   The first character in the \meta{string} is then
%   left in the input stream, with category code \enquote{other}.
%   The functions differ in their treatment of spaces.
%   In the case of \cs{str_head:N} and \cs{str_head:n},
%   a leading space is returned with category code $10$ (blank space).
%   The \cs{str_head_ignore_spaces:n} function leaves  the first
%   non-space character in the input stream.
%   If the \meta{token list} is empty (or blank in the case of the
%   \texttt{_ignore_spaces} variant), then nothing is left on the
%   input stream.
% \end{function}
%
% \begin{function}[EXP]{\str_tail:N, \str_tail:n, \str_tail_ignore_spaces:n}
%   \begin{syntax}
%     \cs{str_tail:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   removes the first character, and leaves
%   the remaining characters (if any) in the input stream,
%   with category codes $12$ and $10$ (for spaces).
%   The functions differ in the case where the first character
%   is a space: \cs{str_tail:N} and \cs{str_tail:n} will trim
%   only that space, while \cs{str_tail_ignore_spaces:n} trims
%   the first non-space character and any space before it.
% \end{function}
%
% \begin{function}[EXP]{\str_item:Nn, \str_item:nn, \str_item_ignore_spaces:nn}
%   \begin{syntax}
%     \cs{str_item:nn} \Arg{token list} \Arg{integer expression}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, and
%   leaves in the input stream the character in position
%   \meta{integer expression} of the \meta{string}.
%   In the case of \cs{str_item:Nn} and \cs{str_item:nn},
%   all characters including spaces are taken into account.
%   The \cs{str_item_ignore_spaces:nn} function skips spaces
%   in its argument.
%   If the \meta{integer expression} is negative, characters
%   are counted from the end of the \meta{string}. Hence, $-1$ is
%   the right-most character, \emph{etc.}, while $0$ is the first
%   (left-most) character.
% \end{function}
%
% \begin{function}[EXP]
%   {\str_substr:Nnn, \str_substr:nnn, \str_substr_ignore_spaces:nnn}
%   \begin{syntax}
%     \cs{str_substr:nnn} \Arg{token list} \Arg{start index} \Arg{end index}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and leaves in the input stream the characters
%   between \meta{start index} (inclusive) and \meta{end index} (exclusive).
%   If either of \meta{start index} or \meta{end index} is negative,
%   then it is incremented by the length of the list.
%   If either of \meta{start index} or \meta{end index} is empty,
%   it is replaced by the corresponding end-point of the string.
%   Both \meta{start index} and \meta{end index} count from $0$
%   for the first (left most) character.
%   For instance,
%   \begin{verbatim}
%     \iow_term:x { \str_substr:nnn { abcdef } { 1 } { 4 } }
%     \iow_term:x { \str_substr:nnn { abcdef } { -4 } { } }
%   \end{verbatim}
%   will print \texttt{bcd} and \texttt{cdef}.
% \end{function}
%
% \section{String conditionals}
%
% \begin{function}[EXP, pTF]
%   {
%     \str_if_eq:NN,
%     \str_if_eq:nn, \str_if_eq:Vn, \str_if_eq:on, \str_if_eq:no,
%     \str_if_eq:nV, \str_if_eq:VV, \str_if_eq:xx
%   }
%   \begin{syntax}
%     \cs{str_if_eq_p:nn} \Arg{tl1} \Arg{tl2}
%     \cs{str_if_eq:nnTF} \Arg{tl1} \Arg{tl2} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Compares the two \meta{token lists} on a character by character
%   basis, and is \texttt{true} if the two lists contain the same
%   characters in the same order. Thus for example
%   \begin{verbatim}
%     \str_if_eq_p:xx { abc } { \tl_to_str:n { abc } }
%   \end{verbatim}
%   is logically \texttt{true}. All versions of these functions are fully
%   expandable (including those involving an \texttt{x}-type
%   expansion).
% \end{function}
%
% \section{Encoding functions}
%
% Traditionally, string encodings only specify how strings of characters
% should be stored as bytes. However, the resulting lists of bytes are
% often to be used in contexts where only a restricted subset of bytes
% are permitted (\textsc{pdf} string objects, \textsc{url}s).
% Hence, storing strings of characters has two components.
% \begin{itemize}
% \item The code points (\enquote{character codes})
%   are expressed as bytes following a given
%   \enquote{encoding}. This can be \textsc{utf-16},
%   \textsc{iso 8859-1}, \emph{etc.}
%   See Table~\ref{tab:encodings} for a list
%   of encodings supported.\footnote{Encodings and escapings
%     will be added as they are requested.}
% \item Bytes are translated to \TeX{} tokens through
%   a given \enquote{escaping}. Those are defined for
%   the most part by the \texttt{pdf} file format.
%   See Table~\ref{tab:escapings} for a list
%   of escaping methods supported.\footnotemark
% \end{itemize}
%
% \begin{table}\centering
%   \caption{\label{tab:encodings}Supported encodings.
%     Non-alphanumeric characters are ignored,
%     and capital letters are lower-cased.}
%   \begin{tabular}{cc}
%     \toprule
%     \texttt{utf8}     & \textsc{utf-8} \\
%     \texttt{utf16}    & \textsc{utf-16}, with byte-order mark \\
%     \texttt{utf16be}  & \textsc{utf-16}, big-endian \\
%     \texttt{utf16le}  & \textsc{utf-16}, little-endian \\
%     \texttt{utf32}    & \textsc{utf-32}, with byte-order mark \\
%     \texttt{utf32be}  & \textsc{utf-32}, big-endian \\
%     \texttt{utf32le}  & \textsc{utf-32}, little-endian \\
%     \texttt{iso88591},  \texttt{latin1}  & \textsc{iso 8859-1} \\
%     \texttt{iso88592},  \texttt{latin2}  & \textsc{iso 8859-2} \\
%     \texttt{iso88593},  \texttt{latin3}  & \textsc{iso 8859-3} \\
%     \texttt{iso88594},  \texttt{latin4}  & \textsc{iso 8859-4} \\
%     \texttt{iso88595}                    & \textsc{iso 8859-5} \\
%     \texttt{iso88596}                    & \textsc{iso 8859-6} \\
%     \texttt{iso88597}                    & \textsc{iso 8859-7} \\
%     \texttt{iso88598}                    & \textsc{iso 8859-8} \\
%     \texttt{iso88599},  \texttt{latin5}  & \textsc{iso 8859-9} \\
%     \texttt{iso885910}, \texttt{latin6}  & \textsc{iso 8859-10} \\
%     \texttt{iso885911}                   & \textsc{iso 8859-11} \\
%     \texttt{iso885913}, \texttt{latin7}  & \textsc{iso 8859-13} \\
%     \texttt{iso885914}, \texttt{latin8}  & \textsc{iso 8859-14} \\
%     \texttt{iso885915}, \texttt{latin9}  & \textsc{iso 8859-15} \\
%     \texttt{iso885916}, \texttt{latin10} & \textsc{iso 8859-16} \\
%     \midrule
%     \texttt{native}   & Native Unicode string. \\
%     \texttt{internal} & For curious programmers. \\
%     \bottomrule
%   \end{tabular}
% \end{table}
%
% \begin{table}\centering
%   \caption{\label{tab:escapings}Supported escapings.
%     Non-alphanumeric characters are ignored,
%     and capital letters are lower-cased.}
%   \begin{tabular}{cc}
%     \toprule
%     \texttt{bytes}, or empty
%       & arbitrary bytes \\
%     \texttt{hex}, \texttt{hexadecimal}
%       & byte $=$ two hexadecimal digits \\
%     \texttt{name}
%       & see \tn{pdfescapename} \\
%     \texttt{string}
%       & see \tn{pdfescapestring} \\
%     \texttt{url}
%       & encoding used in \textsc{url}s \\
%     \bottomrule
%   \end{tabular}
% \end{table}
%
% \begin{function}{\str_set_convert:Nnnn}
%   \begin{syntax}
%     \cs{str_set_convert:Nnnn} \meta{str~var} \Arg{string}
%     ~~\Arg{name 1} \Arg{name 2}
%   \end{syntax}
%   This function converts the \meta{string} from the encoding
%   given by \meta{name 1} to the encoding given by \meta{name 2},
%   and stores the result in the \meta{str~var}.
%   Each \meta{name} can have the form \meta{encoding} or
%   \meta{encoding}\texttt{/}\meta{escaping}, where the possible values
%   of \meta{encoding} and \meta{escaping} are given in
%   Tables~\ref{tab:encodings} and~\ref{tab:escapings}, respectively.
%   The default escaping is to input and output bytes directly.
%   The special encodings \texttt{native} and \texttt{internal}
%   do not support a \meta{escaping}, since those formats do not
%   correspond to strings of bytes.
%
%   For example,
%   \begin{verbatim}
%     \str_set_convert:Nnnn \l_foo_str { Hello! }
%       { native } { utf16/hex }
%   \end{verbatim}
%   results in the variable \cs{l_foo_str} holding the string
%   \texttt{FEFF00480065006C006C006F0021}. This is obtained
%   by converting each character in the string \texttt{Hello!}
%   to the \textsc{utf-16} encoding, and expressing each byte
%   as a pair of hexadecimal digits. Note the presence of a
%   (big-endian) byte order mark \texttt{FEFF}, which can be
%   avoided by specifying the encoding \texttt{utf16be/hex}.
%
%   Parts of the \meta{string} which cannot be converted to bytes
%   using the \meta{escaping 1} are silently ignored (including non-byte
%   characters which could be present in the string).
%   Sequences of bytes which are not valid in the \meta{encoding 1}
%   are converted to the replacement character |"FFFD|, and raise
%   an error.
%   Characters which cannot be encoded in the \meta{encoding 2}
%   are silently ignored.
% \end{function}
%
% \section{Internal string functions}
%
% \begin{function}{\str_escape_use:NNNn}
%   \begin{syntax}
%     \cs{str_escape_use:NNNn} \meta{fn1} \meta{fn2} \meta{fn3} \Arg{token list}
%   \end{syntax}
%   The \meta{token list} is converted to a string, then read from
%   left to right, interpreting backslashes as escaping the next character.
%   Unescaped characters are fed to the function \meta{fn1},
%   and escaped characters are fed to the function \meta{fn2}
%   within an \texttt{x}-expansion context (typically those functions
%   perform some tests on their argument to decide how to output them).
%   The escape sequences |\a|, |\e|, |\f|, |\n|, |\r|, |\t| and |\x|
%   are recognized as described for \cs{str_input:Nn}, and those
%   are replaced by the corresponding character, then fed to
%   \meta{fn3}. The result is then left in the input stream.
% \end{function}
%
% \begin{function}[rEXP]{\str_aux_toks_range:nn}
%   \begin{syntax}
%     \cs{str_aux_toks_range:nn} \meta{start} \meta{end}
%   \end{syntax}
%   Expands to the contents of the \tn{toks} registers numbered
%   from \meta{start} (inclusive) to \meta{end} (exclusive).
%   This function is used in \pkg{l3regex}.
% \end{function}
%
% \begin{function}{\str_aux_hexadecimal_use:NTF}
%   \begin{syntax}
%     \cs{str_aux_hexadecimal_use:NTF} \meta{token}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   If the \meta{token} is a hexdecimal digit (upper case or lower case),
%   its upper-case version is left in the input strem, \emph{followed}
%   by the \meta{true code}. Otherwise, the \meta{false code} is left
%   in the input stream.
%   \begin{texnote}
%     This function will fail if the escape character is a hexadecimal
%     digit, or has a character code in the range $[0,5]$. We are thus
%     careful to set the escape character to a known value before using it.
%   \end{texnote}
% \end{function}
%
% \begin{function}[EXP]{\tl_to_other_str:n}
%   \begin{syntax}
%     \cs{tl_to_other_str:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{other string}, where
%   spaces have category code \enquote{other}.
%   \begin{texnote}
%     These functions can be \texttt{f}-expanded without fear of losing
%     a leading space, since spaces do not have category code $10$ in
%     their result.
%   \end{texnote}
% \end{function}
%
% \begin{function}{\str_gset_other:Nn}
%   \begin{syntax}
%     \cs{str_gset_other:Nn} \meta{tl~var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to an \meta{other string}, where
%   spaces have category code \enquote{other}, and assigns the result
%   to the \meta{tl~var}, globally.
% \end{function}
%
% \begin{function}[EXP]
%   {
%     \str_if_contains_char:NNT,
%     \str_if_contains_char:NNTF,
%     \str_if_contains_char:nNTF
%   }
%   \begin{syntax}
%     \cs{str_if_contains_char:nNTF} \Arg{token list} \meta{char}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}
%   and tests whether the \meta{char} is present in the \meta{string}.
%   Spaces are ignored.
% \end{function}
%
% \section{Possibilities, and things to do}
%
% \begin{itemize}
% \item Use flags rather than expandable errors.
% \item Add documentation about each encoding and escaping method,
%   and add examples.
% \item Perhaps use the pdf\TeX{} primitives for escapings when available.
%   But this changes error detection between engines.
% \item More encodings (see Heiko's \pkg{stringenc}). CESU.
% \item More escapings: shell escapes, lua escapes, etc?
% \item \cs{str_if_head_eq:nN}
% \item \cs{str_if_numeric/decimal/integer:n}, perhaps in \pkg{l3fp}?
% \item Should \cs{str_item:Nn} be \cs{str_char:Nn}?
% \end{itemize}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3str} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%    \end{macrocode}
%
% Those string-related functions are defined in \pkg{l3kernel}.
% \begin{itemize}
%   \item \cs{str_if_eq:nn}[pTF] and variants,
%   \item \cs{str_if_eq_return:on},
%   \item \cs{tl_to_str:n}, \cs{tl_to_str:N}, \cs{tl_to_str:c},
%   \item \cs{token_to_str:N}, \cs{cs_to_str:N}
%   \item \cs{str_head:n}, \cs{str_head_aux:w}, (copied here)
%   \item \cs{str_tail:n}, \cs{str_tail_aux:w}, (copied here)
%   \item \cs{str_length_skip_spaces} (deprecated)
%   \item \cs{str_length_loop:NNNNNNNNN} (unchanged)
% \end{itemize}
%
% \subsection{Helpers}
%
% \subsubsection{Assigning strings}
%
% \begin{macro}
%   {
%     \str_set:Nn, \str_set:Nx,
%     \str_set:cn, \str_set:cx,
%     \str_gset:Nn, \str_gset:Nx,
%     \str_gset:cn, \str_gset:cx,
%     \str_const:Nn, \str_const:Nx,
%     \str_const:cn, \str_const:cx,
%     \str_put_left:Nn, \str_put_left:Nx,
%     \str_put_left:cn, \str_put_left:cx,
%     \str_gput_left:Nn, \str_gput_left:Nx,
%     \str_gput_left:cn, \str_gput_left:cx,
%     \str_put_right:Nn, \str_put_right:Nx,
%     \str_put_right:cn, \str_put_right:cx,
%     \str_gput_right:Nn, \str_gput_right:Nx,
%     \str_gput_right:cn, \str_gput_right:cx,
%   }
%   Simply convert the token list inputs to \meta{strings}.
%    \begin{macrocode}
\group_begin:
  \cs_set_protected_nopar:Npn \str_tmp:w #1
    {
      \cs_new_protected:cpx { str_ #1 :Nn } ##1##2
        { \exp_not:c { tl_ #1 :Nx } ##1 { \exp_not:N \tl_to_str:n {##2} } }
      \exp_args:Nc \cs_generate_variant:Nn { str_ #1 :Nn } { Nx , cn , cx }
    }
  \str_tmp:w { set }
  \str_tmp:w { gset }
  \str_tmp:w { const }
  \str_tmp:w { put_left }
  \str_tmp:w { gput_left }
  \str_tmp:w { put_right }
  \str_tmp:w { gput_right }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Variables and constants}
%
% \begin{macro}{\str_tmp:w}
% \begin{variable}{\l_str_tmpa_tl}
%   Internal scratch space for some functions.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_tmp:w { }
\tl_new:N \l_str_tmpa_tl
\int_new:N \l_str_tmpa_int
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \begin{variable}{\g_str_result_tl}
%   The \cs{g_str_result_tl} variable is used to hold the result
%   of various internal string operations which are typically
%   performed in a group. The variable is global so that it remains
%   defined outside the group, to be assigned to a user provided variable.
%    \begin{macrocode}
\tl_new:N \g_str_result_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_str_char_int}
%   When converting from various forms to characters,
%   \cs{l_str_char_int} is the character code of the
%   character which should be created.
%    \begin{macrocode}
\int_new:N \l_str_char_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \c_forty_eight, \c_fifty_eight, \c_sixty_five, \c_ninety_one,
%     \c_ninety_seven, \c_one_hundred_twenty_three,
%     \c_one_hundred_twenty_seven
%   }
%   We declare here some integer values which delimit ranges of
%   ASCII characters of various types. This is mostly used in
%   \pkg{l3regex}.
%    \begin{macrocode}
\int_const:Nn \c_forty_eight  { 48 }
\int_const:Nn \c_fifty_eight  { 58 }
\int_const:Nn \c_sixty_five   { 65 }
\int_const:Nn \c_ninety_one   { 91 }
\int_const:Nn \c_ninety_seven { 97 }
\int_const:Nn \c_one_hundred_twenty_three { 123 }
\int_const:Nn \c_one_hundred_twenty_seven { 127 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_max_char_int}
%   The maximum character code depends on the engine.
%    \begin{macrocode}
\int_const:Nn \c_max_char_int
  { \pdftex_if_engine:TF { 255 } { 1114111 } }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_str_replacement_char_int}
%   When converting, invalid bytes are replaced by the Unicode
%   replacement character \textsc{u-fffd}.
%    \begin{macrocode}
\int_const:Nn \c_str_replacement_char_int { "FFFD }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \c_backslash_str,
%     \c_lbrace_str,
%     \c_rbrace_str,
%     \c_hash_str,
%     \c_tilde_str,
%     \c_percent_str
%   }
%   For all of those strings, \cs{cs_to_str:N} produce characters
%   with the correct category code.
%    \begin{macrocode}
\tl_const:Nx \c_backslash_str { \cs_to_str:N \\ }
\tl_const:Nx \c_lbrace_str    { \cs_to_str:N \{ }
\tl_const:Nx \c_rbrace_str    { \cs_to_str:N \} }
\tl_const:Nx \c_hash_str      { \cs_to_str:N \# }
\tl_const:Nx \c_tilde_str     { \cs_to_str:N \~ }
\tl_const:Nx \c_percent_str   { \cs_to_str:N \% }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_str_aliases_prop}
%   To avoid needing one file per encoding/escaping alias,
%   we keep track of those in a property list.
%    \begin{macrocode}
\prop_new:N \g_str_aliases_prop
\prop_gput:Nnn \g_str_aliases_prop { latin1 } { iso88591 }
\prop_gput:Nnn \g_str_aliases_prop { latin2 } { iso88592 }
\prop_gput:Nnn \g_str_aliases_prop { latin3 } { iso88593 }
\prop_gput:Nnn \g_str_aliases_prop { latin4 } { iso88594 }
\prop_gput:Nnn \g_str_aliases_prop { latin5 } { iso88599 }
\prop_gput:Nnn \g_str_aliases_prop { latin6 } { iso885910 }
\prop_gput:Nnn \g_str_aliases_prop { latin7 } { iso885913 }
\prop_gput:Nnn \g_str_aliases_prop { latin8 } { iso885914 }
\prop_gput:Nnn \g_str_aliases_prop { latin9 } { iso885915 }
\prop_gput:Nnn \g_str_aliases_prop { latin10 } { iso885916 }
\prop_gput:Nnn \g_str_aliases_prop { hexadecimal } { hex }
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{Escaping spaces}
%
% \begin{macro}[EXP]{\tl_to_other_str:n}
% \begin{macro}[EXP,aux]{\tl_to_other_str_loop:w, \tl_to_other_str_end:w}
%   Replaces all spaces by \enquote{other} spaces, after converting
%   the token list to a string via \cs{tl_to_str:n}.
%   This function is \texttt{f}-expandable, storing the part of the string
%   with escaped spaces between the \cs{q_mark} and \cs{q_stop} markers.
%    \begin{macrocode}
\group_begin:
\char_set_lccode:nn { `\* } { `\  }
\char_set_lccode:nn { `\A } { `\A }
\tl_to_lowercase:n
  {
    \group_end:
    \cs_new:Npn \tl_to_other_str:n #1
      {
        \exp_after:wN \tl_to_other_str_loop:w \tl_to_str:n {#1} ~ %
        A ~ A ~ A ~ A ~ A ~ A ~ A ~ A ~ \q_mark \q_stop
      }
    \cs_new_nopar:Npn \tl_to_other_str_loop:w
      #1 ~ #2 ~ #3 ~ #4 ~ #5 ~ #6 ~ #7 ~ #8 ~ #9 \q_stop
      {
        \if_meaning:w A #8
          \tl_to_other_str_end:w
        \fi:
        \tl_to_other_str_loop:w
        #9 #1 * #2 * #3 * #4 * #5 * #6 * #7 * #8 * \q_stop
      }
    \cs_new_nopar:Npn \tl_to_other_str_end:w \fi: #1 \q_mark #2 * A #3 \q_stop
      { \fi: #2 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_gset_other:Nn}
% \begin{macro}[aux,EXP]{\str_gset_other_loop:w}
% \begin{macro}[aux,EXP]{\str_gset_other_end:w}
%   This function could be done by using \cs{tl_to_other_str:n}
%   within an \texttt{x}-expansion, but that would take a time
%   quadratic in the size of the string. Instead, we can
%   \enquote{leave the result behind us} in the input stream,
%   to be captured into the expanding assignment. This gives us
%   a linear time.
%    \begin{macrocode}
\group_begin:
\char_set_lccode:nn { `\* } { `\  }
\char_set_lccode:nn { `\A } { `\A }
\tl_to_lowercase:n
  {
    \group_end:
    \cs_new_protected:Npn \str_gset_other:Nn #1#2
      {
        \tl_gset:Nx #1
          {
            \exp_after:wN \str_gset_other_loop:w \tl_to_str:n {#2} ~ %
            A ~ A ~ A ~ A ~ A ~ A ~ A ~ A ~ A ~ \q_mark \q_stop
          }
      }
    \cs_new_nopar:Npn \str_gset_other_loop:w
      #1 ~ #2 ~ #3 ~ #4 ~ #5 ~ #6 ~ #7 ~ #8 ~ #9 ~
      {
        \if_meaning:w A #9
          \str_gset_other_end:w
        \fi:
        #1 * #2 * #3 * #4 * #5 * #6 * #7 * #8 * #9
        \str_gset_other_loop:w *
      }
    \cs_new_nopar:Npn \str_gset_other_end:w \fi: #1 * A #2 \q_stop
      { \fi: #1 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Functions unrelated to strings}
%
% \begin{macro}[EXP,aux]{\use_i:nnnnnnnn}
%   A function which may already be defined elsewhere.
%    \begin{macrocode}
\cs_if_exist:NF \use_i:nnnnnnnn
  { \cs_new:Npn \use_i:nnnnnnnn #1#2#3#4#5#6#7#8 {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, rEXP]{\str_aux_toks_range:nn}
% \begin{macro}[aux, rEXP]{\str_aux_toks_range:ww}
%   Some non-expandable functions (in this module,
%   \cs{str_aux_escape:NNNn}, which is used by \cs{str_(g)input:Nn})
%   store pieces of their result in \tn{toks} registers.
%   Those pieces are concatenated using \cs{str_aux_toks_range:nn},
%   which expects two integer registers, \meta{start} and \meta{end},
%   and expands to the contents of the \tn{toks} registers from
%   \meta{start} (inclusive) to \meta{end} (exclusive).
%   This function is also used in the \pkg{l3regex} module.
%    \begin{macrocode}
\cs_new:Npn \str_aux_toks_range:nn #1#2
  {
    \exp_after:wN \str_aux_toks_range:ww
    \int_use:N \int_eval:w #1 \exp_after:wN ;
    \int_use:N \int_eval:w #2 ;
    \prg_break_point:n { }
  }
\cs_new:Npn \str_aux_toks_range:ww #1 ; #2 ;
  {
    \if_num:w #1 = #2 \exp_stop_f:
      \exp_after:wN \prg_map_break:
    \fi:
    \tex_the:D \tex_toks:D #1 \exp_stop_f:
    \exp_after:wN \str_aux_toks_range:ww
      \int_use:N \int_eval:w #1 + \c_one ; #2 ;
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Characters given by their position}
%
% \begin{macro}[EXP]{\str_length:N}
% \begin{macro}[EXP]{\str_length:n}
% \begin{macro}[EXP]{\str_length_ignore_spaces:n}
% \begin{macro}[EXP]{\str_length_unsafe:n}
% \begin{macro}[EXP,aux]{\str_length_aux:n,\str_length_loop:NNNNNNNNN}
%   The length of a string is found by first changing all spaces
%   to other spaces using \cs{tl_to_other_str:n}, then counting
%   characters $9$ at a time. When the end is reached, |#9|
%   has the form |X|\meta{digit}, the catcode test is true,
%   the digit gets added to the sum, and the loop is terminated
%   by \cs{use_none_delimit_by_q_stop:w}.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_length:N { \exp_args:No \str_length:n }
\cs_new:Npn \str_length:n #1
  { \exp_args:Nf \str_length_unsafe:n { \tl_to_other_str:n {#1} } }
\cs_new_nopar:Npn \str_length_unsafe:n #1
  { \str_length_aux:n { \str_length_loop:NNNNNNNNN #1 } }
\cs_new:Npn \str_length_ignore_spaces:n #1
  {
    \str_length_aux:n
      { \exp_after:wN \str_length_loop:NNNNNNNNN \tl_to_str:n {#1} }
  }
\cs_new:Npn \str_length_aux:n #1
  {
    \int_eval:n
      {
        #1
        { X \c_eight } { X \c_seven } { X \c_six   }
        { X \c_five  } { X \c_four  } { X \c_three }
        { X \c_two   } { X \c_one   } { X \c_zero  }
        \q_stop
      }
  }
\cs_set:Npn \str_length_loop:NNNNNNNNN #1#2#3#4#5#6#7#8#9
  {
    \if_catcode:w X #9
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi:
    \c_nine + \str_length_loop:NNNNNNNNN
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_head:N}
% \begin{macro}[EXP]{\str_head:n}
% \begin{macro}[EXP]{\str_head_ignore_spaces:n}
% \begin{macro}[EXP]{\str_head_unsafe:n}
% \begin{macro}[EXP,aux]{\str_head_aux:w}
%   The cases of \cs{str_head_ignore_spaces:n} and
%   \cs{str_head_unsafe:n} are mostly identical to
%   \cs{tl_head:n}.
%   As usual, \cs{str_head:N} expands its argument and hands it to
%   \cs{str_head:n}. To circumvent the fact that \TeX{} skips spaces
%   when grabbing undelimited macro parameters, \cs{str_head_aux:w}
%   takes an argument delimited by a space. If |#1| starts with a
%   non-space character, \cs{use_i_delimit_by_q_stop:nw} leaves that
%   in the input stream. On the other hand, if |#1| starts with a
%   space, the \cs{str_head_aux:w} takes an empty argument, and
%   the single (braced) space in the definition of \cs{str_head_aux:w}
%   makes its way to the output. Finally, for an empty argument,
%   the (braced) empty brace group in the definition of \cs{str_head:n}
%   gives an empty result after passing through
%   \cs{use_i_delimit_by_q_stop:nw}.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_head:N { \exp_args:No \str_head:n }
\cs_set:Npn \str_head:n #1
  {
    \exp_after:wN \str_head_aux:w
    \tl_to_str:n {#1}
    { { } } ~ \q_stop
  }
\cs_set_nopar:Npn \str_head_aux:w #1 ~ %
  { \use_i_delimit_by_q_stop:nw #1 { ~ } }
\cs_new:Npn \str_head_ignore_spaces:n #1
  { \exp_after:wN \use_i_delimit_by_q_stop:nw \tl_to_str:n {#1} { } \q_stop }
\cs_new_nopar:Npn \str_head_unsafe:n #1
  { \use_i_delimit_by_q_stop:nw #1 { } \q_stop }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_tail:N}
% \begin{macro}[EXP]{\str_tail:n}
% \begin{macro}[EXP]{\str_tail_ignore_spaces:n}
% \begin{macro}[EXP]{\str_tail_unsafe:n}
% \begin{macro}[EXP,aux]{\str_tail_aux:w}
% \begin{macro}[EXP,aux]{\str_tail_aux_ii:w}
%   As when fetching the head of a string, the cases
%   \enquote{\texttt{ignore_spaces:n}} and \enquote{\texttt{unsafe:n}}
%   are similar to \cs{tl_tail:n}.
%   The more commonly used \cs{str_tail:n} function is a little bit
%   more convoluted: hitting the front of the string with
%   \cs{reverse_if:N} \cs{if_charcode:w} \cs{scan_stop:}
%   removes the first character (which necessarily makes the test true,
%   since it cannot match \cs{scan_stop:}). The auxiliary function inserts
%   the required \cs{fi:} to close the conditional, and leaves the tail
%   of the string in the input string. The details are such that an empty
%   string has an empty tail.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_tail:N { \exp_args:No \str_tail:n }
\cs_set:Npn \str_tail:n #1
  {
    \exp_after:wN \str_tail_aux:w
    \reverse_if:N \if_charcode:w
        \scan_stop: \tl_to_str:n {#1} X X \q_stop
  }
\cs_set_nopar:Npn \str_tail_aux:w #1 X #2 \q_stop { \fi: #1 }
\cs_new:Npn \str_tail_ignore_spaces:n #1
  {
    \exp_after:wN \str_tail_aux_ii:w
    \tl_to_str:n {#1} X { } X \q_stop
  }
\cs_new_nopar:Npn \str_tail_unsafe:n #1
  { \str_tail_aux_ii:w #1 X { } X \q_stop }
\cs_new_nopar:Npn \str_tail_aux_ii:w #1 #2 X #3 \q_stop { #2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,int]{\str_skip_do:nn}
% \begin{macro}[EXP,aux]{\str_skip_aux:nnnnnnnnn}
% \begin{macro}[EXP,aux]{\str_skip_end:nn}
% \begin{macro}[EXP,aux]{\str_skip_end_ii:nwn}
%   Removes |max(#1,0)| characters then leaves |#2| in the input stream.
%   We remove characters $7$ at a time. When the number of characters
%   to remove is not a multiple of $7$, we need to remove less than
%   $7$ characters in the last step. This is done by inserting a number
%   of \texttt{X}, which are discarded as if they were part of the string.
%    \begin{macrocode}
\cs_new:Npn \str_skip_do:nn #1
  {
    \if_num:w \int_eval:w #1 > \c_seven
      \exp_after:wN \str_skip_aux:nnnnnnnnn
    \else:
      \exp_after:wN \str_skip_end:n
    \fi:
      {#1}
  }
\cs_new:Npn \str_skip_aux:nnnnnnnnn #1#2#3#4#5#6#7#8#9
  { \exp_args:Nf \str_skip_do:nn { \int_eval:n { #1 - \c_seven } } {#2} }
\cs_new:Npn \str_skip_end:n #1
  {
    \if_case:w \int_eval:w #1 \int_eval_end:
         \str_skip_end_ii:nwn { XXXXXXX }
    \or: \str_skip_end_ii:nwn { XXXXXX }
    \or: \str_skip_end_ii:nwn { XXXXX }
    \or: \str_skip_end_ii:nwn { XXXX }
    \or: \str_skip_end_ii:nwn { XXX }
    \or: \str_skip_end_ii:nwn { XX }
    \or: \str_skip_end_ii:nwn { X }
    \or: \str_skip_end_ii:nwn {  }
    \else: \str_skip_end_ii:nwn { XXXXXXX }
    \fi:
  }
\cs_new:Npn \str_skip_end_ii:nwn #1#2 \fi: #3
  { \fi: \use_i:nnnnnnnn {#3} #1 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,int]{\str_collect_do:nn}
% \begin{macro}[EXP,aux]{\str_collect_aux:n,\str_collect_aux:nnNNNNNNN}
% \begin{macro}[EXP,aux]
%   {
%     \str_collect_end:nn,
%     \str_collect_end_ii:nwn,
%     \str_collect_end_iii:nwNNNNNNN
%   }
%   Collects |max(#1,0)| characters, and feeds them as an argument to |#2|.
%   Again, we grab $7$ characters at a time. Instead of inserting
%   a string of \texttt{X} to fill in to a multiple of $7$, we insert
%   empty groups, so that they disappear in this context where arguments
%   are accumulated.
%    \begin{macrocode}
\cs_new:Npn \str_collect_do:nn #1#2
  { \str_collect_aux:n {#1} { \str_collect_end_iii:nwNNNNNNN {#2} } }
\cs_new:Npn \str_collect_aux:n #1
  {
    \int_compare:nNnTF {#1} > \c_seven
      { \str_collect_aux:nnNNNNNNN }
      { \str_collect_end:n }
      {#1}
  }
\cs_new:Npn \str_collect_aux:nnNNNNNNN #1#2 #3#4#5#6#7#8#9
  {
    \exp_args:Nf \str_collect_aux:n
      { \int_eval:n { #1 - \c_seven } }
      { #2 #3#4#5#6#7#8#9 }
  }
\cs_new:Npn \str_collect_end:n #1
  {
    \if_case:w \int_eval:w #1 \int_eval_end:
         \str_collect_end_ii:nwn { { } { } { } { } { } { } { } }
    \or: \str_collect_end_ii:nwn { { } { } { } { } { } { } }
    \or: \str_collect_end_ii:nwn { { } { } { } { } { } }
    \or: \str_collect_end_ii:nwn { { } { } { } { } }
    \or: \str_collect_end_ii:nwn { { } { } { } }
    \or: \str_collect_end_ii:nwn { { } { } }
    \or: \str_collect_end_ii:nwn { { } }
    \or: \str_collect_end_ii:nwn {  }
    \else: \str_collect_end_ii:nwn { { } { } { } { } { } { } { } }
    \fi:
  }
\cs_new:Npn \str_collect_end_ii:nwn #1#2 \fi: #3
  { \fi: #3 \q_stop #1 }
\cs_new:Npn \str_collect_end_iii:nwNNNNNNN #1 #2 \q_stop #3#4#5#6#7#8#9
  { #1 {#2#3#4#5#6#7#8#9} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_item:Nn}
% \begin{macro}[EXP]{\str_item:nn}
% \begin{macro}[EXP]{\str_item_ignore_spaces:nn}
% \begin{macro}[EXP]{\str_item_unsafe:nn}
% \begin{macro}[EXP,aux]{\str_item_aux:nn}
%   This is mostly shuffling arguments around to avoid measuring
%   the length of the string more than once, and make sure that
%   the parameters given to \cs{str_skip_do:nn} are necessarily
%   within the bounds of the length of the string.
%   The \cs{str_item_ignore_spaces:nn} function cheats a little bit
%   in that it doesn't hand to \cs{str_item_unsafe:nn} an
%   \enquote{other string}. This is alright, as everything else
%   is done with undelimited arguments.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_item:Nn { \exp_args:No \str_item:nn }
\cs_new:Npn \str_item:nn #1#2
  {
    \exp_args:Nf \tl_to_str:n
      { \exp_args:Nf \str_item_unsafe:nn { \tl_to_other_str:n {#1} } {#2} }
  }
\cs_new:Npn \str_item_ignore_spaces:nn #1
  { \exp_args:No \str_item_unsafe:nn { \tl_to_str:n {#1} } }
\cs_new_nopar:Npn \str_item_unsafe:nn #1#2
  {
    \exp_args:Nff \str_item_aux:nn
      { \int_eval:n {#2} }
      { \str_length_unsafe:n {#1} }
      #1
    \q_stop
  }
\cs_new_nopar:Npn \str_item_aux:nn #1#2
  {
    \int_compare:nNnTF {#1} < \c_zero
      {
        \int_compare:nNnTF {#1} < {-#2}
          { \use_none_delimit_by_q_stop:w }
          {
            \str_skip_do:nn { #1 + #2 }
              { \use_i_delimit_by_q_stop:nw }
          }
      }
      {
        \int_compare:nNnTF {#1} < {#2}
          {
            \str_skip_do:nn {#1}
              { \use_i_delimit_by_q_stop:nw }
          }
          { \use_none_delimit_by_q_stop:w }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_substr:Nnn}
% \begin{macro}[EXP]{\str_substr:nnn}
% \begin{macro}[EXP]{\str_substr_ignore_spaces:nnn}
% \begin{macro}[EXP]{\str_substr_unsafe:nnn}
% \begin{macro}[EXP,aux]{\str_substr_aux:www}
% \begin{macro}[EXP,aux]{\str_substr_aux:nnw}
% \begin{macro}[EXP,aux]{\str_aux_normalize_range:nn}
%   Sanitize the string. Then evaluate the arguments, replacing
%   them by \cs{c_zero} or \cs{c_max_int} if they are empty.
%   This is done by using the construction
%   \begin{verbatim}
%     \int_use:N \int_eval:w #2 \c_zero \c_zero ;
%   \end{verbatim}
%   which expands to the value of |#2|, followed by |\c_zero \c_zero ;|
%   if |#2| is an expression, and expands to |0\c_zero ;| otherwise.
%   The same is done to the end-point of the range.
%   Then limit the range to be at most the length of the string
%   (this avoids needing to check for the end of the string when
%   grabbing characters).
%   Afterwards, skip characters, then keep some more, and finally
%   drop the end of the string.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_substr:Nnn { \exp_args:No \str_substr:nnn }
\cs_new:Npn \str_substr:nnn #1#2#3
  {
    \exp_args:Nf \tl_to_str:n
      {
        \exp_args:Nf \str_substr_unsafe:nnn
          { \tl_to_other_str:n {#1} } {#2} {#3}
      }
  }
\cs_new:Npn \str_substr_ignore_spaces:nnn #1
  { \exp_args:No \str_substr_unsafe:nnn { \tl_to_str:n {#1} } }
\cs_new:Npn \str_substr_unsafe:nnn #1#2#3
  {
    \exp_after:wN \str_substr_aux:www
    \int_value:w \str_length_unsafe:n {#1} \exp_after:wN ;
    \int_use:N \int_eval:w #2 + \c_zero \exp_after:wN ;
    \int_use:N \int_eval:w \exp_args:Nf \str_substr_unsafe:nN {#3} \c_max_int ;
      #1
    \q_stop
  }
\cs_new:Npn \str_substr_unsafe:nN #1 #2
  { \tl_if_empty:nTF {#1} {#2} {#1} }
\cs_new:Npn \str_substr_aux:www #1; #2; #3;
  {
    \exp_args:Nf \str_substr_aux:nnw
      { \str_aux_normalize_range:nn {#2} {#1} }
      { \str_aux_normalize_range:nn {#3} {#1} }
  }
\cs_new:Npn \str_substr_aux:nnw #1#2
  {
    \str_skip_do:nn {#1}
      {
        \exp_args:Nf \str_collect_do:nn
          { \int_eval:n { #2 - #1 } }
          { \use_i_delimit_by_q_stop:nw }
      }
  }
\cs_new:Npn \str_aux_normalize_range:nn #1#2
  {
    \int_eval:n
      {
        \if_num:w #1 < \c_zero
          \if_num:w #1 < - #2 \exp_stop_f:
            \c_zero
          \else:
            #1 + #2
          \fi:
        \else:
          \if_num:w #1 < #2 \exp_stop_f:
            #1
          \else:
            #2
          \fi:
        \fi:
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{String conditionals}
%
% \begin{macro}[EXP,pTF]{\str_if_eq:NN}
% \begin{macro}[EXP,pTF]{\str_if_eq:nn,\str_if_eq:xx}
%   The \texttt{nn} and \texttt{xx} variants are already
%   defined in \pkg{l3basics}. Note that \cs{str_if_eq:NN}
%   is different from \cs{tl_if_eq:NN} because it needs to
%   ignore category codes.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_if_eq:NN #1#2 { p , TF , T , F }
  {
    \if_int_compare:w \pdftex_strcmp:D { \tl_to_str:N #1 } { \tl_to_str:N #2 }
      = \c_zero \prg_return_true: \else: \prg_return_false: \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_if_contains_char:NNT, \str_if_contains_char:NNTF}
% \begin{macro}[EXP]{\str_if_contains_char:nNTF}
% \begin{macro}[EXP,aux]{\str_if_contains_char_aux:NN}
% \begin{macro}[EXP,aux]{\str_if_contains_char_end:}
%   Loop over the characters of the string, comparing character codes.
%   We allow |#2| to be a single-character control sequence, hence the
%   use of \cs{int_compare:nNnT} rather than \cs{token_if_eq_charcode:NNT}.
%   The loop is broken if character codes match. Otherwise we return
%   \enquote{false}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_if_contains_char:NN #1#2 { T , TF }
  {
    \exp_after:wN \str_if_contains_char_aux:NN \exp_after:wN #2
      #1 { \prg_map_break:n { ? \fi: } }
    \prg_break_point:n { }
    \prg_return_false:
  }
\prg_new_conditional:Npnn \str_if_contains_char:nN #1#2 { TF }
  {
    \exp_after:wN \str_if_contains_char_aux:NN \exp_after:wN #2
      \tl_to_str:n {#1} { \prg_map_break:n { ? \fi: } }
    \prg_break_point:n { }
    \prg_return_false:
  }
\cs_new_nopar:Npn \str_if_contains_char_aux:NN #1#2
  {
    \if_charcode:w #1 #2
      \exp_after:wN \str_if_contains_char_end:
    \fi:
    \str_if_contains_char_aux:NN #1
  }
\cs_new_nopar:Npn \str_if_contains_char_end:
  { \prg_map_break:n { \prg_return_true: \use_none:n } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\str_aux_octal_use:NTF}
%   \TeX{} dutifully detects octal digits for us: if |#1|
%   is an octal digit, then the right-hand side of the
%   comparison is |'1#1|, greater than $1$. Otherwise,
%   the right-hand side stops as |'1|, and the conditional
%   takes the \texttt{false} branch.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_aux_octal_use:N #1 { TF }
  {
    \if_num:w \c_one < '1 \token_to_str:N #1 \exp_stop_f:
      #1 \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\str_aux_hexadecimal_use:NTF}
%   \TeX{} detects uppercase hexadecimal digits for us
%   (see \cs{str_aux_octal_use:NTF}, but not the
%   lowercase letters, which we need to detect and replace
%   by their uppercase counterpart.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_aux_hexadecimal_use:N #1 { TF }
  {
    \if_num:w \c_two < "1 \token_to_str:N #1 \exp_stop_f:
      #1 \prg_return_true:
    \else:
      \if_case:w \int_eval:w
          \exp_after:wN ` \token_to_str:N #1 - `a
        \int_eval_end:
           A
      \or: B
      \or: C
      \or: D
      \or: E
      \or: F
      \else:
        \prg_return_false:
        \exp_after:wN \use_none:n
      \fi:
      \prg_return_true:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Conversions}
%
% \subsubsection{Producing one byte or character}
%
% \begin{variable}{\c_str_byte_0_tl}
% \begin{variable}{\c_str_byte_-1_tl}
% \begin{variable}{\c_str_positive_bytes_tl}
%   For each integer $N$ in the range $[0,255]$, we create
%   a constant token list which holds three character tokens
%   with category code other: the character with character
%   code $N$, followed by the representation of $N$ as
%   two hexadecimal digits.
%   The value $-1$ is given a default token list which ensures
%   that later functions give an empty result for the input $-1$.
%   Simultaneously, we build a list of all bytes (from which we
%   remove the null byte) in \cs{c_str_positive_bytes_tl}.
%    \begin{macrocode}
\group_begin:
  \tl_clear:N \l_str_tmpa_tl
  \char_set_catcode_other:n { \c_zero }
  \tl_gset:Nx \g_str_result_tl { \tl_to_str:n { 0123456789ABCDEF } }
  \tl_map_inline:Nn \g_str_result_tl
    { \char_set_lccode:nn {`#1} {`#1} }
  \tl_map_inline:Nn \g_str_result_tl
    {
      \tl_map_inline:Nn \g_str_result_tl
        {
          \char_set_lccode:nn { \c_zero } {"#1##1}
          \tl_to_lowercase:n
            {
              \tl_const:cx
                { c_str_byte_ \int_eval:n {"#1##1} _tl }
                { ^^@ #1 ##1 }
              \tl_put_right:Nn \l_str_tmpa_tl { ^^@ }
            }
        }
    }
  \tl_const:Nx \c_str_positive_bytes_tl
    { \exp_after:wN \use_none:n \l_str_tmpa_tl }
\group_end:
\tl_const:cn { c_str_byte_-1_tl } { { } \use_none:n { } }
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \begin{macro}[int, EXP]{\str_output_byte:n}
% \begin{macro}[aux, EXP]{\str_output_byte:w}
% \begin{macro}[int, EXP]{\str_output_hexadecimal:n}
% \begin{macro}[aux, EXP]{\str_output_hexadecimal:w}
% \begin{macro}[aux, EXP]{\str_output_end:}
%   For now, no error detection, we simply pick either
%   the byte or the hexadecimal representation of it
%   from the three-character token list corresponding
%   to the argument.
%   The value $-1$ produces an empty result.
%    \begin{macrocode}
\cs_new:Npn \str_output_byte:n #1
  { \str_output_byte:w #1 \str_output_end: }
\cs_new_nopar:Npn \str_output_byte:w
  {
    \exp_after:wN \exp_after:wN
    \exp_after:wN \use_i:nnn
    \cs:w c_str_byte_ \int_use:N \int_eval:w
  }
\cs_new:Npn \str_output_hexadecimal:n #1
  { \str_output_hexadecimal:w #1 \str_output_end: }
\cs_new_nopar:Npn \str_output_hexadecimal:w
  {
    \exp_after:wN \exp_after:wN
    \exp_after:wN \use_none:n
    \cs:w c_str_byte_ \int_use:N \int_eval:w
  }
\cs_new_nopar:Npn \str_output_end:
  { \int_eval_end: _tl \cs_end: }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Mapping functions for encoding conversion}
%
% \begin{macro}{\str_aux_gmap_result:N}
% \begin{macro}[aux, rEXP]{\str_aux_gmap_result_loop:NN}
%   This maps the function |#1| over all characters
%   in \cs{g_str_result_tl}, which should be a byte
%   string in most cases, sometimes a native string.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_aux_gmap_result:N #1
  {
    \tl_gset:Nx \g_str_result_tl
      {
        \exp_after:wN \str_aux_gmap_result_loop:NN
        \exp_after:wN #1
          \g_str_result_tl { ? \prg_map_break: }
        \prg_break_point:n { }
      }
  }
\cs_new_nopar:Npn \str_aux_gmap_result_loop:NN #1#2
  {
    \use_none:n #2
    #1#2
    \str_aux_gmap_result_loop:NN #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\str_aux_gmap_internal_result:N}
% \begin{macro}[aux, rEXP]{\str_aux_gmap_internal_result_loop:Nw}
%   This maps the function |#1| over all character codes
%   in \cs{g_str_result_tl}, which must be in the internal
%   representation.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_aux_gmap_internal_result:N #1
  {
    \tl_gset:Nx \g_str_result_tl
      {
        \exp_after:wN \str_aux_gmap_internal_result_loop:Nww
        \exp_after:wN #1
          \g_str_result_tl \q_mark \q_stop \prg_map_break: ,
        \prg_break_point:n { }
      }
  }
\cs_new_nopar:Npn \str_aux_gmap_internal_result_loop:Nww #1#2\q_mark #3,
  {
    \use_none_delimit_by_q_stop:w #3 \q_stop
    #1 {#3}
    \str_aux_gmap_internal_result_loop:Nww #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Unescape user input}
%
% The code of this section is used both here for \cs{str_(g)input:Nn},
% and in the regular expression module to go through the regular expression
% once before actually parsing it. The goal in that case is to turn any
% character with a meaning in regular expressions (\texttt{*}, \texttt{?},
% \texttt{\{}, etc.) into a marker indicating that this was a special
% character,
% and replace any escaped character by the corresponding unescaped character,
% so that the \pkg{l3regex} code can avoid caring about escaping issues
% (those can become quite complex to handle in combination with ranges
% in character classes).
%
% The idea is to feed unescaped characters to one function,
% escaped characters to another, and feed |\a|, |\e|, |\f|,
% |\n|, |\r|, |\t| and |\x| converted to the appropriate
% character to a third function. Spaces are ignored unless
% escaped.
% For the \cs{str_(g)input:Nn} application, all the functions are simply
% \cs{token_to_str:N} (this ensures that spaces correctly get assigned
% category code $10$).
% For the \pkg{l3regex} applications, the functions do some further
% tests on the character they receive.
%
% \begin{macro}{\str_input:Nn,\str_ginput:Nn}
%   Simple wrappers around the internal \cs{str_aux_escape:NNNn}.
%    \begin{macrocode}
\cs_new_protected:Npn \str_input:Nn #1#2
  {
    \str_aux_escape:NNNn \token_to_str:N \token_to_str:N \token_to_str:N {#2}
    \tl_set_eq:NN #1 \g_str_result_tl
  }
\cs_new_protected:Npn \str_ginput:Nn #1#2
  {
    \str_aux_escape:NNNn \token_to_str:N \token_to_str:N \token_to_str:N {#2}
    \tl_gset_eq:NN #1 \g_str_result_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\str_escape_use:NNNn}
%   Use the internal \cs{str_aux_escape:NNNn}, then leave the result
%   in the input stream. This is used in \pkg{l3regex}.
%    \begin{macrocode}
\cs_new_protected:Npn \str_escape_use:NNNn #1#2#3#4
  {
    \str_aux_escape:NNNn #1#2#3 {#4}
    \g_str_result_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\str_aux_escape:NNNn}
% \begin{macro}[aux]{\str_aux_escape_loop:N}
% \begin{macro}[aux]+\str_aux_escape_\:w+
%   Most of the work is done within an \texttt{x}-expanding assignment,
%   but the |\x| escape sequence cannot be done in that way. Therefore,
%   we interrupt the assignment at each |\x| escape sequence, store the
%   partial result in a \tn{toks} register, and at the end unpack all
%   of the \tn{toks} registers to the left of the last chunk of
%   \cs{g_str_result_tl}.
%    \begin{macrocode}
\cs_new_protected:Npn \str_aux_escape:NNNn #1#2#3#4
  {
    \group_begin:
      \cs_set_nopar:Npn \str_aux_escape_unescaped:N { #1 }
      \cs_set_nopar:Npn \str_aux_escape_escaped:N { #2 }
      \cs_set_nopar:Npn \str_aux_escape_raw:N { #3 }
      \int_set:Nn \tex_escapechar:D { 92 }
      \str_gset_other:Nn \g_str_result_tl {#4}
      \int_zero:N \l_str_tmpa_int
      \tl_gset:Nx \g_str_result_tl
        {
          \exp_after:wN \str_aux_escape_loop:N \g_str_result_tl
          \q_recursion_tail \q_recursion_stop
        }
      \tl_gput_left:Nx \g_str_result_tl
        { \str_aux_toks_range:nn \c_zero \l_str_tmpa_int }
    \group_end:
  }
\cs_new_nopar:Npn \str_aux_escape_loop:N #1
  {
    \cs_if_exist_use:cF { str_aux_escape_\token_to_str:N #1:w }
      { \str_aux_escape_unescaped:N #1 }
    \str_aux_escape_loop:N
  }
\cs_new_nopar:cpn { str_aux_escape_ \c_backslash_str :w }
    \str_aux_escape_loop:N #1
  {
    \cs_if_exist_use:cF { str_aux_escape_/\token_to_str:N #1:w }
      { \str_aux_escape_escaped:N #1 }
    \str_aux_escape_loop:N
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\str_aux_escape_unescaped:N}
% \begin{macro}[aux]{\str_aux_escape_escaped:N}
% \begin{macro}[aux]{\str_aux_escape_raw:N}
%   Those functions are never called before being given a new meaning,
%   so their definitions here don't matter.
%    \begin{macrocode}
\cs_new_eq:NN \str_aux_escape_unescaped:N \prg_do_nothing:
\cs_new_eq:NN \str_aux_escape_escaped:N   \prg_do_nothing:
\cs_new_eq:NN \str_aux_escape_raw:N       \prg_do_nothing:
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]+\str_aux_escape_\q_recursion_tail:w+
% \begin{macro}[aux]+\str_aux_escape_/\q_recursion_tail:w+
% \begin{macro}[aux]+\str_aux_escape_ :w+
% \begin{macro}[aux]
%   {
%     \str_aux_escape_/a:w, \str_aux_escape_/e:w, \str_aux_escape_/f:w,
%     \str_aux_escape_/n:w, \str_aux_escape_/r:w, \str_aux_escape_/t:w
%   }
%   The loop is ended upon seeing \cs{q_recursion_tail}.
%   Spaces are ignored, and |\a|, |\e|, |\f|, |\n|, |\r|, |\t| take
%   their meaning here.
%    \begin{macrocode}
\cs_new_eq:cN
  { str_aux_escape_ \c_backslash_str q_recursion_tail :w }
  \use_none_delimit_by_q_recursion_stop:w
\cs_new_eq:cN
  { str_aux_escape_ / \c_backslash_str q_recursion_tail :w }
  \use_none_delimit_by_q_recursion_stop:w
\cs_new_nopar:cpn { str_aux_escape_~:w } { }
\cs_new_nopar:cpx { str_aux_escape_/a:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^G }
\cs_new_nopar:cpx { str_aux_escape_/t:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^I }
\cs_new_nopar:cpx { str_aux_escape_/n:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^J }
\cs_new_nopar:cpx { str_aux_escape_/f:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^L }
\cs_new_nopar:cpx { str_aux_escape_/r:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^M }
\cs_new_nopar:cpx { str_aux_escape_/e:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^[ }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\str_aux_escape_/x:w}
% \begin{macro}[aux]{\str_aux_escape_x_test:N}
% \begin{macro}[aux]{\str_aux_escape_x_unbraced_i:N}
% \begin{macro}[aux]{\str_aux_escape_x_unbraced_ii:N}
% \begin{macro}[aux]{\str_aux_escape_x_braced_loop:N}
% \begin{macro}[aux]{\str_aux_escape_x_braced_end:N}
% \begin{macro}[aux]{\str_aux_escape_x_end:}
%   When |\x| is encountered, interrupt the assignment,
%   and distinguish the cases of a braced or unbraced syntax.
%   In the braced case, collect arbitrarily many hexadecimal digits,
%   building the number in \cs{l_str_char_int} (using
%   \cs{str_aux_hexadecimal_use:NTF}), and check that
%   the run of digits was stopped by a closing brace.
%   In the unbraced case, collect up to two hexadecimal digits,
%   possibly less, building the character number in \cs{l_str_char_int}.
%   In both cases, once all digits have been collected, use
%   the \TeX{} primitive \tn{lowercase} to produce that character,
%   and use an \cs{if_false:} trick to restart the assignment.
%    \begin{macrocode}
\cs_new_nopar:cpn { str_aux_escape_/x:w } \str_aux_escape_loop:N
  {
    \if_false: { \fi: }
    \tex_toks:D \l_str_tmpa_int \exp_after:wN { \g_str_result_tl }
    \int_incr:N \l_str_tmpa_int
    \int_zero:N \l_str_char_int
    \str_aux_escape_x_test:N
  }
\cs_new_protected_nopar:Npx \str_aux_escape_x_test:N #1
  {
    \exp_not:N \token_if_eq_charcode:NNTF \c_space_token #1
      { \exp_not:N \str_aux_escape_x_test:N }
      {
        \l_str_char_int = "0
          \exp_not:N \token_if_eq_charcode:NNTF \c_lbrace_str #1
            { \exp_not:N \str_aux_escape_x_braced_loop:N }
            { \exp_not:N \str_aux_escape_x_unbraced_i:N #1 }
      }
  }
\cs_new_nopar:Npn \str_aux_escape_x_unbraced_i:N #1
  {
    \str_aux_hexadecimal_use:NTF #1
      { \str_aux_escape_x_unbraced_ii:N }
      { \exp_stop_f: \str_aux_escape_x_end: #1 }
  }
\cs_new_nopar:Npn \str_aux_escape_x_unbraced_ii:N #1
  {
    \token_if_eq_charcode:NNTF \c_space_token #1
      { \str_aux_escape_x_unbraced_ii:N }
      {
        \str_aux_hexadecimal_use:NTF #1
          { \exp_stop_f: \str_aux_escape_x_end: }
          { \exp_stop_f: \str_aux_escape_x_end: #1 }
      }
  }
\cs_new_nopar:Npn \str_aux_escape_x_braced_loop:N #1
  {
    \token_if_eq_charcode:NNTF \c_space_token #1
      { \str_aux_escape_x_braced_loop:N }
      {
        \str_aux_hexadecimal_use:NTF #1
          { \str_aux_escape_x_braced_loop:N }
          { \exp_stop_f: \str_aux_escape_x_braced_end:N #1 }
      }
  }
\cs_new_protected_nopar:Npx \str_aux_escape_x_braced_end:N #1
  {
    \exp_not:N \token_if_eq_charcode:NNTF \c_rbrace_str #1
      { \exp_not:N \str_aux_escape_x_end: }
      {
        \msg_kernel_error:nn { str } { x-missing-brace }
        \exp_not:N \str_aux_escape_x_end: #1
      }
  }
\group_begin:
  \char_set_catcode_other:N \^^@
  \cs_new_protected_nopar:Npn \str_aux_escape_x_end:
    {
      \tex_lccode:D \c_zero \l_str_char_int
      \tl_to_lowercase:n
        {
          \tl_gset:Nx \g_str_result_tl
            { \if_false: } \fi:
            \str_aux_escape_raw:N ^^@
            \str_aux_escape_loop:N
        }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Framework for encoding conversions}
%
% Most functions in this module expect to be working with
% \enquote{native} strings. Strings can also be stored as
% bytes, in one of many encodings, for instance \textsc{utf8}.
% The bytes themselves can be expressed as character
% tokens with the relevant character code, or as pairs
% of hexadecimal digits, \emph{etc.} The questions of going
% from arbitrary characters to bytes, and from bytes to \TeX{}
% tokens are mostly independent.
%
% Conversions are done in four steps:
% \begin{itemize}
% \item \enquote{input} produces a string of bytes;
% \item \enquote{from} interprets the byte string in the old encoding,
%   and converts it to a comma-list, each character becoming
%   \enquote{\ttfamily \meta{character code},};
% \item \enquote{to} encodes the internal comma list as a byte string
%   in the new encoding;
% \item \enquote{output} escapes bytes as requested.
% \end{itemize}
% The process is modified in case one of the encoding is
% \texttt{internal} or \texttt{native}: then the input or
% output step is ignored.
%
% \begin{macro}{\str_set_convert:Nnnn, \str_gset_convert:Nnnn}
% \begin{macro}[aux]{\str_convert_aux_i:NNnnn}
% \begin{macro}[aux]{\str_convert_aux_ii:wwwnn}
% \begin{macro}[aux]{\str_convert_aux_iii:nnF}
% \begin{macro}[aux]{\str_convert_aux_iv:nnnF}
% \begin{macro}[aux]{\str_convert_aux_v:NNnNN}
%   The input string is stored in \cs{g_str_result_tl},
%   then we call the various conversion functions, which all
%   act on \cs{g_str_result_tl}. The arguments |#3| and |#4|
%   of the \texttt{aux_i} function are split into their
%   \meta{encoding} and \meta{escaping} parts by \texttt{aux_ii}.
%   The conversion function names are built by \texttt{aux_iii},
%   which first tries to use the name as supplied by the user,
%   then filters it with \cs{str_aux_lowercase_alphanum:n},
%   and calls \texttt{aux_iv} to load the relevant definition file.
%   In all cases, \texttt{aux_iii} ensures that the two
%   required conversion functions are defined, with
%   a fall-back to the native encoding with no escaping.
%   Once this is done, \texttt{aux_v} does the main work:
%   \begin{itemize}
%   \item |#1| is the encoding conversion function;
%   \item |#2| is the escaping function;
%   \item |#3| is the escaping name;
%   \item |#4| is the \enquote{native} encoding function
%     (either \enquote{from} or \enquote{to});
%   \item |#5| is \cs{use_i:nn} or \cs{use_ii:nn}.
%   \end{itemize}
%   When converting to the internal format, the escaping must be done
%   first, then the encoding (this is controlled by |#5|).
%   If the encoding is native, then the escaping is ignored and
%   must be empty. Otherwise, the escaping |#2| is performed.
%    \begin{macrocode}
\cs_new_protected:Npn \str_set_convert:Nnnn
  { \str_convert_aux_i:NNnnn \tl_set_eq:NN }
\cs_new_protected:Npn \str_gset_convert:Nnnn
  { \str_convert_aux_i:NNnnn \tl_gset_eq:NN }
\cs_new_protected:Npn \str_convert_aux_i:NNnnn #1#2#3#4#5
  {
    \group_begin:
      \str_gset_other:Nn \g_str_result_tl {#5}

      \exp_after:wN \str_convert_aux_ii:wwwnn
        \tl_to_str:n {#3} /// \q_stop
        { from } { input } \str_convert_from_native: \use_i:nn

      \exp_after:wN \str_convert_aux_ii:wwwnn
        \tl_to_str:n {#4} /// \q_stop
        { to } { output } \str_convert_to_native: \use_ii:nn

    \group_end:
    #1 #2 \g_str_result_tl
  }
\cs_new_protected:Npn \str_convert_aux_ii:wwwnn #1 / #2 // #3 \q_stop #4#5
  {
    \str_convert_aux_iii:nnF {#4} {#1} {native}
    \str_convert_aux_iii:nnF {#5} {#2} { }
    \exp_args:Ncc \str_convert_aux_v:NNnNN
      { str_convert_#4_#1: } { str_convert_#5_#2: } {#2}
  }
\cs_new_protected:Npn \str_convert_aux_iii:nnF #1#2#3
  {
    \cs_if_exist:cF { str_convert_#1_#2: }
      {
        \exp_args:Nx \str_convert_aux_iv:nnnF
          { \str_aux_lowercase_alphanum:n {#2} }
          {#1} {#2} {#3}
      }
  }
\cs_new_protected:Npn \str_convert_aux_iv:nnnF #1#2#3#4
  {
    \cs_if_exist:cF { str_convert_#2_#1: }
      {
        \group_begin:
          \str_load_catcodes:
          \str_load_one:n {#1}
        \group_end:
      }
    \cs_if_exist:cTF { str_convert_#2_#1: }
      { \cs_gset_eq:cc { str_convert_#2_#3: } { str_convert_#2_#1: } }
      {
        \msg_kernel_error:nnx { str } { unknown-#2 } {#3}
        \cs_gset_eq:cc { str_convert_#2_#3: } { str_convert_#2_#4: }
      }
  }
\cs_new_protected:Npn \str_convert_aux_v:NNnNN #1#2#3#4#5
  {
    #5 { } {#1}
    \cs_if_eq:NNTF #1 #4
      {
        \tl_if_empty:nF {#3}
          { \msg_kernel_error:nnx { str } { native-ignore-escaping } {#3} }
      }
      { #2 }
    #5 {#1} { }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, rEXP]{\str_aux_lowercase_alphanum:n}
% \begin{macro}[aux, rEXP]{\str_aux_lowercase_alphanum_loop:N}
%   This function keeps only letters and digits, with upper case
%   letters converted to lower case.
%    \begin{macrocode}
\cs_new:Npn \str_aux_lowercase_alphanum:n #1
  {
    \exp_after:wN \str_aux_lowercase_alphanum_loop:N
      \tl_to_str:n {#1} { ? \prg_map_break: }
    \prg_break_point:n { }
  }
\cs_new:Npn \str_aux_lowercase_alphanum_loop:N #1
  {
    \use_none:n #1
    \if_num:w `#1 < \c_ninety_one
      \if_num:w `#1 < \c_sixty_five
        \if_num:w \c_one < 1#1 \exp_stop_f:
          #1
        \fi:
      \else:
        \str_output_byte:n { `#1 + \c_thirty_two }
      \fi:
    \else:
      \if_num:w `#1 < \c_one_hundred_twenty_three
        \if_num:w `#1 < \c_ninety_seven
        \else:
          #1
        \fi:
      \fi:
    \fi:
    \str_aux_lowercase_alphanum_loop:N
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_from_internal:}
% \begin{macro}[int]{\str_convert_to_internal:}
%   Converting from the internal format to itself is
%   of course trivial.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_convert_from_internal: { }
\cs_new_protected_nopar:Npn \str_convert_to_internal:   { }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Loading encoding files}
%
% \begin{macro}{\str_load:n}
% \begin{macro}[int]{\str_load_one:n}
% \begin{macro}[aux]{\str_load_alias:n, \str_load_alias_aux:nnn}
%   Loading encoding or escaping files can be done in bulk by
%   specifying a comma-list of encodings and escapings. Each
%   name is normalized: only alphanumeric characters are kept,
%   lowercased. The relevant file is loaded if it was not loaded
%   already.
%    \begin{macrocode}
\cs_new_protected:Npn \str_load:n #1
  {
    \group_begin:
      \str_load_catcodes:
      \clist_map_inline:nn {#1}
        {
          \exp_args:Nx \str_load_one:n
            { \str_aux_lowercase_alphanum:n {#1} }
        }
    \group_end:
  }
\cs_new_protected:Npn \str_load_one:n #1
  {
    \cs_if_exist:cF { str_convert_from_ #1 : }
      {
        \cs_if_exist:cF { str_convert_input_#1: }
          {
            \file_if_exist:nTF { l3str- #1 .def }
              { \file_input:n { l3str- #1 .def } }
              { \str_load_alias:n {#1} }
          }
      }
  }
\cs_new_protected:Npn \str_load_alias:n #1
  {
    \exp_args:NNx \prop_get:NnNTF \g_str_aliases_prop {#1} \l_str_tmpa_tl
      {
        \str_load_one:n { \l_str_tmpa_tl }
        \cs_if_exist:cTF
          { str_convert_from_ \l_str_tmpa_tl : }
          {
            \str_load_alias_aux:nnn {#1} { \l_str_tmpa_tl } { from }
            \str_load_alias_aux:nnn {#1} { \l_str_tmpa_tl } { to }
          }
          {
            \str_load_alias_aux:nnn {#1} { \l_str_tmpa_tl } { input }
            \str_load_alias_aux:nnn {#1} { \l_str_tmpa_tl } { output }
          }
      }
      { \msg_kernel_error:nnx { str } { file-not-found } {#1} }
  }
\cs_new_protected:Npn \str_load_alias_aux:nnn #1#2#3
  { \cs_new_eq:cc { str_convert_#3_#1: } { str_convert_#3_#2: } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_load_catcodes:}
%   Since encoding files may be loaded at arbitrary places
%   in a \TeX{} document, including within verbatim mode,
%   we set the catcodes of all characters appearing in any
%   encoding definition file.
%    \begin{macrocode}
\cs_new_protected:Npn \str_load_catcodes:
  {
    \char_set_catcode_escape:N \\
    \char_set_catcode_group_begin:N \{
    \char_set_catcode_group_end:N \}
    \char_set_catcode_math_superscript:N \^
    \char_set_catcode_ignore:N \ %
    \tl_map_function:nN { abcdefghijklmnopqrstuvwxyz_:ABCDEFN }
      \char_set_catcode_letter:N
    \tl_map_function:nN { 0123456789"'?*+ }
      \char_set_catcode_other:N
    \char_set_catcode_comment:N \%
    \int_set:Nn \tex_endlinechar:D {32}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_from_eight_bit:n}
% \begin{macro}[aux]{\str_convert_from_eight_bit_load:nn}
% \begin{macro}[aux]{\str_convert_from_eight_bit_load_missing:n}
% \begin{macro}[aux, EXP]{\str_convert_from_eight_bit_aux:N}
%^^A todo: document
%    \begin{macrocode}
\cs_new_protected:Npn \str_convert_from_eight_bit:n #1
  {
    \group_begin:
      \int_zero:N \l_str_tmpa_int
      \exp_last_unbraced:Nx \str_convert_from_eight_bit_load:nn
        { \tl_use:c { c_str_encoding_#1_tl } }
        { \q_stop \prg_map_break: } { }
      \prg_break_point:n { }
      \exp_last_unbraced:Nx \str_convert_from_eight_bit_load_missing:n
        { \tl_use:c { c_str_encoding_#1_missing_tl } }
        { \q_stop \prg_map_break: }
      \prg_break_point:n { }
      \str_aux_gmap_result:N \str_convert_from_eight_bit_aux:N
    \group_end:
  }
\cs_new_protected_nopar:Npn \str_convert_from_eight_bit_load:nn #1#2
  {
    \use_none_delimit_by_q_stop:w #1 \q_stop
    \tex_dimen:D "#1 = \l_str_tmpa_int sp \scan_stop:
    \tex_skip:D \l_str_tmpa_int = "#1 sp \scan_stop:
    \tex_toks:D \l_str_tmpa_int \exp_after:wN { \int_value:w "#2 }
    \tex_advance:D \l_str_tmpa_int \c_one
    \str_convert_from_eight_bit_load:nn
  }
\cs_new_protected_nopar:Npn \str_convert_from_eight_bit_load_missing:n #1
  {
    \use_none_delimit_by_q_stop:w #1 \q_stop
    \tex_dimen:D "#1 = \l_str_tmpa_int sp \scan_stop:
    \tex_skip:D \l_str_tmpa_int = "#1 sp \scan_stop:
    \tex_toks:D \l_str_tmpa_int \exp_after:wN { \int_value:w "FFFD }
    \tex_advance:D \l_str_tmpa_int \c_one
    \str_convert_from_eight_bit_load_missing:n
  }
\cs_new:Npn \str_convert_from_eight_bit_aux:N #1
  {
    #1 \exp_not:N \q_mark
    \if_num:w \tex_dimen:D `#1 < \l_str_tmpa_int
      \if_num:w \tex_skip:D \tex_dimen:D `#1 = `#1 \exp_stop_f:
        \tex_the:D \tex_toks:D \tex_dimen:D
      \fi:
    \fi:
    \int_value:w `#1 ,
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_to_eight_bit:n}
% \begin{macro}[aux]{\str_convert_to_eight_bit_load:nn}
% \begin{macro}[aux, rEXP]{\str_convert_to_eight_bit_aux:n}
% \begin{macro}[aux, rEXP]{\str_convert_to_eight_bit_aux_ii:n}
%^^A todo: document
%    \begin{macrocode}
\cs_new_protected:Npn \str_convert_to_eight_bit:n #1
  {
    \group_begin:
      \int_zero:N \l_str_tmpa_int
      \exp_last_unbraced:Nx \str_convert_to_eight_bit_load:nn
        { \tl_use:c { c_str_encoding_#1_tl } }
        { \q_stop \prg_map_break: } { }
      \prg_break_point:n { }
      \str_aux_gmap_internal_result:N \str_convert_to_eight_bit_aux:n
    \group_end:
  }
\cs_new_protected_nopar:Npn \str_convert_to_eight_bit_load:nn #1#2
  {
    \use_none_delimit_by_q_stop:w #1 \q_stop
    \tex_dimen:D "#2 = \l_str_tmpa_int sp \scan_stop:
    \tex_skip:D \l_str_tmpa_int = "#2 sp \scan_stop:
    \exp_args:NNf \tex_toks:D \l_str_tmpa_int
      { \str_output_byte:n { "#1 } }
    \tex_advance:D \l_str_tmpa_int \c_one
    \str_convert_to_eight_bit_load:nn
  }
\cs_new:Npn \str_convert_to_eight_bit_aux:n #1
  {
    \if_num:w #1 < "8000 \exp_stop_f:
      \if_num:w \tex_dimen:D #1 < \l_str_tmpa_int
        \if_num:w \tex_skip:D \tex_dimen:D #1 = #1 \exp_stop_f:
          \tex_the:D \tex_toks:D \tex_dimen:D #1 \exp_stop_f:
          \exp_after:wN \exp_after:wN \exp_after:wN \use_none:nn
        \fi:
      \fi:
      \str_convert_to_eight_bit_aux_ii:n {#1}
    \else:
      \msg_expandable_kernel_error:nnn
        { str } { eight-bit-to-byte-overflow } {#1}
    \fi:
  }
\cs_new:Npn \str_convert_to_eight_bit_aux_ii:n #1
  {
    \if_num:w #1 < \c_two_hundred_fifty_six
      \str_output_byte:n {#1}
    \else:
      \msg_expandable_kernel_error:nn { str } { eight-bit-to-byte }
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_encoding_eight_bit:n}
%^^A todo: document
%    \begin{macrocode}
\cs_new_protected:Npn \str_encoding_eight_bit:n #1
  {
    \cs_new_protected:cpn { str_convert_from_#1: }
      { \str_convert_from_eight_bit:n {#1} }
    \cs_new_protected:cpn { str_convert_to_#1: }
      { \str_convert_to_eight_bit:n {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Byte input and output}
%
% Strings of bytes may need to be stored in auxiliary files
% in safe \enquote{escaping} formats. Each such escaping
% is only loaded as needed. By default, on input any non-byte
% is filtered out, while the output simply consists in letting
% bytes through.
%
% \begin{macro}[int, rEXP]{\str_filter_bytes:n}
% \begin{macro}[aux, rEXP]{\str_filter_bytes_aux:N}
%   In the case of pdf\TeX{}, every character is a byte.
%   For Unicode-aware engines, test the character code.
%   Spaces have already been given the correct category
%   code when this function is called.
%    \begin{macrocode}
\pdftex_if_engine:TF
  { \cs_new_eq:NN \str_filter_bytes:n \use:n }
  {
    \cs_new_nopar:Npn \str_filter_bytes:n #1
      {
        \str_filter_bytes_aux:N #1
          { ? \prg_map_break: }
        \prg_break_point:n { }
      }
    \cs_new_nopar:Npn \str_filter_bytes_aux:N #1
      {
        \use_none:n #1
        \if_num:w `#1 < 256 \exp_stop_f: #1 \fi:
        \str_filter_bytes_aux:N
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_input_:}
% \begin{macro}[int]{\str_convert_input_bytes:}
%   The simplest input method removes non-bytes
%   from \cs{g_str_result_tl}.
%    \begin{macrocode}
\pdftex_if_engine:TF
  { \cs_new_protected_nopar:Npn \str_convert_input_: { } }
  {
    \cs_new_protected_nopar:Npn \str_convert_input_:
      {
        \tl_gset:Nx \g_str_result_tl
          { \exp_args:No \str_filter_bytes:n \g_str_result_tl }
      }
  }
\cs_new_eq:NN \str_convert_input_bytes: \str_convert_input_:
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_output_:}
% \begin{macro}[int]{\str_convert_output_bytes:}
%   The simplest form of output leaves the bytes from the previous
%   step of the conversion unchanged.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_convert_output_: { }
\cs_new_eq:NN \str_convert_output_bytes: \str_convert_output_:
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Convert to and from native strings}
%
% \begin{macro}[int]{\str_convert_from_native:}
% \begin{macro}[aux, rEXP]{\str_convert_from_native_aux:N}
%   Convert each character to its character code, one at a time.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_convert_from_native:
  { \str_aux_gmap_result:N \str_convert_from_native_aux:N }
\cs_new:Npn \str_convert_from_native_aux:N #1
  { #1 \exp_not:N \q_mark \int_value:w `#1 , }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_to_native:}
% \begin{macro}[aux]{\str_convert_to_native_aux:w}
%   This function is based on the internal functions
%   \cs{str_aux_convert_to_native:n} and
%   \cs{str_aux_convert_to_native_step:n}.
%   Loop through the comma-list, and call
%   \cs{str_aux_convert_to_native_step:n}
%   with the relevant integer argument.
%   We need to store \cs{g_str_result_tl} in a temporary
%   token list, because that global \enquote{result} is
%   cleared silently by \cs{str_aux_convert_to_native:n}.
%^^A todo: update
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_convert_to_native:
  {
    \tl_set_eq:NN \l_str_tmpa_tl \g_str_result_tl
    \str_aux_convert_to_native:n
      {
        \exp_after:wN \str_convert_to_native_aux:w
        \l_str_tmpa_tl \q_mark { \q_stop \prg_map_break: } ,
      }
  }
\cs_new_protected_nopar:Npn \str_convert_to_native_aux:w #1\q_mark #2,
  {
    \use_none_delimit_by_q_stop:w #2 \q_stop
    \str_aux_convert_to_native_step:n {#2}
    \str_convert_to_native_aux:w
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_aux_convert_to_native:n}
% \begin{macro}[int]{\str_aux_convert_to_native_step:n}
% \begin{macro}[aux]{\str_aux_convert_to_native_flush:}
% \begin{macro}[aux, rEXP]{\str_aux_convert_to_native_filter:N}
%^^A todo: document.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_aux_convert_to_native:n #1
  {
    \tex_lccode:D \c_zero \c_zero
    \int_zero:N \l_str_tmpa_int
    \tl_gclear:N \g_str_result_tl
    #1
    \prg_break_point:n { \str_aux_convert_to_native_flush: }
  }
\cs_new_protected_nopar:Npn \str_aux_convert_to_native_step:n #1
  {
    \if_num:w \l_str_tmpa_int = \c_two_hundred_fifty_five
      \str_aux_convert_to_native_flush:
      \l_str_tmpa_int \c_zero
    \fi:
    \tex_advance:D \l_str_tmpa_int \c_one
    \if_int_compare:w #1 > \c_max_char_int
      \msg_kernel_error:nnx { str } { overflow } {#1}
      \tex_lccode:D \l_str_tmpa_int \c_str_replacement_char_int
    \else:
      \tex_lccode:D \l_str_tmpa_int \int_eval:w #1 \int_eval_end:
    \fi:
  }
\cs_new_protected_nopar:Npn \str_aux_convert_to_native_flush:
  {
    \use:x
      {
        \tl_to_lowercase:n
          {
            \tl_gput_right:Nx \exp_not:N \g_str_result_tl
              {
                \exp_after:wN \str_aux_convert_to_native_filter:N
                  \c_str_positive_bytes_tl
                  { ? = \c_zero \fi: \prg_map_break: }
                \prg_break_point:n { }
              }
          }
      }
  }
\group_begin:
  \char_set_catcode_other:n { 0 }
  \cs_new:Npn \str_aux_convert_to_native_filter:N #1
    {
      \if_num:w `#1 > \l_str_tmpa_int
        \exp_after:wN \prg_map_break:
      \fi:
      \if_num:w \tex_lccode:D `#1 = \c_zero
        ^^@
      \else:
        #1
      \fi:
      \str_aux_convert_to_native_filter:N
    }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\msg_kernel_new:nnnn { str } { x-missing-brace }
  { Missing~closing~brace~in~ \token_to_str:N \x ~byte~sequence. }
  {
    You~wrote~something~like~
    `\iow_char:N\\x\{ \int_to_hexadecimal:n { \l_str_char_int }'.~
    The~closing~brace~is~missing.
  }
\msg_kernel_new:nnnn { str } { overflow }
  { Character~code~#1~too~big. }
  {
    \int_compare:nNnTF {#1} > { 1114111 }
      { The~Unicode~standard~limits~code~points~to~1114111. }
      {
        The~pdfTeX~engine~only~supports~8-bit~characters:~
        valid~character~codes~are~in~the~range~[0,255].~
        To~manipulate~arbitrary~Unicode,~use~LuaTeX~or~XeTeX.
      }
  }
\msg_kernel_new:nnn { str } { convert-input }
  { Input~scheme~`#1'~unknown. }
\msg_kernel_new:nnn { str } { convert-from }
  { Encoding~`#1'~unknown. }
\msg_kernel_new:nnn { str } { convert-to }
  { Encoding~`#1'~unknown.~Using~UTF-8. }
\msg_kernel_new:nnn { str } { convert-output }
  { Output~scheme~`#1~unknown. }
\msg_kernel_new:nnn { str } { to-native }
  { Use~\str_set_convert:Nnn to~convert~to~native~strings. }
\msg_kernel_new:nnn { str } { unicode-surrogate }
  { Code~point~#1~is~an~unpaired~surrogate. }
\msg_kernel_new:nnn { str } { utf16-surrogate }
  { UTF-16~unpaired~surrogate~#1. }
\msg_kernel_new:nnn { str } { utf16-odd }
  { UTF-16~dangling~byte~#1. }
\msg_kernel_new:nnn { str } { utf8-extra-conti }
  { UTF-8~extra~continuation~byte~#1. }
\msg_kernel_new:nnn { str } { utf8-missing-conti }
  { UTF-8~missing~continuation~byte~#1. }
\msg_kernel_new:nnn { str } { utf8-invalid-byte }
  { Byte~#1~cannot~appear~in~UTF-8. }
\msg_kernel_new:nnn { str } { utf8-overlong }
  { Overlong~UTF-8~byte~sequence~for~code~point~#1. }
\msg_kernel_new:nnn { str } { utf8-premature-end }
  { Incomplete~last~UTF-8~character. }
\msg_kernel_new:nnn { str } { utf32-overflow }
  { Code~point~too~large~(UTF-32~`#1'). }
\msg_kernel_new:nnn { str } { utf32-truncated }
  { Truncated~UTF-32~string~`...#1'. }
%    \end{macrocode}
%
% \subsection{Deprecated string functions}
%
% \begin{macro}{\str_length_skip_spaces:N, \str_length_skip_spaces:n}
%   The naming scheme is a little bit more consistent
%   with \enquote{ignore_spaces} instead of \enquote{skip_spaces}.
%    \begin{macrocode}
\cs_set:Npn \str_length_skip_spaces:N
  { \exp_args:No \str_length_skip_spaces:n }
\cs_set_eq:NN \str_length_skip_spaces:n \str_length_ignore_spaces:n
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \subsection{Escaping definition files}
%
% Several of those encodings are defined by the pdf file format.
% The following byte storage methods are defined:
% \begin{itemize}
% \item \texttt{bytes} (default), non-bytes are filtered out,
%   and bytes are left untouched;
% \item \texttt{hex} or \texttt{hexadecimal},
%   as per the pdf\TeX{} primitive \tn{pdfescapehex}
% \item \texttt{name}, as per the pdf\TeX{} primitive \tn{pdfescapename}
% \item \texttt{string}, as per the pdf\TeX{} primitive \tn{pdfescapestring}
% \item \texttt{url}, as per the percent encoding of urls.
% \end{itemize}
%
% \subsubsection{Input methods}
%
% \begin{macro}[int]{\str_convert_input_hex:}
% \begin{macro}[int]{\str_convert_input_hexadecimal:}
% \begin{macro}[aux, rEXP]{\str_convert_input_hex_aux:N}
% \begin{macro}[aux, rEXP]{\str_convert_input_hex_aux_ii:N}
%   Take chars two by two, and interpret  each pair as
%   the hexadecimal code for a byte. Anything else than
%   hexadecimal digits is ignored.
%   A string which contains an odd number of hexadecimal
%   digits gets |0| appended to it: this is equivalent
%   to appending a |0| in all cases, and dropping it if
%   it is alone.
%    \begin{macrocode}
%<*hex>
\cs_new_protected_nopar:Npn \str_convert_input_hex:
  {
    \group_begin:
      \int_set:Nn \tex_escapechar:D { 92 }
      \tl_gset:Nx \g_str_result_tl
        {
          \str_output_byte:w "
            \exp_after:wN \str_convert_input_hex_aux:N
            \g_str_result_tl 0 { ? 0 - \c_one \prg_map_break: }
          \prg_break_point:n { \str_output_end: }
        }
    \group_end:
  }
\cs_new_nopar:Npn \str_convert_input_hex_aux:N #1
  {
    \use_none:n #1
    \str_aux_hexadecimal_use:NTF #1
      \str_convert_input_hex_aux_ii:N
      \str_convert_input_hex_aux:N
  }
\cs_new_nopar:Npn \str_convert_input_hex_aux_ii:N #1
  {
    \use_none:n #1
    \str_aux_hexadecimal_use:NTF #1
      {
        \str_output_end:
        \str_output_byte:w " \str_convert_input_hex_aux:N
      }
      \str_convert_input_hex_aux_ii:N
  }
%</hex>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_input_name:}
% \begin{macro}[aux, rEXP]{\str_convert_input_name_aux:wNN}
% \begin{macro}[int]{\str_convert_input_url:}
% \begin{macro}[aux, rEXP]{\str_convert_input_url_aux:wNN}
%   The \cs{str_convert_input_name:} function replaces each
%   occurrence of |#| followed by two hexadecimal digits
%   in \cs{g_str_result_tl} by the corresponding byte.
%   The \texttt{url} function is identical, with escape
%   character |%| instead of |#|. Thus we define the two
%   together. The arguments of \cs{str_tmp:w} are the character
%   code of |#| or |%| in hexadecimal, the name of the main
%   function to define, and the name of the auxiliary which
%   performs the loop.
%
%   The looping auxiliary |#3| finds the next escape character,
%   reads the following two characters, and tests them. The test
%   \cs{str_aux_hexadecimal_use:NTF} leaves the upper-case digit
%   in the input stream, hence we surround the test with
%   \cs{str_output_byte:w}~|"| and \cs{str_output_end:}.
%   If both characters are hexadecimal digits, they should be
%   removed before looping: this is done by \cs{use_i:nnn}.
%   If one of the characters is not a hexadecimal digit,
%   then feed |"#1| to \cs{str_output_byte:w} to produce the
%   escape character, and call the looping function followed
%   by the two characters (remove \cs{use_i:nnn}).
%    \begin{macrocode}
%<*name|url>
\cs_set_protected:Npn \str_tmp:w #1#2#3
  {
    \cs_new_protected_nopar:Npn #2
      {
        \group_begin:
          \int_set:Nn \tex_escapechar:D { 92 }
          \tl_gset:Nx \g_str_result_tl
            {
              \exp_after:wN #3 \g_str_result_tl
                #1 ? { ? \prg_map_break: }
              \prg_break_point:n { }
            }
        \group_end:
      }
    \cs_new_nopar:Npn #3 ##1#1##2##3
      {
        \str_filter_bytes:n {##1}
        \use_none:n ##3
        \str_output_byte:w "
          \str_aux_hexadecimal_use:NTF ##2
            {
              \str_aux_hexadecimal_use:NTF ##3
                { }
                { * \c_zero + `#1 \use_i:nn }
            }
            { 0 + `#1 \use_i:nn }
        \str_output_end:
        \use_i:nnn #3 ##2##3
      }
  }
%</name|url>
%<name>\exp_after:wN \str_tmp:w \c_hash_str
%<name>  \str_convert_input_name: \str_convert_input_name_aux:wNN
%<url>\exp_after:wN \str_tmp:w \c_percent_str
%<url>  \str_convert_input_url: \str_convert_input_url_aux:wNN
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_input_string:}
% \begin{macro}[aux, rEXP]{\str_convert_input_string_aux:wN}
% \begin{macro}[aux, rEXP]{\str_convert_input_string_aux:wNNN}
% \begin{macro}[aux, rEXP]{\str_convert_input_string_aux:NNNNNN}
%   The \texttt{string} escaping is somewhat similar to
%   the \texttt{name} and \texttt{url} escapings, with
%   escape character |\|.
%   The first step is to convert all three line endings,
%   |^^J|, |^^M|, and |^^M^^J| to the common |^^J|, as per
%   the \textsc{pdf} specification.
%   Then the following escape sequences are decoded.
%   \begin{itemize}\def\makelabel#1{\hss\llap{\ttfamily\string#1}}
%   \item[\n] Line feed ($10$)
%   \item[\r] Carriage return ($13$)
%   \item[\t] Horizontal tab ($9$)
%   \item[\b] Backspace ($8$)
%   \item[\f] Form feed ($12$)
%   \item[\(] Left parenthesis
%   \item[\)] Right parenthesis
%   \item[\\] Backslash
%   \item[\ddd] (backslash followed by $1$ to $3$ octal digits)
%     Byte \texttt{ddd} (octal), subtracting $256$ in case of overflow.
%   \end{itemize}
%   If followed by an end-of-line character, the backslash and
%   the end-of-line are ignored. If followed by anything else,
%   the backslash is ignored.
%    \begin{macrocode}
%<*string>
\group_begin:
  \char_set_lccode:nn {`\*} {`\\}
  \char_set_catcode_other:N \^^J
  \char_set_catcode_other:N \^^M
  \tl_to_lowercase:n
    {
      \cs_new_protected_nopar:Npn \str_convert_input_string:
        {
          \group_begin:
            \int_set:Nn \tex_escapechar:D { 92 }
            \tl_gset:Nx \g_str_result_tl
              {
                \exp_after:wN \str_convert_input_string_aux:wN
                  \g_str_result_tl \prg_map_break: ^^M ?
                \prg_break_point:n { }
              }
            \tl_gset:Nx \g_str_result_tl
              {
                \exp_after:wN \str_convert_input_string_aux:wNNN
                  \g_str_result_tl * ?? { ? \prg_map_break: }
                \prg_break_point:n { }
              }
          \group_end:
        }
      \cs_new_nopar:Npn \str_convert_input_string_aux:wNNN #1 *#2#3#4
    }
        {
          \str_filter_bytes:n {#1}
          \use_none:n #4
          \str_output_byte:w '
            \str_aux_octal_use:NTF #2
              {
                \str_aux_octal_use:NTF #3
                  {
                    \str_aux_octal_use:NTF #4
                      {
                        \if_int_compare:w #2 > \c_three
                          - 256
                        \fi:
                        \str_convert_input_string_aux:NNNNNN
                      }
                      { \str_convert_input_string_aux:NNNNNN ? }
                  }
                  { \str_convert_input_string_aux:NNNNNN ?? }
              }
              {
                \prg_case_str:xxn {#2}
                  {
                    { \c_backslash_str } { 134 }
                    { ( } { 50 }
                    { ) } { 51 }
                    { r } { 15 }
                    { f } { 14 }
                    { n } { 12 }
                    { t } { 11 }
                    { b } { 10 }
                    { ^^J } { 0 - \c_one }
                  }
                  { 0 - \c_one \use_i:nn }
              }
          \str_output_end:
          \use_i:nn \str_convert_input_string_aux:wNNN #2#3#4
        }
  \cs_new_nopar:Npn \str_convert_input_string_aux:NNNNNN #1#2#3#4#5#6
    { \str_output_end: \str_convert_input_string_aux:wNNN }
  \cs_new_nopar:Npn \str_convert_input_string_aux:wN #1 ^^M #2
    {
      #1 ^^J
      \if_charcode:w ^^J #2
        \exp_after:wN \use_i:nn
      \fi:
      \str_convert_input_string_aux:wN #2
    }
\group_end:
%</string>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Output methods}
%
% \begin{macro}[int]{\str_convert_output_hex:}
% \begin{macro}[int]{\str_convert_output_hexadecimal:}
% \begin{macro}[aux, rEXP]{\str_convert_output_hex_aux:N}
%   Loop and convert each byte to hexadecimal.
%    \begin{macrocode}
%<*hex>
\cs_new_protected_nopar:Npn \str_convert_output_hex:
  { \str_aux_gmap_result:N \str_convert_output_hex_aux:N }
\cs_new_nopar:Npn \str_convert_output_hex_aux:N #1
  { \str_output_hexadecimal:n { `#1 } }
%</hex>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_output_name:}
% \begin{macro}[aux, rEXP]{\str_convert_output_name_aux:N}
% \begin{macro}[aux, rEXP]{\str_convert_output_name_aux:NTF}
% \begin{variable}{\c_str_convert_output_name_str}
% \begin{variable}{\c_str_convert_output_name_not_str}
%   For each byte, test whether it should
%   be output as is, or be \enquote{hash-encoded}.
%   Roughly, bytes outside the range from |"2A| to |"7E|
%   are hash-encoded. We keep two lists of exceptions:
%   characters in \cs{c_str_convert_output_name_not_str}
%   are not hash-encoded, and characters in the
%   \cs{c_str_convert_output_name_str} are encoded.
%    \begin{macrocode}
%<*name>
\str_const:Nn \c_str_convert_output_name_not_str { ! " $ & ' } %$
\str_const:Nn \c_str_convert_output_name_str { {}/<>[] }
\cs_new_protected_nopar:Npn \str_convert_output_name:
  { \str_aux_gmap_result:N \str_convert_output_name_aux:N }
\cs_new_nopar:Npn \str_convert_output_name_aux:N #1
  {
    \str_convert_output_name_aux:NTF #1 {#1}
      { \c_hash_str \str_output_hexadecimal:n {`#1} }
  }
\prg_new_conditional:Npnn \str_convert_output_name_aux:N #1 { TF }
  {
    \if_num:w `#1 < "2A \exp_stop_f:
      \str_if_contains_char:NNTF \c_str_convert_output_name_not_str #1
        \prg_return_true: \prg_return_false:
    \else:
      \if_num:w `#1 > "7E \exp_stop_f:
        \prg_return_false:
      \else:
        \str_if_contains_char:NNTF \c_str_convert_output_name_str #1
          \prg_return_false: \prg_return_true:
      \fi:
    \fi:
  }
%</name>
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_output_string:}
% \begin{macro}[aux, rEXP]{\str_convert_output_string_aux:N}
% \begin{macro}[aux, rEXP]{\str_convert_output_string_aux:NTF}
% \begin{variable}{\c_str_convert_output_string_str}
%   Any character below (and including) space, and any character
%   above (and including) \texttt{del}, are converted to octal.
%   One backslash is added before each parenthesis and backslash.
%    \begin{macrocode}
%<*string>
\str_const:Nx \c_str_convert_output_string_str
  { \c_backslash_str ( ) }
\cs_new_protected_nopar:Npn \str_convert_output_string:
  { \str_aux_gmap_result:N \str_convert_output_string_aux:N }
\cs_new_nopar:Npn \str_convert_output_string_aux:N #1
  {
    \str_convert_output_string_aux:NTF #1
      {
        \str_if_contains_char:NNT
          \c_str_convert_output_string_str #1
          { \c_backslash_str }
        #1
      }
      {
        \c_backslash_str
        \int_div_truncate:nn {`#1} {64}
        \int_mod:nn { \int_div_truncate:nn {`#1} \c_eight } \c_eight
        \int_mod:nn {`#1} \c_eight
      }
  }
\prg_new_conditional:Npnn \str_convert_output_string_aux:N #1 { TF }
  {
    \if_num:w `#1 < "21 \exp_stop_f:
      \prg_return_false:
    \else:
      \if_num:w `#1 > "7E \exp_stop_f:
        \prg_return_false:
      \else:
        \prg_return_true:
      \fi:
    \fi:
  }
%</string>
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_output_url:}
% \begin{macro}[aux, rEXP]{\str_convert_output_url_aux:N}
% \begin{macro}[aux, rEXP]{\str_convert_output_url_aux:NTF}
%^^A todo: Figure out what bytes should be percent encoded! Safe could be
%^^A     !'()*-./0123456789_
%   This function is similar to \cs{str_convert_output_name:},
%   escaping different characters.
%    \begin{macrocode}
%<*url>
\cs_new_protected_nopar:Npn \str_convert_output_url:
  { \str_aux_gmap_result:N \str_convert_output_url_aux:N }
\cs_new_nopar:Npn \str_convert_output_url_aux:N #1
  {
    \str_convert_output_url_aux:NTF #1 {#1}
      { \c_percent_str \str_output_hexadecimal:n { `#1 } }
  }
\prg_new_conditional:Npnn \str_convert_output_url_aux:N #1 { TF }
  {
    \if_num:w `#1 < "41 \exp_stop_f:
      \str_if_contains_char:nNTF { "-.<> } #1
        \prg_return_true: \prg_return_false:
    \else:
      \if_num:w `#1 > "7E \exp_stop_f:
        \prg_return_false:
      \else:
        \str_if_contains_char:nNTF { [ ] } #1
          \prg_return_false: \prg_return_true:
      \fi:
    \fi:
  }
%</url>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Encoding definition files}
%
% The \texttt{native} and \texttt{internal} encodings are automatically
% defined. Other encodings are loaded as needed. The following encodings
% are supported:
% \begin{itemize}
% \item \textsc{utf-8};
% \item \textsc{utf-16}, big-endian, little-endian, or with byte order mark;
% \item \textsc{utf-32}, big-endian, little-endian, or with byte order mark;
% \item the \textsc{iso 8859} code pages, numbered from $1$ to $16$,
%   skipping the inexistent \textsc{iso 8859-12}.
% \end{itemize}
%
% \subsubsection{\textsc{utf-8} support}
%
%    \begin{macrocode}
%<*utf8>
%    \end{macrocode}
%
% \begin{macro}[int]{\str_convert_to_utf8:}
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_to_utf_viii:n,
%     \str_aux_to_utf_viii:nnnnw
%   }
%   Loop through the internal string, and convert each character
%   to the \textsc{utf-8} representation. The details are messy.
%^^A todo: document.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { str_convert_to_utf8: }
  { \str_aux_gmap_internal_result:N \str_aux_to_utf_viii:n }
\cs_new:Npn \str_aux_to_utf_viii:n #1
  {
    \str_aux_to_utf_viii:nnnnw
      {#1} { \c_minus_one + \c_zero * \use_none:n }
      { 128 } { \c_zero }
      {  32 } {     192 }
      {  16 } {     224 }
      {   8 } {     240 }
    \q_stop
  }
\cs_new_nopar:Npn \str_aux_to_utf_viii:nnnnw #1#2#3#4 #5 \q_stop
  {
    \if_num:w #1 < #3 \exp_stop_f:
      \str_output_byte:n { #1 + #4 }
    \else:
      \exp_args:Nf \str_aux_to_utf_viii:nnnnw
        { \int_div_truncate:nn {#1} {64} }
        {#1}
        #5 \q_stop
    \fi:
    \str_output_byte:n { #2 - 64 * ( #1 - \c_two ) }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_convert_from_utf8:}
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_from_utf_viii:N,
%     \str_aux_from_utf_viii:wwNN,
%     \str_aux_from_utf_viii:wNNww
%   }
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_from_utf_viii_error:w,
%     \str_aux_from_utf_viii_error:NwNN,
%     \str_aux_from_utf_viii_error:
%   }
%   In the \textsc{utf-8} encoding, bytes in the range $[0,127]$ stand
%   for themselves, bytes in the range $[128,191]$ are continuation bytes,
%   and larger bytes must be followed by a number of continuation bytes.
%   Documentation to come.
% ^^A todo: refuse "D800 -- "DFFF?
% ^^A todo: document
% ^^A todo: what error recovery for code points > "10FFFF?
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { str_convert_from_utf8: }
  {
    \tl_gset:Nx \g_str_result_tl
      {
        \exp_after:wN \str_aux_from_utf_viii:N \g_str_result_tl
          { \prg_map_break: \str_aux_from_utf_viii_error: }
        \prg_break_point:n { }
      }
  }
\cs_new_nopar:Npn \str_aux_from_utf_viii:N #1
  {
    #1
    \if_num:w `#1 < "C0 \exp_stop_f:
      \exp_not:N \q_mark
      \if_num:w `#1 < "80 \exp_stop_f:
        \int_value:w `#1
      \else:
        \msg_expandable_kernel_error:nnn
          { str } { utf8-extra-conti } {#1}
        \int_use:N \c_str_replacement_char_int
      \fi:
    \else:
      \if_num:w `#1 < "F5 \exp_stop_f:
        \exp_after:wN \str_aux_from_utf_viii:wwNN
          \int_use:N \int_eval:w `#1 - "C0
      \else:
        \exp_not:N \q_mark
        \msg_expandable_kernel_error:nnn
          { str } { utf8-invalid-byte } {#1}
        \int_use:N \c_str_replacement_char_int
      \fi:
    \fi:
    ,
    \use_none_delimit_by_q_stop:w
      "80 , "800 , "10000 , "10FFFF ,
    \q_stop
    \str_aux_from_utf_viii:N
  }
\cs_new_nopar:Npn \str_aux_from_utf_viii:wwNN #1 , #2 \q_stop #3#4
  {
    \use_none:n #4
    \exp_after:wN \str_aux_from_utf_viii:wNNww
      \int_use:N \int_eval:w #1 * "40 + `#4 - "80 ,
      #4
      #2
    \q_stop #3
  }
\cs_new_nopar:Npn \str_aux_from_utf_viii:wNNww #1, #2 #3#4, #5,
  {
    \if_num:w \int_eval:w ( `#2 + \c_thirty_two ) / "40 = \c_three
      \if_num:w #1 < #4 \exp_stop_f:
        \str_aux_from_utf_viii_error:w #1 ,
      \else:
        #2
        \if_num:w #1 < #5 \exp_stop_f:
          \exp_not:N \q_mark #1
        \else:
          \exp_after:wN \str_aux_from_utf_viii:wwNN
            \int_use:N \int_eval:w #1 - #5
        \fi:
      \fi:
    \else:
      \exp_after:wN \str_aux_from_utf_viii_error:NwN
      \exp_after:wN #2
    \fi:
    , #3#5,
  }
\cs_new_nopar:Npn \str_aux_from_utf_viii_error:w #1 ,
  {
    \exp_not:N \q_mark
    \msg_expandable_kernel_error:nnn
      { str } { utf8-overlong } {#1}
    \c_str_replacement_char_int
  }
\cs_new_nopar:Npn \str_aux_from_utf_viii_error:NwN #1 #2 \q_stop #3
  {
    \exp_not:N \q_mark
    \msg_expandable_kernel_error:nnn
      { str } { utf8-missing-conti } {#1}
    \c_str_replacement_char_int ,
    #3#1
  }
\cs_new_nopar:Npn \str_aux_from_utf_viii_error:
  {
    \exp_not:N \q_mark
    \msg_expandable_kernel_error:nn
      { str } { utf8-premature-end }
    \c_str_replacement_char_int ,
    \prg_map_break:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
%</utf8>
%    \end{macrocode}
%
% \subsubsection{\textsc{utf-16} support}
%
% The definitions are done in a category code regime where
% the bytes $254$ and $255$ used by the byte order mark
% have catcode \enquote{other}.
%    \begin{macrocode}
%<*utf16>
\group_begin:
  \char_set_catcode_other:N \^^fe
  \char_set_catcode_other:N \^^ff
%    \end{macrocode}
%
% \begin{macro}[int]{\str_convert_to_utf16:}
% \begin{macro}[int]{\str_convert_to_utf16be:}
% \begin{macro}[int]{\str_convert_to_utf16le:}
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_to_utf_xvi:n,
%     \str_aux_to_utf_xvi_be:n,
%     \str_aux_to_utf_xvi_le:n
%   }
%   Convert characters one by one in a loop, with different
%   behaviours depending on the character code:
%   \begin{itemize}
%   \item $[0, 55295]$ converted to two bytes;
%   \item $[55296, 57343]$ cannot be converted, replaced by
%     the replacement character;
%   \item $[57344, 65535]$ converted to two bytes;
%   \item $[65536, 1114111]$ converted to a pair of surrogates,
%     each two bytes.
%   \end{itemize}
%   For the duration of this operation, \cs{str_tmp:w} is defined
%   as a function to convert a number in the range $[0, 65536]$
%   to a pair of bytes (either big endian or little endian).
%    \begin{macrocode}
  \cs_new_protected_nopar:cpx { str_convert_to_utf16: }
    {
      \exp_not:c { str_convert_to_utf16be: }
      \exp_not:n { \tl_gput_left:Nx \g_str_result_tl { ^^fe ^^ff } }
    }
  \cs_new_protected_nopar:cpn { str_convert_to_utf16be: }
    {
      \cs_set_eq:NN \str_tmp:w \str_aux_to_utf_xvi_be:n
      \str_aux_gmap_internal_result:N \str_aux_to_utf_xvi:n
    }
  \cs_new_protected_nopar:cpn { str_convert_to_utf16le: }
    {
      \cs_set_eq:NN \str_tmp:w \str_aux_to_utf_xvi_le:n
      \str_aux_gmap_internal_result:N \str_aux_to_utf_xvi:n
    }
  \cs_new_nopar:Npn \str_aux_to_utf_xvi:n #1
    {
      \if_int_compare:w #1 < "D800 \exp_stop_f:
        \str_tmp:w {#1}
      \else:
        \if_int_compare:w #1 < "10000 \exp_stop_f:
          \if_int_compare:w #1 < "E000 \exp_stop_f:
            \msg_expandable_kernel_error:nnn
              { str } { unicode-surrogate } {#1}
            \str_tmp:w { \c_str_replacement_char_int }
          \else:
            \str_tmp:w {#1}
          \fi:
        \else:
          \exp_args:Nf \str_tmp:w { \int_div_truncate:nn {#1} {"400} + "D800 }
          \exp_args:Nf \str_tmp:w { \int_mod:nn {#1} {"400} + "DC00 }
        \fi:
      \fi:
    }
  \cs_new_nopar:Npn \str_aux_to_utf_xvi_be:n #1
    {
      \str_output_byte:n { \int_div_truncate:nn {#1} {"100} }
      \str_output_byte:n { \int_mod:nn {#1} {"100} }
    }
  \cs_new_nopar:Npn \str_aux_to_utf_xvi_le:n #1
    {
      \str_output_byte:n { \int_mod:nn {#1} {"100} }
      \str_output_byte:n { \int_div_truncate:nn {#1} {"100} }
    }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \str_convert_from_utf16:,
%     \str_convert_from_utf16be:,
%     \str_convert_from_utf16le:
%   }
% \begin{macro}[aux]{\str_aux_from_utf_xvi_bom:NNw}
% \begin{macro}[aux]{\str_aux_from_utf_xvi:No}
%   Define \cs{str_tmp:w} to take two arguments and return the
%   character code of the first one if the string is big-endian,
%   and the second one if the string is little-endian.
%   If the endianness is not known, look for a byte order mark
%   to decide.
%    \begin{macrocode}
  \cs_new_protected_nopar:cpn { str_convert_from_utf16be: }
    { \str_aux_from_utf_xvi:No 1 { \g_str_result_tl } }
  \cs_new_protected_nopar:cpn { str_convert_from_utf16le: }
    { \str_aux_from_utf_xvi:No 2 { \g_str_result_tl } }
  \cs_new_protected_nopar:cpn { str_convert_from_utf16: }
    {
      \exp_after:wN \str_aux_from_utf_xvi_bom:NNw
        \g_str_result_tl \scan_stop: \scan_stop: \scan_stop:
    }
  \cs_new_protected_nopar:Npn
      \str_aux_from_utf_xvi_bom:NNw #1#2#3\scan_stop:
    {
      \str_if_eq:nnTF { #1#2 } { ^^ff ^^fe }
        { \str_aux_from_utf_xvi:No 2 {#3} }
        {
          \str_if_eq:nnTF { #1#2 } { ^^fe ^^ff }
            { \str_aux_from_utf_xvi:No 1 {#3} }
            { \str_aux_from_utf_xvi:No 1 {#1#2#3} }
        }
    }
  \cs_new_protected_nopar:Npn \str_aux_from_utf_xvi:No #1#2
    {
      \cs_set_nopar:Npn \str_tmp:w ##1 ##2 { ` ## #1 }
      \tl_gset:Nx \g_str_result_tl
        {
          \exp_after:wN \str_aux_from_utf_xvi:NN
            #2 \scan_stop: \scan_stop:
          \prg_break_point:n { }
        }
    }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\str_aux_from_utf_xvi:NN}
% \begin{macro}[aux, rEXP]{\str_aux_from_utf_xvi:wNNN}
% \begin{macro}[aux, rEXP]{\str_aux_from_utf_xvi_error:wNNw}
% \begin{macro}[aux, rEXP]{\str_aux_from_utf_xvi_end:Nw}
% \begin{macro}[aux, rEXP]{\str_aux_from_utf_xvi_end:wNNww}
%   When \cs{str_aux_from_utf_xvi:NN} is called, \cs{str_tmp:w}
%   is such that |\str_tmp:w #1#2| expands to |`#1| if the string
%   is big-endian, and |`#2| if the string is little-endian.
%   If the most significant byte is between |"D8| and |"DB|
%   inclusive, then the pair of bytes is a high surrogate,
%   and we fetch the following pair, which must be a low surrogate,
%   \emph{i.e.}, between |"DC| and |"DF| inclusive.
%   Unpaired surrogates are errors, handled with
%   \cs{str_aux_from_utf_xvi_error:wNNw}.
%    \begin{macrocode}
  \cs_new:Npn \str_aux_from_utf_xvi:NN #1#2
    {
      \if_meaning:w \scan_stop: #2
        \str_aux_from_utf_xvi_end:Nw #1
      \fi:
      \if_case:w
        \int_eval:w ( \str_tmp:w #1#2 - "D6 ) / \c_four \int_eval_end:
      \or: #1#2 \exp_after:wN \str_aux_from_utf_xvi:wNNN
      \or: \exp_after:wN \str_aux_from_utf_xvi_error:wNNw
      \else: #1#2 \exp_not:N \q_mark \int_use:N \int_eval:w
      \fi:
      "100 * \str_tmp:w #1#2 + \str_tmp:w #2#1 ,
      \str_aux_from_utf_xvi:NN
    }
  \cs_new:Npn \str_aux_from_utf_xvi:wNNN #1, #2#3#4
    {
      \if_meaning:w \scan_stop: #4
        \str_aux_from_utf_xvi_end:wNNww #1 , #3
      \fi:
      \if_num:w \int_eval:w ( \str_tmp:w #3#4 - "DA ) / \c_four = \c_one
        #3 #4
        \int_use:N \int_eval:w
          ( #1 - "D800 ) * "400
            + \str_tmp:w #3#4 * "100 + \str_tmp:w #4#3 - "DC00 ,
        \exp_after:wN \use_i:nnn
      \else:
        \str_aux_from_utf_xvi_error:wNNw #1 ,
      \fi:
      #2#3#4
    }
  \cs_new:Npn \str_aux_from_utf_xvi_error:wNNw #1 \str_tmp:w #2#3 #4,
    {
      \exp_not:N \q_mark
      \msg_expandable_kernel_error:nnn
        { str } { utf16-surrogate } { #2#3 }
      \c_str_replacement_char_int ,
    }
  \cs_new:Npn \str_aux_from_utf_xvi_end:Nw #1 \fi:
    {
      \fi:
      \if_meaning:w \scan_stop: #1
      \else:
        #1 \exp_not:N \q_mark
        \msg_expandable_kernel_error:nnn
          { str } { utf16-odd } {#1}
        \int_use:N \c_str_replacement_char_int ,
      \fi:
      \prg_map_break:
    }
  \cs_new:Npn \str_aux_from_utf_xvi_end:wNNww #1 `#2#3 #4, #5 \fi:
    {
      \fi:
      \exp_not:N \q_mark
      \if_meaning:w \scan_stop: #5
        \msg_expandable_kernel_error:nnn
          { str } { utf16-surrogate } { #2#3 }
      \else:
        \msg_expandable_kernel_error:nnn
          { str } { utf16-odd } { #2#3#5 }
      \fi:
      \int_use:N \c_str_replacement_char_int ,
      \prg_map_break:
    }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% Restore the original catcodes of bytes $254$ and $255$.
%    \begin{macrocode}
\group_end:
%</utf16>
%    \end{macrocode}
%
% \subsubsection{\textsc{utf-32} support}
%
% The definitions are done in a category code regime where
% the bytes $0$, $254$ and $255$ used by the byte order mark
% have catcode \enquote{other}.
%    \begin{macrocode}
%<*utf32>
\group_begin:
  \char_set_catcode_other:N \^^00
  \char_set_catcode_other:N \^^fe
  \char_set_catcode_other:N \^^ff
%    \end{macrocode}
%
% \begin{macro}[int]
%   {
%     \str_convert_to_utf32:,
%     \str_convert_to_utf32be:,
%     \str_convert_to_utf32le:
%   }
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_to_utf_xxxii_be:n,
%     \str_aux_to_utf_xxxii_le:n
%   }
%   Convert each integer in the comma-list \cs{g_str_result_tl}
%   to a sequence of four bytes. The functions for big-endian
%   and little-endian encodings are very similar, but the
%   \cs{str_output_byte:n} instructions are reversed.
%    \begin{macrocode}
  \cs_new_protected_nopar:cpx { str_convert_to_utf32: }
    {
      \exp_not:c { str_convert_to_utf32be: }
      \exp_not:n { \tl_gput_left:Nx \g_str_result_tl { ^^00 ^^00 ^^fe ^^ff } }
    }
  \cs_new_protected_nopar:cpn { str_convert_to_utf32be: }
    { \str_aux_gmap_internal_result:N \str_aux_to_utf_xxxii_be:n }
  \cs_new_protected_nopar:cpn { str_convert_to_utf32le: }
    { \str_aux_gmap_internal_result:N \str_aux_to_utf_xxxii_le:n }
  \cs_new:Npn \str_aux_to_utf_xxxii_be:n #1
    {
      ^^00
      \str_output_byte:n { \int_div_truncate:nn {#1} { "10000 } }
      \str_output_byte:n
        { \int_mod:nn { \int_div_truncate:nn {#1} {"100} } {"100} }
      \str_output_byte:n { \int_mod:nn {#1} {"100} }
    }
  \cs_new:Npn \str_aux_to_utf_xxxii_le:n #1
    {
      \str_output_byte:n { \int_mod:nn {#1} {"100} }
      \str_output_byte:n
        { \int_mod:nn { \int_div_truncate:nn {#1} {"100} } {"100} }
      \str_output_byte:n { \int_div_truncate:nn {#1} { "10000 } }
      ^^00
    }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \str_convert_from_utf32:,
%     \str_convert_from_utf32be:,
%     \str_convert_from_utf32le:
%   }
% \begin{macro}[aux]
%   {
%     \str_aux_from_utf_xxxii_bom:NNNNw,
%     \str_aux_from_utf_xxxii:No
%   }
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_from_utf_xxxii:NNNN,
%     \str_aux_from_utf_xxxii_end:ww
%   }
%   See the conversion functions from \textsc{utf-16} encodings.
%   The \cs{str_aux_from_utf_xxxii:No} auxiliary defines
%   \cs{str_tmp:w} to take two arguments and give the character
%   code of either the first argument (big-endian) or the second
%   argument (little-endian). Then we loop over the string,
%   four bytes at a time, check for overflow, and otherwise
%   produce the number corresponding to the four bytes with
%   the given endianness.
%    \begin{macrocode}
  \cs_new_protected_nopar:cpn { str_convert_from_utf32be: }
    { \str_aux_from_utf_xxxii:No 1 { \g_str_result_tl } }
  \cs_new_protected_nopar:cpn { str_convert_from_utf32le: }
    { \str_aux_from_utf_xxxii:No 2 { \g_str_result_tl } }
  \cs_new_protected_nopar:cpn { str_convert_from_utf32: }
    {
      \exp_after:wN \str_aux_from_utf_xxxii_bom:NNNNw \g_str_result_tl
        \scan_stop: \scan_stop: \scan_stop: \scan_stop: \scan_stop:
    }
  \cs_new_protected_nopar:Npn
      \str_aux_from_utf_xxxii_bom:NNNNw #1#2#3#4#5\scan_stop:
    {
      \str_if_eq:nnTF { #1#2#3#4 } { ^^ff ^^fe ^^00 ^^00 }
        { \str_aux_from_utf_xxxii:No 2 {#5} }
        {
          \str_if_eq:nnTF { #1#2#3#4 } { ^^00 ^^00 ^^fe ^^ff }
            { \str_aux_from_utf_xxxii:No 1 {#5} }
            { \str_aux_from_utf_xxxii:No 1 {#1#2#3#4#5} }
        }
    }
  \cs_new_protected_nopar:Npn \str_aux_from_utf_xxxii:No #1#2
    {
      \cs_set_nopar:Npn \str_tmp:w ##1 ##2 { ` ## #1 }
      \tl_gset:Nx \g_str_result_tl
        {
          \exp_after:wN \str_aux_from_utf_xxxii:NNNN
            #2 \scan_stop: \scan_stop: \scan_stop: \scan_stop:
          \prg_break_point:n { }
        }
    }
  \cs_new:Npn \str_aux_from_utf_xxxii:NNNN #1#2#3#4
    {
      \if_meaning:w \scan_stop: #4
        \exp_after:wN \str_aux_from_utf_xxxii_end:w
      \fi:
      #1#2#3#4 \exp_not:N \q_mark
      \if_num:w \int_eval:w
                  \str_tmp:w #1#4 * \c_two_hundred_fifty_six
                  + \str_tmp:w #2#3
                > \c_sixteen
        \msg_expandable_kernel_error:nnn
          { str } { utf32-overflow } { #1#2#3#4 }
        \int_use:N \c_str_replacement_char_int
      \else:
        \int_use:N \int_eval:w
        \str_tmp:w #2#3*"10000
        + \str_tmp:w #3#2 * \c_two_hundred_fifty_six
        + \str_tmp:w #4#1
      \fi:
      ,
      \str_aux_from_utf_xxxii:NNNN
    }
  \cs_new:Npn \str_aux_from_utf_xxxii_end:w #1 \scan_stop:
    {
      \tl_if_empty:nF {#1}
        {
          \msg_expandable_kernel_error:nnn
            { str } { utf32-truncated } { #1 }
          #1 \exp_not:N \q_mark
          \int_use:N \c_str_replacement_char_int ,
        }
      \prg_map_break:
    }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% Restore the original catcodes of bytes $0$, $254$ and $255$.
%    \begin{macrocode}
\group_end:
%</utf32>
%    \end{macrocode}
%
% \subsubsection{\textsc{iso 8859} support}
%^^A todo: document
%
% The \textsc{iso-8859-1} encoding exactly matches with the $256$
% first Unicode characters. For other 8-bit encodings
% of the \textsc{iso-8859} family, we keep track only of
% differences, and of unassigned bytes.
%    \begin{macrocode}
%<*iso88591>
\str_encoding_eight_bit:n { iso88591 }
\tl_const:cn { c_str_encoding_iso88591_tl }
  {
  }
\tl_const:cn { c_str_encoding_iso88591_missing_tl }
  {
  }
%</iso88591>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso88592>
\str_encoding_eight_bit:n { iso88592 }
\tl_const:cn { c_str_encoding_iso88592_tl }
  {
    { A1 } { 0104 }
    { A2 } { 02D8 }
    { A3 } { 0141 }
    { A5 } { 013D }
    { A6 } { 015A }
    { A9 } { 0160 }
    { AA } { 015E }
    { AB } { 0164 }
    { AC } { 0179 }
    { AE } { 017D }
    { AF } { 017B }
    { B1 } { 0105 }
    { B2 } { 02DB }
    { B3 } { 0142 }
    { B5 } { 013E }
    { B6 } { 015B }
    { B7 } { 02C7 }
    { B9 } { 0161 }
    { BA } { 015F }
    { BB } { 0165 }
    { BC } { 017A }
    { BD } { 02DD }
    { BE } { 017E }
    { BF } { 017C }
    { C0 } { 0154 }
    { C3 } { 0102 }
    { C5 } { 0139 }
    { C6 } { 0106 }
    { C8 } { 010C }
    { CA } { 0118 }
    { CC } { 011A }
    { CF } { 010E }
    { D0 } { 0110 }
    { D1 } { 0143 }
    { D2 } { 0147 }
    { D5 } { 0150 }
    { D8 } { 0158 }
    { D9 } { 016E }
    { DB } { 0170 }
    { DE } { 0162 }
    { E0 } { 0155 }
    { E3 } { 0103 }
    { E5 } { 013A }
    { E6 } { 0107 }
    { E8 } { 010D }
    { EA } { 0119 }
    { EC } { 011B }
    { EF } { 010F }
    { F0 } { 0111 }
    { F1 } { 0144 }
    { F2 } { 0148 }
    { F5 } { 0151 }
    { F8 } { 0159 }
    { F9 } { 016F }
    { FB } { 0171 }
    { FE } { 0163 }
    { FF } { 02D9 }
  }
\tl_const:cn { c_str_encoding_iso88592_missing_tl }
  {
  }
%</iso88592>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso88593>
\str_encoding_eight_bit:n { iso88593 }
\tl_const:cn { c_str_encoding_iso88593_tl }
  {
    { A1 } { 0126 }
    { A2 } { 02D8 }
    { A6 } { 0124 }
    { A9 } { 0130 }
    { AA } { 015E }
    { AB } { 011E }
    { AC } { 0134 }
    { AF } { 017B }
    { B1 } { 0127 }
    { B6 } { 0125 }
    { B9 } { 0131 }
    { BA } { 015F }
    { BB } { 011F }
    { BC } { 0135 }
    { BF } { 017C }
    { C5 } { 010A }
    { C6 } { 0108 }
    { D5 } { 0120 }
    { D8 } { 011C }
    { DD } { 016C }
    { DE } { 015C }
    { E5 } { 010B }
    { E6 } { 0109 }
    { F5 } { 0121 }
    { F8 } { 011D }
    { FD } { 016D }
    { FE } { 015D }
    { FF } { 02D9 }
  }
\tl_const:cn { c_str_encoding_iso88593_missing_tl }
  {
    { A5 }
    { AE }
    { BE }
    { C3 }
    { D0 }
    { E3 }
    { F0 }
  }
%</iso88593>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso88594>
\str_encoding_eight_bit:n { iso88594 }
\tl_const:cn { c_str_encoding_iso88594_tl }
  {
    { A1 } { 0104 }
    { A2 } { 0138 }
    { A3 } { 0156 }
    { A5 } { 0128 }
    { A6 } { 013B }
    { A9 } { 0160 }
    { AA } { 0112 }
    { AB } { 0122 }
    { AC } { 0166 }
    { AE } { 017D }
    { B1 } { 0105 }
    { B2 } { 02DB }
    { B3 } { 0157 }
    { B5 } { 0129 }
    { B6 } { 013C }
    { B7 } { 02C7 }
    { B9 } { 0161 }
    { BA } { 0113 }
    { BB } { 0123 }
    { BC } { 0167 }
    { BD } { 014A }
    { BE } { 017E }
    { BF } { 014B }
    { C0 } { 0100 }
    { C7 } { 012E }
    { C8 } { 010C }
    { CA } { 0118 }
    { CC } { 0116 }
    { CF } { 012A }
    { D0 } { 0110 }
    { D1 } { 0145 }
    { D2 } { 014C }
    { D3 } { 0136 }
    { D9 } { 0172 }
    { DD } { 0168 }
    { DE } { 016A }
    { E0 } { 0101 }
    { E7 } { 012F }
    { E8 } { 010D }
    { EA } { 0119 }
    { EC } { 0117 }
    { EF } { 012B }
    { F0 } { 0111 }
    { F1 } { 0146 }
    { F2 } { 014D }
    { F3 } { 0137 }
    { F9 } { 0173 }
    { FD } { 0169 }
    { FE } { 016B }
    { FF } { 02D9 }
  }
\tl_const:cn { c_str_encoding_iso88594_missing_tl }
  {
  }
%</iso88594>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso88595>
\str_encoding_eight_bit:n { iso88595 }
\tl_const:cn { c_str_encoding_iso88595_tl }
  {
    { A1 } { 0401 }
    { A2 } { 0402 }
    { A3 } { 0403 }
    { A4 } { 0404 }
    { A5 } { 0405 }
    { A6 } { 0406 }
    { A7 } { 0407 }
    { A8 } { 0408 }
    { A9 } { 0409 }
    { AA } { 040A }
    { AB } { 040B }
    { AC } { 040C }
    { AE } { 040E }
    { AF } { 040F }
    { B0 } { 0410 }
    { B1 } { 0411 }
    { B2 } { 0412 }
    { B3 } { 0413 }
    { B4 } { 0414 }
    { B5 } { 0415 }
    { B6 } { 0416 }
    { B7 } { 0417 }
    { B8 } { 0418 }
    { B9 } { 0419 }
    { BA } { 041A }
    { BB } { 041B }
    { BC } { 041C }
    { BD } { 041D }
    { BE } { 041E }
    { BF } { 041F }
    { C0 } { 0420 }
    { C1 } { 0421 }
    { C2 } { 0422 }
    { C3 } { 0423 }
    { C4 } { 0424 }
    { C5 } { 0425 }
    { C6 } { 0426 }
    { C7 } { 0427 }
    { C8 } { 0428 }
    { C9 } { 0429 }
    { CA } { 042A }
    { CB } { 042B }
    { CC } { 042C }
    { CD } { 042D }
    { CE } { 042E }
    { CF } { 042F }
    { D0 } { 0430 }
    { D1 } { 0431 }
    { D2 } { 0432 }
    { D3 } { 0433 }
    { D4 } { 0434 }
    { D5 } { 0435 }
    { D6 } { 0436 }
    { D7 } { 0437 }
    { D8 } { 0438 }
    { D9 } { 0439 }
    { DA } { 043A }
    { DB } { 043B }
    { DC } { 043C }
    { DD } { 043D }
    { DE } { 043E }
    { DF } { 043F }
    { E0 } { 0440 }
    { E1 } { 0441 }
    { E2 } { 0442 }
    { E3 } { 0443 }
    { E4 } { 0444 }
    { E5 } { 0445 }
    { E6 } { 0446 }
    { E7 } { 0447 }
    { E8 } { 0448 }
    { E9 } { 0449 }
    { EA } { 044A }
    { EB } { 044B }
    { EC } { 044C }
    { ED } { 044D }
    { EE } { 044E }
    { EF } { 044F }
    { F0 } { 2116 }
    { F1 } { 0451 }
    { F2 } { 0452 }
    { F3 } { 0453 }
    { F4 } { 0454 }
    { F5 } { 0455 }
    { F6 } { 0456 }
    { F7 } { 0457 }
    { F8 } { 0458 }
    { F9 } { 0459 }
    { FA } { 045A }
    { FB } { 045B }
    { FC } { 045C }
    { FD } { 00A7 }
    { FE } { 045E }
    { FF } { 045F }
  }
\tl_const:cn { c_str_encoding_iso88595_missing_tl }
  {
  }
%</iso88595>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso88596>
\str_encoding_eight_bit:n { iso88596 }
\tl_const:cn { c_str_encoding_iso88596_tl }
  {
    { AC } { 060C }
    { BB } { 061B }
    { BF } { 061F }
    { C1 } { 0621 }
    { C2 } { 0622 }
    { C3 } { 0623 }
    { C4 } { 0624 }
    { C5 } { 0625 }
    { C6 } { 0626 }
    { C7 } { 0627 }
    { C8 } { 0628 }
    { C9 } { 0629 }
    { CA } { 062A }
    { CB } { 062B }
    { CC } { 062C }
    { CD } { 062D }
    { CE } { 062E }
    { CF } { 062F }
    { D0 } { 0630 }
    { D1 } { 0631 }
    { D2 } { 0632 }
    { D3 } { 0633 }
    { D4 } { 0634 }
    { D5 } { 0635 }
    { D6 } { 0636 }
    { D7 } { 0637 }
    { D8 } { 0638 }
    { D9 } { 0639 }
    { DA } { 063A }
    { E0 } { 0640 }
    { E1 } { 0641 }
    { E2 } { 0642 }
    { E3 } { 0643 }
    { E4 } { 0644 }
    { E5 } { 0645 }
    { E6 } { 0646 }
    { E7 } { 0647 }
    { E8 } { 0648 }
    { E9 } { 0649 }
    { EA } { 064A }
    { EB } { 064B }
    { EC } { 064C }
    { ED } { 064D }
    { EE } { 064E }
    { EF } { 064F }
    { F0 } { 0650 }
    { F1 } { 0651 }
    { F2 } { 0652 }
  }
\tl_const:cn { c_str_encoding_iso88596_missing_tl }
  {
    { A1 }
    { A2 }
    { A3 }
    { A5 }
    { A6 }
    { A7 }
    { A8 }
    { A9 }
    { AA }
    { AB }
    { AE }
    { AF }
    { B0 }
    { B1 }
    { B2 }
    { B3 }
    { B4 }
    { B5 }
    { B6 }
    { B7 }
    { B8 }
    { B9 }
    { BA }
    { BC }
    { BD }
    { BE }
    { C0 }
    { DB }
    { DC }
    { DD }
    { DE }
    { DF }
  }
%</iso88596>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso88597>
\str_encoding_eight_bit:n { iso88597 }
\tl_const:cn { c_str_encoding_iso88597_tl }
  {
    { A1 } { 2018 }
    { A2 } { 2019 }
    { A4 } { 20AC }
    { A5 } { 20AF }
    { AA } { 037A }
    { AF } { 2015 }
    { B4 } { 0384 }
    { B5 } { 0385 }
    { B6 } { 0386 }
    { B8 } { 0388 }
    { B9 } { 0389 }
    { BA } { 038A }
    { BC } { 038C }
    { BE } { 038E }
    { BF } { 038F }
    { C0 } { 0390 }
    { C1 } { 0391 }
    { C2 } { 0392 }
    { C3 } { 0393 }
    { C4 } { 0394 }
    { C5 } { 0395 }
    { C6 } { 0396 }
    { C7 } { 0397 }
    { C8 } { 0398 }
    { C9 } { 0399 }
    { CA } { 039A }
    { CB } { 039B }
    { CC } { 039C }
    { CD } { 039D }
    { CE } { 039E }
    { CF } { 039F }
    { D0 } { 03A0 }
    { D1 } { 03A1 }
    { D3 } { 03A3 }
    { D4 } { 03A4 }
    { D5 } { 03A5 }
    { D6 } { 03A6 }
    { D7 } { 03A7 }
    { D8 } { 03A8 }
    { D9 } { 03A9 }
    { DA } { 03AA }
    { DB } { 03AB }
    { DC } { 03AC }
    { DD } { 03AD }
    { DE } { 03AE }
    { DF } { 03AF }
    { E0 } { 03B0 }
    { E1 } { 03B1 }
    { E2 } { 03B2 }
    { E3 } { 03B3 }
    { E4 } { 03B4 }
    { E5 } { 03B5 }
    { E6 } { 03B6 }
    { E7 } { 03B7 }
    { E8 } { 03B8 }
    { E9 } { 03B9 }
    { EA } { 03BA }
    { EB } { 03BB }
    { EC } { 03BC }
    { ED } { 03BD }
    { EE } { 03BE }
    { EF } { 03BF }
    { F0 } { 03C0 }
    { F1 } { 03C1 }
    { F2 } { 03C2 }
    { F3 } { 03C3 }
    { F4 } { 03C4 }
    { F5 } { 03C5 }
    { F6 } { 03C6 }
    { F7 } { 03C7 }
    { F8 } { 03C8 }
    { F9 } { 03C9 }
    { FA } { 03CA }
    { FB } { 03CB }
    { FC } { 03CC }
    { FD } { 03CD }
    { FE } { 03CE }
  }
\tl_const:cn { c_str_encoding_iso88597_missing_tl }
  {
    { AE }
    { D2 }
  }
%</iso88597>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso88598>
\str_encoding_eight_bit:n { iso88598 }
\tl_const:cn { c_str_encoding_iso88598_tl }
  {
    { AA } { 00D7 }
    { BA } { 00F7 }
    { DF } { 2017 }
    { E0 } { 05D0 }
    { E1 } { 05D1 }
    { E2 } { 05D2 }
    { E3 } { 05D3 }
    { E4 } { 05D4 }
    { E5 } { 05D5 }
    { E6 } { 05D6 }
    { E7 } { 05D7 }
    { E8 } { 05D8 }
    { E9 } { 05D9 }
    { EA } { 05DA }
    { EB } { 05DB }
    { EC } { 05DC }
    { ED } { 05DD }
    { EE } { 05DE }
    { EF } { 05DF }
    { F0 } { 05E0 }
    { F1 } { 05E1 }
    { F2 } { 05E2 }
    { F3 } { 05E3 }
    { F4 } { 05E4 }
    { F5 } { 05E5 }
    { F6 } { 05E6 }
    { F7 } { 05E7 }
    { F8 } { 05E8 }
    { F9 } { 05E9 }
    { FA } { 05EA }
    { FD } { 200E }
    { FE } { 200F }
  }
\tl_const:cn { c_str_encoding_iso88598_missing_tl }
  {
    { A1 }
    { BF }
    { C0 }
    { C1 }
    { C2 }
    { C3 }
    { C4 }
    { C5 }
    { C6 }
    { C7 }
    { C8 }
    { C9 }
    { CA }
    { CB }
    { CC }
    { CD }
    { CE }
    { CF }
    { D0 }
    { D1 }
    { D2 }
    { D3 }
    { D4 }
    { D5 }
    { D6 }
    { D7 }
    { D8 }
    { D9 }
    { DA }
    { DB }
    { DC }
    { DD }
    { DE }
    { FB }
    { FC }
  }
%</iso88598>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso88599>
\str_encoding_eight_bit:n { iso88599 }
\tl_const:cn { c_str_encoding_iso88599_tl }
  {
    { D0 } { 011E }
    { DD } { 0130 }
    { DE } { 015E }
    { F0 } { 011F }
    { FD } { 0131 }
    { FE } { 015F }
  }
\tl_const:cn { c_str_encoding_iso88599_missing_tl }
  {
  }
%</iso88599>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso885910>
\str_encoding_eight_bit:n { iso885910 }
\tl_const:cn { c_str_encoding_iso885910_tl }
  {
    { A1 } { 0104 }
    { A2 } { 0112 }
    { A3 } { 0122 }
    { A4 } { 012A }
    { A5 } { 0128 }
    { A6 } { 0136 }
    { A8 } { 013B }
    { A9 } { 0110 }
    { AA } { 0160 }
    { AB } { 0166 }
    { AC } { 017D }
    { AE } { 016A }
    { AF } { 014A }
    { B1 } { 0105 }
    { B2 } { 0113 }
    { B3 } { 0123 }
    { B4 } { 012B }
    { B5 } { 0129 }
    { B6 } { 0137 }
    { B8 } { 013C }
    { B9 } { 0111 }
    { BA } { 0161 }
    { BB } { 0167 }
    { BC } { 017E }
    { BD } { 2015 }
    { BE } { 016B }
    { BF } { 014B }
    { C0 } { 0100 }
    { C7 } { 012E }
    { C8 } { 010C }
    { CA } { 0118 }
    { CC } { 0116 }
    { D1 } { 0145 }
    { D2 } { 014C }
    { D7 } { 0168 }
    { D9 } { 0172 }
    { E0 } { 0101 }
    { E7 } { 012F }
    { E8 } { 010D }
    { EA } { 0119 }
    { EC } { 0117 }
    { F1 } { 0146 }
    { F2 } { 014D }
    { F7 } { 0169 }
    { F9 } { 0173 }
    { FF } { 0138 }
  }
\tl_const:cn { c_str_encoding_iso885910_missing_tl }
  {
  }
%</iso885910>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso885911>
\str_encoding_eight_bit:n { iso885911 }
\tl_const:cn { c_str_encoding_iso885911_tl }
  {
    { A1 } { 0E01 }
    { A2 } { 0E02 }
    { A3 } { 0E03 }
    { A4 } { 0E04 }
    { A5 } { 0E05 }
    { A6 } { 0E06 }
    { A7 } { 0E07 }
    { A8 } { 0E08 }
    { A9 } { 0E09 }
    { AA } { 0E0A }
    { AB } { 0E0B }
    { AC } { 0E0C }
    { AD } { 0E0D }
    { AE } { 0E0E }
    { AF } { 0E0F }
    { B0 } { 0E10 }
    { B1 } { 0E11 }
    { B2 } { 0E12 }
    { B3 } { 0E13 }
    { B4 } { 0E14 }
    { B5 } { 0E15 }
    { B6 } { 0E16 }
    { B7 } { 0E17 }
    { B8 } { 0E18 }
    { B9 } { 0E19 }
    { BA } { 0E1A }
    { BB } { 0E1B }
    { BC } { 0E1C }
    { BD } { 0E1D }
    { BE } { 0E1E }
    { BF } { 0E1F }
    { C0 } { 0E20 }
    { C1 } { 0E21 }
    { C2 } { 0E22 }
    { C3 } { 0E23 }
    { C4 } { 0E24 }
    { C5 } { 0E25 }
    { C6 } { 0E26 }
    { C7 } { 0E27 }
    { C8 } { 0E28 }
    { C9 } { 0E29 }
    { CA } { 0E2A }
    { CB } { 0E2B }
    { CC } { 0E2C }
    { CD } { 0E2D }
    { CE } { 0E2E }
    { CF } { 0E2F }
    { D0 } { 0E30 }
    { D1 } { 0E31 }
    { D2 } { 0E32 }
    { D3 } { 0E33 }
    { D4 } { 0E34 }
    { D5 } { 0E35 }
    { D6 } { 0E36 }
    { D7 } { 0E37 }
    { D8 } { 0E38 }
    { D9 } { 0E39 }
    { DA } { 0E3A }
    { DF } { 0E3F }
    { E0 } { 0E40 }
    { E1 } { 0E41 }
    { E2 } { 0E42 }
    { E3 } { 0E43 }
    { E4 } { 0E44 }
    { E5 } { 0E45 }
    { E6 } { 0E46 }
    { E7 } { 0E47 }
    { E8 } { 0E48 }
    { E9 } { 0E49 }
    { EA } { 0E4A }
    { EB } { 0E4B }
    { EC } { 0E4C }
    { ED } { 0E4D }
    { EE } { 0E4E }
    { EF } { 0E4F }
    { F0 } { 0E50 }
    { F1 } { 0E51 }
    { F2 } { 0E52 }
    { F3 } { 0E53 }
    { F4 } { 0E54 }
    { F5 } { 0E55 }
    { F6 } { 0E56 }
    { F7 } { 0E57 }
    { F8 } { 0E58 }
    { F9 } { 0E59 }
    { FA } { 0E5A }
    { FB } { 0E5B }
  }
\tl_const:cn { c_str_encoding_iso885911_missing_tl }
  {
    { DB }
    { DC }
    { DD }
    { DE }
  }
%</iso885911>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso885913>
\str_encoding_eight_bit:n { iso885913 }
\tl_const:cn { c_str_encoding_iso885913_tl }
  {
    { A1 } { 201D }
    { A5 } { 201E }
    { A8 } { 00D8 }
    { AA } { 0156 }
    { AF } { 00C6 }
    { B4 } { 201C }
    { B8 } { 00F8 }
    { BA } { 0157 }
    { BF } { 00E6 }
    { C0 } { 0104 }
    { C1 } { 012E }
    { C2 } { 0100 }
    { C3 } { 0106 }
    { C6 } { 0118 }
    { C7 } { 0112 }
    { C8 } { 010C }
    { CA } { 0179 }
    { CB } { 0116 }
    { CC } { 0122 }
    { CD } { 0136 }
    { CE } { 012A }
    { CF } { 013B }
    { D0 } { 0160 }
    { D1 } { 0143 }
    { D2 } { 0145 }
    { D4 } { 014C }
    { D8 } { 0172 }
    { D9 } { 0141 }
    { DA } { 015A }
    { DB } { 016A }
    { DD } { 017B }
    { DE } { 017D }
    { E0 } { 0105 }
    { E1 } { 012F }
    { E2 } { 0101 }
    { E3 } { 0107 }
    { E6 } { 0119 }
    { E7 } { 0113 }
    { E8 } { 010D }
    { EA } { 017A }
    { EB } { 0117 }
    { EC } { 0123 }
    { ED } { 0137 }
    { EE } { 012B }
    { EF } { 013C }
    { F0 } { 0161 }
    { F1 } { 0144 }
    { F2 } { 0146 }
    { F4 } { 014D }
    { F8 } { 0173 }
    { F9 } { 0142 }
    { FA } { 015B }
    { FB } { 016B }
    { FD } { 017C }
    { FE } { 017E }
    { FF } { 2019 }
  }
\tl_const:cn { c_str_encoding_iso885913_missing_tl }
  {
  }
%</iso885913>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso885914>
\str_encoding_eight_bit:n { iso885914 }
\tl_const:cn { c_str_encoding_iso885914_tl }
  {
    { A1 } { 1E02 }
    { A2 } { 1E03 }
    { A4 } { 010A }
    { A5 } { 010B }
    { A6 } { 1E0A }
    { A8 } { 1E80 }
    { AA } { 1E82 }
    { AB } { 1E0B }
    { AC } { 1EF2 }
    { AF } { 0178 }
    { B0 } { 1E1E }
    { B1 } { 1E1F }
    { B2 } { 0120 }
    { B3 } { 0121 }
    { B4 } { 1E40 }
    { B5 } { 1E41 }
    { B7 } { 1E56 }
    { B8 } { 1E81 }
    { B9 } { 1E57 }
    { BA } { 1E83 }
    { BB } { 1E60 }
    { BC } { 1EF3 }
    { BD } { 1E84 }
    { BE } { 1E85 }
    { BF } { 1E61 }
    { D0 } { 0174 }
    { D7 } { 1E6A }
    { DE } { 0176 }
    { F0 } { 0175 }
    { F7 } { 1E6B }
    { FE } { 0177 }
  }
\tl_const:cn { c_str_encoding_iso885914_missing_tl }
  {
  }
%</iso885914>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso885915>
\str_encoding_eight_bit:n { iso885915 }
\tl_const:cn { c_str_encoding_iso885915_tl }
  {
    { A4 } { 20AC }
    { A6 } { 0160 }
    { A8 } { 0161 }
    { B4 } { 017D }
    { B8 } { 017E }
    { BC } { 0152 }
    { BD } { 0153 }
    { BE } { 0178 }
  }
\tl_const:cn { c_str_encoding_iso885915_missing_tl }
  {
  }
%</iso885915>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*iso885916>
\str_encoding_eight_bit:n { iso885916 }
\tl_const:cn { c_str_encoding_iso885916_tl }
  {
    { A1 } { 0104 }
    { A2 } { 0105 }
    { A3 } { 0141 }
    { A4 } { 20AC }
    { A5 } { 201E }
    { A6 } { 0160 }
    { A8 } { 0161 }
    { AA } { 0218 }
    { AC } { 0179 }
    { AE } { 017A }
    { AF } { 017B }
    { B2 } { 010C }
    { B3 } { 0142 }
    { B4 } { 017D }
    { B5 } { 201D }
    { B8 } { 017E }
    { B9 } { 010D }
    { BA } { 0219 }
    { BC } { 0152 }
    { BD } { 0153 }
    { BE } { 0178 }
    { BF } { 017C }
    { C3 } { 0102 }
    { C5 } { 0106 }
    { D0 } { 0110 }
    { D1 } { 0143 }
    { D5 } { 0150 }
    { D7 } { 015A }
    { D8 } { 0170 }
    { DD } { 0118 }
    { DE } { 021A }
    { E3 } { 0103 }
    { E5 } { 0107 }
    { F0 } { 0111 }
    { F1 } { 0144 }
    { F5 } { 0151 }
    { F7 } { 015B }
    { F8 } { 0171 }
    { FD } { 0119 }
    { FE } { 021B }
  }
\tl_const:cn { c_str_encoding_iso885916_missing_tl }
  {
  }
%</iso885916>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
