% \iffalse meta-comment
%
%% File: l3str.dtx Copyright (C) 2011-2013 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3experimental bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental strings}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \tableofcontents
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \title{^^A
%   The \textsf{l3str} package: manipulating strings of characters^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \LaTeX3 provides a set of functions to manipulate token lists
% as strings of characters, ignoring the category codes of those
% characters.
%
% String variables are simply specialised token lists, but by convention
% should be named with the suffix \texttt{\ldots str}. Such variables
% should contain characters with category code $12$ (other), except
% spaces, which have category code $10$ (blank space). All the functions
% in this module first convert their argument to a string for internal
% processing, and will not treat a token list or the corresponding
% string representation differently.
%
% Most expandable functions in this module come in three flavours:
% \begin{itemize}
%   \item \cs{str_...:N...}, which expect a token list or string
%     variable as their argument;
%   \item \cs{str_...:n...}, taking any token list (or string) as an
%     argument;
%   \item \cs{str_..._ignore_spaces:n...}, which ignores any space
%     encountered during the operation: these functions are faster than
%     those which take care of escaping spaces appropriately;
% \end{itemize}
%
% \section{Building strings}
%
% \begin{variable}
%   {
%     \c_backslash_str,
%     \c_lbrace_str,
%     \c_rbrace_str,
%     \c_hash_str,
%     \c_tilde_str,
%     \c_percent_str
%   }
%   Constant strings, containing a single character, with category code
%   $12$.  Any character can be accessed as \cs{iow_char:N}
%   |\|\meta{character}.
% \end{variable}
%
% \begin{function}[EXP]{\tl_to_str:N, \tl_to_str:n}
%   \begin{syntax}
%     \cs{tl_to_str:N} \meta{tl var}
%     \cs{tl_to_str:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, leaving the
%   resulting tokens in the input stream.
%   \begin{texnote}
%     The string representation of a token list may depend on the
%     category codes in effect when it is evaluated, and the value of
%     the \tn{escapechar}: for instance |\tl_to_str:n {\a}| normally
%     produces the three character \enquote{backslash},
%     \enquote{lower-case a}, \enquote{space}, but it may also produce
%     $1$ or $2$ characters depending on the escape character, and the
%     category code of \texttt{a}. This impacts almost all functions in
%     the module, which use \cs{tl_to_str:n} internally.
%   \end{texnote}
% \end{function}
%
% \begin{function}{\str_new:N, \str_new:c}
%   \begin{syntax}
%     \cs{str_new:N} \meta{str~var}
%   \end{syntax}
%   Creates a new \meta{str~var} or raises an error if the name is
%   already taken. The declaration is global. The \meta{str~var} will
%   initially be empty.
% \end{function}
%
% \begin{function}{\str_const:Nn, \str_const:Nx, \str_const:cn, \str_const:cx}
%   \begin{syntax}
%     \cs{str_const:Nn} \meta{str~var} \Arg{token list}
%   \end{syntax}
%   Creates a new constant \meta{str~var} or raises an error if the name
%   is already taken. The value of the \meta{str~var} will be set
%   globally to the \meta{token list}, converted to a string.
% \end{function}
%
% \begin{function}
%   {
%     \str_set:Nn,  \str_set:Nx,  \str_set:cn,  \str_set:cx,
%     \str_gset:Nn, \str_gset:Nx, \str_gset:cn, \str_gset:cx
%   }
%   \begin{syntax}
%     \cs{str_set:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, and stores the
%   result in \meta{str var}.
% \end{function}
%
% \begin{function}
%   {
%     \str_put_left:Nn,  \str_put_left:Nx,
%     \str_put_left:cn,  \str_put_left:cx,
%     \str_gput_left:Nn, \str_gput_left:Nx,
%     \str_gput_left:cn, \str_gput_left:cx
%   }
%   \begin{syntax}
%     \cs{str_put_left:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, and prepends the
%   result to \meta{str var}.  The current contents of the \meta{str
%     var} are not automatically converted to a string.
% \end{function}
%
% \begin{function}
%   {
%     \str_put_right:Nn,  \str_put_right:Nx,
%     \str_put_right:cn,  \str_put_right:cx,
%     \str_gput_right:Nn, \str_gput_right:Nx,
%     \str_gput_right:cn, \str_gput_right:cx
%   }
%   \begin{syntax}
%     \cs{str_put_right:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, and appends the
%   result to \meta{str var}.  The current contents of the \meta{str
%     var} are not automatically converted to a string.
% \end{function}
%
% \section{Accessing the contents of a string}
%
% \begin{function}[EXP]
%   {\str_count:N, \str_count:n, \str_count_ignore_spaces:n}
%   \begin{syntax}
%     \cs{str_count:n} \Arg{token list}
%   \end{syntax}
%   Leaves the number of tokens in the string representation of
%   \meta{token list}
%   in the input stream as an integer denotation. The functions differ
%   in their treatment of spaces.  In the case of \cs{str_count:N} and
%   \cs{str_count:n}, all characters including spaces are counted.  The
%   \cs{str_count_ignore_spaces:n} leaves the number of non-space
%   characters in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\str_count_spaces:N, \str_count_spaces:n}
%   \begin{syntax}
%     \cs{str_count_spaces:n} \Arg{token list}
%   \end{syntax}
%   Leaves in the input stream the number of space characters in the
%   string representation of \meta{token list}, as an integer
%   denotation. Of course, this function has no \texttt{_ignore_spaces}
%   variant.
% \end{function}
%
% \begin{function}[EXP]{\str_head:N, \str_head:n, \str_head_ignore_spaces:n}
%   \begin{syntax}
%     \cs{str_head:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} into a \meta{string}.  The first
%   character in the \meta{string} is then left in the input stream,
%   with category code \enquote{other}.  The functions differ in their
%   treatment of spaces.  In the case of \cs{str_head:N} and
%   \cs{str_head:n}, a leading space is returned with category code $10$
%   (blank space).  The \cs{str_head_ignore_spaces:n} function leaves
%   the first non-space character in the input stream.  If the
%   \meta{token list} is empty (or blank in the case of the
%   \texttt{_ignore_spaces} variant), then nothing is left on the input
%   stream.
% \end{function}
%
% \begin{function}[EXP]{\str_tail:N, \str_tail:n, \str_tail_ignore_spaces:n}
%   \begin{syntax}
%     \cs{str_tail:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, removes the first
%   character, and leaves the remaining characters (if any) in the input
%   stream, with category codes $12$ and $10$ (for spaces).  The
%   functions differ in the case where the first character is a space:
%   \cs{str_tail:N} and \cs{str_tail:n} will trim only that space, while
%   \cs{str_tail_ignore_spaces:n} removes the first non-space character
%   and any space before it.  If the \meta{token list} is empty (or
%   blank in the case of the \texttt{_ignore_spaces} variant), then
%   nothing is left on the input stream.
% \end{function}
%
% \begin{function}[EXP]{\str_item:Nn, \str_item:nn, \str_item_ignore_spaces:nn}
%   \begin{syntax}
%     \cs{str_item:nn} \Arg{token list} \Arg{integer expression}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, and leaves in the
%   input stream the character in position \meta{integer expression} of
%   the \meta{string}.  In the case of \cs{str_item:Nn} and
%   \cs{str_item:nn}, all characters including spaces are taken into
%   account.  The \cs{str_item_ignore_spaces:nn} function skips spaces
%   in its argument.  If the \meta{integer expression} is negative,
%   characters are counted from the end of the \meta{string}. Hence,
%   $-1$ is the right-most character, \emph{etc.}, while $1$ is the
%   first (left-most) character.
% \end{function}
%
% \begin{function}[EXP]
%   {\str_substr:Nnn, \str_substr:nnn, \str_substr_ignore_spaces:nnn}
%   \begin{syntax}
%     \cs{str_substr:nnn} \Arg{token list} \Arg{start index} \Arg{end index}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, and leaves in the
%   input stream the characters from the \meta{start index} to the
%   \meta{end index} inclusive.  Positive \meta{indices} are counted
%   from the start of the string, $1$~being the first character, and
%   negative \meta{indices} are counted from the end of the string,
%   $-1$~being the last character.  If either of \meta{start index} or
%   \meta{end index} is empty of~$0$, it is replaced by the
%   corresponding end-point of the string.  For instance,
%   \begin{verbatim}
%     \iow_term:x { \str_substr:nnn { abcdef } { 2 } { 5 } }
%     \iow_term:x { \str_substr:nnn { abcdef } { -4 } { } }
%   \end{verbatim}
%   will print \texttt{bcd} and \texttt{cdef} to the terminal.
% \end{function}
%
% \section{String conditionals}
%
% \begin{function}[EXP,pTF]
%   {
%     \str_if_eq:nn, \str_if_eq:Vn, \str_if_eq:on, \str_if_eq:no,
%     \str_if_eq:nV, \str_if_eq:VV
%   }
%   \begin{syntax}
%     \cs{str_if_eq_p:nn} \Arg{tl_1} \Arg{tl_2}
%     \cs{str_if_eq:nnTF} \Arg{tl_1} \Arg{tl_2} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Compares the two \meta{token lists} on a character by character
%   basis, and is \texttt{true} if the two lists contain the same
%   characters in the same order. Thus for example
%   \begin{verbatim}
%     \str_if_eq_p:no { abc } { \tl_to_str:n { abc } }
%   \end{verbatim}
%   is logically \texttt{true}.
% \end{function}
%
% \begin{function}[EXP,pTF, added = 2012-06-05]{\str_if_eq_x:nn}
%   \begin{syntax}
%     \cs{str_if_eq_x_p:nn} \Arg{tl_1} \Arg{tl_2}
%     \cs{str_if_eq_x:nnTF} \Arg{tl_1} \Arg{tl_2} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Compares the full expansion of two \meta{token lists} on a character by
%   character basis, and is \texttt{true} if the two lists contain the same
%   characters in the same order. Thus for example
%   \begin{verbatim}
%     \str_if_eq_x_p:nn { abc } { \tl_to_str:n { abc } }
%   \end{verbatim}
%   is logically \texttt{true}.
% \end{function}
%
% \begin{function}[added = 2012-06-03, EXP]{\str_case:nnn, \str_case:onn}
%   \begin{syntax}
%     \cs{str_case:nnn} \Arg{test string} \\
%     ~~|{| \\
%     ~~~~\Arg{string case1} \Arg{code case1} \\
%     ~~~~\Arg{string case2} \Arg{code case2} \\
%     ~~~~\ldots \\
%     ~~~~\Arg{string case$\sb{n}$} \Arg{code case$\sb{n}$} \\
%     ~~|}| \\
%     ~~\Arg{else case}
%   \end{syntax}
%   This function compares the \meta{test string} in turn with each
%   of the \meta{string cases}. If the two are equal (as described for
%   \cs{str_if_eq:nnTF} then the
%   associated \meta{code} is left in the input stream. If none of
%   the tests are \texttt{true} then the \texttt{else code} will be
%   left in the input stream.
% \end{function}
%
% \begin{function}[added = 2012-06-05, EXP]{\str_case_x:nnn}
%   \begin{syntax}
%     \cs{str_case_x:nnn} \Arg{test string} \\
%     ~~|{| \\
%     ~~~~\Arg{string case1} \Arg{code case1} \\
%     ~~~~\Arg{string case2} \Arg{code case2} \\
%     ~~~~\ldots \\
%     ~~~~\Arg{string case$\sb{n}$} \Arg{code case$\sb{n}$} \\
%     ~~|}| \\
%     ~~\Arg{else case}
%   \end{syntax}
%   This function compares the full expansion of the \meta{test string}
%   in turn with the full expansion of the \meta{string cases}. If the two
%   full expansions are equal (as described for \cs{str_if_eq:nnTF} then the
%   associated \meta{code} is left in the input stream. If none of the tests
%   are \texttt{true} then the \texttt{else code} will be left in the input
%   stream. The \meta{test string} is expanded in each comparison, and must
%   always yield the same result: for example, random numbers must
%   not be used within this string.
% \end{function}
%
% \section{Viewing strings}
%
% \begin{function}{\str_show:N, \str_show:c, \str_show:n}
%   \begin{syntax}
%     \cs{str_show:N} \meta{tl~var}
%   \end{syntax}
%   Displays the content of the \meta{str~var} on the terminal.
% \end{function}
%
% \section{Scratch strings}
%
% \begin{variable}{\l_tmpa_str, \l_tmpb_str}
%   Scratch strings for local assignment. These are never used by
%   the kernel code, and so are safe for use with any \LaTeX3-defined
%   function. However, they may be overwritten by other non-kernel
%   code and so should only be used for short-term storage.
% \end{variable}
%
% \begin{variable}{\g_tmpa_str, \g_tmpb_str}
%   Scratch strings for global assignment. These are never used by
%   the kernel code, and so are safe for use with any \LaTeX3-defined
%   function. However, they may be overwritten by other non-kernel
%   code and so should only be used for short-term storage.
% \end{variable}
%
% \section{Possibilities, and things to do}
%
% Other string tasks.
% \begin{itemize}
%   \item Expandable \cs{str_if_in:nnTF}?
%   \item \cs{str_if_head_eq:nN}
%   \item \cs{str_if_numeric/decimal/integer:n}, perhaps in \pkg{l3fp}?
%   \item Should \cs{str_item:Nn} be \cs{str_char:Nn}?
%   \item Should \cs{str_substr:Nnn} be \cs{str_range:Nnn}?
%   \item Introduce \cs{str_slice:Nnnn} with a third \enquote{step}
%     argument?  Or should we simply have \cs{str_slice:Nn}
%     \meta{string} \Arg{clist}, where the \meta{clist}'s items are
%     either one integer expression, two integer expressions separated
%     by |:|, or three integer expressions separated by |:|, \emph{cf.}
%     Python's extended slice syntax?
%   \item Analog of \texttt{printf}?
% \end{itemize}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3str} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=str>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%    \end{macrocode}
%
% The following string-related functions are currently defined in
% \pkg{l3kernel}.
% \begin{itemize}
%   \item \cs{str_if_eq:nn}[pTF] and variants,
%   \item \cs{str_if_eq_x_return:on}, \cs{str_if_eq_x_return:nn}
%   \item \cs{tl_to_str:n}, \cs{tl_to_str:N}, \cs{tl_to_str:c},
%   \item \cs{token_to_str:N}, \cs{cs_to_str:N}
%   \item \cs{str_head:n}, \cs{__str_head:w}, (copied here)
%   \item \cs{str_tail:n}, \cs{__str_tail:w}, (copied here)
%   \item \cs{__str_count_ignore_spaces} (unchanged)
%   \item \cs{__str_count_loop:NNNNNNNNN} (unchanged)
% \end{itemize}
%
% \subsection{Helpers}
%
% \subsubsection{Assigning strings}
%
% \begin{macro}{\str_new:N, \str_new:c}
%   A string is simply a token list.
%    \begin{macrocode}
\cs_new_eq:NN \str_new:N \tl_new:N
\cs_generate_variant:Nn \str_new:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \str_set:Nn, \str_set:Nx,
%     \str_set:cn, \str_set:cx,
%     \str_gset:Nn, \str_gset:Nx,
%     \str_gset:cn, \str_gset:cx,
%     \str_const:Nn, \str_const:Nx,
%     \str_const:cn, \str_const:cx,
%     \str_put_left:Nn, \str_put_left:Nx,
%     \str_put_left:cn, \str_put_left:cx,
%     \str_gput_left:Nn, \str_gput_left:Nx,
%     \str_gput_left:cn, \str_gput_left:cx,
%     \str_put_right:Nn, \str_put_right:Nx,
%     \str_put_right:cn, \str_put_right:cx,
%     \str_gput_right:Nn, \str_gput_right:Nx,
%     \str_gput_right:cn, \str_gput_right:cx,
%   }
%   Simply convert the token list inputs to \meta{strings}.
%    \begin{macrocode}
\tl_map_inline:nn
  {
    { set }
    { gset }
    { const }
    { put_left }
    { gput_left }
    { put_right }
    { gput_right }
  }
  {
    \cs_new_protected:cpx { str_ #1 :Nn } ##1##2
      { \exp_not:c { tl_ #1 :Nx } ##1 { \exp_not:N \tl_to_str:n {##2} } }
    \exp_args:Nc \cs_generate_variant:Nn { str_ #1 :Nn } { Nx , cn , cx }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Variables and constants}
%
% \begin{variable}
%   {
%     \c_backslash_str,
%     \c_lbrace_str,
%     \c_rbrace_str,
%     \c_hash_str,
%     \c_tilde_str,
%     \c_percent_str
%   }
%   For all of those strings, use \cs{cs_to_str:N} to get characters with
%   the correct category code.
%    \begin{macrocode}
\tl_const:Nx \c_backslash_str { \cs_to_str:N \\ }
\tl_const:Nx \c_lbrace_str    { \cs_to_str:N \{ }
\tl_const:Nx \c_rbrace_str    { \cs_to_str:N \} }
\tl_const:Nx \c_hash_str      { \cs_to_str:N \# }
\tl_const:Nx \c_tilde_str     { \cs_to_str:N \~ }
\tl_const:Nx \c_percent_str   { \cs_to_str:N \% }
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{Escaping spaces}
%
% \begin{macro}[EXP]{\@@_to_other:n}
% \begin{macro}[EXP, aux]{\@@_to_other_loop:w, \@@_to_other_end:w}
%   \begin{syntax}
%     \cs{@@_to_other:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{other string}, where
%   spaces have category code \enquote{other}.  First apply
%   \cs{tl_to_str:n}, then replace all spaces by \enquote{other} spaces,
%   $8$ at a time, storing the converted part of the string between the
%   \cs{q_mark} and \cs{q_stop} markers.  This function can be
%   \texttt{f}-expanded without fear of losing a leading space, since
%   spaces do not have category code $10$ in its result.  This function
%   takes a time quadratic in the token count of the string.  There
%   exist non-expandable ways to reach linear time.
%    \begin{macrocode}
\group_begin:
\char_set_lccode:nn { `\* } { `\  }
\char_set_lccode:nn { `\A } { `\A }
\tl_to_lowercase:n
  {
    \group_end:
    \cs_new:Npn \@@_to_other:n #1
      {
        \exp_after:wN \@@_to_other_loop:w \tl_to_str:n {#1} ~ %
        A ~ A ~ A ~ A ~ A ~ A ~ A ~ A ~ \q_mark \q_stop
      }
    \cs_new:Npn \@@_to_other_loop:w
      #1 ~ #2 ~ #3 ~ #4 ~ #5 ~ #6 ~ #7 ~ #8 ~ #9 \q_stop
      {
        \if_meaning:w A #8
          \@@_to_other_end:w
        \fi:
        \@@_to_other_loop:w
        #9 #1 * #2 * #3 * #4 * #5 * #6 * #7 * #8 * \q_stop
      }
    \cs_new:Npn \@@_to_other_end:w \fi: #1 \q_mark #2 * A #3 \q_stop
      { \fi: #2 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Characters given by their position}
%
% \begin{macro}[EXP]{\str_count_spaces:N}
% \begin{macro}[EXP]{\str_count_spaces:n}
% \begin{macro}[EXP,aux]{\@@_count_spaces_loop:wwwwwwwww}
%   To speed up this function, we grab $9$ spaces in each step.  The
%   loop stops when the last argument is one of the trailing
%   |X|\meta{number}, and that \meta{number} is added to the sum of $9$
%   that preceeds, to adjust the result.
%    \begin{macrocode}
\cs_new:Npn \str_count_spaces:N
  { \exp_args:No \str_count_spaces:n }
\cs_new:Npn \str_count_spaces:n #1
  {
    \int_eval:n
      {
        \exp_after:wN \@@_count_spaces_loop:wwwwwwwww
        \tl_to_str:n {#1} ~
        X 7 ~ X 6 ~ X 5 ~ X 4 ~ X 3 ~ X 2 ~ X 1 ~ X 0 ~ X -1 ~
        \q_stop
      }
  }
\cs_new:Npn \@@_count_spaces_loop:wwwwwwwww #1~#2~#3~#4~#5~#6~#7~#8~#9~
  {
    \if_meaning:w X #9
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi:
    \c_nine + \@@_count_spaces_loop:wwwwwwwww
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_count:N}
% \begin{macro}[EXP]{\str_count:n}
% \begin{macro}[EXP]{\@@_count_unsafe:n}
% \begin{macro}[EXP]{\str_count_ignore_spaces:n}
% \begin{macro}[EXP,aux]{\@@_count:n, \@@_count_loop:NNNNNNNNN}
%   To measure the token count of a string we could first escape all spaces
%   using \cs{@@_to_other:o}, then measure the count of this token
%   list. However, this would be quadratic in the length of the string,
%   and we can do better. Namely, add the number of spaces (counted
%   using the functions defined above) to the length ignoring spaces.
%   To measure the length ignoring spaces we use the same technique as
%   for counting spaces: loop, grabbing $9$ characters at each step, and
%   end as soon as we reach one of the $9$ trailing items.  The
%   \texttt{_unsafe} variant expects a token list consisting entirely of
%   category code $12$ characters.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_count:N { \exp_args:No \str_count:n }
\cs_new:Npn \str_count:n #1
  {
    \@@_count:n
      {
        \str_count_spaces:n {#1}
        + \exp_after:wN \@@_count_loop:NNNNNNNNN \tl_to_str:n {#1}
      }
  }
\cs_new:Npn \@@_count_unsafe:n #1
  {
    \@@_count:n
      { \@@_count_loop:NNNNNNNNN #1 }
  }
\cs_new:Npn \str_count_ignore_spaces:n #1
  {
    \@@_count:n
      { \exp_after:wN \@@_count_loop:NNNNNNNNN \tl_to_str:n {#1} }
  }
\cs_new:Npn \@@_count:n #1
  {
    \int_eval:n
      {
        #1
        { X \c_eight } { X \c_seven } { X \c_six   }
        { X \c_five  } { X \c_four  } { X \c_three }
        { X \c_two   } { X \c_one   } { X \c_zero  }
        \q_stop
      }
  }
\cs_set:Npn \@@_count_loop:NNNNNNNNN #1#2#3#4#5#6#7#8#9
  {
    \if_meaning:w X #9
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi:
    \c_nine + \@@_count_loop:NNNNNNNNN
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_head:N}
% \begin{macro}[EXP]{\str_head:n}
% \begin{macro}[EXP]{\str_head_ignore_spaces:n}
% \begin{macro}[EXP,aux]{\@@_head:w}
%   The \texttt{_ignore_spaces} variant is almost identical to
%   \cs{tl_head:n}.  As usual, \cs{str_head:N} expands its argument and
%   hands it to \cs{str_head:n}. To circumvent the fact that \TeX{}
%   skips spaces when grabbing undelimited macro parameters,
%   \cs{@@_head:w} takes an argument delimited by a space. If |#1|
%   starts with a non-space character, \cs{use_i_delimit_by_q_stop:nw}
%   leaves that in the input stream. On the other hand, if |#1| starts
%   with a space, the \cs{@@_head:w} takes an empty argument, and
%   the single (braced) space in the definition of \cs{@@_head:w}
%   makes its way to the output. Finally, for an empty argument, the
%   (braced) empty brace group in the definition of \cs{str_head:n}
%   gives an empty result after passing through
%   \cs{use_i_delimit_by_q_stop:nw}.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_head:N { \exp_args:No \str_head:n }
\cs_set:Npn \str_head:n #1
  {
    \exp_after:wN \@@_head:w
    \tl_to_str:n {#1}
    { { } } ~ \q_stop
  }
\cs_set:Npn \@@_head:w #1 ~ %
  { \use_i_delimit_by_q_stop:nw #1 { ~ } }
\cs_new:Npn \str_head_ignore_spaces:n #1
  {
    \exp_after:wN \use_i_delimit_by_q_stop:nw
    \tl_to_str:n {#1} { } \q_stop
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_tail:N}
% \begin{macro}[EXP]{\str_tail:n}
% \begin{macro}[EXP]{\str_tail_ignore_spaces:n}
% \begin{macro}[EXP,aux]{\@@_tail_auxi:w}
% \begin{macro}[EXP,aux]{\@@_tail_auxii:w}
%   As when fetching the head of a string, the \texttt{_ignore_spaces}
%   variant is similar to \cs{tl_tail:n}.  The more commonly used
%   \cs{str_tail:n} function is a little bit more convoluted: hitting
%   the front of the string with \cs{reverse_if:N} \cs{if_charcode:w}
%   \cs{scan_stop:} removes the first character (which necessarily makes
%   the test true, since it cannot match \cs{scan_stop:}). The auxiliary
%   function inserts the required \cs{fi:} to close the conditional, and
%   leaves the tail of the string in the input string. The details are
%   such that an empty string has an empty tail.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_tail:N { \exp_args:No \str_tail:n }
\cs_set:Npn \str_tail:n #1
  {
    \exp_after:wN \@@_tail_auxi:w
    \reverse_if:N \if_charcode:w
        \scan_stop: \tl_to_str:n {#1} X X \q_stop
  }
\cs_set:Npn \@@_tail_auxi:w #1 X #2 \q_stop { \fi: #1 }
\cs_new:Npn \str_tail_ignore_spaces:n #1
  {
    \exp_after:wN \@@_tail_auxii:w
    \tl_to_str:n {#1} X X \q_stop
  }
\cs_new:Npn \@@_tail_auxii:w #1 #2 X #3 \q_stop { #2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP, int]{\@@_skip_c_zero:w}
% \begin{macro}[EXP, aux]{\@@_skip_loop:wNNNNNNNN}
% \begin{macro}[EXP, aux]{\@@_skip_end:w, \@@_skip_end:NNNNNNNN}
%   Removes |max(#1,0)| characters from the input stream, and then
%   leaves \cs{c_zero}. This should be expanded using
%   \cs{tex_romannumeral:D}.  We remove characters $8$ at a time until
%   there are at most $8$ to remove. Then we do a dirty trick: the
%   \cs{if_case:w} construction leaves between $0$ and $8$ times the
%   \cs{or:} control sequence, and those \cs{or:} become arguments of
%   \cs{@@_skip_end:NNNNNNNN}. If the number of characters to remove
%   is $6$, say, then there are two \cs{or:} left, and the $8$ arguments
%   of \cs{@@_skip_end:NNNNNNNN} are the two \cs{or:}, and $6$
%   characters from the input stream, exactly what we wanted to
%   remove. Then close the \cs{if_case:w} conditional with \cs{fi:}, and
%   stop the initial expansion with \cs{c_zero} (see places where
%   \cs{@@_skip_c_zero:w} is called).
%    \begin{macrocode}
\cs_new:Npn \@@_skip_c_zero:w #1;
  {
    \if_int_compare:w \__int_eval:w #1 > \c_eight
      \exp_after:wN \@@_skip_loop:wNNNNNNNN
    \else:
      \exp_after:wN \@@_skip_end:w
      \int_use:N \__int_eval:w
    \fi:
    #1 ;
  }
\cs_new:Npn \@@_skip_loop:wNNNNNNNN #1; #2#3#4#5#6#7#8#9
  { \exp_after:wN \@@_skip_c_zero:w \int_use:N \__int_eval:w #1 - \c_eight ; }
\cs_new:Npn \@@_skip_end:w #1 ;
  {
    \exp_after:wN \@@_skip_end:NNNNNNNN
    \if_case:w \if_int_compare:w #1 > \c_zero #1 \else: 0 \fi: \exp_stop_f:
    \or: \or: \or: \or: \or: \or: \or: \or:
  }
\cs_new:Npn \@@_skip_end:NNNNNNNN #1#2#3#4#5#6#7#8 { \fi: \c_zero }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,int]{\@@_collect_delimit_by_q_stop:w}
% \begin{macro}[EXP,aux]{\@@_collect_loop:wn, \@@_collect_loop:wnNNNNNNN}
% \begin{macro}[EXP,aux]
%   {\@@_collect_end:wn, \@@_collect_end:nnnnnnnnw} Collects
%   |max(#1,0)| characters, and removes everything else until
%   \cs{q_stop}. This is somewhat similar to \cs{@@_skip_c_zero:w}, but
%   this time we can only grab $7$ characters at a time.  At the end, we
%   use an \cs{if_case:w} trick again, so that the $8$ first arguments
%   of \cs{@@_collect_end:nnnnnnnnw} are some \cs{or:}, followed by
%   an \cs{fi:}, followed by |#1| characters from the input
%   stream. Simply leaving this in the input stream will close the
%   conditional properly and the \cs{or:} disappear.
%    \begin{macrocode}
\cs_new:Npn \@@_collect_delimit_by_q_stop:w #1;
  {
    \exp_after:wN \@@_collect_loop:wn
    \int_use:N \__int_eval:w #1 ;
    { }
  }
\cs_new:Npn \@@_collect_loop:wn #1 ;
  {
    \if_int_compare:w #1 > \c_seven
      \exp_after:wN \@@_collect_loop:wnNNNNNNN
    \else:
      \exp_after:wN \@@_collect_end:wn
    \fi:
    #1 ;
  }
\cs_new:Npn \@@_collect_loop:wnNNNNNNN #1; #2 #3#4#5#6#7#8#9
  {
    \exp_after:wN \@@_collect_loop:wn
    \int_use:N \__int_eval:w #1 - \c_seven ;
    { #2 #3#4#5#6#7#8#9 }
  }
\cs_new:Npn \@@_collect_end:wn #1 ;
  {
    \exp_after:wN \@@_collect_end:nnnnnnnnw
    \if_case:w \if_int_compare:w #1 > \c_zero #1 \else: 0 \fi: \exp_stop_f:
    \or: \or: \or: \or: \or: \or: \fi:
  }
\cs_new:Npn \@@_collect_end:nnnnnnnnw #1#2#3#4#5#6#7#8 #9 \q_stop
  { #1#2#3#4#5#6#7#8 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_item:Nn}
% \begin{macro}[EXP]{\str_item:nn}
% \begin{macro}[EXP]{\str_item_ignore_spaces:nn}
% \begin{macro}[EXP]{\@@_item_unsafe:nn}
% \begin{macro}[EXP,aux]{\@@_item:ww}
%   This is mostly shuffling arguments around to avoid measuring the
%   length of the string more than once, and make sure that the
%   parameters given to \cs{@@_skip_c_zero:w} are necessarily within
%   the bounds of the length of the string.  The \texttt{_ignore_spaces}
%   function cheats a little bit in that it doesn't hand to
%   \cs{@@_item_unsafe:nn} an \enquote{other string}. This is alright,
%   as everything else is done with undelimited arguments.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_item:Nn { \exp_args:No \str_item:nn }
\cs_new:Npn \str_item:nn #1#2
  {
    \exp_args:Nf \tl_to_str:n
      {
        \exp_args:Nf \@@_item_unsafe:nn
          { \@@_to_other:n {#1} } {#2}
      }
  }
\cs_new:Npn \str_item_ignore_spaces:nn #1
  { \exp_args:No \@@_item_unsafe:nn { \tl_to_str:n {#1} } }
\cs_new:Npn \@@_item_unsafe:nn #1#2
  {
    \exp_after:wN \@@_item:ww
    \int_use:N \__int_eval:w #2 \exp_after:wN ;
    \__int_value:w \@@_count_unsafe:n {#1} ;
      { } #1
    \q_stop
  }
\cs_new:Npn \@@_item:ww #1; #2;
  {
    \int_compare:nNnTF {#1} < \c_zero
      {
        \int_compare:nNnTF {#1} < {-#2}
          { \use_none_delimit_by_q_stop:w }
          {
            \exp_after:wN \use_i_delimit_by_q_stop:nw
            \tex_romannumeral:D \@@_skip_c_zero:w #1 + #2 + \c_one ;
          }
      }
      {
        \int_compare:nNnTF {#1} > {#2}
          { \use_none_delimit_by_q_stop:w }
          {
            \exp_after:wN \use_i_delimit_by_q_stop:nw
            \tex_romannumeral:D \@@_skip_c_zero:w #1 ;
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_substr:Nnn}
% \begin{macro}[EXP]{\str_substr:nnn}
% \begin{macro}[EXP]{\str_substr_ignore_spaces:nnn}
% \begin{macro}[EXP,aux]
%   {
%     \@@_substr_unsafe:nnn,
%     \@@_substr:www,
%     \@@_substr:nnw,
%     \@@_substr_normalize_range:nn
%   }
%   Sanitize the string. Then evaluate the arguments, replacing them by
%   \cs{c_zero} if they are empty.  Then limit the range to be at most
%   the length of the string (this avoids needing to check for the end
%   of the string when grabbing characters).  Afterwards, skip
%   characters, then keep some more, and finally drop the end of the
%   string.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_substr:Nnn { \exp_args:No \str_substr:nnn }
\cs_new:Npn \str_substr:nnn #1#2#3
  {
    \exp_args:Nf \tl_to_str:n
      {
        \exp_args:Nf \@@_substr_unsafe:nnn
          { \@@_to_other:n {#1} } {#2} {#3}
      }
  }
\cs_new:Npn \str_substr_ignore_spaces:nnn #1
  { \exp_args:No \@@_substr_unsafe:nnn { \tl_to_str:n {#1} } }
\cs_new:Npn \@@_substr_unsafe:nnn #1#2#3
  {
    \exp_after:wN \@@_substr:www
    \__int_value:w \@@_count_unsafe:n {#1} \exp_after:wN ;
    \int_use:N \__int_eval:w #2 + \c_zero \exp_after:wN ;
    \int_use:N \__int_eval:w #3 + \c_zero ;
    #1 \q_stop
  }
\cs_new:Npn \@@_substr:www #1; #2; #3;
  {
    \exp_args:Nf \@@_substr:nnw
      {
        \exp_args:Nf \@@_substr_normalize_range:nn
          {
            \int_eval:n
              { #2 + \if_int_compare:w #2 < \c_zero #1 \else: - 1 \fi: }
          }
          {#1}
      }
      {
        \exp_args:Nf \@@_substr_normalize_range:nn
          {
            \int_eval:n
              { #3 \if_int_compare:w #3 < \c_one + #1 + \c_one \fi: }
          }
          {#1}
      }
  }
\cs_new:Npn \@@_substr:nnw #1#2
  {
    \exp_after:wN \@@_collect_delimit_by_q_stop:w
    \int_use:N \__int_eval:w #2 - #1 \exp_after:wN ;
    \tex_romannumeral:D \@@_skip_c_zero:w #1 ;
  }
\cs_new:Npn \@@_substr_normalize_range:nn #1#2
  {
    \int_eval:n
      {
        \if_int_compare:w #1 < #2 \exp_stop_f:
          \if_int_compare:w #1 < \c_zero
            \c_zero
          \else:
            #1
          \fi:
        \else:
          #2
        \fi:
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{String conditionals}
%
% \begin{macro}[EXP,pTF]{\str_if_eq:NN}
% \begin{macro}[EXP,pTF]{\str_if_eq:nn,\str_if_eq_x:nn}
%   Note that \cs{str_if_eq:NN} is different from
%   \cs{tl_if_eq:NN} because it needs to ignore category codes.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_if_eq:NN #1#2 { p , TF , T , F }
  {
    \if_int_compare:w \pdftex_strcmp:D { \tl_to_str:N #1 } { \tl_to_str:N #2 }
      = \c_zero \prg_return_true: \else: \prg_return_false: \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\str_case:nnn, \str_case:onn, \str_case_x:nnn}
%   Defined in \pkg{l3basics} at present.
% \end{macro}
%
% \subsection{Viewing strings}
%
% \begin{macro}{\str_show:n, \str_show:N, \str_show:c}
%   Displays a string on the terminal.
%    \begin{macrocode}
\cs_new_eq:NN \str_show:n \tl_show:n
\cs_new_eq:NN \str_show:N \tl_show:N
\cs_generate_variant:Nn \str_show:N { c }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Deprecated string functions}
%
% Deprecated 2012-05-13 for removal by 2012-08-31.
%
% \begin{macro}{\str_length:N, \str_length:n, \str_length_ignore_spaces:n}
%    \begin{macrocode}
\cs_new_eq:NN \str_length:N \str_count:N
\cs_new_eq:NN \str_length:n \str_count:n
\cs_new_eq:NN \str_length_ignore_spaces:n \str_count_ignore_spaces:n
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
