% \iffalse meta-comment
%
%% File: l3str-format.dtx Copyright (C) 2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3experimental bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id: l3str-format.dtx 3940 2012-07-09 00:41:44Z bruno $
  {L3 Experimental string formatting}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \tableofcontents
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \title{^^A
%   The \textsf{l3str-format} package: formatting strings of characters^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{Format specifications}
%
% In this module, we introduce the notion of a string \meta{format}.
% The syntax follows that of Python's \texttt{format} built-in function.
% A \meta{format specification} is a string of the form
% \begin{equation*}
%   \meta{format specification} = [[\meta{fill}]\meta{alignment}]
%     [\meta{sign}] [\meta{width}] [.\meta{precision}] [\meta{style}]
% \end{equation*}
% where each $[\ldots]$ denotes an independent optional part.
% \begin{itemize}
%   \item \meta{fill} can be any character: it is assumed to be present
%     whenever the second character of the \meta{format specification}
%     is a valid \meta{alignment} character.
%   \item \meta{alignment} can be |<|~(left alignment), |>|~(right
%     alignment), |^|~(centering), or |=|~(for numeric types only).
%   \item \meta{sign} is allowed for numeric types; it can be |+|~(show
%     a sign for positive and negative numbers), |-|~(only put a sign
%     for negative numbers), or a space~(show a space or a~|-|).
%   \item \meta{width} is the minimum number of characters of the
%     result: if the result is naturally shorter than this \meta{width},
%     then it is padded with copies of the character \meta{fill}, with a
%     position depending on the choice of \meta{alignment}.  If the
%     result is naturally longer, it is not truncated.
%   \item \meta{precision}, whose presence is indicated by a period,
%     can have different meanings depending on the type.
%   \item \meta{style} is one character, which controls how the given
%     data should be formatted.  The list of allowed \meta{styles}
%     depends on the type.
% \end{itemize}
% The choice of \meta{alignment} |=| is not implemented yet.
%
% \section{Formatting various data-types}
%
% \begin{function}[EXP]{\tl_format:Nn, \tl_format:cn, \tl_format:nn}
%   \begin{syntax}
%     \cs{tl_format:nn} \Arg{token list} \Arg{format specification}
%   \end{syntax}
%   Converts the \meta{token list} to a string according to the
%   \meta{format specification}.  The \meta{style}, if present, must
%   be~|s|.  If \meta{precision} is given, all characters of the string
%   representation of the \meta{token list} beyond the first
%   \meta{precision} characters are discared.
% \end{function}
%
% \begin{function}[EXP]{\seq_format:Nn, \seq_format:cn}
%   \begin{syntax}
%     \cs{seq_format:Nn} \Arg{sequence} \Arg{format specification}
%   \end{syntax}
%   Converts each item in the \meta{sequence} to a string according to
%   the \meta{format specification}, and concatenates the results.
% \end{function}
%
% \begin{function}[EXP]{\int_format:Nn, \int_format:cn, \int_format:nn}
%   \begin{syntax}
%     \cs{int_format:nn} \Arg{integer expression} \Arg{format specification}
%   \end{syntax}
%   Evaluates the \meta{integer expression} and converts the result to a
%   string according to the \meta{format specification}.  The
%   \meta{precision} argument is not allowed.  The \meta{style} can be
%   |b| for binary output, |d| for decimal output (this is the default),
%   |o| for octal output, |X| for hexadecimal output (using capital
%   letters).
% \end{function}
%
% \section{Possibilities, and things to do}
%
% \begin{itemize}
%   \item Provide a token list formatting \meta{style} which keeps the
%     last \meta{precision} characters rather than the first
%     \meta{precision}.
% \end{itemize}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3str-format} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=str>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\RequirePackage{l3str}
%    \end{macrocode}
%
% \subsection{Helpers}
%
% \begin{macro}[aux, EXP]{\use:nf, \use:fnf}
%   A simple variant.
%    \begin{macrocode}
\cs_generate_variant:Nn \use:nn { nf }
\cs_generate_variant:Nn \use:nnn { fnf }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\tl_to_str:f}
%   A simple variant.
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_to_str:n { f }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_if_digit:NTF}
%   Here we expect |#1| to be a character with category other, or
%   \cs{s__stop}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_format_if_digit:N #1 { TF }
  {
    \if_int_compare:w \c_nine < 1 #1 \exp_stop_f:
      \prg_return_true: \else: \prg_return_false: \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_put:nw, \@@_format_put:ow}
%   Put |#1| after an \cs{s__stop} delimiter.
%    \begin{macrocode}
\cs_new:Npn \@@_format_put:nw #1 #2 \s__stop { #2 \s__stop #1 }
\cs_generate_variant:Nn \@@_format_put:nw { o }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Parsing a format specification}
%
% \begin{macro}[aux, EXP]{\@@_format_parse:n}
% \begin{macro}[aux, EXP]
%   {
%     \@@_format_parse_i:NN,
%     \@@_format_parse_ii:nN,
%     \@@_format_parse_iii:nN,
%     \@@_format_parse_iv:nwN,
%     \@@_format_parse_v:nN,
%     \@@_format_parse_vi:nwN,
%     \@@_format_parse_vii:nN,
%     \@@_format_parse_end:nwn,
%   }
%   The goal is to parse
%   \begin{equation*}
%     \meta{format specification} = [[\meta{fill}]\meta{alignment}]
%     [\meta{sign}] [\meta{width}] [.\meta{precision}] [\meta{style}]
%   \end{equation*}
%    \begin{macrocode}
\cs_new:Npn \@@_format_parse:n #1
  {
    \exp_last_unbraced:Nf \@@_format_parse_i:NN
      \@@_to_other:n {#1} \s__stop \s__stop {#1}
  }
\cs_new:Npx \@@_format_parse_i:NN #1#2
  {
    \exp_not:N \@@_if_contains_char:nNTF { < > = ^ } #2
      { \exp_not:N \@@_format_parse_iii:nN { #1 #2 } }
      {
        \exp_not:N \@@_format_parse_ii:nN
          { \c_catcode_other_space_tl } #1 #2
      }
  }
\cs_new:Npn \@@_format_parse_ii:nN #1#2
  {
    \@@_if_contains_char:nNTF { < > = ^ } #2
      { \@@_format_parse_iii:nN { #1 #2 } }
      { \@@_format_parse_iii:nN { #1 ? } #2 }
  }
\cs_new:Npx \@@_format_parse_iii:nN #1#2
  {
    \exp_not:N \@@_if_contains_char:nNTF
      { + - \c_catcode_other_space_tl }
      #2
      { \exp_not:N \@@_format_parse_iv:nwN { #1 #2 } ; }
      { \exp_not:N \@@_format_parse_iv:nwN { #1 ? } ; #2 }
  }
\cs_new:Npn \@@_format_parse_iv:nwN #1#2; #3
  {
    \@@_format_if_digit:NTF #3
      { \@@_format_parse_iv:nwN {#1} #2 #3 ; }
      { \@@_format_parse_v:nN { #1 {#2} } #3 }
  }
\cs_new:Npn \@@_format_parse_v:nN #1#2
  {
    \token_if_eq_charcode:NNTF . #2
      { \@@_format_parse_vi:nwN {#1} 0 ; }
      { \@@_format_parse_vii:nN { #1 { } } #2 }
  }
\cs_new:Npn \@@_format_parse_vi:nwN #1#2; #3
  {
    \@@_format_if_digit:NTF #3
      { \@@_format_parse_vi:nwN {#1} #2 #3 ; }
      { \@@_format_parse_vii:nN { #1 {#2} } #3 }
  }
\cs_new:Npn \@@_format_parse_vii:nN #1#2
  {
    \token_if_eq_meaning:NNTF \s__stop #2
      { \@@_format_parse_end:nwn { #1 ? } #2 }
      { \@@_format_parse_end:nwn { #1 #2 } }
  }
\cs_new:Npn \@@_format_parse_end:nwn #1 #2 \s__stop \s__stop #3
  {
    \tl_if_empty:nF {#2}
      { \__msg_kernel_expandable_error:nnn { str } { invalid-format } {#3} }
    #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Alignment}
%
% \begin{macro}[aux, EXP]{\@@_format_align_<:nnN}
%   \begin{quote}
%     \cs{@@_format_align_<:nnN} \Arg{other string} \Arg{width}
%     \meta{fill}
%   \end{quote}
%   Aligning an \meta{other string} to the left entails appending |#3|
%   the correct number of times.  Then convert the result to a string.
%    \begin{macrocode}
\cs_new:cpn { @@_format_align_<:nnN } #1#2#3
  {
    \use:nf {#1}
      {
        \prg_replicate:nn
          { \int_max:nn { #2 - \@@_count_unsafe:n {#1} } { 0 } }
          {#3}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_align_>:nnN}
%   \begin{quote}
%     \cs{@@_format_align_>:nnN} \Arg{other string} \Arg{width}
%     \meta{fill}
%   \end{quote}
%   Aligning an \meta{other string} to the right entails prepending |#3|
%   the correct number of times.  Then convert the result to a string.
%    \begin{macrocode}
\cs_new:cpn { @@_format_align_>:nnN } #1#2#3
  {
    \prg_replicate:nn
      { \int_max:nn { #2 - \@@_count_unsafe:n {#1} } { 0 } }
      {#3}
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begingroup\catcode`\^=12
% \begin{macro}[aux, EXP]{\@@_format_align_^:nnN}
%   \begin{quote}
%     \cs{@@_format_align_^:nnN} \Arg{other string} \Arg{width}
%     \meta{fill}
%   \end{quote}
%   Centering an \meta{other string} entails prepending and appending
%   |#3| the correct number of times.  If the number of |#3| to be added
%   is odd, we add one more after than before.
%    \begin{macrocode}
\cs_new:cpn { @@_format_align_^:nnN } #1#2#3
  {
    \use:fnf
      {
        \prg_replicate:nn
          { \int_max:nn { #2 - \@@_count_unsafe:n {#1} - 1 } { 0 } / 2 }
          {#3}
      }
      {#1}
      {
        \prg_replicate:nn
          { \int_max:nn { #2 - \@@_count_unsafe:n {#1} } { 0 } / 2 }
          {#3}
      }
  }
%    \end{macrocode}
% \end{macro}
% \endgroup
%
% \subsection{Formatting token lists}
%
% \begin{macro}[EXP]{\tl_format:Nn, \tl_format:cn, \tl_format:nn}
%   Call \cs{@@_format_tl:NNNnnNn} to read the parsed \meta{format
%     specification}.  Then convert the result to a string.
%    \begin{macrocode}
\cs_new_nopar:Npn \tl_format:Nn { \exp_args:No \tl_format:nn }
\cs_generate_variant:Nn \tl_format:Nn { c }
\cs_new:Npn \tl_format:nn #1#2
  {
    \tl_to_str:f
      {
        \exp_last_unbraced:Nf \@@_format_tl:NNNnnNn
          { \@@_format_parse:n {#2} }
          {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_tl:NNNnnNn}
%   \begin{quote}
%     \cs{@@_format_tl:NNNnnNn} \meta{fill} \meta{alignment} \meta{sign}
%     \Arg{width} \Arg{precision} \meta{style} \Arg{token list}
%   \end{quote}
%   First check that the \meta{alignment} is not |=|, and set the
%   default alignment |?| to |<|.  Place the modified information after
%   a trailing \cs{s__stop} for later retrieval.  Then check that there
%   was no \meta{sign}.  The width will be useful later, store it after
%   \cs{s__stop}.  Afterwards, check the \meta{precision}: if it is
%   empty, we will eventually use the whole string, otherwise we will
%   only use a substring, starting at the index $1$, and ending at |#5|.
%   There is a need to use the \enquote{unsafe} function, as otherwise
%   leading spaces would get stripped by |f|-expansion.  Finally, check
%   that the \meta{style} is |?| or |s|.
%    \begin{macrocode}
\cs_new:Npn \@@_format_tl:NNNnnNn #1#2#3#4#5#6
  {
    \token_if_eq_charcode:NNTF #2 =
      {
        \__msg_kernel_expandable_error:nnnn
          { str } { invalid-align-format } {#2} {tl}
        \@@_format_put:nw { #1 < }
      }
      {
        \token_if_eq_charcode:NNTF #2 ?
          { \@@_format_put:nw { #1 < } }
          { \@@_format_put:nw { #1 #2 } }
      }
    \token_if_eq_charcode:NNF #3 ?
      {
        \__msg_kernel_expandable_error:nnnn
          { str } { invalid-sign-format } {#3} {tl}
      }
    \@@_format_put:nw { {#4} }
    \tl_if_empty:nTF {#5}
      { \@@_format_put:nw { \use:n { } } }
      { \@@_format_put:nw { \@@_substr_unsafe:nnn { {1} {#5} } } }
    \token_if_eq_charcode:NNF #6 s
      {
        \token_if_eq_charcode:NNF #6 ?
          {
            \__msg_kernel_expandable_error:nnnn
              { str } { invalid-style-format } {#6} {tl}
          }
      }
    \@@_format_tl_s:NNnnNNn
    \s__stop
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_tl_s:NNnnNNn}
%   \begin{quote}
%     \cs{@@_format_tl_s:NNnnNNn} \cs{s__stop} \meta{function}
%     \Arg{arguments} \Arg{width} \meta{fill} \meta{alignment}
%     \Arg{token list}
%   \end{quote}
%   The \meta{function} and \meta{arguments} are built in such a way
%   that |f|-expanding \meta{function} \Arg{other string}
%   \meta{arguments} yields the piece of the \meta{other string} that we
%   want to output.  The \meta{other string} is built from the
%   \meta{token list} by |f|-expanding \cs{@@_to_other:n}.
%    \begin{macrocode}
\cs_new:Npn \@@_format_tl_s:NNnnNNn #1#2#3#4#5#6#7
  {
    \exp_args:Nc \exp_args:Nf
      { @@_format_align_#6:nnN }
      { \exp_args:Nf #2 { \@@_to_other:n {#7} } #3 }
      {#4} #5
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Formatting sequences}
%
% \begin{macro}[EXP]{\seq_format:Nn, \seq_format:cn}
%   Each item is formatted as a token list according to the
%   specification.  First parse the format and expand the sequence, then
%   loop through the items.  Eventually, convert to a string.
%    \begin{macrocode}
\cs_new:Npn \seq_format:Nn #1#2
  {
    \tl_to_str:f
      { \@@_format_seq:of {#1} { \@@_format_parse:n {#2} } }
  }
\cs_generate_variant:Nn \seq_format:Nn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_seq:nn, \@@_format_seq:of}
%   The first argument is the contents of a \texttt{seq} variable.  The
%   second is a parsed \meta{format specification}.  Set up the loop.
%    \begin{macrocode}
\cs_new:Npn \@@_format_seq:nn #1#2
  {
    \@@_format_seq_loop:nnNn { } {#2}
      #1
      { ? \@@_format_seq_end:w } { }
  }
\cs_generate_variant:Nn \@@_format_seq:nn { of }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_seq_loop:nnNn}
%   \begin{quote}
%     \cs{@@_format_seq_loop:nnNn} \Arg{done} \Arg{parsed format}
%     \cs{__seq_item:n} \Arg{item}
%   \end{quote}
%   The first argument is the result of formatting the items read so
%   far.  The third argument is a single token (\cs{__seq_item:n}),
%   until we reach the end of the sequence, where |\use_none:n #3| ends
%   the loop.
%    \begin{macrocode}
\cs_new:Npn \@@_format_seq_loop:nnNn #1#2#3#4
  {
    \use_none:n #3
    \exp_args:Nf \@@_format_seq_loop:nnNn
      { \use:nf {#1} { \@@_format_tl:NNNnnNn #2 {#4} } }
      {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_seq_end:w}
%   Pick the right piece in the loop above.
%    \begin{macrocode}
\cs_new:Npn \@@_format_seq_end:w #1#2#3#4 { \use_ii:nnn #3 }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Formatting integers}
%
% \begin{macro}[EXP]{\int_format:Nn, \int_format:cn, \int_format:nn}
%   Evalute the first argument and feed it to \cs{@@_format_int:nn}.
%    \begin{macrocode}
\cs_new:Npn \int_format:nn #1
  { \exp_args:Nf \@@_format_int:nn { \int_eval:n {#1} } }
\cs_new_nopar:Npn \int_format:Nn
  { \exp_args:NV \@@_format_int:nn }
\cs_generate_variant:Nn \int_format:Nn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_int:nn}
%   Parse the \meta{format specification} and feed it to
%   \cs{@@_format_int:NNNnnNn}.  Then convert the result to a string
%    \begin{macrocode}
\cs_new:Npn \@@_format_int:nn #1#2
  {
    \tl_to_str:f
      {
        \exp_last_unbraced:Nf \@@_format_int:NNNnnNn
          { \@@_format_parse:n {#2} }
          {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_int:NNNnnNn}
%   \begin{quote}
%     \cs{@@_format_int:NNNnnNn} \meta{fill} \meta{alignment}
%     \meta{sign} \Arg{width} \Arg{precision} \meta{style} \Arg{integer}
%   \end{quote}
%   First check that the \meta{alignment} is not |=|, and set the
%   default alignment |?| to |>|.  Place the modified information after
%   a trailing \cs{s__stop} for later retrieval.  Then check the
%   \meta{sign}: if the integer is negative, always put~|-|.  Otherwise,
%   if the format's \meta{sign} is |~|, put a space (with category
%   \enquote{other}); if it is~|+| put |+|; if it is |-| (default), put
%   nothing, represented as a brace group.  The width |#4| will be
%   useful later, store it after \cs{s__stop}.  Afterwards, check that
%   the \meta{precision} was absent.  Finally, dispatch depending on the
%   \meta{style}.
%    \begin{macrocode}
\cs_new:Npn \@@_format_int:NNNnnNn #1#2#3#4#5#6#7
  {
    \token_if_eq_charcode:NNTF #2 =
      {
        \__msg_kernel_expandable_error:nnnn
          { str } { invalid-align-format } {#2} {int}
        \@@_format_put:nw { #1 > }
      }
      {
        \token_if_eq_charcode:NNTF #2 ?
          { \@@_format_put:nw { #1 > } }
          { \@@_format_put:nw { #1 #2 } }
      }
    \int_compare:nNnTF {#7} < \c_zero
      { \@@_format_put:nw { - } }
      {
        \str_case:nnn {#3}
          {
            { ~ } { \@@_format_put:ow { \c_catcode_other_space_tl } }
            { + } { \@@_format_put:nw { + } }
          }
          { \@@_format_put:nw { { } } }
      }
    \@@_format_put:nw { {#4} }
    \tl_if_empty:nF {#5}
      {
        \__msg_kernel_expandable_error:nnnn
          { str } { invalid-precision-format } {#5} {int}
      }
    \str_case:nnn {#6}
      {
        { ? } { \@@_format_int:NwnnNNn \use:n }
        { d } { \@@_format_int:NwnnNNn \use:n }
        { b } { \@@_format_int:NwnnNNn \int_to_binary:n }
        { o } { \@@_format_int:NwnnNNn \int_to_octal:n }
        { X } { \@@_format_int:NwnnNNn \int_to_hexadecimal:n }
      }
      {
        \__msg_kernel_expandable_error:nnnn
          { str } { invalid-style-format } {#6} { int }
        \@@_format_int:NwnnNNn \use:n
      }
    \s__stop {#7}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_format_int:NwnnNNn}
%   \begin{quote}
%     \cs{@@_format_int:NwnnNNn} \meta{function} \cs{s__stop}
%     \Arg{width} \Arg{sign} \meta{fill} \meta{alignment} \Arg{integer}
%   \end{quote}
%   Use the |format_align| function corresponding to the
%   \meta{alignment}, with the following arguments:
%   \begin{itemize}
%     \item the string formed by combining the sign |#4| with the result
%       of converting the absolute value of the \meta{integer} |#7|
%       according to the conversion function |#1|;
%     \item the \meta{width};
%     \item the \meta{fill} character.
%   \end{itemize}
%    \begin{macrocode}
\cs_new:Npn \@@_format_int:NwnnNNn #1#2 \s__stop #3#4#5#6#7
  {
    \exp_args:Nc \exp_args:Nf
      { @@_format_align_#6:nnN }
      { \use:nf {#4} { #1 { \int_abs:n {#7} } } }
      {#3} #5
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
% All of the messages are produced expandably, so there is no need for
% an extra-text.
%    \begin{macrocode}
\__msg_kernel_new:nnn { str } { invalid-format }
  { Invalid~format~'#1'. }
\__msg_kernel_new:nnn { str } { invalid-align-format }
  { Invalid~alignment~'#1'~for~type~'#2'. }
\__msg_kernel_new:nnn { str } { invalid-sign-format }
  { Invalid~sign~'#1'~for~type~'#2'. }
\__msg_kernel_new:nnn { str } { invalid-precision-format }
  { Invalid~precision~'#1'~for~type~'#2'. }
\__msg_kernel_new:nnn { str } { invalid-style-format }
  { Invalid~style~'#1'~for~type~'#2'. }
%    \end{macrocode}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
