% \iffalse meta-comment
%
%% File: l3regex.dtx Copyright (C) 2011-2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3experimental bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental Regular Expressions}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{l3regex} package: regular expressions in \TeX{}^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
% \newenvironment{l3regex-syntax}
%   {\begin{itemize}\def\\{\char`\\}\def\makelabel##1{\hss\llap{\ttfamily##1}}}
%   {\end{itemize}}
%
% \section{\pkg{l3regex} documentation}
%
% The \pkg{l3regex} package provides regular expression testing,
% extraction of submatches, splitting, and replacement, all acting
% on token lists. The syntax of regular expressions is mostly a subset
% of the \textsc{pcre} syntax (and very close to \textsc{posix}),
% with some additions
% due to the fact that \TeX{} manipulates tokens rather than characters.
% For performance reasons, only a limited set of features are implemented.
% Notably, back-references are not supported.
%
% Let us give a few examples. After
% \begin{verbatim}
%   \tl_set:Nn \l_my_tl { That~cat. }
%   \regex_replace_once:nnN { at } { is } \l_my_tl
% \end{verbatim}
% the token list variable \cs{l_my_tl} holds the text
% \enquote{\texttt{This cat.}}, where the first
% occurrence of \enquote{\texttt{at}} was replaced
% by \enquote{\texttt{is}}. A more complicated example is
% a pattern to add a comma at the end of each word:
% \begin{verbatim}
%   \regex_replace_all:nnN { \w+ } { \0 , } \l_my_tl
% \end{verbatim}
% The |\w| sequence represents any \enquote{word} character,
% and |+| indicates that the |\w| sequence should be repeated
% as many times as possible (at least once), hence matching a word in the
% input token list. In the replacement text, |\0| denotes the full match
% (here, a word).
%
% If a regular expression is to be used several times,
% it can be compiled once, and stored in a regex
% variable using \cs{regex_const:Nn}. For example,
% \begin{verbatim}
%    \regex_const:Nn \c_foo_regex { \c{begin} \cB. (\c[^BE].*) \cE. }
% \end{verbatim}
% stores in \cs{c_foo_regex} a regular expression which matches the
% starting marker for an environment: \cs{begin}, followed by a
% begin-group token (|\cB.|), then any number of tokens which are
% neither begin-group nor end-group character tokens (|\c[^BE].*|),
% ending with an end-group token (|\cE.|). As explained in the next
% section, the parentheses \enquote{capture} the result of |\c[^BE].*|,
% giving us access to the name of the environment when doing
% replacements.
%
% \subsection{Syntax of regular expressions}
%
% Most characters match exactly themselves,
% with an arbitrary category code. Some characters are
% special and must be escaped with a backslash (\emph{e.g.}, |\*|
% matches a star character). Some escape sequences of
% the form backslash--letter also have a special meaning
% (for instance |\d| matches any digit). As a rule,
% \begin{itemize}
% \item every alphanumeric character (\texttt{A}--\texttt{Z},
%   \texttt{a}--\texttt{z}, \texttt{0}--\texttt{9}) matches
%   exactly itself, and should not be escaped, because
%   |\A|, |\B|, \ldots{} have special meanings;
% \item non-alphanumeric printable ascii characters can (and should)
%   always be escaped: many of them have special meanings (\emph{e.g.},
%   use |\(|, |\)|, |\?|, |\.|);
% \item spaces should always be escaped (even in character
%   classes);
% \item any other character may be escaped or not, without any
%   effect: both versions will match exactly that character.
% \end{itemize}
% Note that these rules play nicely with the fact that many
% non-alphanumeric characters are difficult to input into \TeX{}
% under normal category codes. For instance, |\\abc\%|
% matches the characters |\abc%| (with arbitrary category codes),
% but does not match the control sequence |\abc| followed by a
% percent character. Matching control sequences can be done
% using the |\c|\Arg{regex} syntax (see below).
%
% Any special character which appears at a place where its special
% behaviour cannot apply matches itself instead (for instance, a
% quantifier appearing at the beginning of a string), after raising a
% warning.
%
% Characters.
% \begin{l3regex-syntax}
%   \item[\\x\{hh\ldots{}\}] Character with hex code \texttt{hh\ldots{}}
%   \item[\\xhh] Character with hex code \texttt{hh}.
%   \item[\\a] Alarm (hex 07).
%   \item[\\e] Escape (hex 1B).
%   \item[\\f] Form-feed (hex 0C).
%   \item[\\n] New line (hex 0A).
%   \item[\\r] Carriage return (hex 0D).
%   \item[\\t] Horizontal tab (hex 09).
% \end{l3regex-syntax}
%
% Character types.
% \begin{l3regex-syntax}
%   \item[.] A single period matches any token.
%   \item[\\d] Any decimal digit.
%   \item[\\h] Any horizontal space character,
%     equivalent to |[\ \^^I]|: space and tab.
%   \item[\\s] Any space character,
%     equivalent to |[\ \^^I\^^J\^^L\^^M]|.
%   \item[\\v] Any vertical space character,
%     equivalent to |[\^^J\^^K\^^L\^^M]|. Note that |\^^K| is a vertical space,
%     but not a space, for compatibility with Perl.
%   \item[\\w] Any word character, \emph{i.e.},
%     alpha-numerics and underscore, equivalent to |[A-Za-z0-9\_]|.
%   \item[\\D] Any token not matched by |\d|.
%   \item[\\H] Any token not matched by |\h|.
%   \item[\\N] Any token other than the |\n| character (hex 0A).
%   \item[\\S] Any token not matched by |\s|.
%   \item[\\V] Any token not matched by |\v|.
%   \item[\\W] Any token not matched by |\w|.
%   \item[\\N] Any token not matched by |\n|.
% \end{l3regex-syntax}
% Of those, |.|, |\D|, |\H|, |\N|, |\S|, |\V|, and |\W| will match arbitrary
% control sequences.
%
% Character classes match exactly one character in the subject string.
% \begin{l3regex-syntax}
%   \item[{[\ldots{}]}] Positive character class.
%     Matches any of the specified tokens.
%   \item[{[\char`\^\ldots{}]}] Negative character class.
%     Matches any token other than the specified characters.
%   \item[{x-y}] Within a character class, this denotes a range (can be
%     used with escaped characters).
%   \item[{[:\meta{name}:]}] Within a character class (one more set of
%     brackets), this denotes the \textsc{posix} character class
%     \meta{name}, which can be \texttt{alnum}, \texttt{alpha},
%     \texttt{ascii}, \texttt{blank}, \texttt{cntrl}, \texttt{digit},
%     \texttt{graph}, \texttt{lower}, \texttt{print}, \texttt{punct},
%     \texttt{space}, \texttt{upper}, \texttt{word}, or \texttt{xdigit}.
%   \item[{[:\char`\^\meta{name}:]}] Negative \textsc{posix} character class.
% \end{l3regex-syntax}
% For instance, |[a-oq-z\cC.]| matches any lowercase latin letter
% except |p|, as well as control sequences (see below for a description
% of |\c|).
%
% Quantifiers (repetition).
% \begin{l3regex-syntax}
%   \item[?] $0$ or $1$, greedy.
%   \item[??] $0$ or $1$, lazy.
%   \item[*] $0$ or more, greedy.
%   \item[*?] $0$ or more, lazy.
%   \item[+] $1$ or more, greedy.
%   \item[+?] $1$ or more, lazy.
%   \item[\{$n$\}] Exactly $n$.
%   \item[\{$n,$\}] $n$ or more, greedy.
%   \item[\{$n,$\}?] $n$ or more, lazy.
%   \item[\{$n,m$\}] At least $n$, no more than $m$, greedy.
%   \item[\{$n,m$\}?] At least $n$, no more than $m$, lazy.
% \end{l3regex-syntax}
%
% Anchors and simple assertions.
% \begin{l3regex-syntax}
%   \item[\\b] Word boundary: either the previous token is matched by
%     |\w| and the next by |\W|, or the opposite. For this purpose,
%     the ends of the token list are considered as |\W|.
%   \item[\\B] Not a word boundary: between two |\w| tokens
%     or two |\W| tokens (including the boundary).
%   \item[\char`^ \textrm{or} \\A]
%     Start of the subject token list.
%   \item[\char`$\textrm{,} \\Z \textrm{or} \\z]
%     End of the subject token list.
%   \item[\\G] Start of the current match. This is only different from |^|
%     in the case of multiple matches: for instance
%     |\regex_count:nnN { \G a } { aaba } \l_tmpa_int| yields $2$, but
%     replacing |\G| by |^| would result in \cs{l_tmpa_int} holding the
%     value $1$.
% \end{l3regex-syntax}
%
% Alternation and capturing groups.
% \begin{l3regex-syntax}
%   \item[A\char`|B\char`|C] Either one of \texttt{A}, \texttt{B},
%     or \texttt{C}.
%   \item[(\ldots{})] Capturing group.
%   \item[(?:\ldots{})] Non-capturing group.
%   \item[(?\char`|\ldots{})] Non-capturing group which resets
%     the group number for capturing groups in each alternative.
%     The following group will be numbered with the first unused
%     group number.
% \end{l3regex-syntax}
%
% The |\c| escape sequence allows to test the category code of tokens,
% and match control sequences. Each character category is represented
% by a single uppercase letter:
% \begin{itemize}
% \item |C| for control sequences;
% \item |B| for begin-group tokens;
% \item |E| for end-group tokens;
% \item |M| for math shift;
% \item |T| for alignment tab tokens;
% \item |P| for macro parameter tokens;
% \item |U| for superscript tokens (up);
% \item |D| for subscript tokens (down);
% \item |S| for spaces;
% \item |L| for letters;
% \item |O| for others; and
% \item |A| for active characters.
% \end{itemize}
% The |\c| escape sequence is used as follows.
% \begin{l3regex-syntax}
%   \item[\\c\Arg{regex}] A control sequence whose csname matches the
%     \meta{regex}, anchored at the beginning and end, so that |\c{begin}|
%     matches exactly \cs{begin}, and nothing else.
%   \item[\\cX] Applies to the next object, which can be a character,
%     character property, class, or group, and forces this object to
%     only match tokens with category |X| (any of |CBEMTPUDSLOA|. For
%     instance, |\cL[A-Z\d]| matches uppercase letters and digits of
%     category code letter, |\cC.| matches any control sequence, and
%     |\cO(abc)| matches |abc| where each character has category other.
%   \item[{\\c[XYZ]}] Applies to the next object, and forces it to only
%     match tokens with category |X|, |Y|, or |Z| (each being any of
%     |CBEMTPUDSLOA|). For instance, |\c[LSO](..)| matches two tokens of
%     category letter, space, or other.
%   \item[{\\c[\char`\^XYZ]}] Applies to the next object and prevents it
%     from matching any token with category |X|, |Y|, or |Z| (each being
%     any of |CBEMTPUDSLOA|). For instance, |\c[^O]\d| matches digits
%     which have any category different from other.
% \end{l3regex-syntax}
% The category code tests can be used inside classes; for instance,
% |[\cO\d \c[LO][A-F]]| matches what \TeX{} considers as hexadecimal
% digits, namely digits with category other, or uppercase letters from
% |A| to |F| with category either letter or other. Within a group
% affected by a category code test, the outer test can be overridden by
% a nested test: for instance, |\cL(ab\cO\*cd)| matches |ab*cd| where
% all characters are of category letter, except |*| which has category
% other.
%
% The |\u| escape sequence allows to insert the contents of a token list
% directly into a regular expression or a replacement, avoiding the need
% to escape special characters. Namely, |\u|\Arg{tl~var~name} matches
% the exact contents of the token list \meta{tl~var}. Within a |\c{...}|
% control sequence matching, the |\u| escape sequence only expands its
% argument once, in effect performing \cs{tl_to_str:v}. Quantifiers are
% not supported directly: use a group.
%
% The option |(?i)| makes the match case insensitive (identifying
% \texttt{A}--\texttt{Z} with \texttt{a}--\texttt{z}; no Unicode support
% yet). This applies until the end of the group in which it appears, and
% can be reverted using |(?-i)|. For instance, in
% \verb"(?i)(a(?-i)b|c)d", the letters |a| and |d| are affected by the
% |i| option. Characters within ranges and classes are affected
% individually: |(?i)[Y-\\]| is equivalent to |[YZ\[\\yz]|, and
% |(?i)[^aeiou]| matches any character which is not a vowel. Neither
% |\c{...}| nor |\u{...}| are affected by the |i| option.
%
% In character classes, only |[|, |^|, |-|, |]|, |\| and spaces are
% special, and should be escaped. Other non-alphanumeric characters can
% still be escaped without harm. The escape sequences |\d|, |\D|,
% etc. are also supported in character classes.  If the first character
% is |^|, then the meaning of the character class is inverted. Ranges of
% characters can be expressed using |-|, for instance, |[\D 0-5]| is
% a convoluted way of expressing |[^6-9]|.
%
% Capturing groups are a means of extracting information about the
% match. Parenthesized groups are labelled in the order of their
% opening parenthesis, starting at $1$. The contents of those groups
% corresponding to the \enquote{best} match (leftmost longest)
% can be extracted and stored in a sequence of strings using for
% instance \cs{regex_extract_once:nnNTF}.
%
% The |\K| escape sequence resets the beginning of the match to the
% current position in the string. This only affects what is reported as
% the full match. For instance,
% \begin{verbatim}
%   \regex_extract_all:nnN { a \K . } { a123aaxyz } \l_foo_seq
% \end{verbatim}
% results in \cs{l_foo_seq} containing the items |{1}| and |{a}|: the
% true matches are |{a1}| and |{aa}|, but they are trimmed by the use of
% |\K|. The |\K| command does not affect capturing groups: for instance,
% \begin{verbatim}
%   \regex_extract_once:nnN { (. \K c)+ \d } { acbc3 } \l_foo_seq
% \end{verbatim}
% results in \cs{l_foo_seq} containing the items |{c3}| and |{bc}|: the
% true match is |{acbc3}|, with first submatch |{bc}|, but |\K| resets
% the beginning of the match to the last position where it appears.
%
% \subsection{Syntax of the replacement text}
%
% Most of the features described in regular expressions do not make sense
% within the replacement text. Escaped characters are supported as inside
% regular expressions. The whole match is accessed as |\0|, and the first
% $9$ submatches are accessed as |\1|, \ldots{}, |\9|. Submatches with
% numbers higher than $9$ are accessed as |\g{|\meta{number}|}| instead.
%
% For instance,
% \begin{verbatim}
%   \tl_set:Nn \l_my_tl { Hello,~world! }
%   \regex_replace_all:nnN { ([er]?l|o) . } { \(\0\-\-\1\) } \l_my_tl
% \end{verbatim}
% results in \cs{l_my_tl} holding |H(ell--el)(o,--o) w(or--o)(ld--l)!|
%
% The characters inserted by the replacement have category code $12$
% (other) by default. The escape sequence |\c| allows to insert characters
% with arbitrary category codes, as well as control sequences.
% \begin{l3regex-syntax}
% \item[\\cXY] Produces the character |Y| (which can be given as
%   an escape sequence such as |\t| for tab) with category code |X|,
%   which must be one of |CBEMTPUDSLOA|.
% \item[\\c\Arg{text}] Produces the control sequence with csname
%   \meta{text}. The \meta{text} may contain references to the submatches
%   |\0|, |\1| \emph{etc.}
% \end{l3regex-syntax}
%
% \subsection{Pre-compiling regular expressions}
%
% If a regular expression is to be used several times,
% it is better to compile it once rather than doing it
% each time the regular expression is used. The compiled
% regular expression is stored in a variable. All
% of the \pkg{l3regex} module's functions can be given their
% regular expression argument either as an explicit string
% or as a compiled regular expression.
%
% \begin{function}{\regex_new:N}
%   \begin{syntax}
%     \cs{regex_new:N} \meta{regex~var}
%   \end{syntax}
%   Creates a new \meta{regex~var} or raises an error if the
%   name is already taken. The declaration is global. The
%   \meta{regex~var} will initially be such that it never matches.
% \end{function}
%
% \begin{function}{\regex_set:Nn, \regex_gset:Nn, \regex_const:Nn}
%   \begin{syntax}
%     \cs{regex_set:Nn} \meta{regex~var} \Arg{regex}
%   \end{syntax}
%   Stores a compiled version of the \meta{regular expression}
%   in the \meta{regex~var}. For instance, this function can be used
%   as
%   \begin{verbatim}
%     \regex_new:N \l_my_regex
%     \regex_set:Nn \l_my_regex { my\ (simple\ )? reg(ex|ular\ expression) }
%   \end{verbatim}
%   The assignment is local for \cs{regex_set:Nn} and global for
%   \cs{regex_gset:Nn}. Use \cs{regex_const:Nn} for compiled expressions
%   which will never change.
% \end{function}
%
% \begin{function}{\regex_show:n, \regex_show:N}
%   \begin{syntax}
%     \cs{regex_show:n} \Arg{regex}
%   \end{syntax}
%   Shows how \pkg{l3regex} interprets the \meta{regex}. For instance,
%   \cs{regex_show:n} \verb+{\A X|Y}+ shows
%   \begin{verbatim}
%     +-branch
%       anchor at start (\A)
%       char code 88
%     +-branch
%       char code 89
%   \end{verbatim}
%   indicating that the anchor |\A| only applies to the first branch:
%   the second branch is not anchored to the beginning of the match.
% \end{function}
%
% \subsection{Matching}
%
% All regular expression functions are available in both |:n| and |:N|
% variants. The former require a \enquote{standard} regular expression,
% while the later require a compiled expression as generated by
% \cs{regex_(g)set:Nn}.
%
% \begin{function}[TF]{\regex_match:nn, \regex_match:Nn}
%   \begin{syntax}
%     \cs{regex_match:nnTF} \Arg{regex} \Arg{token list} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{regular expression} matches any part
%   of the \meta{token list}. For instance,
%   \begin{verbatim}
%     \regex_match:nnTF { b [cde]* } { abecdcx } { TRUE } { FALSE }
%     \regex_match:nnTF { [b-dq-w] } { example } { TRUE } { FALSE }
%   \end{verbatim}
%   leaves \texttt{TRUE} then \texttt{FALSE} in the input stream.
% \end{function}
%
% \begin{function}{\regex_count:nnN, \regex_count:NnN}
%   \begin{syntax}
%     \cs{regex_count:nnN} \Arg{regex} \Arg{token list} \meta{int var}
%   \end{syntax}
%   Sets \meta{int var} within the current \TeX{} group level
%   equal to the number of times
%   \meta{regular expression} appears in \meta{token list}.
%   The search starts by finding the left-most longest match,
%   respecting greedy and ungreedy operators. Then the search
%   starts again from the character following the last character
%   of the previous match, until reaching the end of the token list.
%   Infinite loops are prevented in the case where the regular expression
%   can match an empty string: then we count one match between each
%   pair of characters.
%   For instance,
%   \begin{verbatim}
%     \int_new:N \l_foo_int
%     \regex_count:nnN { (b+|c) } { abbababcbb } \l_foo_int
%   \end{verbatim}
%   results in \cs{l_foo_int} taking the value $5$.
% \end{function}
%
% \subsection{Submatch extraction}
%
% \begin{function}[TF]{\regex_extract_once:nnN, \regex_extract_once:NnN}
%   \begin{syntax}
%     \cs{regex_extract_once:nnN} \Arg{regex} \Arg{token list} \meta{seq~var}
%     \cs{regex_extract_once:nnNTF} \Arg{regex} \Arg{token list} \meta{seq~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Finds the first match of the \meta{regular expression}
%   in the \meta{token list}. If it exists, the match is stored
%   as the zeroeth item of the \meta{seq~var}, and further
%   items are the contents of capturing groups, in the order
%   of their opening parenthesis. The \meta{seq~var}
%   is assigned locally. If there is no match,
%   the \meta{seq~var} is cleared.
%   The testing versions insert the \meta{true code} into the input
%   stream if a match was found, and the \meta{false code} otherwise.
%   For instance, assume that you type
%   \begin{verbatim}
%     \regex_extract_once:nnNTF { \A(La)?TeX(!*)\Z } { LaTeX!!! } \l_foo_seq
%       { true } { false }
%   \end{verbatim}
%   Then the regular expression (anchored at the start with |\A| and
%   at the end with |\Z|) will match the whole token list. The first
%   capturing group, |(La)?|, matches |La|, and the second capturing
%   group, |(!*)|, matches |!!!|. Thus, |\l_foo_seq| will contain
%   the items |{LaTeX!!!}|, |{La}|, and |{!!!}|, and the \texttt{true}
%   branch is left in the input stream.
% \end{function}
%
% \begin{function}[TF]{\regex_extract_all:nnN, \regex_extract_all:NnN}
%   \begin{syntax}
%     \cs{regex_extract_all:nnN} \Arg{regex} \Arg{token list} \meta{seq~var}
%     \cs{regex_extract_all:nnNTF} \Arg{regex} \Arg{token list} \meta{seq~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Finds all matches of the \meta{regular expression}
%   in the \meta{token list}, and stores all the submatch information
%   in a single sequence (concatenating the results of
%   multiple \cs{regex_extract_once:nnN} calls).
%   The \meta{seq~var} is assigned locally. If there is no match,
%   the \meta{seq~var} is cleared.
%   The testing versions insert the \meta{true code} into the input
%   stream if a match was found, and the \meta{false code} otherwise.
%   For instance, assume that you type
%   \begin{verbatim}
%     \regex_extract_all:nnNTF { \w+ } { Hello,~world! } \l_foo_seq
%       { true } { false }
%   \end{verbatim}
%   Then the regular expression will match twice, and the resulting
%   sequence contains the two items |{Hello}| and |{world}|,
%   and the \texttt{true} branch is left in the input stream.
% \end{function}
%
% \begin{function}[TF]{\regex_split:nnN, \regex_split:NnN}
%   \begin{syntax}
%     \cs{regex_split:nnN} \Arg{regular expression} \Arg{token list} \meta{seq~var}
%     \cs{regex_split:nnNTF} \Arg{regular expression} \Arg{token list} \meta{seq~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Splits the \meta{token list} into a sequence of parts, delimited by
%   matches of the \meta{regular expression}. If the \meta{regular expression}
%   has capturing groups, then the token lists that they match are stored as
%   items of the sequence as well. The assignment to \meta{seq~var} is local.
%   If no match is found the resulting \meta{seq~var} has the
%   \meta{token list} as its sole item. If the \meta{regular expression}
%   matches the empty token list, then the \meta{token list} is split
%   into single tokens.
%   The testing versions insert the \meta{true code} into the input
%   stream if a match was found, and the \meta{false code} otherwise.
%   For example, after
%   \begin{verbatim}
%     \seq_new:N \l_path_seq
%     \regex_split:nnNTF { / } { the/path/for/this/file.tex } \l_path_seq
%       { true } { false }
%   \end{verbatim}
%   the sequence |\l_path_seq| contains the items |{the}|, |{path}|,
%   |{for}|, |{this}|, and |{file.tex}|, and the \texttt{true} branch
%   is left in the input stream.
% \end{function}
%
% \subsection{Replacement}
%
% \begin{function}[TF]{\regex_replace_once:nnN,\regex_replace_once:NnN}
%   \begin{syntax}
%     \cs{regex_replace_once:nnN} \Arg{regular expression} \Arg{replacement} \meta{tl~var}
%     \cs{regex_replace_once:nnNTF} \Arg{regular expression} \Arg{replacement} \meta{tl~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Searches for the \meta{regular expression} in the \meta{token list}
%   and replaces the first match with the \meta{replacement}. The result
%   is assigned locally to \meta{tl~var}. In the \meta{replacement},
%   |\0| represents the full match, |\1| represent the contents
%   of the first capturing group, |\2| of the second, \emph{etc.}
% \end{function}
%
% \begin{function}[TF]{\regex_replace_all:nnN, \regex_replace_all:NnN}
%   \begin{syntax}
%     \cs{regex_replace_all:nnN} \Arg{regular expression} \Arg{replacement} \meta{tl~var}
%     \cs{regex_replace_all:nnNTF} \Arg{regular expression} \Arg{replacement} \meta{tl~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Replaces all occurrences of the \cs{regular expression}
%   in the \meta{token list} by the \meta{replacement}, where
%   |\0| represents the full match, |\1|
%   represent the contents of the first capturing group,
%   |\2| of the second, \emph{etc.} Every match
%   is treated independently, and matches cannot overlap.
%   The result is assigned locally to \meta{tl~var}.
% \end{function}
%
% \subsection{Bugs, misfeatures, future work, and other possibilities}
%
% The following need to be done now.
% \begin{itemize}
%   \item Change user function names!
%   \item Clean up the use of messages.
%   \item Code comments.
%   \item Rewrite the documentation in a clearer way.
%   \item Document interaction between caseless matching and |\c| and |\u|.
%   \item Quantifiers for |\u| and assertions.
%   \item Clarify expansion of |\u| in regex versus replacement.
% \end{itemize}
% ^^A todo: check that \regex_set:Nn \A { [ } and friends don't break. ^^A]
%
% Code improvements to come.
% \begin{itemize}
%   \item Test for the maximum register \cs{c_max_register_int}.
%   \item Use \tn{dimen} registers rather than \cs{l_regex_nesting_tl}
%     to build \cs{regex_nesting:n}.
%   \item Reduce the number of epsilon-transitions in alternatives.
%   \item Move the \enquote{reconstruction} part of \pkg{l3regex} to
%     \pkg{l3tl-analysis}.
%   \item Optimize regexes for csnames when the regex is a simple
%     string.
%   \item Optimize simple strings: use less states (|abcade| should give
%     two states, for |abc| and |ade|). [Does that really make sense?]
%   \item Optimize groups with no alternative.
%   \item Optimize the use of \cs{prg_stepwise_...} functions.
%   \item Decide what |\c{\c{...}}| should do in the replacement text.
%   \item Fix the |\c{\cBx}| bug in replacement text.
%   \item Better \enquote{show} for anchors, properties, and catcode tests.
%   \item Find out whether the fact that |\W| and friends match the
%     end-marker leads to bugs.
%   \item Does |\K| really need a new state for itself?
% \end{itemize}
%
% The following features are likely to be implemented at some point
% in the future.
% \begin{itemize}
% \item General look-ahead/behind assertions.
% \item Regex matching on external files.
% \item Conditional subpatterns with look ahead/behind: \enquote{if
%     what follows is [\ldots{}], then [\ldots{}]}.
% \item |(*..)| and |(?..)| sequences to set some options.
% \item UTF-8 mode for pdf\TeX{}.
% \item Newline conventions are not done.
%   In particular, we should have an option for |.| not to match newlines.
%   Also, |\A| should differ from |^|, and |\Z|, |\z| and |$| should
%   differ.
% \item Unicode properties: |\p{..}| and |\P{..}|;
%   |\X| which should match any \enquote{extended} Unicode sequence.
%   This requires to manipulate a lot of data, hence a lot of optimization
%   ahead.
% \end{itemize}
%
% The following features of \textsc{pcre} or Perl will probably not be
% implemented.
% \begin{itemize}
% \item |\ddd|, matching the character with code \texttt{ddd} in octal;
% \item Callout with |(?C...)|, we cannot run arbitrary user code during
%   the matching, because the regex code uses registers in an unsafe way;
% \item Conditional subpatterns (other than with a look-ahead
%   or look-behind condition): this is non-regular, isn't it?
% \item Named subpatterns: \TeX{} programmers have lived so far without
%   any need for named macro parameters.
% \end{itemize}
%
% The following features of \textsc{pcre} or Perl will definitely not be
% implemented.
% \begin{itemize}
% \item |\cx|, similar to \TeX{}'s own |\^^x|;
% \item Comments: \TeX{} already has its own system for comments.
% \item |\Q...\E| escaping: this would require to read the argument
%   verbatim, which is not in the scope of this module.
% \item Atomic grouping, possessive quantifiers: those tools, mostly
%   meant to fix catastrophic backtracking, are unnecessary in a
%   non-backtracking algorithm, and difficult to implement.
% \item Subroutine calls: this syntactic sugar is difficult to include
%   in a non-backtracking algorithm, in particular because the
%   corresponding group should be treated as atomic. Also, we cannot
%   afford to run user code within the regular expression matching,
%   because of our \enquote{misuse} of registers.
% \item Recursion: this is a non-regular feature.
% \item Back-references: non-regular feature, this requires backtracking,
%   which is prohibitively slow.
% \item Backtracking control verbs: intrinsically tied to backtracking.
% \item |\C| single byte in UTF-8 mode: Xe\TeX{} and Lua\TeX{} serve
%   us characters directly, and splitting those into bytes is tricky,
%   encoding dependent, and most likely not useful anyways.
% \end{itemize}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3regex} implementation}
%
%<*package>
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\RequirePackage{l3tl-build, l3tl-analysis, l3flag, l3str}
%    \end{macrocode}
%
% \subsection{Plan of attack}
%
% Most regex engines use backtracking. This allows to provide very
% powerful features (back-references come to mind first), but it is
% costly, and raises the problem of catastrophic backtracking. Since
% \TeX{} is not first and foremost a programming language, complicated
% code tends to run slowly, and we must use faster, albeit slightly more
% restrictive, techniques, coming from automata theory.
%
% Given a regular expression of $n$ characters, we do the following:
% \begin{itemize}
%   \item (Compiling.) Analyse the regex, finding invalid input, and
%     convert it to an internal representation.
%   \item (Building.) Convert the compiled regex to a non-deterministic
%     finite automaton (\textsc{nfa}) with roughly $n$ states which
%     accepts precisely token lists matching that regex.
%   \item (Matching.) Loop through the query token list one token (one
%     \enquote{index}) at a time, exploring in parallel every possible
%     path through the \textsc{nfa}, with various priorities encoding
%     the operators' greediness.
% \end{itemize}
%
%^^A \begin{todo}{update}
% We use the following vocabulary in the code comments (and in variable
% names).
% \begin{itemize}
%   \item \emph{Group}: index of the capturing group, $-1$ for
%     non-capturing groups.
%   \item \emph{Index}: each token in the query is labelled by an integer
%     \meta{index}, with $\cs{l_regex_min_index_int} - 1 \leq \meta{index}
%     \leq \cs{l_regex_max_index_int}$. The lowest and highest indexes
%     correspond to imaginary begin and end markers (with inacessible
%     category code and character code).
%   \item \emph{Query}: the token list to which we apply the regular
%     expression.
%   \item \emph{State}: each state of the \textsc{nfa} is labelled by an integer
%     \meta{state} with $0 \leq \meta{state} <
%     \cs{l_regex_max_state_int}$.
%   \item \emph{Active state}: state of the \textsc{nfa} that is reached when
%     reading the query string for the matching. Those states are
%     ordered according to the greediness of quantifiers.
%   \item \emph{Step}: used when matching, starts at $0$, incremented
%     every time a character is read, and is not reset when searching
%     for repeated matches.
% \end{itemize}
%
% To acheive a good performance, we abuse \TeX{}'s registers in two
% ways.  We access registers directly by number rather than tying them
% to control sequence using \cs{int_new:N} and other allocation
% functions. And we store integers in \tn{dimen} registers in scaled
% points (\texttt{sp}), using \TeX{}'s implicit conversion from
% dimensions to integers in some contexts. Specifically, the registers
% are used as follows. When building,
% \begin{itemize}
%   \item \tn{toks}\meta{state} has two parts separated by \cs{s_stop}:
%     a property list which holds the submatch information, followed by
%     the tests and actions to perform in the \meta{state} of the \textsc{nfa}.
%   \item \tn{skip}$i$ has the form \meta{group} \texttt{plus}
%     \meta{left state} \texttt{minus} \meta{right state}.
%     ^^A todo: not done yet.
% \end{itemize}
% When matching,
% \begin{itemize}
%   \item \tn{dimen}\meta{state} is equal to the last \meta{step} in
%     which the \meta{state} was active.
%   \item \tn{skip}$i$ holds the \meta{state} number corresponding to
%     the $i$-th active \meta{state} (smaller $i$ is higher precendence)
%     and has no shrink or stretch components.
%   \item \tn{toks}\meta{index} holds \meta{tokens} which \texttt{o}-
%     and \texttt{x}-expand to the \meta{index}-th token in the query.
% \end{itemize}
% \tn{count} registers are not abused, which means that we can safely
% use named integers in this module.
%^^A \end{todo}
%
% The code is structured as follows. Variables, constants and various
% helper functions are introduced first, to limit the clutter in later
% parts. The next three sections have to do with compiling, building,
% and matching. We then we give tools for the replacements. Finally,
% user functions.
%
% \subsection{Constants and variables}
%
% \begin{macro}{\regex_tmp:w}
%   Temporary function used for expansion in
%   \cs{regex_toks_put_left/right:Nx}.
%    \begin{macrocode}
\cs_new:Npn \regex_tmp:w { }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_regex_internal_a_int, \l_regex_internal_b_int}
% \begin{variable}{\l_regex_internal_a_tl, \l_regex_internal_b_tl}
% \begin{variable}{\g_regex_internal_tl}
% \begin{variable}{\l_regex_internal_bool}
%   Temporary variables used for various purposes.
%    \begin{macrocode}
\tl_new:N   \l_regex_internal_a_tl
\tl_new:N   \l_regex_internal_b_tl
\int_new:N  \l_regex_internal_a_int
\int_new:N  \l_regex_internal_b_int
\tl_new:N   \g_regex_internal_tl
\bool_new:N \l_regex_internal_bool
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \subsubsection{Variables used when compiling}
%
% \begin{variable}{\l_regex_group_level_int}
%   When compiling, we make sure to open the same number of groups as we
%   close.
%    \begin{macrocode}
\int_new:N \l_regex_group_level_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_mode_int}
%   While compiling, ten modes are recognized, labelled $-63$, $-23$,
%   $-6$, $-2$, $0$, $2$, $3$, $6$, $23$, $63$. See
%   section~\ref{sec:regex-modes}.
%    \begin{macrocode}
\int_new:N \l_regex_mode_int
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{Variables used while building}
%
%^^A \begin{todo}{update}
% \begin{variable}{\l_regex_max_state_int}
% \begin{variable}{\l_regex_left_state_int, \l_regex_right_state_int}
%   The last state that was allocated is $\cs{l_regex_max_state_int}-1$,
%   so that \cs{l_regex_max_state_int} always points to a free state.
%   The starting state and end state of the last group (which any
%   quantifier would act on) are stored as
%   \cs{l_regex_left/right_state_int}.  In almost all cases, the left
%   and right pointers only differ by~$1$.
%    \begin{macrocode}
\int_new:N  \l_regex_max_state_int
\int_new:N  \l_regex_left_state_int
\int_new:N  \l_regex_right_state_int
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\l_regex_left_state_seq, \l_regex_right_state_seq}
%   Alternatives are implemented by branching from a state into the
%   various choices, then merging those into another state. We store
%   information about those states in two sequences.
%    \begin{macrocode}
\seq_new:N  \l_regex_left_state_seq
\seq_new:N  \l_regex_right_state_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_capturing_group_int}
%   \cs{l_regex_capturing_group_int} is the ID number of the current
%   capturing group, starting at $0$ for a group enclosing the full
%   regular expression, and counting in the order of their left parenthesis.
%   This number is used when a branch of the alternation ends.
%    \begin{macrocode}
\int_new:N  \l_regex_capturing_group_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_catcodes_int, \l_regex_default_catcodes_int}
% \begin{variable}
%   {
%     \c_regex_catcode_C_int, \c_regex_catcode_B_int, \c_regex_catcode_E_int,
%     \c_regex_catcode_M_int, \c_regex_catcode_T_int, \c_regex_catcode_P_int,
%     \c_regex_catcode_U_int, \c_regex_catcode_D_int, \c_regex_catcode_S_int,
%     \c_regex_catcode_L_int, \c_regex_catcode_O_int, \c_regex_catcode_A_int
%   }
% \begin{variable}{\c_regex_all_catcodes_int}
%   We wish to allow constructions such as |\c[^BE](..\cL[a-z]..)|,
%   matching two tokens which are neither a begin-group nor an end-group
%   token, followed by a token of category letter and character code in
%   |[a-z]|, followed by two more tokens which are neither begin-group
%   nor end-group tokens. For this to work, we need to keep track of
%   lists of allowed category codes: \cs{l_regex_catcodes_int} and
%   \cs{l_regex_default_catcodes_int} are bitmaps, sums of $4^c$, for
%   all allowed catcodes $c$. The latter is local to each capturing
%   group, and we reset \cs{l_regex_catcodes_int} to that value after
%   each character or class, changing it only when encountering a |\c|
%   escape. Errata: the \cs{l_regex_default_catcodes_int} is not used
%   yet, because the idea of having \verb+\cL(...|...)+ act on the whole
%   contents of the group is not yet implemented.
%    \begin{macrocode}
\int_new:N \l_regex_catcodes_int
\int_new:N \l_regex_default_catcodes_int
\int_const:Nn \c_regex_catcode_C_int { "1 }
\int_const:Nn \c_regex_catcode_B_int { "4 }
\int_const:Nn \c_regex_catcode_E_int { "10 }
\int_const:Nn \c_regex_catcode_M_int { "40 }
\int_const:Nn \c_regex_catcode_T_int { "100 }
\int_const:Nn \c_regex_catcode_P_int { "1000 }
\int_const:Nn \c_regex_catcode_U_int { "4000 }
\int_const:Nn \c_regex_catcode_D_int { "10000 }
\int_const:Nn \c_regex_catcode_S_int { "100000 }
\int_const:Nn \c_regex_catcode_L_int { "400000 }
\int_const:Nn \c_regex_catcode_O_int { "1000000 }
\int_const:Nn \c_regex_catcode_A_int { "4000000 }
\int_const:Nn \c_regex_all_catcodes_int { "5515155 }
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\l_regex_catcodes_bool}
%   Controls whether the bitmap of category codes built should be
%   inverted or not.
%    \begin{macrocode}
\bool_new:N \l_regex_catcodes_bool
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{Variables used when matching}
%
% \begin{variable}{\l_regex_min_index_int}
% \begin{variable}{\l_regex_max_index_int}
%   The tokens in the query are indexed from \cs{l_regex_min_index_int}
%   for the first to $\cs{l_regex_max_index_int}-1$ for the last, and
%   their information is stored in \tn{muskip} and \tn{toks} registers
%   with those numbers. We don't start from $0$ because the \tn{toks}
%   registers with low numbers are used to hold the states of the \textsc{nfa}.
%    \begin{macrocode}
\int_new:N \l_regex_min_index_int
\int_new:N \l_regex_max_index_int
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\l_regex_nesting_int}
%   The first phase when matching is to go once through the query token
%   list and store the information for each token as \tn{muskip} and
%   \tn{toks} registers. During this phase, \cs{l_regex_nesting_int}
%   counts the balance of begin-group and end-group character tokens
%   which appear before a given point in the string, and is stored as
%   the shrink component of the \tn{muskip} registers. This integer is
%   also used to keep track of the balance in the replacement text.
%    \begin{macrocode}
\int_new:N \l_regex_nesting_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_current_index_int}
% \begin{variable}{\l_regex_start_index_int}
% \begin{variable}{\l_regex_success_index_int}
%   While reading through the query token list,
%   \cs{l_regex_current_index_int} is the position in the token list,
%   starting at \cs{l_regex_min_index_int} for the first token.
%   Each match begins at the position given by
%   \cs{l_regex_start_index_int}. Whenever an execution thread succeeds,
%   the corresponding index is stored into \cs{l_regex_success_index_int},
%   which will be the next starting index (except in the case of empty
%   matches).
%   \begin{macrocode}
\int_new:N \l_regex_current_index_int
\int_new:N \l_regex_start_index_int
\int_new:N \l_regex_success_index_int
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\l_regex_current_char_int}
% \begin{variable}{\l_regex_current_catcode_int}
% \begin{variable}{\l_regex_current_token_tl}
% \begin{variable}{\l_regex_last_char_int}
% \begin{variable}{\l_regex_case_changed_char_int}
%   The character and category codes of the token at the current
%   position; \meta{tokens} which \texttt{o}- and \texttt{x}-expand to
%   the token (as provided by \cs{tl_analysis:n}); the character code of
%   the token at the previous position; and the character code of the
%   result of changing the case of the current token
%   (|A-Z|$\leftrightarrow$|a-z|). This last integer is only computed if
%   the \enquote{case insensitive} option |(?i)| is used in the regex.
%   The \cs{l_regex_current_char_int} variable is also used in various
%   other phases to hold a character code.
%    \begin{macrocode}
\int_new:N \l_regex_current_char_int
\int_new:N \l_regex_current_catcode_int
\tl_new:N  \l_regex_current_token_tl
\int_new:N \l_regex_last_char_int
\int_new:N \l_regex_case_changed_char_int
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\g_regex_caseless_bool}
%   True if caseless matching is used within the regular expression.
%   This controls whether \cs{l_regex_case_changed_char_int} is computed.
%    \begin{macrocode}
\bool_new:N \g_regex_caseless_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_current_state_int}
%   For every character in the token list, each of the active states is
%   considered in turn.
%   The variable \cs{l_regex_current_state_int} holds the state
%   of the \textsc{nfa} which is currently considered: transitions are then
%   given as shifts relative to the current state.
%   In some cases of groups with quantifiers,
%   \cs{l_regex_current_state_int} is shifted to a fake value for
%   transitions to point to the correct states.
%    \begin{macrocode}
\int_new:N \l_regex_current_state_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_current_submatches_prop}
% \begin{variable}{\l_regex_success_submatches_prop}
%   The submatches for the thread which lies at the
%   \cs{l_regex_current_state_int} are stored in a property
%   list variable. This property list is stored by
%   \cs{regex_action_cost:n} into the \tn{toks} register
%   for the target state of the transition. When a thread
%   succeeds, this property list is copied to
%   \cs{l_regex_success_submatches_prop} and only the last
%   sucessful thread will remain there.
%    \begin{macrocode}
\prop_new:N \l_regex_current_submatches_prop
\prop_new:N \l_regex_success_submatches_prop
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\l_regex_step_int}
%   In the case of repeated matches, \cs{l_regex_current_index_int}
%   is reset to the end-position of the previous match. In contrast,
%   \cs{l_regex_step_int} is simply incremented to provide
%   a unique number for each iteration of the matching loop. This
%   is handy to attach each set of submatch information to a given
%   iteration (and automatically discard it when it corresponds to
%   a past iteration).
%    \begin{macrocode}
\int_new:N \l_regex_step_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_max_active_int}
%   All the currently active states are kept in order of precedence
%   in the \tn{skip} registers, which for our purpose serve as an array:
%   the $i$th item of the array is \tn{skip}$i$. The largest index used
%   after treating the previous character is \cs{l_regex_max_active_int}.
%   At the start of every step, the whole array is unpacked, so that the
%   space can immediately be reused, and \cs{l_regex_max_active_int} is
%   reset to zero, effectively clearing the array.
%    \begin{macrocode}
\int_new:N \l_regex_max_active_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_every_match_tl}
%   Every time a match is found, this token list is used.  For single
%   matching, the token list is empty. For multiple matching, the token
%   list is set to repeat the matching.
%    \begin{macrocode}
\tl_new:N \l_regex_every_match_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_fresh_thread_bool}
% \begin{variable}{\l_regex_success_empty_bool}
% \begin{macro}{\regex_if_two_empty_matches:F}
%   When doing multiple matches, we need to avoid infinite loops where
%   each iteration matches the same empty token list. When an empty
%   token list is matched, the next successful match of the same empty
%   token list is suppressed. We detect empty matches by setting
%   \cs{l_regex_fresh_thread_bool} to \texttt{true} for threads which
%   directly come from the start of the regular expression, and testing
%   that boolean whenever a thread succeeds. The function
%   \cs{regex_if_two_empty_matches:F} is redefined at every match
%   attempt, depending on whether the previous match was empty or not:
%   if it was, then the function must cancel a purported success if it
%   is empty and at the same spot as the previous match; otherwise, we
%   definitely don't have two identical empty matches, so the function
%   is \cs{use:n}.
%    \begin{macrocode}
\bool_new:N \l_regex_fresh_thread_bool
\bool_new:N \l_regex_success_empty_bool
\cs_new_eq:NN \regex_if_two_empty_matches:F \use:n
%    \end{macrocode}
% \end{macro}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\g_regex_success_bool}
% \begin{variable}{\l_regex_saved_success_bool}
% \begin{variable}{\l_regex_success_match_bool}
%   The boolean \cs{g_regex_success_bool} is true if there was at least
%   one successful match, and \cs{l_regex_success_match_bool} is true if
%   the current match attempt was successful.  The variable
%   \cs{g_regex_success_bool} is the only global variable in this whole
%   module. When nesting \cs{regex} functions internally, the value of
%   \cs{g_regex_success_bool} is saved into
%   \cs{l_regex_saved_success_bool}, which is local, hence not affected
%   by the changes due to inner regex functions.
%    \begin{macrocode}
\bool_new:N \g_regex_success_bool
\bool_new:N \l_regex_saved_success_bool
\bool_new:N \l_regex_success_match_bool
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
%^^A \end{todo}
%
% \subsubsection{Regular expression variables}
%
% \begin{macro}{\regex_new:N}
% \begin{variable}{\c_regex_no_match_regex}
%   This regular expression matches nothing, but is still a valid
%   regular expression. We could use a failing assertion, but I went for
%   an empty class. It is used as the initial value for regular
%   expressions declared using \cs{regex_new:N}.
%    \begin{macrocode}
\tl_const:Nn \c_regex_no_match_regex
  {
    \regex_branch:n
      { \regex_class:NnnnN \c_true_bool { } { 1 } { 0 } \c_true_bool }
  }
\cs_new_protected:Npn \regex_new:N #1
  { \cs_new_eq:NN #1 \c_regex_no_match_regex }
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \begin{variable}{\l_regex_internal_regex}
%   This holds a temporary pre-compiled regular expression in various
%   occasions.
%    \begin{macrocode}
\regex_new:N \l_regex_internal_regex
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{Variables used in user functions}
%^^A todo: move?
%^^A todo: run with the check-declarations option.
%
% \begin{variable}{\l_regex_replacement_csnames_int}
%   The behaviour of closing braces inside a replacement text depends on
%   whether a sequences |\c{| or |\u{| has been encountered. The number
%       of \enquote{open} such sequences that should be closed by |}| is
%     stored in \cs{l_regex_replacement_csnames_int}, and decreased by
%     $1$ by each |}|.
%    \begin{macrocode}
\int_new:N \l_regex_replacement_csnames_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_submatch_int}
% \begin{variable}{\l_regex_submatch_start_int}
%    \begin{macrocode}
\int_new:N \l_regex_submatch_int
\int_new:N \l_regex_submatch_start_int
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\l_regex_match_count_int}
%   The number of matches found so far is stored
%   in \cs{l_regex_match_count_int}. This is only used
%   in the \cs{regex_count:nnN} functions.
%    \begin{macrocode}
\int_new:N \l_regex_match_count_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{regex_begin, regex_end}
%   Those flags are raised to indicate extra begin-group
%   or end-group tokens when extracting submatches.
%    \begin{macrocode}
\flag_new:n { regex_begin }
\flag_new:n { regex_end }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_show_prefix_seq}
%   This sequence holds the prefix that makes up the line displayed to
%   the end-user. The various items must be removed from the right,
%   which is tricky with a token list, hence we use a sequence.
%    \begin{macrocode}
\seq_new:N \l_regex_show_prefix_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_regex_show_lines_int}
%   Somewhat a hack. To know whether a given class has a single item in
%   it or not, we count the number of lines when showing the class.
%    \begin{macrocode}
\int_new:N \l_regex_show_lines_int
%    \end{macrocode}
% \end{variable}
%
% \subsection{Helpers}
%
% \subsubsection{Expansion}
%
% \begin{macro}[int, EXP]{\regex_exp_after:Nf}
%   Similar to \cs{exp_last_unbraced:Nf}, but without grabbing the
%   second argument.
%    \begin{macrocode}
\cs_new:Npn \regex_exp_after:Nf #1
  { \exp_after:wN #1 \tex_romannumeral:D -`0 }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Toks}
%
% Two unrelated sets of functions for manipulating \tn{toks} registers.
%
% \begin{macro}[int]{\regex_toks_put_left:Nx}
% \begin{macro}[int]{\regex_toks_put_right:Nx}
%   During the building phase, every \tn{toks} register starts with
%   \cs{s_stop}, and we wish to add \texttt{x}-expanded material to
%   those registers. The expansion is done \enquote{by hand} for
%   optimization (these operations are used quite a lot). When adding
%   material to the left, we define \cs{regex_tmp:w} to remove the
%   \cs{s_stop} marker and put it back to the left of the new material.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_toks_put_left:Nx #1#2
  {
    \cs_set_nopar:Npx \regex_tmp:w \s_stop { \s_stop #2 }
    \tex_toks:D #1 \exp_after:wN \exp_after:wN \exp_after:wN
      { \exp_after:wN \regex_tmp:w \tex_the:D \tex_toks:D #1 }
  }
\cs_new_protected:Npn \regex_toks_put_right:Nx #1#2
  {
    \cs_set_nopar:Npx \regex_tmp:w {#2}
    \tex_toks:D #1 \exp_after:wN
      { \tex_the:D \tex_toks:D \exp_after:wN #1 \regex_tmp:w }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%^^A \begin{todo}{update}
% \begin{macro}[int, rEXP]{\regex_toks_range:nn}
% \begin{macro}[aux, rEXP]{\regex_toks_range:ww}
%   Some non-expandable functions store pieces of their result in
%   \tn{toks} registers.  Those pieces are concatenated using
%   \cs{regex_toks_range:nn}, which expects two integers, \meta{start}
%   and \meta{end}, and expands to the contents of the \tn{toks}
%   registers from \meta{start} (inclusive) to \meta{end}
%   (exclusive). This correctly expands to nothing if \meta{start}
%   $\geq$ \meta{end}.
%    \begin{macrocode}
\cs_new:Npn \regex_toks_range:nn #1#2
  {
    \exp_after:wN \regex_toks_range:ww
    \int_use:N \int_eval:w #1 \exp_after:wN ;
    \int_use:N \int_eval:w #2 ;
    \prg_break_point:n { }
  }
\cs_new:Npn \regex_toks_range:ww #1 ; #2 ;
  {
    \if_num:w #1 < #2 \exp_stop_f:
    \else:
      \exp_after:wN \prg_map_break:
    \fi:
    \tex_the:D \tex_toks:D #1 \exp_stop_f:
    \exp_after:wN \regex_toks_range:ww
      \int_use:N \int_eval:w #1 + \c_one ; #2 ;
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% On the one hand, when performing the matching, the \tn{toks} registers
% hold submatch information, followed by the instruction for a given
% state of the \textsc{nfa}. The two parts are separated by \cs{s_stop}.  On the
% other hand, we provide functions to unpack the contents from a range
% of \tn{toks} within an \texttt{x}-expanding assignment.
%
% When it is time to extract submatches from the token list, the various
% tokens are stored in \tn{toks} registers numbered from
% \cs{l_regex_min_index_int} inclusive to \cs{l_regex_max_index_int}
% exclusive. Furthermore, the \tn{skip} registers hold\ldots{} ^^A ??
%
% \begin{macro}[int]{\regex_query_submatch:nn}
% \begin{macro}[int]{\regex_query_submatch:w}
%    \begin{macrocode}
\cs_new:Npn \regex_query_submatch:nn #1#2
  {
    \if_num:w #1 < \l_regex_capturing_group_int
      \exp_after:wN \regex_query_submatch:w
      \int_use:N \int_eval:w #1 + #2 ;
    \fi:
  }
\cs_new:Npn \regex_query_submatch:w #1 ;
  {
    \regex_toks_range:nn
      { \tex_skip:D #1 }
      { \etex_gluestretch:D \tex_skip:D #1 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%^^A \end{todo}
%
% \subsubsection{Sequences}
%
% \begin{macro}[int]{\regex_seq_pop_int:NN}
% \begin{macro}[int]{\regex_seq_get_int:NN}
% \begin{macro}[int]{\regex_seq_push_int:NN}
%   When building the regular expression, we keep track of some integers
%   (pointers to various states) without help from \TeX{}'s grouping.
%   Here are variants of \cs{seq_pop:NN} and \cs{seq_get:NN} which
%   assign using \cs{int_set:Nn} rather than \cs{tl_set:Nn}.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_seq_pop_int:NN #1#2
  {
    \seq_pop:NN #1 \l_regex_internal_a_tl
    \int_set:Nn #2 \l_regex_internal_a_tl
  }
\cs_new_protected:Npn \regex_seq_get_int:NN #1#2
  {
    \seq_get:NN #1 \l_regex_internal_a_tl
    \int_set:Nn #2 \l_regex_internal_a_tl
  }
\cs_new_protected:Npn \regex_seq_push_int:NN #1#2
  { \seq_push:No #1 { \int_use:N #2 } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Grabbing digits}
%
% \begin{macro}[int]{\regex_get_digits:NTFw}
% \begin{macro}[aux, rEXP]{\regex_get_digits_loop:w}
%   If followed by some raw digits, collect them one by one in the
%   integer variable |#1|, and take the \texttt{true} branch. Otherwise,
%   take the \texttt{false} branch.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_get_digits:NTFw #1#2#3#4#5
  {
    \regex_if_raw_digit:NNTF #4 #5
      { #1 = #5 \regex_get_digits_loop:nw {#2} }
      { #3 #4 #5 }
  }
\cs_new:Npn \regex_get_digits_loop:nw #1#2#3
  {
    \regex_if_raw_digit:NNTF #2 #3
      { #3 \regex_get_digits_loop:nw {#1} }
      { \scan_stop: #1 #2 #3 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\regex_if_raw_digit:NNTF}
%   Test used when grabbing digits for the |{m,n}| quantifier.
%   It only accepts non-escaped digits.
%    \begin{macrocode}
\prg_new_conditional:Npnn \regex_if_raw_digit:NN #1#2 { TF }
  {
    \if_meaning:w \regex_compile_raw:N #1
      \if_int_compare:w \c_one < 1 #2 \exp_stop_f:
        \prg_return_true:
      \else:
        \prg_return_false:
      \fi:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Testing characters}
%
% \begin{macro}[int]{\regex_break_point:TF}
% \begin{macro}[int]{\regex_break_true:w}
%   When testing whether a character of the query token list matches
%   a given character class in the regular expression, we often
%   have to test it against several ranges of characters, checking
%   if any one of those matches. This is done with a structure like
%   \begin{quote}
%     \meta{test1} \ldots{} \meta{test$\sb{n}$} \\
%     \cs{regex_break_point:TF} \Arg{true code} \Arg{false code}
%   \end{quote}
%   If any of the tests succeeds, it calls \cs{regex_break_true:w},
%   which cleans up and leaves \meta{true code} in the input stream.
%   Otherwise, \cs{regex_break_point:TF} leaves the \meta{false code}
%   in the input stream.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_break_true:w
   #1 \regex_break_point:TF #2 #3 {#2}
\cs_new_protected:Npn \regex_break_point:TF #1 #2 { #2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\regex_item_reverse:n}
%   This function makes showing regular expressions easier. It may lead
%   to reducing the cs consumption later on.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_item_reverse:n #1
  {
    #1
    \regex_break_point:TF { } \regex_break_true:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {\regex_item_caseful_equal:n, \regex_item_caseful_range:nn}
%   Simple comparisons triggering \cs{regex_break_true:w} when true.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_item_caseful_equal:n #1
  {
    \if_num:w #1 = \l_regex_current_char_int
      \exp_after:wN \regex_break_true:w
    \fi:
  }
\cs_new_protected:Npn \regex_item_caseful_range:nn #1 #2
  {
    \reverse_if:N \if_num:w #1 > \l_regex_current_char_int
      \reverse_if:N \if_num:w #2 < \l_regex_current_char_int
        \exp_after:wN \exp_after:wN \exp_after:wN \regex_break_true:w
      \fi:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {\regex_item_caseless_equal:n, \regex_item_caseless_range:nn}
%   For caseless matching, we perform the test both on
%   \cs{l_regex_current_char_int} and on
%   \cs{l_regex_case_changed_char_int}.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_item_caseless_equal:n #1
  {
    \if_num:w #1 = \l_regex_current_char_int
      \exp_after:wN \regex_break_true:w
    \fi:
    \regex_match_loop_case_hook:
    \if_num:w #1 = \l_regex_case_changed_char_int
      \exp_after:wN \regex_break_true:w
    \fi:
  }
\cs_new_protected:Npn \regex_item_caseless_range:nn #1 #2
  {
    \reverse_if:N \if_num:w #1 > \l_regex_current_char_int
      \reverse_if:N \if_num:w #2 < \l_regex_current_char_int
        \exp_after:wN \exp_after:wN \exp_after:wN \regex_break_true:w
      \fi:
    \fi:
    \regex_match_loop_case_hook:
    \reverse_if:N \if_num:w #1 > \l_regex_case_changed_char_int
      \reverse_if:N \if_num:w #2 < \l_regex_case_changed_char_int
        \exp_after:wN \exp_after:wN \exp_after:wN \regex_break_true:w
      \fi:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A \begin{todo}{update}
% \begin{macro}{\regex_match_loop_case_hook:}
%   ^^A todo: only compute the case-changed char when needed.
%   Set \cs{l_regex_case_changed_char_int} properly.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_match_loop_case_hook:
  {
    \if_num:w \l_regex_case_changed_char_int = \c_max_int
      \int_set_eq:NN \l_regex_case_changed_char_int \l_regex_current_char_int
      \if_num:w \l_regex_current_char_int < \c_ninety_one
        \if_num:w \l_regex_current_char_int < \c_sixty_five
        \else:
          \int_add:Nn \l_regex_case_changed_char_int { \c_thirty_two }
        \fi:
      \else:
        \if_num:w \l_regex_current_char_int < \c_one_hundred_twenty_three
          \if_num:w \l_regex_current_char_int < \c_ninety_seven
          \else:
            \int_sub:Nn \l_regex_case_changed_char_int { \c_thirty_two }
          \fi:
        \fi:
      \fi:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% ^^A \end{todo}
%
% \begin{macro}[int]{\regex_item_equal:n, \regex_item_range:nn}
%   Those must always be defined to expand to a \texttt{caseful}
%   (default) or \texttt{caseless} version, and not be protected: they
%   must expand when compiling, to hard-code which tests are caseless or
%   caseful.
%    \begin{macrocode}
\cs_new_eq:NN \regex_item_equal:n ?
\cs_new_eq:NN \regex_item_range:nn ?
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_item_catcode:nT, \regex_item_catcode:nNT}
% \begin{macro}[aux]{\regex_item_catcode_aux:}
%^^A todo: get rid of \regex_item_catcode:nNT, somehow.
%   The argument is a sum of powers of $4$ with exponents given by the
%   allowed category codes (between $0$ and $13$). Dividing by a given
%   power of $4$ gives an odd result if and only if that category code
%   is allowed. If the catcode does not match, then skip the character
%   code tests which follow.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_item_catcode_aux:
  {
    "
    \if_case:w \l_regex_current_catcode_int
         1       \or: 4       \or: 10      \or: 40
    \or: 100     \or:         \or: 1000    \or: 4000
    \or: 10000   \or:         \or: 100000  \or: 400000
    \or: 1000000 \or: 4000000 \else: 1*\c_zero
    \fi:
  }
\cs_new_protected:Npn \regex_item_catcode:nT #1
  {
    \if_int_odd:w \int_eval:w #1 / \regex_item_catcode_aux: \int_eval_end:
      \exp_after:wN \use:n
    \else:
      \exp_after:wN \use_none:n
    \fi:
  }
\cs_new_protected:Npn \regex_item_catcode:nNT #1#2#3
  {
    \bool_if:NTF #2
      { \regex_item_catcode:nT {#1} {#3} }
      { \regex_item_catcode:nT {#1} { \regex_item_reverse:n {#3} } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\regex_item_exact:nn, \regex_item_exact_cs:N}
%   This matches an exact \meta{category}-\meta{character code} pair, or
%   an exact control sequence.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_item_exact:nn #1#2
  {
    \if_num:w #1 = \l_regex_current_catcode_int
      \if_num:w #2 = \l_regex_current_char_int
        \exp_after:wN \exp_after:wN \exp_after:wN \regex_break_true:w
      \fi:
    \fi:
  }
\cs_new_protected:Npn \regex_item_exact_cs:N #1
  {
    \str_if_eq:xxTF { \l_regex_current_token_tl } { \exp_not:N #1 }
      { \regex_break_true:w } { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_item_cs:n}
%   Match a control sequence (the argument is a compiled regex).
%   First test the catcode of the current token to be zero.
%   Then perform the matching test, and break if the csname
%   indeed matches. The three \cs{exp_after:wN} expand the contents
%   of \cs{l_regex_current_token_tl} (of the form \cs{exp_not:n}
%   \Arg{control sequence}) to \meta{control sequence}.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_item_cs:n #1
  {
    \int_compare:nNnT \l_regex_current_catcode_int = \c_zero
      {
        \group_begin:
          \tl_clear:N \l_regex_every_match_tl
          \regex_disable_submatches:
          \regex_use_for_cs:n {#1}
          \bool_set_eq:NN \l_regex_saved_success_bool \g_regex_success_bool
          \exp_args:Nx \regex_match:n
            {
              \exp_after:wN \exp_after:wN
              \exp_after:wN \cs_to_str:N \l_regex_current_token_tl
            }
          \if_meaning:w \c_true_bool \g_regex_success_bool
            \group_insert_after:N \regex_break_true:w
          \fi:
          \bool_gset_eq:NN \g_regex_success_bool \l_regex_saved_success_bool
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_item_anchor:N}
%   Anchors at the start or end of match, as controlled by |#1|.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_item_anchor:N #1
  {
    \if_num:w #1 = \l_regex_current_index_int
      \exp_after:wN \regex_break_true:w
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, TF]{\regex_if_word_boundary:}
%   This conditional is used by the |\b| and |\B| escape. Check if the
%   last character was a word character or not, and do the same to the
%   current character. The boundaries of the string are word boundaries.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_item_B:
  {
    \group_begin:
      \int_set_eq:NN \l_regex_current_char_int \l_regex_last_char_int
      \regex_prop_w:
      \regex_break_point:TF
        { \group_end: \regex_prop_w: }
        { \group_end: \regex_item_reverse:n \regex_prop_w: }
  }
\cs_new_protected_nopar:Npn \regex_item_b:
  {
    \group_begin:
      \int_set_eq:NN \l_regex_current_char_int \l_regex_last_char_int
      \regex_prop_w:
      \regex_break_point:TF
        { \group_end: \regex_item_reverse:n \regex_prop_w: }
        { \group_end: \regex_prop_w: }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Character property tests}
%
% \begin{macro}[aux]
%   {
%     \regex_prop_d:, \regex_prop_h:, \regex_prop_s:,
%     \regex_prop_v:, \regex_prop_w:, \regex_prop_N:
%   }
%   Character property tests for |\d|, |\W|, \emph{etc.} These character
%   properties are not affected by the |(?i)| option. The characters
%   recognized by each one are as follows: |\d=[0-9]|,
%   |\w=[0-9A-Z_a-z]|, \verb*+\s=[\ \^^I\^^J\^^L\^^M]+,
%   \verb*+\h=[\ \^^I]+, |\v=[\^^J-\^^M]|, and the upper case
%   counterparts match anything that the lower case does not match.  The
%   order in which the various tests appear is optimized for usual
%   mostly lower case letter text.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_prop_d:
  { \regex_item_caseful_range:nn \c_forty_eight { 57 } } % 0--9
\cs_new_protected_nopar:Npn \regex_prop_h:
  {
    \regex_item_caseful_equal:n \c_thirty_two % space
    \regex_item_caseful_equal:n \c_nine       % tab
  }
\cs_new_protected_nopar:Npn \regex_prop_s:
  {
    \regex_item_caseful_equal:n \c_thirty_two % space
    \regex_item_caseful_equal:n \c_nine       % tab
    \regex_item_caseful_equal:n \c_ten        % lf
    \regex_item_caseful_equal:n \c_twelve     % ff
    \regex_item_caseful_equal:n \c_thirteen   % cr
  }
\cs_new_protected_nopar:Npn \regex_prop_v:
  { \regex_item_caseful_range:nn \c_ten \c_thirteen } % lf, vtab, ff, cr
\cs_new_protected_nopar:Npn \regex_prop_w:
  {
    \regex_item_caseful_range:nn \c_ninety_seven { 122 } % a--z
    \regex_item_caseful_range:nn \c_sixty_five   {  90 } % A--Z
    \regex_item_caseful_range:nn \c_forty_eight  {  57 } % 0--9
    \regex_item_caseful_equal:n  { 95 } % _
  }
\cs_new_protected_nopar:Npn \regex_prop_N:
  { \regex_item_reverse:n { \regex_item_caseful_equal:n \c_ten } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]
%   {
%     \regex_posix_alnum:, \regex_posix_alpha:, \regex_posix_ascii:,
%     \regex_posix_blank:, \regex_posix_cntrl:, \regex_posix_digit:,
%     \regex_posix_graph:, \regex_posix_lower:, \regex_posix_print:,
%     \regex_posix_punct:, \regex_posix_space:, \regex_posix_upper:,
%     \regex_posix_word: , \regex_posix_xdigit:
%   }
%   \textsc{posix} properties. No surprise.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_posix_alnum:
  { \regex_posix_alpha: \regex_posix_digit: }
\cs_new_protected_nopar:Npn \regex_posix_alpha:
  { \regex_posix_lower: \regex_posix_upper: }
\cs_new_protected_nopar:Npn \regex_posix_ascii:
  { \regex_item_caseful_range:nn \c_zero \c_one_hundred_twenty_seven }
\cs_new_eq:NN \regex_posix_blank: \regex_prop_h:
\cs_new_protected_nopar:Npn \regex_posix_cntrl:
  { %^^A?
    \regex_item_caseful_range:nn \c_zero { 31 }
    \regex_item_caseful_equal:n \c_one_hundred_twenty_seven
  }
\cs_new_eq:NN \regex_posix_digit: \regex_prop_d:
\cs_new_protected_nopar:Npn \regex_posix_graph:
  { \regex_item_caseful_range:nn { 33 } { 126 } }
\cs_new_protected_nopar:Npn \regex_posix_lower:
  { \regex_item_caseful_range:nn \c_ninety_seven { 122 } }
\cs_new_protected_nopar:Npn \regex_posix_print:
  { \regex_item_caseful_range:nn \c_thirty_two { 126 } }
\cs_new_protected_nopar:Npn \regex_posix_punct:
  {
    \regex_item_caseful_range:nn { 33 } { 47 }
    \regex_item_caseful_range:nn { 58 } { 64 }
    \regex_item_caseful_range:nn { 91 } { 96 }
    \regex_item_caseful_range:nn { 123 } { 126 }
  }
\cs_new_protected_nopar:Npn \regex_posix_space:
  {
    \regex_item_caseful_equal:n \c_thirty_two % space
    \regex_item_caseful_range:nn \c_nine \c_thirteen
  }
\cs_new_protected_nopar:Npn \regex_posix_upper:
  { \regex_item_caseful_range:nn \c_sixty_five { 90 } }
\cs_new_eq:NN \regex_posix_word: \regex_prop_w:
\cs_new_protected_nopar:Npn \regex_posix_xdigit:
  {
    \regex_posix_digit:
    \regex_item_caseful_range:nn { 65 } { 70 }
    \regex_item_caseful_range:nn { 97 } { 102 }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Simple character escape}
%
% Before actually parsing the regular expression or the replacement
% text, we go through them once, converting |\n| to the character $10$,
% \emph{etc.} In this pass, we also convert any special character
% (\texttt{*}, \texttt{?}, \texttt{\{}, etc.) or escaped alphanumeric
% character into a marker indicating that this was a special sequence,
% and replace escaped special characters and non-escaped alphanumeric
% characters by markers indicating that those were \enquote{raw}
% characters. The rest of the code can then avoid caring about escaping
% issues (those can become quite complex to handle in combination with
% ranges in character classes).
%
% Usage: \cs{regex_escape_use:nnnn} \meta{inline~1} \meta{inline~2}
% \meta{inline~3} \Arg{token list} The \meta{token list} is converted to
% a string, then read from left to right, interpreting backslashes as
% escaping the next character.  Unescaped characters are fed to the
% function \meta{inline~1}, and escaped characters are fed to the function
% \meta{inline~2} within an \texttt{x}-expansion context (typically those
% functions perform some tests on their argument to decide how to output
% them).  The escape sequences |\a|, |\e|, |\f|, |\n|, |\r|, |\t| and
% |\x| are recognized, and those are replaced by the corresponding
% character, then fed to \meta{inline~3}. The result is then left in the
% input stream. Spaces are ignored unless escaped.
%
% The conversion is mostly done within an \texttt{x}-expanding
% assignment, except for the |\x| escape sequence, which is not amenable
% to that in general. For this, we use the general framework of
% \cs{tl_set_build:Nw}.
%
% \begin{macro}[int]{\regex_escape_use:nnnn}
%   The result is built in \cs{l_regex_internal_a_tl}, which is then
%   left in the input stream.  Go through |#4| once, applying |#1|,
%   |#2|, or |#3| as relevant to each character (after de-escaping
%   it). Note that we cannot replace \cs{tl_se:Nx} and
%   \cs{tl_build_one:o} by a single call to \cs{tl_build_one:x}, because
%   the \texttt{x}-expanding assignment is interrupted by |\x|.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_escape_use:nnnn #1#2#3#4
  {
%<trace>    \trace_push:nnn { regex } { 1 } { regex_escape_use:nnnn }
    \tl_set_build:Nw \l_regex_internal_a_tl
      \cs_set_nopar:Npn \regex_escape_unescaped:N ##1 { #1 }
      \cs_set_nopar:Npn \regex_escape_escaped:N ##1 { #2 }
      \cs_set_nopar:Npn \regex_escape_raw:N ##1 { #3 }
      \int_set:Nn \tex_escapechar:D { 92 }
      \str_gset_other:Nn \g_regex_internal_tl { #4 }
      \tl_set:Nx \l_regex_internal_b_tl
        {
          \exp_after:wN \regex_escape_loop:N \g_regex_internal_tl
          { break } \prg_break_point:n { }
        }
      \tl_build_one:o \l_regex_internal_b_tl
    \tl_build_end:
%<trace>    \trace_pop:nnn { regex } { 1 } { regex_escape_use:nnnn }
    \l_regex_internal_a_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_escape_loop:N}
% \begin{macro}[aux]+\regex_escape_\:w+
%   \cs{regex_escape_loop:N} reads one character: if it is special
%   (space, backslash, or end-marker), perform the associated action,
%   otherwise it is simply an unescaped character. After a backslash,
%   the same is done, but unknown characters are \enquote{escaped}.
%    \begin{macrocode}
\cs_new:Npn \regex_escape_loop:N #1
  {
    \cs_if_exist_use:cF { regex_escape_\token_to_str:N #1:w }
      { \regex_escape_unescaped:N #1 }
    \regex_escape_loop:N
  }
\cs_new_nopar:cpn { regex_escape_ \c_backslash_str :w }
    \regex_escape_loop:N #1
  {
    \cs_if_exist_use:cF { regex_escape_/\token_to_str:N #1:w }
      { \regex_escape_escaped:N #1 }
    \regex_escape_loop:N
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]
%   {\regex_escape_unescaped:N, \regex_escape_escaped:N, \regex_escape_raw:N}
%   Those functions are never called before being given a new meaning,
%   so their definitions here don't matter.
%    \begin{macrocode}
\cs_new_eq:NN \regex_escape_unescaped:N ?
\cs_new_eq:NN \regex_escape_escaped:N   ?
\cs_new_eq:NN \regex_escape_raw:N       ?
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]
%   {
%     \regex_escape_break:w, \regex_escape_/break:w,
%     \regex_escape_/a:w, \regex_escape_/e:w, \regex_escape_/f:w,
%     \regex_escape_/n:w, \regex_escape_/r:w, \regex_escape_/t:w
%   }
% \begin{macro}[aux]+\regex_escape_ :w+
%   The loop is ended upon seeing the end-marker
%   \enquote{\texttt{break}}, with an error if the string ended in a
%   backslash.  Spaces are ignored, and |\a|, |\e|, |\f|, |\n|, |\r|,
%   |\t| take their meaning here.
%    \begin{macrocode}
\cs_new_eq:NN \regex_escape_break:w \prg_map_break:
\cs_new_nopar:cpn { regex_escape_/break:w }
  {
    \if_false: { \fi: }
    \msg_kernel_error:nn { regex } { trailing-backslash }
    \exp_after:wN \use_none:n \exp_after:wN { \if_false: } \fi:
  }
\cs_new_nopar:cpn { regex_escape_~:w } { }
\cs_new_nopar:cpx { regex_escape_/a:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^G }
\cs_new_nopar:cpx { regex_escape_/t:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^I }
\cs_new_nopar:cpx { regex_escape_/n:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^J }
\cs_new_nopar:cpx { regex_escape_/f:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^L }
\cs_new_nopar:cpx { regex_escape_/r:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^M }
\cs_new_nopar:cpx { regex_escape_/e:w }
  { \exp_not:N \regex_escape_raw:N \iow_char:N \^^[ }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_escape_/x:w}
% \begin{macro}[aux]{\regex_escape_x_end:w, \regex_escape_x_large:n}
%   When |\x| is encountered, \cs{regex_escape_x_test:N} is responsible
%   for grabbing some hexadecimal digits, and feeding the result to
%   \cs{regex_escape_x_end:w}. If the number is $<256$, then it is
%   turned into a byte and fed to \cs{regex_escape_raw:N}. Otherwise,
%   interrupt the assignment, and either produce an error, or use a
%   standard \tn{lowercase} trick depending on the precise value.
%   ^^A todo: check what Perl does to \x{12345678}.
%    \begin{macrocode}
\cs_new:cpn { regex_escape_/x:w } \regex_escape_loop:N
  {
    \exp_after:wN \regex_escape_x_end:w
    \int_value:w "0 \regex_escape_x_test:N
  }
\cs_new:Npn \regex_escape_x_end:w #1 ;
  {
    \int_compare:nNnTF {#1} < \c_two_hundred_fifty_six
      {
        \exp_last_unbraced:Nf \regex_escape_raw:N
          { \str_output_byte:n {#1} }
      }
      { \regex_escape_x_large:n {#1} }
  }
\group_begin:
  \char_set_catcode_other:n { 0 }
  \cs_new:Npn \regex_escape_x_large:n #1
    {
      \if_false: { \fi: }
      \tl_build_one:o \l_regex_internal_b_tl
      \int_compare:nNnTF {#1} > \c_max_char_int
        {
          \msg_kernel_error:nnx { regex } { x-overflow } {#1}
          \tl_set:Nx \l_regex_internal_b_tl
            { \if_false: } \fi: \regex_escape_loop:N
        }
        {
          \char_set_lccode:nn { \c_zero } {#1}
          \tl_to_lowercase:n
            {
              \tl_set:Nx \l_regex_internal_b_tl
                { \if_false: } \fi:
                \regex_escape_raw:N ^^@
                \regex_escape_loop:N
            }
        }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_escape_x_test:N}
%   Find out whether the first character is a left brace (allowing any
%   number of hexadecimal digits), or not (allowing up to two
%   hexadecimal digits). We need to check for the end-of-string marker.
%   Eventually, call either \cs{regex_escape_x_loop:N} or
%   \cs{regex_escape_x_ii:N}.
%    \begin{macrocode}
\cs_new:Npn \regex_escape_x_test:N #1
  {
    \str_if_eq:xxTF {#1} { break } { ; }
      {
        \if_charcode:w \c_space_token #1
          \exp_after:wN \regex_escape_x_test:N
        \else:
          \exp_after:wN \regex_escape_x_test_ii:N
          \exp_after:wN #1
        \fi:
      }
  }
\cs_new:Npn \regex_escape_x_test_ii:N #1
  {
    \if_charcode:w \c_lbrace_str #1
      \exp_after:wN \regex_escape_x_loop:N
    \else:
      \str_aux_hexadecimal_use:NTF #1
        { \exp_after:wN \regex_escape_x_ii:N }
        { ; \exp_after:wN \regex_escape_loop:N \exp_after:wN #1 }
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_escape_x_ii:N}
%   This looks for the second digit in the unbraced case.
%    \begin{macrocode}
\cs_new:Npn \regex_escape_x_ii:N #1
  {
    \str_if_eq:xxTF {#1} { break } { ; }
      {
        \str_aux_hexadecimal_use:NTF #1
          { ; \regex_escape_loop:N }
          { ; \regex_escape_loop:N #1 }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_escape_x_loop:N}
%   Grab hexadecimal digits, skip spaces, and at the end, check that
%   there is a right brace, otherwise raise an error outside the
%   assignment.
%    \begin{macrocode}
\cs_new:Npn \regex_escape_x_loop:N #1
  {
    \str_aux_hexadecimal_use:NTF #1
      { \regex_escape_x_loop:N }
      {
        \token_if_eq_charcode:NNTF \c_space_token #1
          { \regex_escape_x_loop:N }
          {
            ;
            \exp_after:wN \token_if_eq_charcode:NNTF \c_rbrace_str #1
              { \regex_escape_loop:N }
              {
                \if_false: { \fi: }
                \tl_build:o \l_regex_internal_b_tl
                \msg_kernel_error:nn { regex } { x-missing-rbrace } {#1}
                \tl_set:Nx \l_regex_internal_b_tl
                  { \if_false: } \fi: \regex_escape_loop:N #1
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, aux]{\regex_char_if_alphanumeric:NTF}
% \begin{macro}[EXP, aux]{\regex_char_if_special:NTF}
%   These two tests are used in the first pass when parsing a
%   regular expression. That pass is responsible for finding
%   escaped and non-escaped characters, and recognizing which
%   ones have special meanings and which should be interpreted
%   as \enquote{raw} characters. Namely,
%   \begin{itemize}
%     \item alphanumerics are \enquote{raw} if they are not escaped,
%       and may have a special meaning when escaped;
%     \item non-alphanumeric printable ascii characters are \enquote{raw}
%       if they are escaped, and may have a special meaning when not escaped;
%     \item characters other than printable ascii are always \enquote{raw}.
%   \end{itemize}
%   The code is ugly, and highly based on magic numbers and the ascii
%   codes of characters. This is mostly unavoidable for performance
%   reasons: testing for instance with \cs{str_if_contains_char:nN}
%   would be much slower. Maybe the tests can be optimized a little
%   bit more.
%   Here, \enquote{alphanumeric} means \texttt{0}--\texttt{9},
%   \texttt{A}--\texttt{Z}, \texttt{a}--\texttt{z};
%   \enquote{special} character means non-alphanumeric
%   but printable ascii, from space (hex \texttt{20}) to
%   \texttt{del} (hex \texttt{7E}).
%    \begin{macrocode}
\prg_new_conditional:Npnn \regex_char_if_special:N #1 { TF }
  {
    \if_num:w `#1 < \c_ninety_one
      \if_num:w `#1 < \c_fifty_eight
        \if_num:w `#1 < \c_forty_eight
          \if_num:w `#1 < \c_thirty_two
            \prg_return_false: \else: \prg_return_true: \fi:
        \else: \prg_return_false: \fi:
      \else:
        \if_num:w `#1 < \c_sixty_five
          \prg_return_true: \else: \prg_return_false: \fi:
      \fi:
    \else:
      \if_num:w `#1 < \c_one_hundred_twenty_three
        \if_num:w `#1 < \c_ninety_seven
          \prg_return_true: \else: \prg_return_false: \fi:
      \else:
        \if_num:w `#1 < \c_one_hundred_twenty_seven
          \prg_return_true: \else: \prg_return_false: \fi:
      \fi:
    \fi:
  }
\prg_new_conditional:Npnn \regex_char_if_alphanumeric:N #1 { TF }
  {
    \if_num:w `#1 < \c_ninety_one
      \if_num:w `#1 < \c_fifty_eight
        \if_num:w `#1 < \c_forty_eight
          \prg_return_false: \else: \prg_return_true: \fi:
      \else:
        \if_num:w `#1 < \c_sixty_five
          \prg_return_false: \else: \prg_return_true: \fi:
      \fi:
    \else:
      \if_num:w `#1 < \c_one_hundred_twenty_three
        \if_num:w `#1 < \c_ninety_seven
          \prg_return_false: \else: \prg_return_true: \fi:
      \else:
        \prg_return_false:
      \fi:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Compiling}
%
% A regular expression starts its life as a string of characters. In
% this section, we convert it to internal instructions such as
% \cs{regex_group:nnnN} or \cs{regex_branch:n}, resulting in a
% \enquote{compiled} regular expression. This compiled expression is
% then turned into states of an automaton in the building phase.
%
% \subsubsection{Mode}
% \label{sec:regex-modes}
%^^A todo: find better magic numbers.
%
% When compiling the \textsc{nfa} corresponding to a given regex string, we can
% be in ten distinct modes, which we label by some magic numbers:
% \begin{itemize}
%   \item[-6] |[\c{...}]| control sequence in a class,
%   \item[-2] |\c{...}| control sequence,
%   \item[0] |...| outer,
%   \item[2] |\c...| catcode test,
%   \item[6] |[\c...]| catcode test in a class,
%   \item[-63] |[\c{[...]}]| class inside mode $-6$,
%   \item[-23] |\c{[...]}| class inside mode $-2$,
%   \item[3] |[...]| class inside mode $-3$,
%   \item[23] |\c[...]| class inside mode $2$,
%   \item[63] |[\c[...]]| class inside mode $6$.
% \end{itemize}
% This list is exhaustive, because |\c| escape sequences cannot be
% nested, and character classes cannot be nested directly. The choice
% of numbers is such as to optimize the most useful tests, and make
% transitions from one mode to another as simple as possible.
% \begin{itemize}
%   \item Even modes mean that we are not directly in a character class.
%     In this case, a left bracket appends $3$ to the mode. In a
%     character class, a right bracket changes the mode as $m\to
%     (m-15)/13$, truncated.
%   \item Grouping, assertion, and anchors are allowed in non-positive
%     even modes ($0$, $-2$, $-6$), and do not change the
%     mode. Otherwise, they trigger an error.
%   \item A left bracket is special in even modes, appending $3$ to the
%     mode; in those modes, quantifiers and the dot are recognized, and
%     the right bracket is normal. In odd modes (within classes), the
%     left bracket is normal, but the right bracket ends the class,
%     changing the mode from $m$ to $(m-15)/13$, truncated; also, ranges
%     are recognized.
%   \item In non-negative modes, left and right braces are normal. In
%     negative modes, however, left braces trigger a warning; right
%     braces end the control sequence, going from $-2$ to $0$ or $-6$ to
%     $3$, with error recovery for odd modes.
%   \item Properties (such as the |\d| character class) can appear in
%     any mode.
% \end{itemize}
%
% \begin{macro}[int, EXP]{\regex_if_in_class:TF}
%   Test whether we are currently in a character class (at the
%   inner-most level of nesting). There, many escape sequences are not
%   recognized, and special characters are normal. Also, for every raw
%   character, we must look ahead for a possible raw dash.
%   \begin{macrocode}
\cs_new_nopar:Npn \regex_if_in_class:TF
  {
    \if_int_odd:w \l_regex_mode_int
      \exp_after:wN \use_i:nn
    \else:
      \exp_after:wN \use_ii:nn
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\regex_if_within_cs:TF}
%   Similar to \cs{regex_if_in_class:TF}.
%   \begin{macrocode}
\cs_new_nopar:Npn \regex_if_within_cs:TF
  {
    \if_int_compare:w \l_regex_mode_int < \c_zero
      \exp_after:wN \use_i:nn
    \else:
      \exp_after:wN \use_ii:nn
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\regex_if_class_or_catcode:TF}
%   Assertions are only allowed in modes $0$, $-2$, and $-6$,
%   \emph{i.e.}, even, non-positive modes.
%    \begin{macrocode}
\cs_new_nopar:Npn \regex_if_class_or_catcode:TF
  {
    \if_int_odd:w \l_regex_mode_int
      \exp_after:wN \use_i:nn
    \else:
      \if_int_compare:w \l_regex_mode_int > \c_zero
        \exp_after:wN \exp_after:wN \exp_after:wN \use_i:nn
      \else:
        \exp_after:wN \exp_after:wN \exp_after:wN \use_ii:nn
      \fi:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_chk_c_allowed:T}
%   The |\c| escape sequence is only allowed in modes $0$ and $3$,
%   \emph{i.e.}, not within any other |\c| escape sequence.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_chk_c_allowed:T
  {
    \if_num:w \l_regex_mode_int = \c_zero
      \exp_after:wN \use:n
    \else:
      \if_num:w \l_regex_mode_int = \c_three
        \exp_after:wN \exp_after:wN \exp_after:wN \use:n
      \else:
        \msg_kernel_error:nn { regex } { c-bad-mode }
        \exp_after:wN \exp_after:wN \exp_after:wN \use_none:n
      \fi:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_mode_quit_c:}
%   This function changes the mode as it is needed just after a catcode
%   test.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_mode_quit_c:
  {
    \if_num:w \l_regex_mode_int = \c_two
      \l_regex_mode_int = \c_zero
    \else:
      \if_num:w \l_regex_mode_int = \c_six
        \l_regex_mode_int = \c_three
      \fi:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Framework}
%
% \begin{macro}[int]{\regex_compile:w, \regex_compile_end:}
%   Used when compiling a user regex or a regex for the |\c{...}| escape
%   sequence within another regex. Start building a token list within a
%   group (with \texttt{x}-expansion at the outset), and set a few
%   variables (group level, catcodes), then start the first branch. At
%   the end, make sure there are no dangling classes nor groups, close
%   the last branch: we are done building \cs{l_regex_internal_regex}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_compile:w
  {
    \tl_set_build_x:Nw \l_regex_internal_regex
      \int_zero:N \l_regex_group_level_int
      \int_set_eq:NN \l_regex_default_catcodes_int \c_regex_all_catcodes_int
      \int_set_eq:NN \l_regex_catcodes_int \l_regex_default_catcodes_int
      \cs_set_nopar:Npn \regex_item_equal:n  { \regex_item_caseful_equal:n }
      \cs_set_nopar:Npn \regex_item_range:nn { \regex_item_caseful_range:nn }
      \tl_build_one:n { \regex_branch:n { \if_false: } \fi: }
  }
\cs_new_protected_nopar:Npn \regex_compile_end:
  {
      \regex_if_in_class:TF
        {
          \msg_kernel_error:nn { regex } { missing-rbrack }
          \use:c { regex_compile_]: }
          \prg_do_nothing: \prg_do_nothing:
        }
        { }
      \if_num:w \l_regex_group_level_int > \c_zero
        \msg_kernel_error:nnx { regex } { missing-rparen }
          { \int_use:N \l_regex_group_level_int }
        \prg_replicate:nn
          { \l_regex_group_level_int }
          {
              \tl_build_one:n
                {
                  \if_false: { \fi: }
                  \if_false: { \fi: } { 1 } { 0 } \c_true_bool
                }
            \tl_build_end:
            \tl_build_one:o \l_regex_internal_regex
          }
      \fi:
      \tl_build_one:n { \if_false: { \fi: } }
    \tl_build_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_compile:n}
%   The compilation is done between \cs{regex_compile:w} and
%   \cs{regex_compile_end:}, starting in mode~$0$. Then
%   \cs{regex_escape_use:nnnn} distinguishes special characters, escaped
%   alphanumerics, and raw characters, interpreting |\a|, |\x| and other
%   sequences. The $4$ trailing \cs{prg_do_nothing:} are needed because
%   some functions defined later look up to $4$ tokens ahead. Before
%   ending, make sure that any |\c{...}| is properly closed.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile:n #1
  {
    \regex_compile:w
      \int_set_eq:NN \l_regex_mode_int \c_zero
      \regex_escape_use:nnnn
        {
          \regex_char_if_special:NTF ##1
            \regex_compile_special:N \regex_compile_raw:N ##1
        }
        {
          \regex_char_if_alphanumeric:NTF ##1
            \regex_compile_escaped:N \regex_compile_raw:N ##1
        }
        { \regex_compile_raw:N ##1 }
        { #1 }
      \prg_do_nothing: \prg_do_nothing:
      \prg_do_nothing: \prg_do_nothing:
      \int_compare:nNnT \l_regex_mode_int < \c_zero
        {
          \msg_kernel_error:nn { regex } { c-missing-rbrace }
          \exp_after:wN \regex_compile_special:N \c_rbrace_str
        }
    \regex_compile_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_compile_escaped:N, \regex_compile_special:N}
%   If the special character or escaped alphanumeric has a particular
%   meaning in regexes, the corresponding function is used. Otherwise,
%   it is interpreted as a raw character. We distinguish special
%   characters from escaped alphanumeric characters because they behave
%   differently when appearing as an end-point of a range.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_special:N #1
  {
    \cs_if_exist_use:cF { regex_compile_#1: }
      { \regex_compile_raw:N #1 }
  }
\cs_new_protected:Npn \regex_compile_escaped:N #1
  {
    \cs_if_exist_use:cF { regex_compile_/#1: }
      { \regex_compile_raw:N #1 }
  }
%    \end{macrocode}
% \end{macro}
%
%^^A todo: \c{} starts a group, so modes within can be = mode outside.
% \begin{macro}[int]{\regex_compile_one:x}
%   This is used after finding one \enquote{test}, such as |\d|, or a
%   raw character. If that followed a catcode test (\emph{e.g.}, |\cL|),
%   then restore the mode. If we are not in a class, then the test is
%   \enquote{standalone}, and we need to add \cs{regex_class:NnnnN} and
%   search for quantifiers. In any case, insert the test, possibly
%   together with a catcode test if appropriate.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_one:x #1
  {
    \regex_mode_quit_c:
    \regex_if_in_class:TF { }
      {
        \tl_build_one:n
          { \regex_class:NnnnN \c_true_bool { \if_false: } \fi: }
      }
    \tl_build_one:x
      {
        \if_num:w \l_regex_catcodes_int < \c_regex_all_catcodes_int
          \regex_item_catcode:nT { \int_use:N \l_regex_catcodes_int }
            { \exp_not:N \exp_not:n {#1} }
        \else:
          \exp_not:N \exp_not:n {#1}
        \fi:
      }
    \int_set_eq:NN \l_regex_catcodes_int \l_regex_default_catcodes_int
    \regex_if_in_class:TF { } { \regex_compile_quantifier:w }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_compile_abort_tokens:n, \regex_compile_abort_tokens:x}
%   This function places the collected tokens back in the input stream,
%   each as a raw character. Spaces are not preserved.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_abort_tokens:n #1
  {
    \use:x
      {
        \exp_args:No \tl_map_function:nN { \tl_to_str:n {#1} }
          \regex_compile_raw:N
      }
  }
\cs_generate_variant:Nn \regex_compile_abort_tokens:n { x }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Quantifers}
%
% \begin{macro}[int]{\regex_compile_quantifier:w}
%   This looks ahead and finds any quantifier (special character equal
%   to either of \texttt{?+*\{}).
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_quantifier:w #1#2
  {
    \token_if_eq_meaning:NNTF #1 \regex_compile_special:N
      {
        \cs_if_exist_use:cF { regex_compile_quantifier_#2:w }
          { \regex_compile_quantifier_none: #1 #2 }
      }
      { \regex_compile_quantifier_none: #1 #2 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_quantifier_none:}
% \begin{macro}[aux]{\regex_compile_quantifier_abort:xNN}
%   Those functions are called whenever there is no quantifier, or a
%   braced construction is invalid (equivalent to no quantifier, and
%   whatever characters were grabbed are left raw).
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_quantifier_none:
  { \tl_build_one:n { \if_false: { \fi: } { 1 } { 0 } \c_false_bool } }
\cs_new_protected:Npn \regex_compile_quantifier_abort:xNN #1#2#3
  {
    \regex_compile_quantifier_none:
    \msg_kernel_warning:nnxx { regex } { invalid-quantifier } {#1} {#3}
    \regex_compile_abort_tokens:x {#1}
    #2 #3
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_quantifier_lazyness:nnNN}
%   Once the \enquote{main} quantifier (\texttt{?}, \texttt{*},
%   \texttt{+} or a braced construction) is found, we check whether it
%   is lazy (followed by a question mark). We then add to the compiled
%   regex a closing brace (ending \cs{regex_class:NnnnN} and friends),
%   the start-point of the range, its end-point, and a boolean,
%   \texttt{true} for lazy and \texttt{false} for greedy operators.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_quantifier_lazyness:nnNN #1#2#3#4
  {
    \str_if_eq:nnTF { #3 #4 } { \regex_compile_special:N ? }
      { \tl_build_one:n { \if_false: { \fi: } { #1 } { #2 } \c_true_bool } }
      {
        \tl_build_one:n { \if_false: { \fi: } { #1 } { #2 } \c_false_bool }
        #3 #4
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]
%   {
%     \regex_compile_quantifier_?:w,
%     \regex_compile_quantifier_*:w,
%     \regex_compile_quantifier_+:w
%   }
%   For each \enquote{basic} quantifier, |?|, |*|, |+|, feed the correct
%   arguments to \cs{regex_compile_quantifier_lazyness:nnNN}, $-1$ means
%   that there is no upper bound on the number of repetitions.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_compile_quantifier_?:w }
  { \regex_compile_quantifier_lazyness:nnNN { 0 } { 1 } }
\cs_new_protected_nopar:cpn { regex_compile_quantifier_*:w }
  { \regex_compile_quantifier_lazyness:nnNN { 0 } { -1 } }
\cs_new_protected_nopar:cpn { regex_compile_quantifier_+:w }
  { \regex_compile_quantifier_lazyness:nnNN { 1 } { -1 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]+\regex_compile_quantifier_{:w+ ^^A}
% \begin{macro}[aux]
%   {
%     \regex_compile_quantifier_braced_i:w,
%     \regex_compile_quantifier_braced_ii:w,
%     \regex_compile_quantifier_braced_iii:w,
%   }
%   Three possible syntaxes: \texttt{\{\meta{int}\}},
%   \texttt{\{\meta{int},\}}, or \texttt{\{\meta{int},\meta{int}\}}. Any
%   other syntax causes us to abort and put whatever we collected back
%   in the input stream, as \texttt{raw} characters, including the
%   opening brace. Grab a number into \cs{l_regex_internal_a_int}. If
%   the number is followed by a right brace, the range is $[a,a]$. If
%   followed by a comma, grab one more number, and call the \texttt{_ii}
%   or \texttt{_iii} auxiliary. Those auxiliaries check for a closing
%   brace, leading to the range $[a,\infty]$ or $[a,b]$, encoded as
%   $\{a\}\{-1\}$ and $\{a\}\{b-a\}$.
%    \begin{macrocode}
\cs_new_protected:cpn { regex_compile_quantifier_ \c_lbrace_str :w }
  {
    \regex_get_digits:NTFw \l_regex_internal_a_int
      { \regex_compile_quantifier_braced_i:w }
      { \regex_compile_quantifier_abort:xNN { \c_lbrace_str } }
  }
\cs_new_protected:Npn \regex_compile_quantifier_braced_i:w #1#2
  {
    \prg_case_str:xxn { #1 #2 }
      {
        { \regex_compile_special:N \c_rbrace_str }
          {
            \exp_args:No \regex_compile_quantifier_lazyness:nnNN
              { \int_use:N \l_regex_internal_a_int } { 0 }
          }
        { \regex_compile_special:N , }
          {
            \regex_get_digits:NTFw \l_regex_internal_b_int
              { \regex_compile_quantifier_braced_iii:w }
              { \regex_compile_quantifier_braced_ii:w }
          }
      }
      {
        \regex_compile_quantifier_abort:xNN
          { \c_lbrace_str \int_use:N \l_regex_internal_a_int }
        #1 #2
      }
  }
\cs_new_protected:Npn \regex_compile_quantifier_braced_ii:w #1#2
  {
    \str_if_eq:xxTF
      { #1 #2 } { \regex_compile_special:N \c_rbrace_str }
      {
        \exp_args:No \regex_compile_quantifier_lazyness:nnNN
          { \int_use:N \l_regex_internal_a_int } { -1 }
      }
      {
        \regex_compile_quantifier_abort:xNN
          { \c_lbrace_str \int_use:N \l_regex_internal_a_int , }
        #1 #2
      }
  }
\cs_new_protected:Npn \regex_compile_quantifier_braced_iii:w #1#2
  {
    \str_if_eq:xxTF
      { #1 #2 } { \regex_compile_special:N \c_rbrace_str }
      {
        \if_num:w \l_regex_internal_a_int > \l_regex_internal_b_int
          \msg_kernel_error:nnxx { regex } { backwards-quantifier }
            { \int_use:N \l_regex_internal_a_int }
            { \int_use:N \l_regex_internal_b_int }
          \int_zero:N \l_regex_internal_b_int
        \else:
          \int_sub:Nn \l_regex_internal_b_int \l_regex_internal_a_int
        \fi:
        \exp_args:Noo \regex_compile_quantifier_lazyness:nnNN
          { \int_use:N \l_regex_internal_a_int }
          { \int_use:N \l_regex_internal_b_int }
      }
      {
        \regex_compile_quantifier_abort:xNN
          {
            \c_lbrace_str
            \int_use:N \l_regex_internal_a_int ,
            \int_use:N \l_regex_internal_b_int
          }
        #1 #2
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Raw characters}
%
% \begin{macro}[int]{\regex_compile_raw_error:N}
%   Within character classes, and following catcode tests, some escaped
%   alphanumeric sequences such as |\b| do not have any meaning. They
%   are replaced by a raw character, after spitting out an error.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_raw_error:N #1
  {
    \msg_kernel_error:nnx { regex } { bad-escape } {#1}
    \regex_compile_raw:N #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_compile_raw:N}
%   If we are in a character class and the next character is an
%   unescaped dash, this denotes a range. Otherwise, the current
%   character |#1| matches itself.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_raw:N #1#2#3
  {
    \regex_if_in_class:TF
      {
        \str_if_eq:nnTF {#2#3} { \regex_compile_special:N - }
          { \regex_compile_range:Nw #1 }
          {
            \regex_compile_one:x
              { \regex_item_equal:n { \int_value:w `#1 ~ } }
            #2 #3
          }
      }
      {
        \regex_compile_one:x
          { \regex_item_equal:n { \int_value:w `#1 ~ } }
        #2 #3
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_range:Nw, \regex_if_end_range:NNTF}
%   We have just read a raw character followed by a dash; this should be
%   followed by an end-point for the range. Valid end-points are: any
%   raw character; any special character, except a right bracket. In
%   particular, escaped characters are forbidden.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \regex_if_end_range:NN #1#2 { TF }
  {
    \if_meaning:w \regex_compile_raw:N #1
      \prg_return_true:
    \else:
      \if_meaning:w \regex_compile_special:N #1 % [
        \if_charcode:w ] #2
          \prg_return_false:
        \else:
          \prg_return_true:
        \fi:
      \else:
        \prg_return_false:
      \fi:
    \fi:
  }
\cs_new_protected:Npn \regex_compile_range:Nw #1#2#3
  {
    \regex_if_end_range:NNTF #2 #3
      {
        \if_num:w `#1 > `#3 \exp_stop_f:
          \msg_kernel_error:nnxx { regex } { range-backwards } {#1} {#3}
        \else:
          \tl_build_one:x
            {
              \if_num:w `#1 = `#3 \exp_stop_f:
                \regex_item_equal:n
              \else:
                \regex_item_range:nn { \int_value:w `#1 ~ }
              \fi:
              { \int_value:w `#3 ~ }
            }
        \fi:
      }
      {
        \msg_kernel_warning:nnxx { regex } { range-missing-end } % [
          {#1} { \c_backslash_str #3 }
        \tl_build_one:x
          {
            \regex_item_equal:n { \int_value:w `#1 ~ }
            \regex_item_equal:n { \int_value:w `- ~ }
          }
        #2#3
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Character properties}
%
% \begin{macro}[aux]{\regex_compile_.:, \regex_prop_.:}
%   In a class, the dot has no special meaning. Outside, insert
%   \cs{regex_prop_.:}, which matches any character or control
%   sequence, and refuses $-2$, which marks the end of the query.
%    \begin{macrocode}
\cs_new_protected_nopar:cpx { regex_compile_.: }
  {
    \exp_not:N \regex_if_in_class:TF
      { \regex_compile_raw:N . }
      { \regex_compile_one:x \exp_not:c { regex_prop_.: } }
  }
\cs_new_protected_nopar:cpn { regex_prop_.: }
  {
    \if_num:w \l_regex_current_char_int > - \c_two
      \exp_after:wN \regex_break_true:w
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]
%   {
%     \regex_compile_/d:, \regex_compile_/D:,
%     \regex_compile_/h:, \regex_compile_/H:,
%     \regex_compile_/s:, \regex_compile_/S:,
%     \regex_compile_/v:, \regex_compile_/V:,
%     \regex_compile_/w:, \regex_compile_/W:,
%     \regex_compile_/N:,
%   }
%   The constants \cs{regex_prop_d:}, \emph{etc.} hold
%   a list of tests which match the corresponding character
%   class, and jump to the \cs{regex_break_point:TF} marker.
%   As for a normal character, we check for quantifiers.
%    \begin{macrocode}
\cs_set_protected:Npn \regex_tmp:w #1#2
  {
    \cs_new_protected_nopar:cpx { regex_compile_/#1: }
      { \regex_compile_one:x \exp_not:c { regex_prop_#1: } }
    \cs_new_protected_nopar:cpx { regex_compile_/#2: }
      {
        \regex_compile_one:x
          { \regex_item_reverse:n \exp_not:c { regex_prop_#1: } }
      }
  }
\regex_tmp:w d D
\regex_tmp:w h H
\regex_tmp:w s S
\regex_tmp:w v V
\regex_tmp:w w W
\cs_new_protected_nopar:cpn { regex_compile_/N: }
  { \regex_compile_one:x \regex_prop_N: }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Anchoring and simple assertions}
%
% ^^A todo: add \regex_assertion_quantifier:
%
% \begin{macro}[aux]{\regex_compile_anchor:NF}
% \begin{macro}[aux]+\regex_compile_^:+
% \begin{macro}[aux]{\regex_compile_/A:, \regex_compile_/G:}
% \begin{macro}[aux]+\regex_compile_$:+
% \begin{macro}[aux]{\regex_compile_/Z:, \regex_compile_/z:}
%   In modes where assertions are allowed, anchor to the start of the
%   query, the start of the match, or the end of the query, depending on
%   the integer |#1|. In other modes, |#2| treats the character as raw,
%   with an error for escaped letters (|$| is valid in a class, but |\A|
%   is definitely a mistake on the user's part).
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_anchor:NF #1#2
  {
    \regex_if_class_or_catcode:TF {#2}
      { \tl_build_one:n { \regex_assertion:n { \regex_item_anchor:N #1 } } }
  }
\cs_set_protected:Npn \regex_tmp:w #1#2
  {
    \cs_new_protected_nopar:cpn { regex_compile_/#1: }
      { \regex_compile_anchor:NF #2 { \regex_compile_raw_error:N #1 } }
  }
\regex_tmp:w A \l_regex_min_index_int
\regex_tmp:w G \l_regex_start_index_int
\regex_tmp:w Z \l_regex_max_index_int
\regex_tmp:w z \l_regex_max_index_int
\cs_set_protected:Npn \regex_tmp:w #1#2
  {
    \cs_new_protected_nopar:cpn { regex_compile_#1: }
      { \regex_compile_anchor:NF #2 { \regex_compile_raw:N #1 } }
  }
\exp_args:Nx \regex_tmp:w { \iow_char:N \^ } \l_regex_min_index_int
\exp_args:Nx \regex_tmp:w { \iow_char:N \$ } \l_regex_max_index_int
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_/b:, \regex_compile_/B:}
%   Contrarily to |^| and |$|, which could be implemented without really
%   knowing what precedes in the token list, this requires more
%   information, namely, the knowledge of the last character code.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_compile_/b: }
  {
    \regex_if_class_or_catcode:TF
      { \regex_compile_raw_error:N b }
      { \tl_build_one:n { \regex_assertion:n { \regex_item_b: } } }
  }
\cs_new_protected_nopar:cpn { regex_compile_/B: }
  {
    \regex_if_class_or_catcode:TF
      { \regex_compile_raw_error:N B }
      { \tl_build_one:n { \regex_assertion:n { \regex_item_B: } } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Character classes}
%
% \begin{macro}[aux]{\regex_compile_[:}
%   In a class, left brackets might introduce a \textsc{posix} character
%   class, or mean nothing. Outside a class, update the mode by
%   appending $3$ to it, then examine the first two characters (special
%   in the case |[^]...| for instance.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_compile_[: }
  {
    \regex_if_in_class:TF
      { \regex_compile_class_posix_test:w }
      {
        \l_regex_mode_int = \int_value:w \l_regex_mode_int 3 \exp_stop_f:
        \int_compare:nNnTF \l_regex_mode_int > \c_sixteen
          { \regex_compile_class_nested:w }
          { \regex_compile_class:nNNNN { \regex_class:NnnnN } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_]:}
%   Outside a class, right brackets have no meaning. In a class, change
%   the mode ($m\to (m-15)/13$, truncated) to reflect the fact that we
%   are leaving the class. Look for quantifiers, unless we are still in
%   a class after leaving one (the case of |[...\cL[...]...]|).
%   quantifiers.
%    \begin{macrocode}
\cs_new_protected:cpn { regex_compile_]: }
  {
    \regex_if_in_class:TF
      {
        \if_num:w \l_regex_mode_int > \c_sixteen
          \tl_build_one:n { \if_false: { \fi: } }
        \fi:
        \tex_advance:D \l_regex_mode_int - \c_fifteen
        \tex_divide:D \l_regex_mode_int \c_thirteen
        \if_int_odd:w \l_regex_mode_int \else:
          \exp_after:wN \regex_compile_quantifier:w
        \fi:
      }
      { \regex_compile_raw:N ] }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]
%   {
%     \regex_compile_class_posix_test:w,
%     \regex_compile_class_posix:NNNNw,
%     \regex_compile_class_posix_loop:w,
%     \regex_compile_class_posix_end:w
%   }
%   Here we check for a syntax such as |[:alpha:]|. We also detect |[=|
%   and |[.| which have a meaning in \textsc{posix} regular expressions,
%   but are not implemented in \pkg{l3regex}. In case we see |[:|, grab
%   raw characters until hopefully reaching |:]|. If that's missing, or
%   the \textsc{posix} class is unknown, abort. If all is right, add the
%   test to the current class, with an extra \cs{regex_item_reverse:n}
%   for negative classes.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_class_posix_test:w #1#2
  {
    \token_if_eq_meaning:NNT \regex_compile_special:N #1
      {
        \prg_case_str:nnn { #2 }
          {
            : { \regex_compile_class_posix:NNNNw }
            = { \msg_kernel_warning:nnx { regex } { posix-unsupported } { = } }
            . { \msg_kernel_warning:nnx { regex } { posix-unsupported } { . } }
          }
          { }
      }
    \regex_compile_raw:N [ #1 #2
  }
\cs_new_protected:Npn \regex_compile_class_posix:NNNNw #1#2#3#4#5#6
  {
    \str_if_eq:nnTF { #5 #6 } { \regex_compile_special:N ^ }
      {
        \bool_set_false:N \l_regex_internal_bool
        \tl_set:Nx \l_regex_internal_a_tl { \if_false: } \fi:
          \regex_compile_class_posix_loop:w
      }
      {
        \bool_set_true:N \l_regex_internal_bool
        \tl_set:Nx \l_regex_internal_a_tl { \if_false: } \fi:
          \regex_compile_class_posix_loop:w #5 #6
      }
  }
\cs_new:Npn \regex_compile_class_posix_loop:w #1#2
  {
    \token_if_eq_meaning:NNTF \regex_compile_raw:N #1
      { #2 \regex_compile_class_posix_loop:w }
      { \if_false: { \fi: } \regex_compile_class_posix_end:w #1 #2 }
  }
\cs_new_protected:Npn \regex_compile_class_posix_end:w #1#2#3#4
  {
    \str_if_eq:nnTF { #1 #2 #3 #4 }
      { \regex_compile_special:N : \regex_compile_special:N ] }
      {
        \cs_if_exist:cTF { regex_posix_ \l_regex_internal_a_tl : }
          {
            \regex_compile_one:x
              {
                \bool_if:NF \l_regex_internal_bool \regex_item_reverse:n
                \exp_not:c { regex_posix_ \l_regex_internal_a_tl : }
              }
          }
          {
            \msg_kernel_warning:nnx { regex } { posix-unknown }
              { \l_regex_internal_a_tl }
            \regex_compile_abort_tokens:x
              {
                [: \bool_if:NF \l_regex_internal_bool { ^ }
                \l_regex_internal_a_tl :]
              }
          }
      }
      {
        \msg_kernel_error:nnxx { regex } { posix-missing-close }
          { [: \l_regex_internal_a_tl } { #2 #4 }
        \regex_compile_abort_tokens:x { [: \l_regex_internal_a_tl }
        #1 #2 #3 #4
      }
  }
%    \end{macrocode}
% \end{macro}
%
%^^A \begin{todo}{update}
% \begin{macro}[aux]{\regex_compile_class_nested:w}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_compile_class_nested:w
  {
    \tl_build_one:x
      {
        \if_int_compare:w \l_regex_mode_int < \c_thirty_two
          \regex_class:NnnnN \c_true_bool
          \exp_not:n { { \if_false: } \fi: }
        \fi:
        \exp_not:N \exp_not:n
          {
            \regex_item_catcode:nNT
              { \int_use:N \l_regex_catcodes_int }
          }
      }
    \int_set_eq:NN  \l_regex_catcodes_int \c_regex_all_catcodes_int
    \regex_compile_class:nNNNN { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_class:nNNNN}
%   If the first character is |^|, then the class is inverted. If the
%   next character is a right bracket, then it should be changed to a
%   raw one.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_class:nNNNN #1#2#3#4#5
  {
    \token_if_eq_meaning:NNTF #2 \regex_compile_special:N
      {
        \token_if_eq_charcode:NNTF #3 ^
          {
            \tl_build_one:n { #1 \c_false_bool { \if_false: } \fi: }
            \str_if_eq:nnTF { #4 #5 } { \regex_compile_special:N ] }
              { \regex_compile_raw:N ] }
              { #4 #5 }
          }
          { % [
            \tl_build_one:n { #1 \c_true_bool { \if_false: } \fi: }
            \token_if_eq_charcode:NNTF #3 ]
              { \regex_compile_raw:N #3 }
              { #2 #3 }
            #4 #5
          }
      }
      {
        \tl_build_one:n { #1 \c_true_bool { \if_false: } \fi: }
        #2 #3 #4 #5
      }
  }
%    \end{macrocode}
% \end{macro}
%^^A\end{todo}
%
% \subsubsection{Groups and alternations}
%
% \begin{macro}[aux]{\regex_compile_group_begin:N, \regex_compile_group_end:}
%   The contents of a regex group are turned into compiled code in
%   \cs{l_regex_internal_regex}, which ends up with items of the form
%   \cs{regex_branch:n} \Arg{concatenation}. This construction is done
%   using \pkg{l3tl-build} within a \TeX{} group, which automatically
%   makes sure that options (case-sensitivity and default catcode) are
%   reset at the end of the group. The argument |#1| is
%   \cs{regex_group:nnnN} or a variant thereof. A small subtelty to
%   support |\cL(abc)| as a shorthand for |(\cLa\cLb\cLc)|: exit any
%   pending catcode test, save the category code at the start of the
%   group as the default catcode for that group, and make sure that the
%   catcode is restored to the default outside the group.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_group_begin:N #1
  {
    \tl_build_one:n { #1 { \if_false: } \fi: }
    \regex_mode_quit_c:
    \tl_set_build:Nw \l_regex_internal_regex
      \int_set_eq:NN \l_regex_default_catcodes_int \l_regex_catcodes_int
      \int_incr:N \l_regex_group_level_int
      \tl_build_one:n { \regex_branch:n { \if_false: } \fi: }
  }
\cs_new_protected:Npn \regex_compile_group_end:
  {
    \if_num:w \l_regex_group_level_int > \c_zero
        \tl_build_one:n { \if_false: { \fi: } }
      \tl_build_end:
      \int_set_eq:NN \l_regex_catcodes_int \l_regex_default_catcodes_int
      \tl_build_one:o \l_regex_internal_regex
      \exp_after:wN \regex_compile_quantifier:w
    \else:
      \msg_kernel_warning:nn { regex } { extra-rparen }
      \exp_after:wN \regex_compile_raw:N \exp_after:wN )
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_(:}
%   In a class, parentheses are not special. Outside, check for a |?|,
%   denoting special groups, and run the code for the corresponding
%   special group.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_compile_(: }
  {
    \regex_if_in_class:TF { \regex_compile_raw:N ( }
      { \regex_compile_lparen:w }
  }
\cs_new_protected:Npn \regex_compile_lparen:w #1#2#3#4
  {
    \str_if_eq:nnTF { #1 #2 } { \regex_compile_special:N ? }
      {
        \cs_if_exist_use:cF
          { regex_compile_special_group_\token_to_str:N #4 :w }
          {
            \msg_kernel_warning:nnx { regex } { special-group-unknown }
              { (? \token_to_str:N #4 }
            \regex_compile_group_begin:N \regex_group:nnnN
              \regex_compile_raw:N ? #3 #4
          }
      }
      {
        \regex_compile_group_begin:N \regex_group:nnnN
          #1 #2 #3 #4
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]+\regex_compile_|:+
%   In a class, the pipe is not special. Otherwise, end the current
%   branch and open another one.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_compile_|: }
  {
    \regex_if_in_class:TF { \regex_compile_raw:N | }
      {
        \tl_build_one:n
          { \if_false: { \fi: } \regex_branch:n { \if_false: } \fi: }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_):}
%   Within a class, parentheses are not special. Outside, close a group.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_compile_): }
  {
    \regex_if_in_class:TF { \regex_compile_raw:N ) }
      { \regex_compile_group_end: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_special_group_::w}
% \begin{macro}[aux]+\regex_compile_special_group_|:w+
%   Non-capturing, and resetting groups are easy to take care of during
%   compilation; for those groups, the harder parts will come when
%   building.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_compile_special_group_::w }
  { \regex_compile_group_begin:N \regex_group_no_capture:nnnN }
\cs_new_protected_nopar:cpn { regex_compile_special_group_|:w }
  { \regex_compile_group_begin:N \regex_group_resetting:nnnN }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]
%   {\regex_compile_special_group_i:w, \regex_compile_special_group_-:w}
%   The match can be made case-insensitive by setting the option with
%   \texttt{(?i)}; the original behaviour is restored by \texttt{(?-i)}.
%   This is the only supported option.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_special_group_i:w #1#2
  {
    \str_if_eq:nnTF { #1 #2 } { \regex_compile_special:N ) }
      {
        \cs_set_nopar:Npn \regex_item_equal:n  { \regex_item_caseless_equal:n }
        \cs_set_nopar:Npn \regex_item_range:nn { \regex_item_caseless_range:nn }
      }
      {
        \msg_kernel_warning:nnx { regex } { unknown-option } { (?i #2 }
        \regex_compile_raw:N (
        \regex_compile_raw:N ?
        \regex_compile_raw:N i
        #1 #2
      }
  }
\cs_new_protected_nopar:cpn { regex_compile_special_group_-:w } #1#2#3#4
  {
    \str_if_eq:nnTF { #1 #2 #3 #4 }
      { \regex_compile_raw:N i \regex_compile_special:N ) }
      {
        \cs_set_nopar:Npn \regex_item_equal:n  { \regex_item_caseful_equal:n }
        \cs_set_nopar:Npn \regex_item_range:nn { \regex_item_caseful_range:nn }
      }
      {
        \msg_kernel_warning:nnx { regex } { unknown-option } { (?-#2#4 }
        \regex_compile_raw:N (
        \regex_compile_raw:N ?
        \regex_compile_raw:N -
        #1 #2 #3 #4
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Catcodes and csnames}
%
% \begin{macro}[aux]{\regex_compile_/c:, \regex_compile_c_test:NN}
%   The |\c| escape sequence can be followed by a capital letter
%   representing a character category, by a left bracket which starts a
%   list of categories, or by a brace group holding a regular expression
%   for a control sequence name. Otherwise, raise an error.
%    \begin{macrocode}
\cs_new_protected:cpn { regex_compile_/c: }
  { \regex_chk_c_allowed:T { \regex_compile_c_test:NN } }
\cs_new_protected:Npn \regex_compile_c_test:NN #1#2
  {
    \token_if_eq_meaning:NNTF #1 \regex_compile_raw:N
      {
        \cs_if_exist:cTF { c_regex_catcode_#2_int }
          {
            \int_set_eq:Nc \l_regex_catcodes_int { c_regex_catcode_#2_int }
            \l_regex_mode_int
              = \if_case:w \l_regex_mode_int \c_two \else: \c_six \fi:
          }
      }
      { \cs_if_exist_use:cF { regex_compile_c_#2:w } }
          {
            \msg_kernel_error:nnx { regex } { c-missing-category } {#2}
            #1 #2
          }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]
%   {
%     \regex_compile_c_[:w,
%     \regex_compile_c_lbrack_loop:NN,
%     \regex_compile_c_lbrack_add:N,
%     \regex_compile_c_lbrack_end:,
%   }
%   When encountering |\c[|, the task is to collect uppercase letters
%   representing character categories. First check for |^| which negates
%   the list of category codes.
%^^A todo: directly put \regex_item_catcode:nNT at this stage.
%    \begin{macrocode}
\cs_new_protected:cpn { regex_compile_c_[:w } #1#2
  {
    \l_regex_mode_int
      = \if_case:w \l_regex_mode_int \c_two \else: \c_six \fi:
    \int_zero:N \l_regex_catcodes_int
    \str_if_eq:nnTF { #1 #2 } { \regex_compile_special:N ^ }
      {
        \bool_set_false:N \l_regex_catcodes_bool
        \regex_compile_c_lbrack_loop:NN
      }
      {
        \bool_set_true:N \l_regex_catcodes_bool
        \regex_compile_c_lbrack_loop:NN
        #1 #2
      }
  }
\cs_new_protected:Npn \regex_compile_c_lbrack_loop:NN #1#2
  {
    \token_if_eq_meaning:NNTF #1 \regex_compile_raw:N
      {
        \cs_if_exist:cTF { c_regex_catcode_#2_int }
          {
            \exp_args:Nc \regex_compile_c_lbrack_add:N
              { c_regex_catcode_#2_int }
            \regex_compile_c_lbrack_loop:NN
          }
      }
      {
        \token_if_eq_charcode:NNTF #2 ]
          { \regex_compile_c_lbrack_end: }
      }
          {
            \msg_kernel_error:nnx { regex } { c-missing-rbrack } {#2}
            \regex_compile_c_lbrack_end:
            #1 #2
          }
  }
\cs_new_protected:Npn \regex_compile_c_lbrack_add:N #1
  {
    \if_int_odd:w \int_eval:w \l_regex_catcodes_int / #1 \int_eval_end:
    \else:
      \tex_advance:D \l_regex_catcodes_int #1
    \fi:
  }
\cs_new_protected_nopar:Npn \regex_compile_c_lbrack_end:
  {
    \if_meaning:w \c_false_bool \l_regex_catcodes_bool
      \int_set:Nn \l_regex_catcodes_int
        { \c_regex_all_catcodes_int - \l_regex_catcodes_int }
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}+\regex_compile_c_{:+
%   The case of a left brace is easy, based on what we have done so far:
%   in a group, build the regular expression, after changing the mode to
%   forbid nesting |\c|.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_compile_c_ \c_lbrace_str :w }
  {
    \regex_compile:w
      \l_regex_mode_int
        = - \if_case:w \l_regex_mode_int \c_two \else: \c_six \fi:
  }
%    \end{macrocode}
% \end{macro}
%
%^^A todo: document that groups don't capture within regexes; optimize for that.
% \begin{macro}+\regex_compile_}:+
%   Non-escaped right braces are only special if they appear when
%   building the regular expression for a csname. In that case, end
%   building the inner regex (this closes any dangling class or group).
%   Then insert the corresponding test.
%    \begin{macrocode}
\cs_new_protected:cpn { regex_compile_ \c_rbrace_str : }
  {
    \int_compare:nNnTF \l_regex_mode_int < \c_zero
      {
        \regex_compile_end:
        \regex_compile_one:x
          { \regex_item_cs:n { \exp_not:o \l_regex_internal_regex } }
      }
      { \exp_after:wN \regex_compile_raw:N \c_rbrace_str }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Matching raw token lists with \cs{u}}
%
% \begin{macro}[aux]{\regex_compile_/u:}
% \begin{macro}[aux, EXP]{\regex_compile_u_loop:NN}
%   The |\u| escape is invalid in classes and directly following a
%   catcode test. Otherwise, it must be followed by a left brace. We
%   then collect the characters for the argument of |\u| within an
%   \texttt{x}-expanding assignment. In principle we could just wait to
%   encounter a right brace, but this is unsafe: if the right brace is
%   missing, then we will reach the end-markers of the regex, and
%   continue, leading to obscure fatal errors. Instead, we only allow
%   raw and special characters, and stop when encountering a special
%   right brace, any escaped character, or the end-marker.
%    \begin{macrocode}
\cs_new_protected:cpn { regex_compile_/u: } #1#2
  {
    \regex_if_class_or_catcode:TF
      { \regex_compile_raw_error:N u #1 #2 }
      {
        \str_if_eq:xxTF {#1#2} { \regex_compile_special:N \c_lbrace_str }
          {
            \tl_set:Nx \l_regex_internal_a_tl { \if_false: } \fi:
            \regex_compile_u_loop:NN
          }
          {
            \msg_kernel_error:nn { regex } { u-missing-lbrace }
            \regex_compile_raw_error:N u #1 #2
          }
      }
  }
\cs_new:Npn \regex_compile_u_loop:NN #1#2
  {
    \token_if_eq_meaning:NNTF #1 \regex_compile_raw:N
      { #2 \regex_compile_u_loop:NN }
      {
        \token_if_eq_meaning:NNTF #1 \regex_compile_special:N
          {
            \exp_after:wN \token_if_eq_charcode:NNTF \c_rbrace_str #2
              { \if_false: { \fi: } \regex_compile_u_end: }
              { #2 \regex_compile_u_loop:NN }
          }
          {
            \if_false: { \fi: }
            \msg_kernel_error:nnx { regex } { u-missing-rbrace } {#2}
            \regex_compile_u_end:
            #1 #2
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_u_end:}
%   Once we have extracted the variable's name, we store the contents of
%   that variable in \cs{l_regex_internal_a_tl}. The behaviour of |\u|
%   then depends on whether we are within a |\c{...}| escape (in this
%   case, the variable is turned to a string), or not.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_u_end:
  {
    \tl_set:Nv \l_regex_internal_a_tl { \l_regex_internal_a_tl }
    \if_num:w \l_regex_mode_int = \c_zero
      \regex_compile_u_not_cs:
    \else:
      \regex_compile_u_in_cs:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_u_in_cs:}
%   When |\u| appears within a control sequence, we convert the variable
%   to a string with escaped spaces. Then for each character insert a
%   class matching exactly that character, once.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_u_in_cs:
  {
    \exp_args:NNo \str_gset_other:Nn \g_regex_internal_tl
      { \l_regex_internal_a_tl }
    \tl_build_one:x
      {
        \tl_map_function:NN \g_regex_internal_tl
          \regex_compile_u_in_cs_aux:n
      }
  }
\cs_new:Npn \regex_compile_u_in_cs_aux:n #1
  {
    \regex_class:NnnnN \c_true_bool
      { \regex_item_caseful_equal:n { \int_value:w `#1 } }
      { 1 } { 0 } \c_false_bool
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_compile_u_not_cs:}
%   In mode $0$, the |\u| escape adds one state to the NFA for each
%   token in \cs{l_regex_internal_a_tl}. If a given \meta{token} is a
%   control sequence, then insert a string comparison test, otherwise,
%   \cs{regex_item_exact:nn} which compares catcode and character code.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_compile_u_not_cs:
  {
    \exp_args:No \tl_analysis_map_inline:nn { \l_regex_internal_a_tl }
      {
        \tl_build_one:n
          {
            \regex_class:NnnnN \c_true_bool
              {
                \if_num:w "##2 = \c_zero
                  \regex_item_exact_cs:N ##1
                \else:
                  \regex_item_exact:nn { \int_value:w "##2 } { ##3 }
                \fi:
              }
              { 1 } { 0 } \c_false_bool
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Other}
%
% \begin{macro}[aux]{\regex_compile_/K:}
%   The |\K| control sequence is currently the only \enquote{command},
%   which performs some action, rather than matching something. It is
%   allowed in the same contexts as |\b|. At the compilation stage, we
%   leave it as a single control sequence, defined later.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_compile_/K: }
  {
    \int_compare:nNnTF \l_regex_mode_int = \c_zero
      { \tl_build_one:n { \regex_command_K: } }
      { \regex_compile_raw_error:N K }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Building}
%
%^^A \begin{todo}{update}
% This phase is about going from a compiled regex to an \textsc{nfa}.
%
% \subsubsection{Helpers for building an \textsc{nfa}}
%
% \begin{macro}[int]{\regex_build_new_state:}
%   Add a new state to the \textsc{nfa}. At the end of the building phase, we
%   want every \tn{toks} register to start with \cs{s_stop}, hence
%   initialize the new register appropriately.  Then update
%   the left, right, and max \meta{states}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_new_state:
  {
%<trace>    \trace:nnn { regex } { 2 } { regex~new~state }
    \tex_toks:D \l_regex_max_state_int { \s_stop }
    \int_set_eq:NN \l_regex_left_state_int \l_regex_right_state_int
    \int_set_eq:NN \l_regex_right_state_int \l_regex_max_state_int
    \int_incr:N \l_regex_max_state_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_transition:NN}
% \begin{macro}[aux]{\regex_build_transitions:NNNN}
%   These functions create a new state, and put one or two transitions
%   starting from the old current state.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_build_transition:NN #1#2
  {
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_left_state_int
      { #1 { \int_eval:n { #2 - \l_regex_left_state_int } } }
  }
\cs_new_protected:Npn \regex_build_transitions:NNNN #1#2#3#4
  {
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_left_state_int
      {
        #1 { \int_eval:n { #2 - \l_regex_left_state_int } }
        #3 { \int_eval:n { #4 - \l_regex_left_state_int } }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Framework}
%
%^^A todo: add safeguard that the regex is only "used" within a group.
%
% \begin{macro}{\regex_use:N}
%
%    \begin{macrocode}
\cs_new_protected:Npn \regex_use:N #1
  {
%<trace>    \trace_push:nnn { regex } { 1 } { regex_use }
    \int_set_eq:NN \l_regex_capturing_group_int \c_zero
    \int_zero:N \l_regex_max_state_int
    \regex_build_new_state:
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_left_state_int
      { \regex_action_start_wildcard: }
    \regex_group:nnnN {#1} { 1 } { 0 } \c_false_bool
    \regex_toks_put_right:Nx \l_regex_right_state_int
      { \regex_action_success: }
%<trace>    \regex_trace_states:
  }
%^^A todo: move.
%<*trace>
\cs_new_protected:Npn \regex_trace_states:
  {
    \prg_stepwise_inline:nnnn { 0 } { 1 } { \l_regex_max_state_int - 1 }
      {
        \trace:nnx { regex } { 1 }
          { \iow_char:N \\toks ##1 = { \tex_the:D \tex_toks:D ##1 } }
      }
    \trace_pop:nnn { regex } { 1 } { regex_use }
  }
%</trace>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_use_for_cs:n}
%   When using a regex to match a cs, we don't insert a wildcard, we
%   anchor at the end, and since we ignore submatches, there is no need
%   to surround the expression with a group.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_use_for_cs:n #1
  {
%<trace>    \trace_push:nnn { regex } { 1 } { regex_use }
    \int_zero:N \l_regex_max_state_int
    \regex_build_new_state:
    \regex_build_new_state: % ^^A todo: needed?
    \regex_seq_push_int:NN \l_regex_left_state_seq  \l_regex_left_state_int
    \regex_seq_push_int:NN \l_regex_right_state_seq \l_regex_right_state_int
    #1
    \regex_seq_pop_int:NN \l_regex_left_state_seq  \l_regex_left_state_int
    \regex_seq_pop_int:NN \l_regex_right_state_seq \l_regex_right_state_int
    \regex_group_transition_right_max:
    \regex_build_new_state: % ^^A todo: needed?
    \regex_toks_put_right:Nx \l_regex_right_state_int
      {
        \exp_not:n
          {
            \if_num:w \l_regex_current_index_int = \l_regex_max_index_int
              \exp_after:wN \regex_action_success:
            \fi:
          }
      }
%<trace>    \regex_trace_states:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Quantifiers on classes}
%
% \begin{macro}{\regex_class:NnnnN}
%
%    \begin{macrocode}
\cs_new_protected:Npn \regex_class:NnnnN #1#2#3#4#5
  {
    \cs_set_nopar:Npx \regex_tests_action_cost:n ##1
      {
        \exp_not:n { \exp_not:n {#2} }
        \bool_if:NTF #1
          { \regex_break_point:TF { \regex_action_cost:n {##1} } { } }
          { \regex_break_point:TF { } { \regex_action_cost:n {##1} } }
      }
    \if_case:w - #4 \exp_stop_f:
           \regex_class_repeat:n   {#3}
    \or:   \regex_class_repeat:nN  {#3}      #5
    \else: \regex_class_repeat:nnN {#3} {#4} #5
    \fi:
  }
\cs_new:Npn \regex_tests_action_cost:n { \regex_action_cost:n }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_class_repeat:n}
%   In case the syntax is \texttt{\{\meta{int}\}}. Greedy and lazy
%   operators are identical, since the number of repetitions is
%   fixed. Build one state for each repetition, with a transition
%   controlled by the tests that we have collected.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_class_repeat:n #1
  {
    \prg_replicate:nn {#1}
      {
        \regex_build_transition:NN
          \regex_tests_action_cost:n \l_regex_right_state_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_class_repeat:nN}
%   In case the syntax is \texttt{\{\meta{int},\}}. The |*| and |+|
%   quantifiers (greedy or lazy) are special cases for $n=0$ or $n=1$.
%   In the case $n=0$, build a costly transition going from the current
%   state to itself, and a free transition moving to a new state. In the
%   case $n\geq 1$, reuse \cs{regex_compile_one_n:} to match $n$
%   repetition, then add free transitions from the last state to the
%   previous one, and from the last state to a new one. The greedy and
%   lazy versions only differ in the order of transitions.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_class_repeat:nN #1#2
  {
    \if_num:w #1 = \c_zero
      \if_meaning:w \c_true_bool #2
        \regex_build_transitions:NNNN
          \regex_action_free:n       \l_regex_right_state_int
          \regex_tests_action_cost:n \l_regex_left_state_int
      \else:
        \regex_build_transitions:NNNN
          \regex_tests_action_cost:n \l_regex_left_state_int
          \regex_action_free:n       \l_regex_right_state_int
      \fi:
    \else:
      \regex_class_repeat:n {#1}
      \int_set_eq:NN \l_regex_internal_a_int \l_regex_left_state_int
      \if_meaning:w \c_true_bool #2
        \regex_build_transitions:NNNN
          \regex_action_free:n \l_regex_right_state_int
          \regex_action_free:n \l_regex_internal_a_int
      \else:
        \regex_build_transitions:NNNN
          \regex_action_free:n \l_regex_internal_a_int
          \regex_action_free:n \l_regex_right_state_int
      \fi:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_class_repeat:nnN}
%   Those functions are called when the syntax is
%   \texttt{\{\meta{int},\meta{int}\}}, or for the |?| quantifier, with
%   $m=0$ and $n=1$.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_class_repeat:nnN #1#2#3
  {
    \regex_class_repeat:n {#1}
    \int_set:Nn \l_regex_internal_a_int
      { \l_regex_right_state_int + #2 }
    \if_meaning:w \c_true_bool #3
      \prg_replicate:nn { #2 }
        {
          \regex_build_transitions:NNNN
            \regex_action_free:n       \l_regex_internal_a_int
            \regex_tests_action_cost:n \l_regex_right_state_int
        }
    \else:
      \prg_replicate:nn { #2 }
        {
          \regex_build_transitions:NNNN
            \regex_tests_action_cost:n \l_regex_right_state_int
            \regex_action_free:n       \l_regex_internal_a_int
        }
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Building groups}
%
% \begin{macro}{\regex_group:nnnN, \regex_group_no_capture:nnnN}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_group:nnnN
  {
    \exp_args:No \regex_group_aux:nnnnnN
      { \int_use:N \l_regex_capturing_group_int }
      { \int_incr:N \l_regex_capturing_group_int }
  }
\cs_new_protected_nopar:Npn \regex_group_no_capture:nnnN
  { \regex_group_aux:nnnnnN { -1 } { } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_group_resetting:nnnN}
%    \begin{macrocode}
\cs_new_protected:Npn \regex_group_resetting:nnnN #1
  {
    \regex_group_aux:nnnnnN { -1 } { }
      {
        \exp_args:Noo \regex_group_resetting_loop:nnNn
          { \int_use:N \l_regex_capturing_group_int }
          { \int_use:N \l_regex_capturing_group_int }
          #1
          { ?? \prg_map_break:n } { }
        \prg_break_point:n { }
      }
  }
\cs_new_protected:Npn \regex_group_resetting_loop:nnNn #1#2#3#4
  {
    \use_none:nn #3 { \int_set:Nn \l_regex_capturing_group_int {#1} }
    \int_set:Nn \l_regex_capturing_group_int {#2}
    #3 {#4}
    \exp_args:Nf \regex_group_resetting_loop:nnNn
      { \int_max:nn {#1} { \l_regex_capturing_group_int } }
      {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_group_aux:nnnN}
%
%    \begin{macrocode}
\cs_new_protected:Npn \regex_group_aux:nnnnnN #1#2#3#4#5#6
  {
%<trace>    \trace_push:nnn { regex } { 1 } { regex_group }
    \if_num:w #4 = \c_zero
      \if_num:w #5 = \c_zero \else:
        \regex_build_transition:NN
          \regex_action_free:n \l_regex_right_state_int
        \int_compare:nNnF
          \l_regex_right_state_int = { \l_regex_left_state_int + \c_one }
          { \ERROR }
      \fi:
    \fi:
    \regex_build_new_state:
    \regex_seq_push_int:NN \l_regex_left_state_seq  \l_regex_left_state_int
    \regex_seq_push_int:NN \l_regex_right_state_seq \l_regex_right_state_int
    #2
    #3
    \regex_seq_pop_int:NN \l_regex_left_state_seq  \l_regex_left_state_int
    \regex_seq_pop_int:NN \l_regex_right_state_seq \l_regex_right_state_int
    \if_case:w - #5 \exp_stop_f:
           \regex_group_repeat:nn   {#1} {#4}
    \or:   \regex_group_repeat:nnN  {#1} {#4}      #6
    \else: \regex_group_repeat:nnnN {#1} {#4} {#5} #6
    \fi:
%<trace>    \trace_pop:nnn { regex } { 1 } { regex_group }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_branch:n}
%
%    \begin{macrocode}
\cs_new_protected:Npn \regex_branch:n #1
  {
%<trace>    \trace_push:nnn { regex } { 1 } { regex_branch }
    \regex_build_new_state:
    \regex_seq_get_int:NN \l_regex_left_state_seq \l_regex_left_state_int
    \regex_toks_put_right:Nx \l_regex_left_state_int
      {
        \regex_action_free:n
          {
            \int_eval:n
              { \l_regex_right_state_int - \l_regex_left_state_int }
          }
      }
    #1
    \int_set_eq:NN \l_regex_left_state_int \l_regex_right_state_int
    \regex_seq_get_int:NN \l_regex_right_state_seq \l_regex_right_state_int
    \regex_toks_put_right:Nx \l_regex_left_state_int
      {
        \regex_action_free:n
          {
            \int_eval:n
              { \l_regex_right_state_int - \l_regex_left_state_int }
          }
      }
%<trace>    \trace_pop:nnn { regex } { 1 } { regex_branch }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_group_submatches:nNN}
%   Once the quantifier is found by \cs{regex_compile_quantifier:w},
%   we insert the code for tracking submatches.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_group_submatches:nNN #1#2#3
  {
    \if_num:w #1 > \c_minus_one
      \regex_toks_put_left:Nx #2 { \regex_action_submatch:n { #1 < } }
      \regex_toks_put_left:Nx #3 { \regex_action_submatch:n { #1 > } }
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_group_repeat:nn}
%   This function is called to repeat a group a fixed number of
%   times. Greedy and lazy operators are identical, since the number of
%   repetitions is fixed. We only record the submatch information at the
%   last repetition; and of course, in the case $n=0$, we do nothing.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_group_repeat:nn #1#2
  {
    \if_num:w #2 > \c_zero
      \regex_group_transition_right_max:
      \regex_group_repeat_aux:n {#2}
      \regex_build_new_state:
      \regex_group_submatches:nNN {#1}
        \l_regex_internal_a_int \l_regex_left_state_int
    \else:
      \l_regex_max_state_int \l_regex_left_state_int %^^A todo: test.
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_group_repeat_aux:n}
%    \begin{macrocode}
\cs_new_protected:Npn \regex_group_repeat_aux:n #1
  {
    \int_set_eq:NN \l_regex_internal_a_int \l_regex_left_state_int
    \int_set_eq:NN \l_regex_internal_b_int \l_regex_max_state_int
    \int_add:Nn \l_regex_right_state_int
      {
        ( #1 - \c_one )
        * ( \l_regex_internal_b_int - \l_regex_internal_a_int )
      }
    \int_set:Nn \l_regex_max_state_int
      {
        \l_regex_internal_a_int
        + (#1) * ( \l_regex_internal_b_int - \l_regex_internal_a_int )
      }
    \int_while_do:nNnn \l_regex_internal_b_int < \l_regex_max_state_int
      {
        \tex_toks:D \l_regex_internal_b_int
          = \tex_toks:D \l_regex_internal_a_int
        \int_incr:N \l_regex_internal_a_int
        \int_incr:N \l_regex_internal_b_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_group_transition_right_max:}
%   The braced quantifiers rely on replicating the states corresponding
%   to the group that has just been built, and joining the right state
%   of each copy to the left state of the next copy. Once this function
%   has been run, \cs{l_regex_internal_a_int} points to the last copy of
%   the initial left-most state, \cs{l_regex_left/right_state_int} have
%   their initial values. Furthermore, \cs{l_regex_max_state_int} is set
%   appropriately to the largest allocated \tn{toks} register plus $1$.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_group_transition_right_max:
  {
    \regex_toks_put_right:Nx \l_regex_right_state_int
      {
        \regex_action_free:n
          {
            \int_eval:n
              { \l_regex_max_state_int - \l_regex_right_state_int }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_group_repeat:nnN}
%   This function is called to repeat a group at least $n$ times.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_group_repeat:nnN #1#2#3
  {
    \if_num:w #2 = \c_zero
      \regex_group_submatches:nNN {#1}
        \l_regex_left_state_int \l_regex_right_state_int
      \int_set:Nn \l_regex_internal_a_int
        { \l_regex_left_state_int - \c_one } %^^A here we need to have shifted.
      \regex_build_transition:NN
        \regex_action_free:n \l_regex_internal_a_int
      \regex_group_put_free:NNNN \c_true_bool #3
        \l_regex_internal_a_int \l_regex_right_state_int
    \else:
      \regex_group_transition_right_max:
      \regex_group_repeat_aux:n {#2}
      \regex_build_new_state:
      \regex_group_put_free:NNNN \c_false_bool #3
        \l_regex_left_state_int \l_regex_internal_a_int
      \regex_group_submatches:nNN {#1}
        \l_regex_internal_a_int \l_regex_left_state_int
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_group_put_free:NNNN}
%   This ought to be given a better name.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_group_put_free:NNNN #1#2#3#4
  {
    \if_meaning:w #1 #2
      \exp_after:wN \regex_toks_put_left:Nx
    \else:
      \exp_after:wN \regex_toks_put_right:Nx
    \fi:
      #3 { \regex_action_free:n { \int_eval:n { #4 - #3 } } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_group_repeat:nnnN}
%   In principle, we could avoid recording submatches for the first |#1|
%   copies of the group, but that forces us to treat specially the case
%   where |#1| is zero, for a limited gain.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_group_repeat:nnnN #1#2#3#4
  {
    \regex_group_submatches:nNN {#1}
      \l_regex_left_state_int \l_regex_right_state_int
    \regex_group_transition_right_max:
    \regex_group_repeat_aux:n { #2 + #3 }
    \if_meaning:w \c_true_bool #4
      \int_set_eq:NN \l_regex_left_state_int \l_regex_max_state_int
      \prg_replicate:nn { #3 }
        {
          \int_sub:Nn \l_regex_left_state_int
            { \l_regex_internal_b_int - \l_regex_internal_a_int }
          \regex_toks_put_left:Nx \l_regex_left_state_int
            {
              \regex_action_free:n
                {
                  \int_eval:n
                    { \l_regex_max_state_int - \l_regex_left_state_int }
                }
            }
        }
    \else:
      \prg_replicate:nn { #3 - \c_one }
        {
          \int_sub:Nn \l_regex_right_state_int
            { \l_regex_internal_b_int - \l_regex_internal_a_int }
          \regex_group_transition_right_max:
        }
      \if_num:w #2 = \c_zero
        \int_set:Nn \l_regex_right_state_int
          { \l_regex_left_state_int - \c_one } % here we need to have shifted.
      \else:
        \int_sub:Nn \l_regex_right_state_int
          { \l_regex_internal_b_int - \l_regex_internal_a_int }
      \fi:
      \regex_group_transition_right_max:
    \fi:
    \regex_build_new_state: %^^A todo: left_state is wrong at this stage.
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Others}
%
% \begin{macro}{\regex_assertion:n}
%
%    \begin{macrocode}
\cs_new_protected:Npn \regex_assertion:n #1
  {
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_left_state_int
      {
        \exp_not:n {#1}
        \regex_break_point:TF
          {
            \regex_action_free:n
              {
                \int_eval:n
                  { \l_regex_right_state_int - \l_regex_left_state_int }
              }
          }
          { }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_command_K:}
%   Make a new state to be on the safe side. In this state, set the
%   beginning-of-match submatch marker to the value of the current
%   index, and go to the new state.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_command_K:
  {
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_left_state_int
      {
        \regex_action_submatch:n { 0< }
        \regex_action_free:n
          {
            \int_eval:n
              { \l_regex_right_state_int - \l_regex_left_state_int }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Matching}
%
% At every index,  we unpack  that array  of active states and
% empty it. Then loop over all active states, and perform the
% instruction  at  that state  of  the \textsc{nfa}.  This can involve
% \enquote{free} transitions to other states,  or transitions
% which  \enquote{consume}  the  current character.  For free
% transitions, the instruction at the new state of the \textsc{nfa} is
% performed.  When a transition consumes a character, the new
% state is put  in the array of \tn{skip} registers:  it will
% be active again when the next character is read.
%
% If two paths through the \textsc{nfa} \enquote{collide} in the sense
% that  they  reach  the  same state  when  reading  a  given
% character, then any future execution  will be identical for
% both.  Hence,  it is indeed enough  to keep track of  which
% states are active. [In the presence of back-references, the
% future execution is affected by how the previous match took
% place;  this  is why we  cannot  support  those non-regular
% features.]
%
% Many of the functions require extracting the submatches for
% the \enquote{best} match.  Execution paths  through the \textsc{nfa}
% are  ordered  by  precedence:  for  instance,  the  regular
% expression \texttt{a?}  creates two paths,  matching either
% an empty token list or a single \texttt{a}; the path matching
% an \texttt{a} has higher precedence. When two paths collide,
% the path with the highest precedence is kept, and the other
% one is discarded. The submatch information for a given path
% is stored  at  the start  of the  \tn{toks} register  which
% holds the state at which that path currently is.
%
% Deciding  to  store  the submatch information  in \tn{toks}
% registers alongside  with states  of the \textsc{nfa}  unfortunately
% implies some shuffling around. The two other options are to
% store the submatch information  in one control sequence per
% path, which wastes csnames, or to store all of the submatch
% information in one property list, which turns out to be too
% slow. A tricky aspect of submatch tracking  is to know when
% to get rid of submatch information.  This naturally happens
% when submatch information  is stored in \tn{toks} registers:
% if  the information  is not moved,  it will be  overwritten
% later.
%
% The presence  of $\epsilon$-transitions  (transitions which
% consume  no character)  leads to  potential  infinite loops;
% for instance the regular expression  |(a??)*| could lead to
% an infinite recursion, where |a??| matches no character, |*|
% loops back to the start of the group,  and |a??| matches no
% character again.  Therefore,  we need to  keep track of the
% states  of  the  \textsc{nfa}  visited  at  the  current step.  More
% precisely,  a state  is marked  as \enquote{visited} if the
% instructions for that state have been inserted in the input
% stream, by setting the corresponding \tn{dimen} register to
% a value which uniquely identifies at which step it was last
% inserted.
%
% \subsubsection{Helpers for running the \textsc{nfa}}
%
% \begin{macro}[aux]{\regex_store_state:n}
%   Put the given state in the array of \tn{skip} registers.
%   This is done by increasing the pointer
%   \cs{l_regex_max_active_int}, and converting the integer
%   to a dimension (suitable for a \tn{skip} assignment) in
%   scaled points.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_store_state:n #1
  {
    \int_incr:N \l_regex_max_active_int
    \tex_skip:D \l_regex_max_active_int #1 sp \scan_stop:
    \regex_store_submatches:n {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_state_use:}
% \begin{macro}[int]{\regex_state_use_with_submatches:}
% \begin{macro}[aux]{\regex_state_use_aux_ii:w}
% \begin{macro}[aux]{\regex_state_use_aux:n}
%   Use a given program instruction, unless it has already been
%   executed at this step. The \tn{toks} registers begin with
%   some submatch information, ignored by \cs{regex_state_use:},
%   but not by \cs{regex_state_use_with_submatches:}.
%   A state is free if it is not marker as taken, namely
%   if the corresponding \tn{dimen} register is not
%   \cs{l_regex_step_int} in \texttt{sp}.
%   The primitive conditional is ended before unpacking
%   the \tn{toks} register.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_state_use_with_submatches:
  { \regex_state_use_aux:n { } }
\cs_new_protected_nopar:Npn \regex_state_use:
  { \regex_state_use_aux:n { \exp_after:wN \use_none_delimit_by_s_stop:w } }
\cs_new_protected:Npn \regex_state_use_aux:n #1
  {
    \if_num:w \tex_dimen:D \l_regex_current_state_int < \l_regex_step_int
      \tex_dimen:D \l_regex_current_state_int
        = \l_regex_step_int sp \scan_stop:
      #1 \tex_the:D \tex_toks:D \exp_after:wN \l_regex_current_state_int
    \fi:
    \scan_stop:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Submatch tracking when running the \textsc{nfa}}
%
% \begin{macro}[int]{\regex_disable_submatches:}
%   Some user functions don't require tracking submatches.
%   We get a performance improvement by simply defining the
%   relevant functions to remove their argument and do nothing
%   with it.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_disable_submatches:
  {
    \cs_set_eq:NN \regex_state_use_with_submatches: \regex_state_use:
    \cs_set_eq:NN \regex_store_submatches:n
      \regex_protected_use_none:n
    \cs_set_eq:NN \regex_action_submatch:n
      \regex_protected_use_none:n
  }
\cs_new_protected:Npn \regex_protected_use_none:n #1 { }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_store_submatches:n}
% \begin{macro}[aux]{\regex_store_submatches_aux:w}
% \begin{macro}[aux]{\regex_store_submatches_aux_ii:Nnnw}
%   The submatch information pertaining to one given thread is moved
%   from state to state as we execute the \textsc{nfa}.
%   We make sure that most of the \tn{toks} register is not read
%   before being assigned again to that same register.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_store_submatches:n #1
  {
    \tex_toks:D #1 \exp_after:wN
      {
        \tex_romannumeral:D
        \exp_after:wN \regex_store_submatches_aux:w
        \tex_the:D \tex_toks:D #1
      }
  }
\cs_new_protected:Npn \regex_store_submatches_aux:w #1 \s_stop
  {
    \regex_store_submatches_aux_ii:Nnnw
      #1
      \regex_state_submatches:nn \c_minus_one \q_prop
    \s_stop
  }
\cs_new_protected:Npn \regex_store_submatches_aux_ii:Nnnw
    \regex_state_submatches:nn #1 #2 #3 \s_stop
  {
    \exp_after:wN \c_zero
    \exp_after:wN \regex_state_submatches:nn \exp_after:wN
      { \int_value:w \int_eval:w \l_regex_step_int + \c_one \exp_after:wN }
      \exp_after:wN { \l_regex_current_submatches_prop }
    \regex_state_submatches:nn {#1} {#2}
    \s_stop
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_state_submatches:nn}
%   This function is inserted by \cs{regex_store_submatches:n}
%   in the \tn{toks} register holding a given state, and it is
%   performed when the state is used.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_state_submatches:nn #1#2
  {
    \if_num:w #1 = \l_regex_step_int
      \tl_set:Nn \l_regex_current_submatches_prop { #2 }
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Matching: framework}
%
% \begin{macro}[int]{\regex_match:n}
%^^A todo: update doc.
%   Then reset a few variables which should be set only once,
%   before the first match, even in the case of multiple matches.
%   Then run the \textsc{nfa} (\cs{regex_match_once:} matches multiple times
%   when appropriate).
%    \begin{macrocode}
\cs_new_protected:Npn \regex_match:n #1
  {
    \int_zero:N \l_regex_nesting_int
    \int_set_eq:NN \l_regex_current_index_int \l_regex_max_state_int
    \regex_query_set:nnn { } { -1 } { -2 }
    \int_set_eq:NN \l_regex_min_index_int \l_regex_current_index_int
    \tl_analysis_map_inline:nn {#1}
      {
        \regex_query_set:nnn {##1} {"##2} {##3}
        \if_case:w "##2 \exp_stop_f:
        \or: \int_incr:N \l_regex_nesting_int
        \or: \int_decr:N \l_regex_nesting_int
        \fi:
      }
    \int_set_eq:NN \l_regex_max_index_int \l_regex_current_index_int
    \regex_query_set:nnn { } { -1 } { -2 }
    \regex_match_initial_setup:
    \regex_match_once:
  }
\cs_new_protected:Npn \regex_query_set:nnn #1#2#3
  {
    \tex_muskip:D \l_regex_current_index_int
      = \etex_gluetomu:D
        #3 sp
        plus #2 sp
        minus \l_regex_nesting_int sp
      \scan_stop:
    \tex_toks:D \l_regex_current_index_int {#1}
    \int_incr:N \l_regex_current_index_int
  }
\cs_new_protected_nopar:Npn \regex_query_get:
  {
    \tl_set:Nx \l_regex_current_token_tl
      { \tex_the:D \tex_toks:D \l_regex_current_index_int }
    \l_regex_current_char_int
      = \etex_mutoglue:D \tex_muskip:D \l_regex_current_index_int
    \l_regex_current_catcode_int = \etex_gluestretch:D
      \etex_mutoglue:D \tex_muskip:D \l_regex_current_index_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_match_once:}
%   Set up more variables in \cs{regex_match_setup:}.
%   If there was a match, use the token list \cs{l_regex_every_match_tl},
%   which may call \cs{regex_match_once:} again to achieve multiple matches.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_match_once:
  {
    \regex_match_setup:
    \regex_query_get:
    \regex_match_loop:
    \prg_break_point:n { }
    \bool_if:NT \l_regex_success_match_bool
      {
        \bool_gset_true:N \g_regex_success_bool
        \l_regex_every_match_tl
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_match_initial_setup:}
%   This function holds the setup that should be done
%   only once for one given pattern matching.
%   It is called only once for the whole token list.
%   On the other hand, \cs{regex_match_setup:}
%   is called for every match in the token list in case of
%   repeated matches.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_match_initial_setup:
  {
    \int_set_eq:NN \l_regex_step_int \c_minus_one
    \prg_stepwise_inline:nnnn
      \c_zero \c_one { \l_regex_max_state_int - \c_one }
      { \tex_dimen:D ##1 \l_regex_step_int sp }
    \int_set:Nn \l_regex_start_index_int
      { \l_regex_min_index_int - \c_one }
    \int_set_eq:NN \l_regex_current_index_int \l_regex_min_index_int
    \int_set_eq:NN \l_regex_success_index_int \l_regex_min_index_int
    \int_set_eq:NN \l_regex_submatch_int \l_regex_max_state_int
    \bool_set_false:N \l_regex_success_empty_bool
    \bool_gset_false:N \g_regex_success_bool
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_match_setup:}
%   Every time a match starts, \cs{regex_match_setup:} resets
%   a few variables.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_match_setup:
  {
    \prop_clear:N \l_regex_current_submatches_prop
    \bool_if:NTF \l_regex_success_empty_bool
      { \cs_set_eq:NN \regex_if_two_empty_matches:F \regex_if_match_empty:F }
      { \cs_set_eq:NN \regex_if_two_empty_matches:F \use:n }
    \int_set_eq:NN \l_regex_start_index_int \l_regex_success_index_int
    \int_set:Nn \l_regex_current_index_int
      { \l_regex_start_index_int - \c_one }
    \bool_set_false:N \l_regex_success_match_bool
    \int_zero:N \l_regex_max_active_int
    \regex_store_state:n {0} %^^A _state_int!
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_match_loop:}
% \begin{macro}[aux]{\regex_match_one_active:n}
% \begin{macro}[aux]{\regex_match_one_active_aux:n}
%   Setup what needs to be reset at every character,
%   then set \cs{l_regex_current_char_int} to the
%   character code of the token that is read
%   (and $-1$ for the end of the token list), and loop
%   over the elements of the \tn{skip} array. Then repeat.
%   There are a couple of tests to stop reading the token list
%   when no active state is left, or when the end is reached.
%   At every step in reading the token list, we store the character
%   code of the current character in \cs{l_regex_current_char_int},
%   unless the end was reached: then we store $-1$.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_match_loop:
  {
    \int_incr:N \l_regex_current_index_int
    \int_incr:N \l_regex_step_int
    \bool_set_false:N \l_regex_fresh_thread_bool
    \int_set_eq:NN \l_regex_last_char_int \l_regex_current_char_int
    \int_set_eq:NN \l_regex_case_changed_char_int \c_max_int
    \regex_query_get:
    \use:x
      {
        \int_zero:N \l_regex_max_active_int
        \regex_match_one_active:w 1 ; \prg_break_point:n { }
        \exp_not:N \prg_break_point:n { }
      }
    \if_num:w \l_regex_current_char_int < \c_minus_one
      \exp_after:wN \prg_map_break:
    \fi:
    \if_num:w \l_regex_max_active_int = \c_zero
      \exp_after:wN \prg_map_break:
    \fi:
    \regex_match_loop:
  }
\cs_new:Npn \regex_match_one_active:w #1;
  {
    \if_num:w #1 > \l_regex_max_active_int
      \exp_after:wN \prg_map_break:
    \fi:
    \regex_match_one_active_aux:n
      { \int_value:w \tex_skip:D #1 }
    \exp_after:wN \regex_match_one_active:w
    \int_use:N \int_eval:w #1 + \c_one ;
  }
\cs_new_protected:Npn \regex_match_one_active_aux:n #1
  {
    \int_set:Nn \l_regex_current_state_int {#1}
    \prop_clear:N \l_regex_current_submatches_prop
    \regex_state_use_with_submatches:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Actions when matching}
%
% \begin{macro}[int]{\regex_action_start_wildcard:}
%: the first state has a free transition to the second
%   state, where the regular expression really begins, and a costly
%   transition to itself, to try again at the next character. ^^A ??
%   The search is made unanchored at the start by putting
%   a free transition to the real start of the \textsc{nfa}, and a
%   costly transition to the same state, waiting for the
%   next token in the query. This combination
%   could be reused (with some changes). We sometimes need
%   to know that the match for a given thread starts at
%   this character. For that, we use the boolean
%   \cs{l_regex_fresh_thread_bool}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_action_start_wildcard:
  {
    \bool_set_true:N \l_regex_fresh_thread_bool
    \regex_action_free:n {1}
    \bool_set_false:N \l_regex_fresh_thread_bool
    \regex_action_cost:n {0}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_action_cost:n}
%   A transition which consumes the current character and moves
%   to state |#1|.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_action_cost:n #1
  {
    \exp_args:Nf \regex_store_state:n
      { \int_eval:n { \l_regex_current_state_int + #1 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_action_success:}
%   There is a successful match when an execution path reaches
%   the end of the regular expression. Then store the current
%   step and submatches. The current step is then interrupted
%   with \cs{prg_map_break:},
%   and only paths with higher precedence are pursued further.
%   The values stored here may be overwritten by a later success
%   of a path with higher precedence.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_action_success:
  {
    \regex_if_two_empty_matches:F
      {
        \bool_set_true:N \l_regex_success_match_bool
        \bool_set_eq:NN \l_regex_success_empty_bool
          \l_regex_fresh_thread_bool
        \int_set_eq:NN \l_regex_success_index_int \l_regex_current_index_int
        \prop_set_eq:NN \l_regex_success_submatches_prop
          \l_regex_current_submatches_prop
        \prg_map_break:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_action_free:n}
%   To copy a thread, check whether the program state has already
%   been used at this character. If not, store submatches in the
%   new state, and insert the instructions for that state in the
%   input stream.
%   Then restore the old value of \cs{l_regex_current_state_int}
%   and of the current submatches.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_action_free:n #1
  {
    \use:x
      {
        \int_add:Nn \l_regex_current_state_int {#1}
        \regex_state_use:
        \int_set:Nn \l_regex_current_state_int
          { \int_use:N \l_regex_current_state_int }
        \tl_set:Nn \exp_not:N \l_regex_current_submatches_prop
          { \exp_not:o \l_regex_current_submatches_prop }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_action_submatch:n}
%   Update the current submatches with the information from the current
%   index.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_action_submatch:n #1
  {
    \prop_put:Nno \l_regex_current_submatches_prop {#1}
      { \int_use:N \l_regex_current_index_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{??}%^^A todo: title
%
% \begin{macro}{\regex_if_match_empty:T, \regex_if_match_empty:F}
%
%    \begin{macrocode}
\cs_new:Npn \regex_if_match_empty:T
  { \int_compare:nNnT \l_regex_start_index_int = \l_regex_current_index_int }
\cs_new:Npn \regex_if_match_empty:F
  { \int_compare:nNnF \l_regex_start_index_int = \l_regex_current_index_int }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Replacement}
%
% \begin{macro}[rEXP]{\regex_submatch_nesting_aux:n}
%    \begin{macrocode}
\cs_new_protected:Npn \regex_submatch_nesting_aux:n #1
  {
    + \etex_glueshrink:D \etex_mutoglue:D \etex_muexpr:D
        \tex_muskip:D \etex_gluestretch:D \tex_skip:D #1
        - \tex_muskip:D \tex_skip:D #1
    \scan_stop:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_replacement:n}
%   Our goal here is to analyse the replacement text. First take care
%   of detecting escaped and non-escaped characters using
%   \cs{regex_escape_use:nnnn} with three protected arguments.
%   This inserts in the input stream a token list of the form
%   \meta{fn 1} \meta{char 1} \ldots{} \meta{fn $N$} \meta{char $N$},
%   where \meta{fn $i$} is one of the three functions, and \meta{char $i$}
%   a character in the string |#1|.
%    \begin{macrocode}
\cs_new:Npn \regex_nesting:n #1 { } %^^A move. Rename?
\tl_new:N \l_regex_nesting_tl
\cs_new_protected:Npn \regex_replacement:n #1
  {
%<trace>    \trace_push:nnn { regex } { 1 } { regex_replacement:n }
    \tl_set_build:Nw \l_regex_internal_a_tl
      \int_zero:N \l_regex_nesting_int
      \tl_clear:N \l_regex_nesting_tl
      \regex_escape_use:nnnn
        { \regex_replacement_unescaped:N ##1 }
        { \regex_replacement_escaped:N ##1 }
        { \tl_build_one:n ##1 }
        {#1}
      \prg_do_nothing: \prg_do_nothing:
      \cs_gset:Npx \regex_nesting:n ##1
        {
          + \int_use:N \l_regex_nesting_int
          \l_regex_nesting_tl
          - \regex_submatch_nesting_aux:n {##1}
        }
    \tl_build_end:
    \use:x
      {
        \exp_not:n { \cs_set:Npn \regex_replacement_tl:n ##1 }
          { \exp_not:o \l_regex_internal_a_tl }
      }
      % ^^A rename!
%<trace>    \trace_pop:nnn { regex } { 1 } { regex_replacement:n }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_replacement_escaped:N}
% \begin{macro}[aux]{\regex_replacement_submatch:w}
% \begin{macro}[aux]{\regex_replacement_submatch_aux:nN}
%    \begin{macrocode}
\cs_new_protected:Npn \regex_replacement_unescaped:N #1
  {
    \if_charcode:w \c_rbrace_str #1
      \if_num:w \l_regex_replacement_csnames_int > \c_zero
        \tl_build_one:n \cs_end:
      \else:
        \tl_build_one:n #1
      \fi:
    \else:
      \tl_build_one:n #1
    \fi:
  }
\cs_new_protected:Npn \regex_replacement_escaped:N #1
  {
    \cs_if_exist_use:cF { regex_replacement_#1:w }
      {
        \if_num:w \c_one < 1#1 \exp_stop_f:
          \regex_replacement_put_submatch:n {#1}
        \else:
          \tl_build_one:n #1
        \fi:
      }
  }
\cs_new_protected:Npn \regex_replacement_put_submatch:n #1
  {
    \tl_build_one:n { \regex_query_submatch:nn {#1} {##1} }
    \if_num:w \l_regex_replacement_csnames_int = \c_zero
      \tl_put_right:Nn \l_regex_nesting_tl
        {
          \exp_not:N \if_num:w #1 < \l_regex_capturing_group_int
            \regex_submatch_nesting_aux:n { \int_eval:w #1+##1 \int_eval_end: }
          \exp_not:N \fi:
        }
    \fi:
  }
\cs_new_protected:Npn \regex_replacement_error:NNN #1#2#3
  {
    \msg_kernel_error:nnxx { regex } { #1-command }
      { replacement~text } {#3}
    #2 #3
  }
\cs_new_protected:Npn \regex_replacement_g:w #1#2
  {
    \str_if_eq:xxTF
      { \exp_not:n { #1#2 } }
      { \regex_replacement_unescaped:N \c_lbrace_str }
      {
        \int_zero:N \l_regex_internal_a_int
        \regex_replacement_g_digits:NN
      }
      { \regex_replacement_error:NNN g #1 #2 }
  }
\cs_new_protected:Npn \regex_replacement_g_digits:NN #1#2
  {
    \token_if_eq_meaning:NNTF #1 \regex_replacement_unescaped:N
      {
        \if_num:w \c_one < 1#2 \exp_stop_f:
          \int_set:Nn \l_regex_internal_a_int { \c_ten * \l_regex_internal_a_int + #2 }
          \exp_after:wN \use_i:nnn
          \exp_after:wN \regex_replacement_g_digits:NN
        \else:
          \if_charcode:w \c_rbrace_str #2
            \exp_args:No \regex_replacement_put_submatch:n
              { \int_use:N \l_regex_internal_a_int }
            \exp_after:wN \exp_after:wN \exp_after:wN \use_none:nn
          \else:
            \exp_after:wN \exp_after:wN
            \exp_after:wN \regex_replacement_error:NNN
            \exp_after:wN \exp_after:wN \exp_after:wN g
          \fi:
        \fi:
      }
      { \regex_replacement_error:NNN g }
    #1 #2
  }
\cs_new_protected:Npn \regex_replacement_u:w #1#2
  {
    \str_if_eq:xxTF { #1#2 } { \regex_replacement_unescaped:N \c_lbrace_str }
      {
        \int_incr:N \l_regex_replacement_csnames_int
        \tl_build_one:n { \exp_not:n { \exp_after:wN \exp_not:V \cs:w } }
      }
      { \regex_replacement_error:NNN u #1#2 }
  }
\cs_new_protected:Npn \regex_replacement_c:w #1#2
  {
    \token_if_eq_meaning:NNTF #1 \regex_replacement_unescaped:N
      {
        \cs_if_exist_use:cF { regex_replacement_c_#2:w }
          { \regex_replacement_error:NNN c #1#2 }
      }
      { \regex_replacement_error:NNN c #1#2 }
  }
\cs_new_protected_nopar:cpn { regex_replacement_c_ \c_lbrace_str :w }
  {
    \int_incr:N \l_regex_replacement_csnames_int
    \tl_build_one:n
      { \exp_not:n { \exp_after:wN \regex_replacement_exp_not:N \cs:w } }
  }
\cs_new:Npn \regex_replacement_exp_not:N #1 { \exp_not:n {#1} }
\group_begin:

  \char_set_catcode_math_superscript:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_U:w
    { \regex_replacement_char:nNN { ^^@ } }

  \char_set_catcode_alignment:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_T:w
    { \regex_replacement_char:nNN { ^^@ } }

  \cs_new_protected:Npn \regex_replacement_c_S:w #1#2
    {
      \int_compare:nNnTF { `#2 } = \c_zero
        { \regex_replacement_error:NNN c #1#2 }
        {
          \char_set_lccode:nn {32} { `#2 }
          \tl_to_lowercase:n { \tl_build_one:n {~} }
        }
    }

  \char_set_catcode_parameter:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_P:w
    { \regex_replacement_char:nNN { ^^@^^@^^@^^@^^@^^@^^@^^@ } }

  \char_set_catcode_other:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_O:w
    { \regex_replacement_char:nNN { ^^@ } }

  \char_set_catcode_math_toggle:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_M:w
    { \regex_replacement_char:nNN { ^^@ } }

  \char_set_catcode_letter:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_L:w
    { \regex_replacement_char:nNN { ^^@ } }

  \char_set_catcode_group_end:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_E:w
    {
      \int_decr:N \l_regex_nesting_int
      \regex_replacement_char:nNN { \if_false: { \fi:  ^^@ }
    }

  \char_set_catcode_math_subscript:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_D:w
    { \regex_replacement_char:nNN { ^^@ } }

  \char_set_catcode_group_begin:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_B:w
    {
      \int_incr:N \l_regex_nesting_int
      \regex_replacement_char:nNN { \exp_after:wN ^^@ \if_false: } \fi: }
    }

  \char_set_catcode_active:N \^^@
  \cs_new_protected_nopar:Npn \regex_replacement_c_A:w
    { \regex_replacement_char:nNN { \exp_not:N ^^@ } }

\group_end:

\cs_new_protected:Npn \regex_replacement_char:nNN #1#2#3
  {
    \char_set_lccode:nn \c_zero { `#3 }
    \tl_to_lowercase:n { \tl_build_one:n { \exp_not:n {#1} } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{User commands}
%
% \subsubsection{Storing compiled patterns}
%
% \begin{macro}{\regex_set:Nn, \regex_gset:Nn, \regex_const:Nn}
%   Compile, then store the result in the user variable with the
%   appropriate assignment function.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_set:Nn #1#2
  {
    \regex_compile:n {#2}
    \tl_set_eq:NN #1 \l_regex_internal_regex
  }
\cs_new_protected_nopar:Npn \regex_gset:Nn #1#2
  {
    \regex_compile:n {#2}
    \tl_gset_eq:NN #1 \l_regex_internal_regex
  }
\cs_new_protected_nopar:Npn \regex_const:Nn #1#2
  {
    \regex_compile:n {#2}
    \tl_const:Nx #1 { \exp_not:o \l_regex_internal_regex }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Generic auxiliary functions}
%
% Most of \pkg{l3regex}'s work is done within a group.
%
% \begin{macro}[aux]{\regex_aux_return:}
%   This function triggers either \cs{prg_return_false:}
%   or \cs{prg_return_true:} as appropriate to whether a
%   match was found or not.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_aux_return:
  {
    \if_meaning:w \c_true_bool \g_regex_success_bool
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_aux_build_match:nn}
%   This auxiliary is used by user functions whose \meta{regex} argument
%   is given as an explicit regular expression within braces. In that
%   case, we need to build the automaton corresponding to that regular
%   expression, then perform the matching on the given token list |#2|.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_aux_build_match:nn #1#2
  {
    \regex_compile:n {#1}
    \regex_use:N \l_regex_internal_regex
    \regex_match:n {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_aux_use_match:Nn}
%   This auxiliary is used by user functions whose \meta{regex} argument
%   is given as a pre-compiled regex variable. We make sure that
%   the token list variable indeed is an automaton (by testing the
%   first token). If not, the match is deemed unsuccessful, after
%   raising an error. If we have an automaton, \enquote{use} it,
%   then perform the matching on the given token list |#2|.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_aux_use_match:Nn #1#2
  {
    \regex_use:N #1
    \regex_match:n {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \regex_extract_once:nnN, \regex_extract_once:NnN,
%     \regex_extract_all:nnN,  \regex_extract_all:NnN,
%     \regex_replace_once:nnN, \regex_replace_once:NnN,
%     \regex_replace_all:nnN,  \regex_replace_all:NnN,
%     \regex_split:nnN,        \regex_split:NnN
%   }
% \begin{macro}[TF]
%   {
%     \regex_extract_once:nnN, \regex_extract_once:NnN,
%     \regex_extract_all:nnN,  \regex_extract_all:NnN,
%     \regex_replace_once:nnN, \regex_replace_once:NnN,
%     \regex_replace_all:nnN,  \regex_replace_all:NnN,
%     \regex_split:nnN,        \regex_split:NnN
%   }
%   We define here $40$ user functions, following a common pattern
%   in terms of an auxiliary such as \cs{regex_extract_once_aux:NnnN}
%   (those auxiliaries are defined in the coming sections).
%   The arguments handed to the auxiliary are
%   \cs{regex_aux_build_match:nn} or \cs{regex_aux_use_match:Nn},
%   followed by the three arguments of the user function.
%   The conditionals call \cs{regex_aux_return:} to return
%   either \texttt{true} or \texttt{false} once matching
%   has been performed.
%    \begin{macrocode}
\cs_set_protected:Npn \regex_tmp:w #1#2#3
  {
    \cs_new_protected_nopar:Npn #1
      { #3 \regex_aux_build_match:nn }
    \cs_new_protected_nopar:Npn #2
      { #3 \regex_aux_use_match:Nn }
    \prg_new_protected_conditional:Npnn #1 ##1##2##3 { T , F , TF }
      {
        #3 \regex_aux_build_match:nn {##1} {##2} ##3
        \regex_aux_return:
      }
    \prg_new_protected_conditional:Npnn #2 ##1##2##3 { T , F , TF }
      {
        #3 \regex_aux_use_match:Nn {##1} {##2} ##3
        \regex_aux_return:
      }
  }
\tl_map_inline:nn
  {
    { extract_once } { extract_all }
    { replace_once } { replace_all }
    { split }
  }
  {
    \exp_args:Nccc \regex_tmp:w
      { regex_#1:nnN } { regex_#1:NnN } { regex_#1_aux:NnnN }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Submatches, once the correct match is found}
%
% \begin{macro}[int]{\regex_extract:}
% \begin{macro}[aux]{\regex_extract_aux_b:wn}
% \begin{macro}[aux]{\regex_extract_aux_e:wn}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_extract:
  {
    \int_set_eq:NN \l_regex_submatch_start_int \l_regex_submatch_int
    \if_meaning:w \c_true_bool \g_regex_success_bool
      \prg_replicate:nn \l_regex_capturing_group_int
        {
          \tex_skip:D \l_regex_submatch_int \c_zero sp \scan_stop:
          \int_incr:N \l_regex_submatch_int
        }
      \prop_map_inline:Nn \l_regex_success_submatches_prop
        {
          \if_num:w ##1 \c_max_int
            \exp_after:wN \regex_extract_aux_b:wn \int_use:N
          \else:
            \exp_after:wN \regex_extract_aux_e:wn \int_use:N
          \fi:
          \int_eval:w \l_regex_submatch_start_int + ##1 {##2}
        }
    \fi:
  }
\cs_new_protected:Npn \regex_extract_aux_b:wn #1 < #2
  {
    \tex_skip:D #1 = #2 sp
      plus \etex_gluestretch:D \tex_skip:D #1 \scan_stop:
  }
\cs_new_protected:Npn \regex_extract_aux_e:wn #1 > #2
  {
    \tex_skip:D #1
      = 1 \tex_skip:D #1 plus #2 sp \scan_stop:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\regex_group_end_extract_seq:N}
% \begin{macro}[aux]{\regex_extract_seq_aux:n}
% \begin{macro}[aux]{\regex_extract_seq_aux:ww}
%    \begin{macrocode}
\cs_new_protected:Npn \regex_group_end_extract_seq:N #1
  {
      \cs_set_eq:NN \seq_item:n \scan_stop:
      \flag_clear:n { regex_begin }
      \flag_clear:n { regex_end }
      \tl_set:Nx \l_regex_internal_a_tl
        {
          \prg_stepwise_function:nnnN
            \l_regex_max_state_int
            \c_one
            { \l_regex_submatch_int - \c_one }
            \regex_extract_seq_aux:n
        }
      \int_compare:nNnF
        { \flag_height:n { regex_begin } + \flag_height:n { regex_end } }
        = \c_zero
        { \msg_kernel_error:nn { regex } { sequence-unbalanced } }
      \tl_set:Nx \l_regex_internal_a_tl { \l_regex_internal_a_tl }
    \exp_args:NNNo \group_end:
    \tl_set:Nn #1 \l_regex_internal_a_tl
  }
\cs_new:Npn \regex_extract_seq_aux:n #1
  {
    \seq_item:n
      {
        \exp_after:wN \regex_extract_seq_aux:ww
        \int_value:w \regex_submatch_nesting_aux:n {#1} ; #1;
      }
  }
\cs_new:Npn \regex_extract_seq_aux:ww #1; #2;
  {
    \if_num:w #1 < \c_zero
      \flag_raise:n { regex_end }
      \prg_replicate:nn {-#1} { \exp_not:n { { \if_false: } \fi: } }
    \fi:
    \regex_query_submatch:w #2;
    \if_num:w #1 > \c_zero
      \flag_raise:n { regex_begin }
      \prg_replicate:nn {#1} { \exp_not:n { \if_false: { \fi: } } }
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Matching}
%
% \begin{macro}[TF]{\regex_match:nn}
% \begin{macro}[TF]{\regex_match:Nn}
% \begin{macro}{\regex_match_aux:n}
%   We don't track submatches. Then either build the \textsc{nfa} corresponding
%   to the regular expression, or use a compiled pattern. Then match,
%   using the internal \cs{regex_match:n}. Finally return the result
%   after closing the group.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \regex_match:nn #1#2 { T , F , TF }
  {
    \regex_match_aux:n
      { \regex_aux_build_match:nn {#1} {#2} }
  }
\prg_new_protected_conditional:Npnn \regex_match:Nn #1#2 { T , F , TF }
  {
    \regex_match_aux:n
      { \regex_aux_use_match:Nn #1 {#2} }
  }
\cs_new_protected:Npn \regex_match_aux:n #1
  {
    \group_begin:
      \tl_clear:N \l_regex_every_match_tl
      \regex_disable_submatches:
      #1
    \group_end:
    \regex_aux_return:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\regex_count:nnN}
% \begin{macro}{\regex_count:NnN}
% \begin{macro}{\regex_count_aux:n}
%   Instead of aborting once the first \enquote{longest match} is found,
%   we repeat the search. The code is such that the search will not
%   start on the same character, hence avoiding infinite loops.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_count:nnN
  { \regex_count_aux:NnnN \regex_aux_build_match:nn }
\cs_new_protected_nopar:Npn \regex_count:NnN
  { \regex_count_aux:NnnN \regex_aux_use_match:Nn }
\cs_new_protected:Npn \regex_count_aux:NnnN #1#2#3#4
  {
    \group_begin:
      \regex_disable_submatches:
      \int_zero:N \l_regex_match_count_int
      \tl_set:Nn \l_regex_every_match_tl
        {
          \int_incr:N \l_regex_match_count_int
          \regex_match_once:
        }
      #1 {#2} {#3}
      \exp_args:NNNo
    \group_end:
    \int_set:Nn #4 { \int_use:N \l_regex_match_count_int }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Submatch extraction}
%
% \begin{macro}[aux]{\regex_extract_once_aux:NnnN}
%   As announced, here comes the auxiliary for extracting one match.
%   Since we only want one match, \cs{l_regex_every_match_tl}
%   is empty, and does not trigger the matching code again.
%   After matching, \cs{regex_extract:} extracts submatches
%   into various \tn{skip} registers, and those are then concatenated
%   into a sequence by \cs{regex_group_end_extract_seq:N}. That function
%   is also responsible for closing the group.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_extract_once_aux:NnnN #1#2#3#4
  {
    \group_begin:
      \tl_set:Nn \l_regex_every_match_tl { \regex_extract: }
      #1 {#2} {#3}
      \regex_group_end_extract_seq:N #4
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_extract_all_aux:NnnN}
%   The set of submatches will be built progressively
%   in \cs{l_regex_result_seq}. For each match, extract
%   the submatches, and concatenate that to the right of
%   the result sequence, then start matching again.
%   Finally, copy the result in the user's sequence variable.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_extract_all_aux:NnnN #1#2#3#4
  {
    \group_begin:
      \tl_set:Nn \l_regex_every_match_tl
        { \regex_extract: \regex_match_once: }
      #1 {#2} {#3}
      \regex_group_end_extract_seq:N #4
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Splitting a token list by matches of a regex}
%
% \begin{macro}[aux]{\regex_split_aux:NnnN}
%   Recurse through the matches, and for each, do the following.
%   Extract the submatches into various \tn{skip} registers,
%   then replace the match |\0|, which should not be kept in the
%   final result, and replace it by the part of the token list
%   before the match.
%   This process must be inhibited to avoid creating empty items
%   if the regex matched an empty token list at the place where
%   the match attempt started.
%   After the last successful match, we need to add to the result
%   the part of the token list after the last match, unless the
%   last match was empty and at the very end.
%   Finally, \cs{regex_group_end_extract_seq:N} builds a sequence
%   from all the \tn{skip} registers, and assigns it to |#4|
%   after closing the group.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_split_aux:NnnN #1#2#3#4
  {
    \group_begin:
      \tl_set:Nn \l_regex_every_match_tl
        {
          \if_num:w \l_regex_start_index_int < \l_regex_success_index_int
            \regex_extract:
            \tex_skip:D \l_regex_submatch_start_int
              = \l_regex_start_index_int sp
                plus \tex_skip:D \l_regex_submatch_start_int \scan_stop:
          \fi:
          \regex_match_once:
        }
      #1 {#2} {#3}
      \tex_skip:D \l_regex_submatch_int
        = \l_regex_start_index_int sp
          plus \l_regex_current_index_int sp \scan_stop:
      \int_incr:N \l_regex_submatch_int
      \if_num:w \l_regex_start_index_int = \l_regex_current_index_int
        \if_meaning:w \c_true_bool \l_regex_success_empty_bool
          \int_decr:N \l_regex_submatch_int
        \fi:
      \fi:
      \regex_group_end_extract_seq:N #4
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Replacement}
%
% \begin{macro}[aux]{\regex_replace_once_aux:NnnN}
%   The replacement text is analysed by \cs{regex_replacement:n},
%   which defines \cs{regex_replacement_tl:n} to expand to the
%   replaced token list, assuming that submatches are stored in
%   various \tn{skip} registers, as done by \cs{regex_extract:}.
%   If there is a match, we grab
%   the parts before and after it, and get the result
%   by \texttt{x}-expanding twice.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_replace_once_aux:NnnN #1#2#3#4
  {
    \group_begin:
      \tl_clear:N \l_regex_every_match_tl
      \regex_replacement:n {#3}
      \exp_args:Nno #1 {#2} #4
      \if_meaning:w \c_true_bool \g_regex_success_bool
        \regex_extract:
        \int_set:Nn \l_regex_internal_a_int
          { \regex_nesting:n { \l_regex_submatch_start_int } }
        \if_num:w \l_regex_internal_a_int = \c_zero
        \else:
          \msg_kernel_error:nnx { regex } { replace-unbalanced }
            { \l_regex_internal_a_int }
        \fi:
        \tl_set:Nx \l_regex_internal_a_tl
          {
            \if_num:w \l_regex_internal_a_int < \c_zero
              \prg_replicate:nn { - \l_regex_internal_a_int }
                { \exp_not:n { { \if_false: } \fi: } }
            \fi:
            \regex_toks_range:nn
              { \l_regex_min_index_int }
              { \tex_skip:D \l_regex_submatch_start_int }
            \regex_replacement_tl:n { \l_regex_submatch_start_int }
            \regex_toks_range:nn
              { \etex_gluestretch:D \tex_skip:D \l_regex_submatch_start_int }
              { \l_regex_max_index_int }
            \if_num:w \l_regex_internal_a_int > \c_zero
              \prg_replicate:nn { \l_regex_internal_a_int }
                { \exp_not:n { \if_false: { \fi: } } }
            \fi:
          }
        \tl_set:Nx \l_regex_internal_a_tl { \l_regex_internal_a_tl }
        \exp_args:NNNo \group_end:
        \tl_set:Nn #4 \l_regex_internal_a_tl
      \else:
        \group_end:
      \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_replace_all_aux:NnnN}
%   For every match, extract submatches, and add the part before
%   the beginning of the match, as well as the replacement,
%   to the result. After the last match, extract the end
%   of the token list, and add it to the replaced token list.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_replace_all_aux:NnnN #1#2#3#4
  {
    \group_begin:
      \tl_set:Nn \l_regex_every_match_tl
        {
          \regex_extract:
          \tex_skip:D \l_regex_submatch_start_int
            = \tex_the:D \tex_skip:D \l_regex_submatch_start_int
              minus \l_regex_start_index_int sp \scan_stop:
          \regex_match_once:
        }
      \regex_replacement:n {#3}
      \exp_args:Nno #1 {#2} #4
      \int_set:Nn \l_regex_internal_a_int
        {
          0
          \prg_stepwise_function:nnnN
            \l_regex_max_state_int
            \l_regex_capturing_group_int
            { \l_regex_submatch_int - \c_one }
            \regex_nesting:n
        }
      \if_num:w \l_regex_internal_a_int = \c_zero
      \else:
        \msg_kernel_error:nnx { regex } { replace-unbalanced }
          { \l_regex_internal_a_int }
      \fi:
      \tl_set:Nx \l_regex_internal_a_tl
        {
          \if_num:w \l_regex_internal_a_int < \c_zero
            \prg_replicate:nn { - \l_regex_internal_a_int }
              { \exp_not:n { { \if_false: } \fi: } }
          \fi:
          \prg_stepwise_function:nnnN
            \l_regex_max_state_int
            \l_regex_capturing_group_int
            { \l_regex_submatch_int - \c_one }
            \regex_replace_all_aux:n
          \regex_toks_range:nn
            \l_regex_start_index_int \l_regex_max_index_int
          \if_num:w \l_regex_internal_a_int > \c_zero
            \prg_replicate:nn { \l_regex_internal_a_int }
              { \exp_not:n { \if_false: { \fi: } } }
          \fi:
        }
      \tl_set:Nx \l_regex_internal_a_tl { \l_regex_internal_a_tl }
    \exp_args:NNNo \group_end:
    \tl_set:Nn #4 \l_regex_internal_a_tl
  }
\cs_new:Npn \regex_replace_all_aux:n #1
  {
    \regex_toks_range:nn
      { \etex_glueshrink:D \tex_skip:D #1 } { \tex_skip:D #1 }
    \regex_replacement_tl:n {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Showing regexes}
%
% \begin{macro}{\regex_show:N, \regex_show:n}
%   User functions: the \texttt{n} variant requires compilation first.
%   Then show the variable with some appropriate text.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_show:n #1
  {
    \regex_compile:n {#1}
    \regex_show_aux:Nx \l_regex_internal_regex
      { { \tl_to_str:n {#1} } }
  }
\cs_new_protected:Npn \regex_show:N #1
  { \regex_show_aux:Nx #1 { variable~\token_to_str:N #1 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_show_aux:Nx}
%   Within a \cs{tl_set_build:Nw} \ldots{} \cs{tl_build_end:} group, we
%   redefine all the function that can appear in a compiled regex, then
%   run the regex. The result is then shown.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_show_aux:Nx #1#2
  {
    \tl_set_build:Nw \l_regex_internal_a_tl
      \cs_set_nopar:Npn \regex_branch:n
        {
          \seq_pop_right:NN \l_regex_show_prefix_seq \l_regex_internal_a_tl
          \regex_show_one:n { +-branch }
          \seq_put_right:No \l_regex_show_prefix_seq \l_regex_internal_a_tl
          \use:n
        }
      \cs_set_eq:NN \regex_assertion:n \use:n
      \cs_set_nopar:Npn \regex_group:nnnN
        { \regex_show_group_aux:nnnnN { } }
      \cs_set_nopar:Npn \regex_group_no_capture:nnnN
        { \regex_show_group_aux:nnnnN { ~(no~capture) } }
      \cs_set_nopar:Npn \regex_group_resetting:nnnN
        { \regex_show_group_aux:nnnnN { ~(resetting) } }
      \cs_set_eq:NN \regex_class:NnnnN \regex_show_class:NnnnN
      \cs_set_nopar:Npn \regex_item_caseful_equal:n ##1
        { \regex_show_one:n { char~code~\int_eval:n{##1} } }
      \cs_set_nopar:Npn \regex_item_caseful_range:nn ##1##2
        { \regex_show_one:n { range~[\int_eval:n{##1}, \int_eval:n{##2}] } }
      \cs_set_nopar:Npn \regex_item_caseless_equal:n ##1
        { \regex_show_one:n { char~code~\int_eval:n{##1}~(caseless) } }
      \cs_set_nopar:Npn \regex_item_caseless_range:nn ##1##2
        {
          \regex_show_one:n
            { Range~[\int_eval:n{##1}, \int_eval:n{##2}]~(caseless) }
        }
      \cs_set:Npn \regex_item_catcode:nT ##1
        { \regex_item_catcode:nNT {##1} \c_true_bool }
      \cs_set_eq:NN \regex_item_catcode:nNT \regex_show_item_catcode:nNT
      \cs_set_nopar:Npn \regex_item_reverse:n
        { \regex_show_scope:nn { Reversed~match } }
      \cs_set_nopar:Npn \regex_item_exact:nn ##1##2
        { \regex_show_one:n { char~##2,~catcode~##1 } }
      \cs_set:Npn \regex_item_exact_cs:N ##1
        { \regex_show_one:n { control~sequence~\token_to_str:N ##1 } }
      \cs_set_nopar:Npn \regex_item_cs:n
        { \regex_show_scope:nn { control~sequence } }
      \cs_set_eq:NN \regex_item_anchor:N \regex_show_item_anchor:N
      \cs_set_nopar:Npn \regex_item_b:
        { \regex_show_one:n { word~boundary } }
      \cs_set_nopar:Npn \regex_item_B:
        { \regex_show_one:n { not~word~boundary } }
      \cs_set_nopar:Npn \regex_command_K:
        { \regex_show_one:n { reset~match~start~(\iow_char:N\\K) } }
      \seq_clear:N \l_regex_show_prefix_seq
      \regex_show_push:n { ~ }
      #1
    \tl_build_end:
    \msg_aux_show:x { > Compiled~regex~#2: \l_regex_internal_a_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_show_one:n}
%   Every part of the final message go through this function, which adds
%   one line to the output, with the apropriate prefix.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_show_one:n #1
  {
    \int_incr:N \l_regex_show_lines_int
    \tl_build_one:x
      { \iow_newline: \seq_use:N \l_regex_show_prefix_seq #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]
%   {\regex_show_push:n, \regex_show_pop:, \regex_show_scope:nn}
%   Enter and exit levels of nesting. The \texttt{scope} function prints
%   its first argument as an \enquote{introduction}, then performs its
%   second argument in a deeper level of nesting.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_show_push:n #1
  { \seq_put_right:Nx \l_regex_show_prefix_seq { #1 ~ } }
\cs_new_protected:Npn \regex_show_pop:
  { \seq_pop_right:NN \l_regex_show_prefix_seq \l_regex_internal_a_tl }
\cs_new_protected:Npn \regex_show_scope:nn #1#2
  {
    \regex_show_one:n {#1}
    \regex_show_push:n { ~ }
    #2
    \regex_show_pop:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_show_group_aux:nnnnN}
%   We display all groups in the same way, simply adding a message,
%   \texttt{(no capture)} or \texttt{(resetting)}, to special groups.
%   The odd \cs{use_ii:nn} avoids printing a spurious \texttt{+-branch}
%   for the first branch.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_show_group_aux:nnnnN #1#2#3#4#5
  {
    \regex_show_one:n { ,-group~begin #1 }
    \regex_show_push:n { | }
    \use_ii:nn #2
    \regex_show_pop:
    \regex_show_one:n
      { `-group~end \regex_msg_repeated:nnN {#3} {#4} #5 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_show_class:NnnnN}
%   I'm entirely unhappy about this function: I couldn't find a way to
%   test if a class is a single test. Instead, collect the
%   representation of the tests in the class. If that had more than one
%   line, write \texttt{Match} or \texttt{Don't match} on its own line,
%   with the repeating information if any. Then the various tests on
%   lines of their own, and finally a line. Otherwise, we need to
%   evaluate the representation of the tests again (since the prefix is
%   incorrect). That's clunky, but not too expensive, since it's only
%   one test.
%    \begin{macrocode}
\cs_set:Npn \regex_show_class:NnnnN #1#2#3#4#5
  {
    \tl_set_build:Nw \l_regex_internal_a_tl
      \int_zero:N \l_regex_show_lines_int
      \regex_show_push:n {~}
      #2
      \exp_last_unbraced:Nf
    \prg_case_int:nnn { \l_regex_show_lines_int }
      {
        {0}
          {
            \tl_build_end:
            \regex_show_one:n { \bool_if:NTF #1 { Fail } { Pass } }
          }
        {1}
          {
            \tl_build_end:
            #2
            \tl_build_one:n { \regex_msg_repeated:nnN {#3} {#4} #5 }
          }
      }
      {
        \tl_build_end:
        \regex_show_one:n
          {
            \bool_if:NTF #1 { M } { Don't~m } atch
            \regex_msg_repeated:nnN {#3} {#4} #5
          }
        \tl_build_one:o \l_regex_internal_a_tl
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_show_item_anchor:N}
%   The argument is an integer telling us where the anchor is. We
%   convert that to the relevant info.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_show_item_anchor:N #1
  {
    \regex_show_one:n
      {
        anchor~at~
        \prg_case_str:nnn { #1 }
          {
            { \l_regex_min_index_int   } { start~(\iow_char:N\\A) }
            { \l_regex_start_index_int } { start~of~match~(\iow_char:N\\G) }
            { \l_regex_max_index_int   } { end~(\iow_char:N\\Z) }
          }
          { <error:~'#1'~not~recognized> }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_show_item_catcode:nNT}
%    \begin{macrocode}
\cs_new_protected:Npn \regex_show_item_catcode:nNT #1#2
  {
    \int_set:Nn \l_regex_internal_a_int {#1}
    \tl_clear:N \l_regex_internal_a_tl
    \tl_map_inline:nn { CBEMTPUDSLOA }
      {
        \int_if_odd:nT
          {
            \l_regex_internal_a_int
            / \int_use:c { c_regex_catcode_##1_int }
          }
          { \tl_put_right:Nn \l_regex_internal_a_tl {##1} }
      }
    \regex_show_scope:nn
      {
        categories~\l_regex_internal_a_tl, ~
        \bool_if:NF #2 { negative~ } class
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
% Messages for the preparsing phase.
%    \begin{macrocode}
\msg_kernel_new:nnnn { regex } { trailing-backslash }
  { Trailing~escape~character~\iow_char:N\\. }
  {
    A~regular~expression~or~its~replacement~text~ends~with~
    the~escape~character~\iow_char:N\\.~It~will~be~ignored.
  }
\msg_kernel_new:nnnn { regex } { x-missing-rbrace }
  { Missing~closing~brace~in~\iow_char:N\\x~hexadecimal~sequence. }
  {
    You~wrote~something~like~
    `\iow_char:N\\x\{\int_to_hexadecimal:n{#1}'.~
    The~closing~brace~is~missing.
  }
\msg_kernel_new:nnnn { regex } { x-overflow }
  { Character~code~'#1'~too~large~in~\iow_char:N\\x~hexadecimal~sequence. }
  {
    You~wrote~something~like~
    `\iow_char:N\\x\{\int_to_hexadecimal:n{#1}\}'.~
    The~character~code~'#1'~is~larger~than~\int_use:N \c_max_char_int.
  }
%    \end{macrocode}
%
% Invalid quantifier.
%    \begin{macrocode}
\msg_kernel_new:nnnn { regex } { invalid-quantifier }
  { Braced~quantifier~'#1'~may~not~be~followed~by~'#2'. }
  {
    The~character~'#2'~is~invalid~in~the~braced~quantifier~'#1'.~
    The~only~valid~quantifiers~are~'*',~'?',~'+',~'{<int>}',~
    '{<min>,}'~and~'{<min>,<max>}',~followed~or~not~by~'?'.
  }
%    \end{macrocode}
%
% Messages for missing or extra closing brackets and parentheses, with
% some fancy singular/plural handling for the case of parentheses.
%    \begin{macrocode}
\msg_kernel_new:nnnn { regex } { missing-rbrack }
  { Missing~right~bracket~inserted~in~regular~expression. }
  {
    LaTeX~was~given~a~regular~expression~where~a~character~class~
    was~started~with~'[',~but~the~matching~']'~is~missing.
  }
\msg_kernel_new:nnnn { regex } { missing-rparen }
  {
    Missing~right~parenthes\int_compare:nTF{#1=1}{i}{e}s~
    inserted~in~regular~expression.
  }
  {
    LaTeX~was~given~a~regular~expression~with~\int_eval:n{#1}~
    more~left~parenthes\int_compare:nTF{#1=1}{i}{e}s~than~right~
    parenthes\int_compare:nTF{#1=1}{i}{e}s.
  }
\msg_kernel_new:nnnn { regex } { extra-rparen }
  { Extra~right~parenthesis~ignored~in~regular~expression. }
  {
    LaTeX~came~across~a~closing~parenthesis~when~no~submatch~group~
    was~open.~The~parenthesis~will~be~ignored.
  }
%    \end{macrocode}
%
% Some escaped alphanumerics are not allowed everywhere.
%    \begin{macrocode}
\msg_kernel_new:nnnn { regex } { bad-escape }
  {
    Invalid~escape~\c_backslash_str #1~
    \regex_if_in_class:TF { in~a~character~class. }
      {
        \regex_if_within_cs:TF
          { within~a~control~sequence. }
          { following~a~category~test. }
      }
  }
  {
    The~escape~sequence~\iow_char:N\\#1~may~not~appear~
    \regex_if_in_class:TF { within~a~character~class.~ }
      {
        \regex_if_within_cs:TF
          {
            within~a~control~sequence~test~introduced~by~
            \iow_char:N\\c\iow_char:N\{.~
          }
          {
            following~a~category~test~such~as~\iow_char:N\\cL~or~
            \iow_char:N\\c[\iow_char:N\^BE].~
          }
      }
  }
%    \end{macrocode}
%
% Range errors.
%    \begin{macrocode}
\msg_kernel_new:nnnn { regex } { range-missing-end }
  { Invalid~end-point~for~range~'#1-#2'~in~character~class. }
  {
    The~end-point~'#2'~of~the~range~'#1-#2'~may~not~serve~as~an~
    end-point~for~a~range:~alphanumeric~characters~should~not~be~
    escaped,~and~non-alphanumeric~characters~should~be~escaped.
  }
\msg_kernel_new:nnnn { regex } { range-backwards }
  { Range~[#1-#2]~out~of~order~in~character~class. }
  {
    In~ranges~of~characters~[x-y]~appearing~in~character~classes,~
    the~first~character~code~must~not~be~larger~than~the~second.~
    Here,~#1~has~character~code~\int_eval:n {`#1},~while~#2~has~
    character~code~\int_eval:n {`#2}.
  }
%    \end{macrocode}
%
% Errors related to |\c| and |\u|.
%    \begin{macrocode}
\msg_kernel_new:nnnn { regex } { c-bad-mode }
  { Invalid~nested~\iow_char:N\\c~escape~in~regular~expression. }
  {
    The~\iow_char:N\\c~escape~cannot~be~used~within~
    a~control~sequence~test~'\iow_char:N\\c{...}'.~
    To~combine~several~category~tests,~use~'\iow_char:N\\c[...]'.
  }
\msg_kernel_new:nnnn { regex } { c-missing-rbrace }
  { Missing~right~brace~inserted~for~\iow_char:N\\c~escape. }
  {
    LaTeX~was~given~a~regular~expression~where~a~
    '\iow_char:N\\c\iow_char:N\{...'~construction~was~not~ended~
    with~a~closing~brace~'\iow_char:N\}'.
  }
\msg_kernel_new:nnnn { regex } { c-missing-rbrack }
  { Missing~right~bracket~inserted~for~\iow_char:N\\c~escape. }
  {
    A~construction~'\iow_char:N\\c[...'~appears~in~a~
    regular~expression,~but~the~closing~']'~is~not~present.
  }
\msg_kernel_new:nnnn { regex } { c-missing-category }
  { Invalid~character~'#1'~following~\iow_char:N\\c~escape. }
  {
    In~regular~expressions,~the~\iow_char:N\\c~escape~sequence~
    may~only~be~followed~by~a~left~brace,~a~left~bracket,~or~a~
    capital~letter~representing~a~character~category,~namely~
    one~of~ABCDELMOPSTU.
  }
\msg_kernel_new:nnnn { regex } { u-missing-lbrace }
  { Missing~left~brace~following~\iow_char:N\\u~escape. }
  {
    The~\iow_char:N\\u~escape~sequence~must~be~followed~by~
    a~brace~group~with~the~name~of~the~variable~to~use.
  }
\msg_kernel_new:nnnn { regex } { u-missing-rbrace }
  { Missing~right~brace~inserted~for~\iow_char:N\\u~escape. }
  {
    LaTeX~
    \tl_if_empty:xTF {#2}
      { reached~the~end~of~the~string~ }
      { encountered~an~escaped~alphanumeric~character '\iow_char:N\\#2'~ }
    when~parsing~the~argument~of~an~'\iow_char:N\\u\iow_char:N\{...\}'~escape.
  }
%    \end{macrocode}
%
% Errors when encountering the \textsc{posix} syntax |[:...:]|.
%    \begin{macrocode}
\msg_kernel_new:nnnn { regex } { posix-unsupported }
  { POSIX~collating~element~'[#1 ~ #1]'~not~supported. }
  {
    The~[.foo.]~and~[=bar=]~syntaxes~have~a~special~meaning~in~POSIX~
    regular~expressions.~This~is~not~supported~by~LaTeX.~Maybe~you~
    forgot~to~escape~a~left~bracket~in~a~character~class?
  }
\msg_kernel_new:nnnn { regex } { posix-unknown }
  { POSIX~class~[:#1:]~unknown. }
  {
    [:#1:]~is~not~among~the~known~POSIX~classes~
    [:alnum:],~[:alpha:],~[:ascii:],~[:blank:],~
    [:cntrl:],~[:digit:],~[:graph:],~[:lower:],~
    [:print:],~[:punct:],~[:space:],~[:upper:],~
    [:word:],~and~[:xdigit:].
  }
\msg_kernel_new:nnnn { regex } { posix-missing-close }
  { Missing~closing~':]'~for~POSIX~class. }
  { The~POSIX~syntax~'#1'~must~be~followed~by~':]',~not~'#2'. }
%    \end{macrocode}
%
% In various cases, the result of a \pkg{l3regex} operation can leave us
% with an unbalanced token list, which we must re-balance by adding
% begin-group or end-group character tokens.
%    \begin{macrocode}
\msg_kernel_new:nnnn { regex } { sequence-unbalanced }
  {
    Missing~
    \flag_if_raised:nTF { regex_end }
      {
        left~
        \flag_if_raised:nTF { regex_begin }
          { and~right~braces } { brace }
      }
      { right~brace }
    \ inserted~in~extracted~match.
  }
  {
    LaTeX~was~asked~to~extract~submatches~or~split~a~token~list~
    according~to~a~given~regular~expression,~but~some~of~the~resulting~
    items~were~not~balanced.
  }
\msg_kernel_new:nnnn { regex } { replace-unbalanced }
  { The~result~of~a~replacement~does~not~have~balanced~braces. }
  {
    LaTeX~was~asked~to~do~some~regular~expression~replacement,~
    and~the~resulting~token~list~would~not~have~the~same~number~
    of~begin-group~and~end-group~tokens. \\ \\
    \ \ \ \
    \prg_case_int:nnn {#1}
      {
        { -1 } { A~left~brace~was }
        {  1 } { A~right~brace~was }
      }
      {
        \int_abs:n {#1} ~
        \int_compare:nNnTF {#1} < \c_zero { left } { right } ~
        braces ~ were
      }
    \ inserted.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_kernel_new:nnnn { regex } { c-command }
  { Misused~\iow_char:N\\c~or\iow_char:N\\C~command~in~a~#1. }
  {
    In~a~#1,~the~\iow_char:N\\C~escape~sequence~
    can~be~followed~by~one~of~the~letters~ABCDELMOPSTU~
    or~a~brace~group,~not~by~'#2'.
  }
\msg_kernel_new:nnnn { regex } { unknown-option }
  { Unknown~option~`#1'~for~regular~expressions. }
  {
    LaTeX~came~across~something~like~`(?#1)'~in~a~regular~expression,~
    but~the~option~`#1'~is~not~known.~It~will~be~ignored.
  }
\msg_kernel_new:nnnn { regex } { invalid-in-option }
  { Invalid~character~in~option~of~a~regular~expression. }
  {
    The~character~or~escape~sequence~`#1'~is~not~defined~
    as~an~option~within~regular~expressions.
  }
\msg_kernel_new:nnnn { regex } { g-command }
  { Missing~brace~for~the~\iow_char:N\\g~construction~in~a~replacement~text. }
  {
    In~the~replacement~text~for~a~regular~expression~search,~
    submatches~are~represented~either~as~\iow_char:N \\g{dd..d},~
    or~\\d,~where~`d'~are~single~digits.~Here,~a~brace~is~missing.
  }
%    \end{macrocode}
%
% \begin{macro}[aux]{\regex_msg_repeated:nnN}
%   This is not technically a message, but seems related enough to go
%   there. The arguments are: |#1| is the minimum number of repetitions;
%   |#2| is the number of allowed extra repetitions ($-1$ for infinite
%   number), and |#3| tells us aboud lazyness.
%    \begin{macrocode}
\cs_new:Npn \regex_msg_repeated:nnN #1#2#3
  {
    \str_if_eq:xxF { #1 #2 } { 1 0 }
      {
        , ~ repeated ~
        \prg_case_int:nnn {#2}
          {
            { -1 } { #1~or~more~times,~\bool_if:NTF #3 { lazy } { greedy } }
            {  0 } { #1~times }
          }
          {
            between~#1~and~\int_eval:n {#1+#2}~times,~
            \bool_if:NTF #3 { lazy } { greedy }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% ^^A \end{todo}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \endinput
%^^A NOT IMPLEMENTED
%^^A    \p{xx}     a character with the xx property
%^^A    \P{xx}     a character without the xx property
%^^A    [[:xxx:]]  positive POSIX named set
%^^A    [[:^xxx:]] negative POSIX named set
%^^A    (?=...)    positive look ahead
%^^A    (?!...)    negative look ahead
%^^A    (?<=...)   positive look behind
%^^A    (?<!...)   negative look behind
%^^A    (?<name>...) or (?'name'...) or (?P<name>...)
%^^A               named capturing group
%^^A    \R         a newline sequence
%^^A    \X         an extended Unicode sequence
%^^A    (?C) or (?Cn)   callout with data n
%^^A    (?R)            recurse whole pattern
%^^A    (?[+-]n) or \g<[+-]n> or (?&name) or (?P>name) or \g<name>
%^^A                    call subpattern
%^^A    (?([+-]n)... or (?(<name>)...
%^^A                    reference condition
%^^A    (?(R)... or (?(Rn)... or (?(R&name)...
%^^A                    recursion condition
%^^A    (?(DEFINE)...   define subpattern for reference
%^^A    (?(assert)...   assertion condition
%^^A    (*ACCEPT)       force successful match
%^^A    (*FAIL)         force backtrack; synonym (*F)
%^^A    (*COMMIT)       overall failure, no advance of starting point
%^^A    (*PRUNE)        advance to next starting character
%^^A    (*SKIP)         advance start to current matching position
%^^A    (*THEN)         local failure, backtrack to next alternation
%^^A    (*CR) or (*LF) or (*CRLF) or (*ANYCRLF) or (*ANY)
%^^A                    newline convention
%^^A    (*BSR_ANYCRLF) or (*BSR_UNICODE)
%^^A                    change what \R matches.
%^^A
%^^A    \cx             "control-x", where x is any ASCII character
%^^A    \C              one byte, even in UTF-8 mode (best avoided)
%^^A    +               possessive quantifiers
%^^A    (?>...)         atomic, non-capturing group
%^^A    (?#....)        comment (not nestable)
%^^A    (?JmsUx)        options (duplicate names; multiline; single line;
%^^A                      ungreedy; extended)
%^^A    (*NO_START_OPT) no start-match optimization (PCRE_NO_START_OPTIMIZE)
%^^A    (*UTF8)         set UTF-8 mode (PCRE_UTF8)
%^^A    (*UCP)          set PCRE_UCP (use Unicode properties for \d etc)
%^^A    \n or \gn or \g{[-]n} or \g{name} or (?P=name)
%^^A    or \k<name> or \k'name' or \k{name}
%^^A                    back-references
