% \iffalse
%
%% File l3fp-symbolic.dtx (C) Copyright 2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental symbolic expressions}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3fp-symbolic} package\\ Symbolic expressions^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3fp-symbolic} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=fp>
%    \end{macrocode}
%
% \subsection{Misc}
%
% \begin{variable}[int]{\l_@@_internal_fp}
%   Scratch floating point.
%    \begin{macrocode}
\fp_new:N \l_@@_internal_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[EXP, int]{\@@_parse_exp_after_array_f:w}
% \begin{macro}[EXP, aux]{\@@_parse_exp_after_stop_f:nw}
%   This is analogous to \cs{@@_exp_after_array_f:w}, but it uses
%   |\__fp_parse_exp_after| functions.  In particular, a symbolic
%   expression is re-evaluated.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_exp_after_array_f:w #1
  {
    \cs:w @@_parse_exp_after \@@_type_from_scan:N #1 _f:nw \cs_end:
      { \@@_parse_exp_after_array_f:w }
    #1
  }
\cs_new_eq:NN \@@_parse_exp_after_stop_f:nw \use_none:nn
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Building blocks for expressions}
%
% Every symbolic expression has the form
% \begin{quote}
%   \cs{s_@@_symbolic} \cs{@@_symbolic_chk:w}
%   \cs{@@_\meta{op}_o:w} \Arg{arguments} |;|
% \end{quote}
% where the \meta{op} is an operation (|infix_+|, |infix_/|, |prefix_-|,
% |prefix_sin|, \ldots{}), and \meta{arguments} is an array of floating
% points or symbolic expressions, with the number of items expected for
% the given operation.  Variables are stored with a \meta{op} of
% |variable_|\meta{name}, with an empty \meta{argument} (the brace group
% is still there, though).
%
% Symbolic expressions are stored in a prefix form.  When encountering a
% symbolic expression in a floating point computation, we attempt to
% evaluate the operands as much as possible, and if that yields floating
% point numbers rather than expressions, we apply the operator which
% follows (if the function is known).
%
% For instance, the expression "a + b * sin(c)" is stored as
% \begin{verbatim}
% \s__fp_symbolic \__fp_symbolic_chk:w \__fp_infix_+_o:w
%   {
%     \s__fp_symbolic \__fp_symbolic_chk:w \__fp_variable_a_o:w { } ;
%     \s__fp_symbolic \__fp_symbolic_chk:w \__fp_infix_*_o:w
%       {
%         \s__fp_symbolic \__fp_symbolic_chk:w \__fp_variable_b_o:w { } ;
%         \s__fp_symbolic \__fp_symbolic_chk:w \__fp_prefix_sin_o:w
%           { \s__fp_symbolic \__fp_symbolic_chk:w \__fp_variable_c_o:w { } ; } ;
%       } ;
%   } ;
% \end{verbatim}
%
% \begin{variable}[int]{\s_@@_symbolic}
%   Scan mark indicating the start of a symbolic expression.
%    \begin{macrocode}
\__scan_new:N \s_@@_symbolic
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_symbolic_chk:w}
%   Analog of \cs{@@_chk:w} for symbolic expressions.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_symbolic_chk:w #1;
  {
    \__msg_kernel_error:nnx { kernel } { misused-fp }
      { \fp_to_tl:n { \s_@@_symbolic \@@_symbolic_chk:w #1; } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Expanding after a symbolic expression}
%
% \begin{macro}[aux, EXP]
%   {\@@_if_has_symbolic:nTF, \@@_if_has_symbolic_aux:w}
%   Tests if |#1| contains \cs{s_@@_symbolic} at top-level.  This test
%   should be precise enough to determine if a given an array contains a
%   symbolic expression or only consists in floating points.  See
%   \cs{@@_exp_after_symbolic_f:nw} for an application.
%    \begin{macrocode}
\cs_new:Npn \@@_if_has_symbolic:nTF #1
  {
    \@@_if_has_symbolic_aux:w
      #1             \q_mark \use_i:nn
      \s_@@_symbolic \q_mark \use_ii:nn
    \q_stop
  }
\cs_new:Npn \@@_if_has_symbolic_aux:w
    #1 \s_@@_symbolic #2 \q_mark #3#4 \q_stop { #3 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_exp_after_symbolic_f:nw}
%   This function does two things: trigger an \texttt{f}-expansion of
%   the argument |#1| after the following symbolic expression, and
%   evaluate all pieces of the expression that can be evaluated.
%    \begin{macrocode}
\cs_new:Npn \@@_exp_after_symbolic_f:nw
    #1 \s_@@_symbolic \@@_symbolic_chk:w #2 #3 ;
  {
    \exp_after:wN \s_@@_symbolic
    \exp_after:wN \@@_symbolic_chk:w
    \exp_after:wN #2
    \exp_after:wN
      {
        \tex_romannumeral:D -`0
        \@@_exp_after_array_f:w #3 \s_@@_stop
        \exp_after:wN
      }
      \exp_after:wN ;
    \tex_romannumeral:D -`0 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_parse_exp_after_symbolic_f:nw}
%   This function does two things: trigger an \texttt{f}-expansion of
%   the argument |#1| after the following symbolic expression, and
%   evaluate all pieces of the expression that can be evaluated.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_exp_after_symbolic_f:nw
    #1 \s_@@_symbolic \@@_symbolic_chk:w #2 #3 ;
  {
    \exp_after:wN #2 \tex_romannumeral:D -`0
    \@@_parse_exp_after_array_f:w #3 \s_@@_stop
    \exp_after:wN \s_@@_stop \tex_romannumeral:D -`0
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Applying infix operators to expressions}
%
% \begin{@makeother}{^} %^^A Hack!
% \begin{@makeother}{|} %^^A Hack!
% \begin{@makeother}{&} %^^A Hack!
% \begin{macro}[EXP, aux]
%   {
%     \@@_symbolic_+_symbolic_o:ww,
%     \@@_symbolic_+_o:ww,
%     \@@_+_symbolic_o:ww,
%     \@@_symbolic_-_symbolic_o:ww,
%     \@@_symbolic_-_o:ww,
%     \@@_-_symbolic_o:ww,
%     \@@_symbolic_*_symbolic_o:ww,
%     \@@_symbolic_*_o:ww,
%     \@@_*_symbolic_o:ww,
%     \@@_symbolic_/_symbolic_o:ww,
%     \@@_symbolic_/_o:ww,
%     \@@_/_symbolic_o:ww,
%     \@@_symbolic_^_symbolic_o:ww,
%     \@@_symbolic_^_o:ww,
%     \@@_^_symbolic_o:ww,
%     \@@_symbolic_|_symbolic_o:ww,
%     \@@_symbolic_|_o:ww,
%     \@@_|_symbolic_o:ww,
%     \@@_symbolic_&_symbolic_o:ww,
%     \@@_symbolic_&_o:ww,
%     \@@_&_symbolic_o:ww,
%   }
%    \begin{macrocode}
\cs_set:Npn \@@_tmp:w #1#2
  {
    \cs_new:cpn { @@_symbolic_#2_symbolic_o:ww } ##1; ##2;
      {
        \@@_exp_after_symbolic_f:nw { \exp_after:wN \exp_stop_f: }
          \s_@@_symbolic \@@_symbolic_chk:w #1 { ##1; ##2; } ;
      }
    \cs_new_eq:cc
      { @@_symbolic_#2         _o:ww }
      { @@_symbolic_#2_symbolic_o:ww }
    \cs_new_eq:cc
      { @@         _#2_symbolic_o:ww }
      { @@_symbolic_#2_symbolic_o:ww }
  }
\tl_map_inline:nn { + - * / ^ & | }
  { \exp_args:Nc \@@_tmp:w { @@_infix_#1_o:w } {#1} }
%    \end{macrocode}
% \end{macro}
% \end{@makeother}
% \end{@makeother}
% \end{@makeother}
%
% \begin{macro}[EXP, aux]
%   {
%     \@@_symbolic_compare_symbolic_o:NNNNww,
%     \@@_symbolic_compare_o:NNNNww,
%     \@@_compare_symbolic_o:NNNNww,
%   }
%    \begin{macrocode}
\cs_new:Npn \@@_symbolic_compare_symbolic_o:NNNNww #1#2#3#4 #5; #6;
  {
    \str_case:nnn { #1#2#3#4 }
      {
        { \c_zero_fp \c_zero_fp \c_zero_fp \c_zero_fp }
          { \exp_after:wN \c_zero_fp }
        { \c_one_fp \c_one_fp \c_one_fp \c_one_fp }
          { \exp_after:wN \c_one_fp }
      }
      {
        \@@_exp_after_symbolic_f:nw { \exp_after:wN \exp_stop_f: }
          \s_@@_symbolic \@@_symbolic_chk:w \@@_infix_compare_o:w
            {
              \s_@@_tokens \@@_tokens_exp_not:n { #1#2#3#4 } ;
              #5 ;
              #6 ;
            } ;
      }
  }
\cs_new_eq:NN \@@_symbolic_compare_o:NNNNww
  \@@_symbolic_compare_symbolic_o:NNNNww
\cs_new_eq:NN \@@_compare_symbolic_o:NNNNww
  \@@_symbolic_compare_symbolic_o:NNNNww
%    \end{macrocode}
% \end{macro}
%
% \subsection{Applying prefix functions to expressions}
%
% \begin{macro}[EXP, aux]
%   {
%     \@@_abs_symbolic_o:w  ,
%     \@@_cos_symbolic_o:w  ,
%     \@@_cot_symbolic_o:w  ,
%     \@@_csc_symbolic_o:w  ,
%     \@@_exp_symbolic_o:w  ,
%     \@@_ln_symbolic_o:w   ,
%     \@@_sec_symbolic_o:w  ,
%     \@@_sin_symbolic_o:w  ,
%     \@@_tan_symbolic_o:w  ,
%     \@@_!_symbolic_o:w    ,
%     \@@_-_symbolic_o:w    ,
%   }
%    \begin{macrocode}
\cs_set:Npn \@@_tmp:w #1#2
  {
    \cs_new:cpn { @@_#2_symbolic_o:w } ##1;
      {
        \@@_exp_after_symbolic_f:nw { \exp_after:wN \exp_stop_f: }
          \s_@@_symbolic \@@_symbolic_chk:w #1 { ##1; } ;
      }
  }
\tl_map_inline:nn
  { {abs} {cos} {cot} {csc} {exp} {ln} {sec} {sin} {tan} {!} {-} }
  { \exp_args:Nc \@@_tmp:w { @@_prefix_#1_o:w } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Conversions}
%
% \begin{macro}[EXP, int]
%   {
%     \@@_symbolic_to_decimal:w,
%     \@@_symbolic_to_int:w,
%     \@@_symbolic_to_scientific:w
%   }
%   Symbolic expressions cannot be converted to decimal, integer, or
%   scientific notation.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_symbolic_to_decimal:w
  { \@@_invalid_operation:nnw { 0 } { fp_to_decimal } }
\cs_new_nopar:Npn \@@_symbolic_to_int:w
  { \@@_invalid_operation:nnw { 0 } { fp_to_int } }
\cs_new_nopar:Npn \@@_symbolic_to_scientific:w
  { \@@_invalid_operation:nnw { 0 } { fp_to_scientific } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, int]{\@@_symbolic_to_tl:w}
% \begin{macro}[rEXP, aux]
%   {
%     \@@_symbolic_to_tl_aux:wwww,
%     \@@_symbolic_to_tl_aux_infix:nww
%   }
%   Converting a symbolic expression to a token list is possible.
%    \begin{macrocode}
\cs_new:Npn \@@_symbolic_to_tl:w
    \s_@@_symbolic \@@_symbolic_chk:w #1 #2;
  {
    \@@_expand:n
      {
        \exp_after:wN \@@_symbolic_to_tl_aux:wwww
          \token_to_str:N #1 ;
          #2 \s_@@_stop
      }
  }
\use:x
  {
    \cs_new:Npn \exp_not:N \@@_symbolic_to_tl_aux:wwww
        ##1 \tl_to_str:n { __fp_ } ##2 \token_to_str:N _
        ##3 \tl_to_str:n { _o:w } ; ##4 \s_@@_stop
  }
      {
        \str_case:nnn {#2}
          {
            {infix}
              {
                \str_if_eq:nnTF {#3} { compare }
                  {
                    \use:nnnn \@@_symbolic_to_tl_aux_compare:www
                      #4 \s_@@_stop
                  }
                  { \@@_symbolic_to_tl_aux_infix:nww {#3} #4 \s_@@_stop }
              }
            {prefix} { #3 ( \@@_array_to_clist:n {#4} ) }
          }
          {#3}
      }
\cs_new:Npn \@@_symbolic_to_tl_aux_infix:nww #1#2; #3 \s_@@_stop
  {
    %^^A todo: test that the array has two args.
    ( \@@_to_tl_dispatch:w #2;
    #1
    \@@_array_to_clist:n {#3} )
  }
\cs_new:Npn \@@_symbolic_to_tl_aux_compare:www
    \s_@@_tokens \@@_tokens_exp_not:n #1#2#3#4; #5; #6 \s_@@_stop
  {
    %^^A todo: test that the array has two args.
    ( \@@_to_tl_dispatch:w #5;
    \if_meaning:w #4 \c_one_fp
      !
      \if_meaning:w #1 \c_zero_fp < \fi:
      \if_meaning:w #3 \c_zero_fp > \fi:
      \if_meaning:w #2 \c_zero_fp = \fi:
    \else:
      \if_meaning:w #1 \c_one_fp < \fi:
      \if_meaning:w #3 \c_one_fp > \fi:
      \if_meaning:w #2 \c_one_fp = \fi:
    \fi:
    \@@_array_to_clist:n {#6} )
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Declaring variables and assigning values}
%
% Functions defined here are not necessarily tied to symbolic
% expressions.
%
% \begin{macro}[TF]{\fp_str_if_identifier:n}
% \begin{macro}[aux, EXP]{\@@_str_if_identifier:N}
%   If |#1| contains a space, it is not a valid identifier.  Otherwise,
%   loop through letters in |#1|: if if is not a letter, break the loop
%   and return \texttt{false}.  If the end of the loop is reached
%   without finding any non-letter, return \texttt{true}.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn
    \fp_str_if_identifier:n #1 { T , F , TF }
  {
    \tl_if_empty:nTF {#1}
      { \prg_return_false: }
      {
        \exp_args:Nxx \tl_if_in:nnTF { \tl_to_str:n {#1} } { \c_space_tl }
          { \prg_return_false: }
          {
            \exp_after:wN \@@_str_if_identifier:N \tl_to_str:n {#1}
              { ? \__prg_break:n \prg_return_true: }
            \__prg_break_point:
          }
      }
  }
\cs_new:Npn \@@_str_if_identifier:N #1
  {
    \use_none:n #1
    \int_compare:nNnTF { `#1 } < { `A }
      { \__prg_break:n { \prg_return_false: } }
      {
        \int_compare:nNnT { `#1 } > { `Z }
          {
            \int_compare:nNnTF { `#1 } < { `a }
              { \__prg_break:n \prg_return_false: }
              {
                \int_compare:nNnT { `#1 } > { `z }
                  { \__prg_break:n \prg_return_false: }
              }
          }
      }
    \@@_str_if_identifier:N
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\@@_variable_parsing:Nn}
%   This gives the right incantations for \pkg{l3fp-parse}: when the
%   parser sees |#1|, it will insert |\__fp_variable_#1_o:w|, and
%   \cs{@@_parse_exp_after_symbolic_f:nw} will expand after that
%   symbolic expression, evaluating whatever can be evaluated.  The
%   scope is controlled by the |_nopar:cpx| assignment function |#1|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_variable_parsing:Nn #1#2
  {
    #1 { @@_parse_word_ \tl_to_str:n {#2} :N }
      {
        \exp_not:n
          {
            \@@_parse_exp_after_symbolic_f:nw
              { \@@_parse_infix:NN }
              \s_@@_symbolic \@@_symbolic_chk:w
          }
        \exp_not:c { @@_variable_ \tl_to_str:n {#2} _o:w } { } ;
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_variable_unknown:Nn}
%   Set the identifier |#2| to be a variable.  This is achieved by
%   defining the appropriate auxiliary to expand to itself in a way
%   somewhat similar to |\protect|-ed macros in \LaTeXe{}.  Loops are
%   avoided by making the function protected: it will still
%   \texttt{f}-expand as appropriate.  The scope is controlled by the
%   |_protected:cpx| assignment function |#1|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_variable_unknown:Nn #1#2
  {
    #1 { @@_variable_ \tl_to_str:n {#2} _o:w } \s_@@_stop
      {
        \exp_not:n
          { \@@_exp_after_symbolic_f:nw { \exp_after:wN \exp_stop_f: } }
        \s_@@_symbolic \@@_symbolic_chk:w
          \exp_not:c { @@_variable_ \tl_to_str:n {#2} _o:w } { } ;
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_new_variable:n}
%   Check that |#1| is a valid identifier.  If the identifier is already
%   in use, complain, and undefine two functions to avoid further
%   errors.  Then set |\__fp_parse_word_#1:N| to use
%   |\__fp_variable_#1_o:w|, and define this second function to evaluate
%   the variable to itself.
%    \begin{macrocode}
\cs_new_protected:Npn \fp_new_variable:n #1
  {
    \fp_str_if_identifier:nTF {#1}
      {
        \cs_if_exist:cT { @@_parse_word_ \tl_to_str:n {#1} :N }
          {
            \__msg_kernel_error:nnn
              { fp } { identifier-already-defined } {#1}
            \cs_undefine:c { @@_parse_word_ \tl_to_str:n {#1} :N }
            \cs_undefine:c { @@_variable_ \tl_to_str:n {#1} _o:w }
          }
        \@@_variable_parsing:Nn \cs_new_nopar:cpx {#1}
        \@@_variable_unknown:Nn \cs_new_protected:cpx {#1}
      }
      { \__msg_kernel_error:nnn { fp } { invalid-identifier } {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_set_variable:nn, \fp_gset_variable:nn}
% \begin{macro}[aux]{\@@_set_variable:Nnn}
%   Refuse invalid identifiers.  If the variable does not exist yet,
%   define it just as in \cs{fp_new_variable:nn} (but without
%   unnecessary checks).  Then evaluate |#3|.  If the result contains
%   the identifier |#2|, we would later get a loop in cases such as
%   \begin{quote}
%     \cs{fp_set_variable:nn} |{A}| |{A}|\\
%     \cs{fp_show:n} |{A}|
%   \end{quote}
%   To detect this, define |\__fp_variable_#2_o:w| to raise the
%   |internal| flag, and evaluate to \texttt{nan}.  Then re-evaluate
%   \cs{l_@@_internal_fp}, and store the result in |#2|.  If the flag is
%   raised, |#2| was present in \cs{l_@@_internal_fp}.  In all cases,
%   the |#2|-free result ends up in |\__fp_variable_#2_o:w|.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_set_variable:nn
  { \@@_set_variable:Nnn \cs_set_protected:cpx }
\cs_new_protected_nopar:Npn \fp_gset_variable:nn
  { \@@_set_variable:Nnn \cs_gset_protected:cpx }
\cs_new_protected:Npn \@@_set_variable:Nnn #1#2#3
  {
    \fp_str_if_identifier:nTF {#2}
      {
        \cs_if_exist:cF { @@_parse_word_#2:N }
          {
            \@@_variable_parsing:Nn \cs_new_nopar:cpx {#2}
            \@@_variable_unknown:Nn \cs_new_protected:cpx {#2}
          }
        \fp_set:Nn \l_@@_internal_fp {#3}
        #1 { @@_variable_ \tl_to_str:n {#2} _o:w } \s_@@_stop
          {
            \exp_not:n
              {
                \fp_flag_on:n { internal }
                \exp_after:wN \c_nan_fp
              }
          }
        \fp_flag_off:n { internal }
        #1 { @@_variable_ \tl_to_str:n {#2} _o:w } \s_@@_stop
          { \@@_parse:n { \l_@@_internal_fp } }
        \fp_if_flag_on:nT { internal }
          {
            \__msg_kernel_error:nnxxx { fp } { identifier-loop }
              { \tl_to_str:n {#2} }
              { \tl_to_str:n {#3} }
              { \fp_to_tl:N \l_@@_internal_fp }
          }
      }
      { \__msg_kernel_error:nnn { fp } { invalid-identifier } {#2} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\__msg_kernel_new:nnnn { fp } { invalid-identifier }
  { Floating~point~identifier~'#1'~invalid. }
  {
    \c_msg_coding_error_text_tl
    LaTeX~has~been~asked~to~create~a~new~floating~point~identifier~'#1'~
    but~this~may~only~contain~ASCII~letters.
  }
\__msg_kernel_new:nnnn { fp } { identifier-already-defined }
  { Floating~point~identifier~'#1'~already~defined. }
  {
    \c_msg_coding_error_text_tl
    LaTeX~has~been~asked~to~create~a~new~floating~point~identifier~'#1'~
    but~this~name~has~already~been~used~elsewhere.
  }
\__msg_kernel_new:nnnn { fp } { identifier-loop }
  { Variable~'#1'~used~in~'#1's~definition. }
  {
    \c_msg_coding_error_text_tl
    LaTeX~has~been~asked~to~set~the~floating~point~identifier~'#1'~
    to~the~expression~'#2'.~Evaluating~this~expression~yields~'#3',~
    which~contains~'#1'~itself.
  }
%    \end{macrocode}
%
% \subsection{Road-map}
%
% The following functions are not implemented: min, max, |?:|,
% comparisons, |round|.
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
