% \iffalse
%
%% File l3fp-symbolic.dtx (C) Copyright 2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental symbolic expressions}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3fp-symbolic} package\\ Symbolic expressions^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3fp-symbolic} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=fp>
%    \end{macrocode}
%
% \subsection{Support for types}
%
% This subsection should probably be moved to a different submodule than
% \pkg{l3fp-symbolic}.  It redefines some \pkg{l3fp} internals to
% support types.
%
% \begin{macro}[EXP, int]
%   {\@@_to_decimal:w, \@@_to_int:w, \@@_to_scientific:w, \@@_to_tl:w}
%   In \pkg{l3fp-convert}, the \texttt{_dispatch} functions do not
%   actually dispatch depending on the type of their argument: they only
%   accept floating points.  Thus, we start by saving the definitions in
%   functions meant only for floating points.
%    \begin{macrocode}
\cs_new_eq:NN \@@_to_decimal:w    \@@_to_decimal_dispatch:w
\cs_new_eq:NN \@@_to_int:w        \@@_to_int_dispatch:w
\cs_new_eq:NN \@@_to_scientific:w \@@_to_scientific_dispatch:w
\cs_new_eq:NN \@@_to_tl:w         \@@_to_tl_dispatch:w
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, int]
%   {
%     \@@_to_decimal_dispatch:w,
%     \@@_to_int_dispatch:w,
%     \@@_to_scientific_dispatch:w,
%     \@@_to_tl_dispatch:w,
%   }
%   Redefine those four functions to actually dispatch on type.
%    \begin{macrocode}
\cs_gset:Npn \@@_to_decimal_dispatch:w #1
  { \cs:w @@ \@@_type_from_scan:N #1 _to_decimal:w \cs_end: #1 }
\cs_gset:Npn \@@_to_int_dispatch:w #1
  { \cs:w @@ \@@_type_from_scan:N #1 _to_int:w \cs_end: #1 }
\cs_gset:Npn \@@_to_scientific_dispatch:w #1
  { \cs:w @@ \@@_type_from_scan:N #1 _to_scientific:w \cs_end: #1 }
\cs_gset:Npn \@@_to_tl_dispatch:w #1
  { \cs:w @@ \@@_type_from_scan:N #1 _to_tl:w \cs_end: #1 }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Building blocks for expressions}
%
% ^^A todo: try to use a variable called "chk".
%
% Every symbolic expression has the form
% \begin{quote}
%   \cs{s_@@_symbolic} \cs{@@_symbolic_chk:w}
%   \cs{@@_\meta{op}:n} \Arg{arguments} |;|
% \end{quote}
% where the \meta{op} is an operation (|infix_+|, |infix_/|, |prefix_-|,
% |prefix_sin|, \ldots{}), and \meta{arguments} is an array of floating
% points or symbolic expressions, with the number of items expected for
% the given operation.  Variables are stored with a \meta{op} of
% |variable_|\meta{name}, with an empty \meta{argument} (the brace group
% is still there, though).
%
% Symbolic expressions are stored in a prefix form.  When encountering a
% symbolic expression in a floating point computation, we attempt to
% evaluate the operands as much as possible, and if that yields floating
% point numbers rather than expressions, we apply the operator which
% follows (if the function is known).
%
% For instance, the expression "a + b * sin(c)" is stored as
% \begin{verbatim}
% \s__fp_symbolic \__fp_symbolic_chk:w \__fp_infix_+:n
%   {
%     \s__fp_symbolic \__fp_symbolic_chk:w \__fp_variable_a:n { } ;
%     \s__fp_symbolic \__fp_symbolic_chk:w \__fp_infix_*:n
%       {
%         \s__fp_symbolic \__fp_symbolic_chk:w \__fp_variable_b:n { } ;
%         \s__fp_symbolic \__fp_symbolic_chk:w \__fp_prefix_sin:n
%           { \s__fp_symbolic \__fp_symbolic_chk:w \__fp_variable_c:n { } ; } ;
%       } ;
%   } ;
% \end{verbatim}
%
% \begin{variable}[int]{\s_@@_symbolic}
%   Scan mark indicating the start of a symbolic expression.
%    \begin{macrocode}
\__scan_new:N \s_@@_symbolic
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_symbolic_chk:w}
%   Analog of \cs{@@_chk:w} for symbolic expressions.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_symbolic_chk:w #1;
  {
    \__msg_kernel_error:nnx { kernel } { misused-fp }
      { \@@_to_tl_dispatch:w \s_@@_symbolic \@@_symbolic_chk:w #1; }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {\@@_if_has_symbolic:nTF, \@@_if_has_symbolic_aux:w}
%   Tests if the string representation of |#1| contains
%   |s__fp_symbolic|.  This test should be precise enough to determine
%   if a given an array contains a symbolic expression or only consists
%   in floating points.  See \cs{@@_exp_after_symbolic_f:nw} for an
%   application.
%    \begin{macrocode}
\cs_set:Npn \@@_tmp:w #1
  {
    \cs_new:Npn \@@_if_has_symbolic:nTF ##1
      {
        \exp_after:wN \@@_if_has_symbolic_aux:w
          \tl_to_str:n {##1} \q_mark \use_i:nn
          #1                 \q_mark \use_ii:nn
        \q_stop
      }
    \cs_new:Npn \@@_if_has_symbolic_aux:w
        ##1 #1 ##2 \q_mark ##3##4 \q_stop { ##3 }
  }
\exp_args:No \@@_tmp:w { \tl_to_str:n { s_@@_symbolic ~ } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_exp_after_symbolic_f:nw}
% \begin{macro}[aux, EXP]{\@@_exp_after_symbolic_aux:Nn}
%   This function does two things: trigger an \texttt{f}-expansion of
%   the argument |#1| after the following symbolic expression, and
%   evaluate all pieces of the expression that can be evaluated.
%    \begin{macrocode}
\cs_new:Npn \@@_exp_after_symbolic_f:nw
    #1 \s_@@_symbolic \@@_symbolic_chk:w #2 #3 ;
  {
    \exp_after:wN \@@_exp_after_symbolic_aux:Nn
    \exp_after:wN #2
    \exp_after:wN
      {
        \tex_romannumeral:D -`0
        \@@_exp_after_array_f:w #3 \s_@@_stop
        \exp_after:wN
      }
      \exp_after:wN ;
    \tex_romannumeral:D -`0 #1
  }
\cs_new:Npn \@@_exp_after_symbolic_aux:Nn #1#2 ;
  {
    \@@_if_has_symbolic:nTF {#2}
      { \s_@@_symbolic \@@_symbolic_chk:w #1 {#2} ; }
      { #1 {#2} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% ^^A todo: test { \fp_gset:Nn \foo { abc } } ...
%
% \subsection{Built-in operators}
%
% \begin{@makeother}{^} %^^A Hack!
% \begin{@makeother}{|} %^^A Hack!
% \begin{@makeother}{&} %^^A Hack!
% \begin{macro}[EXP, aux]
%   {
%     \@@_symbolic_+_symbolic_o:ww,
%     \@@_symbolic_+_o:ww,
%     \@@_+_symbolic_o:ww,
%     \@@_infix_+:n,
%     \@@_symbolic_-_symbolic_o:ww,
%     \@@_symbolic_-_o:ww,
%     \@@_-_symbolic_o:ww,
%     \@@_infix_-:n,
%     \@@_symbolic_*_symbolic_o:ww,
%     \@@_symbolic_*_o:ww,
%     \@@_*_symbolic_o:ww,
%     \@@_infix_*:n,
%     \@@_symbolic_/_symbolic_o:ww,
%     \@@_symbolic_/_o:ww,
%     \@@_/_symbolic_o:ww,
%     \@@_infix_/:n,
%     \@@_symbolic_^_symbolic_o:ww,
%     \@@_symbolic_^_o:ww,
%     \@@_^_symbolic_o:ww,
%     \@@_infix_^:n,
%     \@@_symbolic_|_symbolic_o:ww,
%     \@@_symbolic_|_o:ww,
%     \@@_|_symbolic_o:ww,
%     \@@_infix_|:n,
%     \@@_symbolic_&_symbolic_o:ww,
%     \@@_symbolic_&_o:ww,
%     \@@_&_symbolic_o:ww,
%     \@@_infix_&:n,
%   }
%    \begin{macrocode}
\cs_set:Npn \@@_tmp:w #1#2
  {
    \cs_new:cpn { @@_symbolic_#2_symbolic_o:ww } ##1; ##2;
      {
        \@@_exp_after_symbolic_f:nw { }
          \s_@@_symbolic \@@_symbolic_chk:w #1 { ##1; ##2; } ;
        \exp_after:wN \exp_stop_f: % ?
      }
    \cs_new_eq:cc
      { @@_symbolic_#2         _o:ww }
      { @@_symbolic_#2_symbolic_o:ww }
    \cs_new_eq:cc
      { @@         _#2_symbolic_o:ww }
      { @@_symbolic_#2_symbolic_o:ww }
    \cs_new_protected:Npx #1 ##1
      {
        \exp_not:c { @@_#2_o:ww } ##1
      }
  }
\exp_args:Nc \@@_tmp:w { @@_infix_+:n } +
\exp_args:Nc \@@_tmp:w { @@_infix_-:n } -
\exp_args:Nc \@@_tmp:w { @@_infix_*:n } *
\exp_args:Nc \@@_tmp:w { @@_infix_/:n } /
\exp_args:Nc \@@_tmp:w { @@_infix_^:n } ^
\exp_args:Nc \@@_tmp:w { @@_infix_|:n } |
\exp_args:Nc \@@_tmp:w { @@_infix_&:n } &
%    \end{macrocode}
% \end{macro}
% \end{@makeother}
% \end{@makeother}
% \end{@makeother}
%
% \subsection{Built-in functions}
%
% \begin{macro}[EXP, aux]
%   {
%     \@@_abs_symbolic_o:w  ,
%     \@@_prefix_abs:n,
%     \@@_cos_symbolic_o:w  ,
%     \@@_prefix_cos:n,
%     \@@_cot_symbolic_o:w  ,
%     \@@_prefix_cot:n,
%     \@@_csc_symbolic_o:w  ,
%     \@@_prefix_csc:n,
%     \@@_exp_symbolic_o:w  ,
%     \@@_prefix_exp:n,
%     \@@_ln_symbolic_o:w   ,
%     \@@_prefix_ln:n ,
%     \@@_sec_symbolic_o:w  ,
%     \@@_prefix_sec:n,
%     \@@_sin_symbolic_o:w  ,
%     \@@_prefix_sin:n,
%     \@@_tan_symbolic_o:w  ,
%     \@@_prefix_tan:n,
%     \@@_!_symbolic_o:w  ,
%     \@@_prefix_!:n,
%     \@@_-_symbolic_o:w  ,
%     \@@_prefix_-:n,
%   }
%    \begin{macrocode}
\cs_set:Npn \@@_tmp:w #1#2
  {
    \cs_new:cpn { @@_#2_symbolic_o:w } ##1;
      {
        \@@_exp_after_symbolic_f:nw { \exp_after:wN \exp_stop_f: } % ?
          \s_@@_symbolic \@@_symbolic_chk:w #1 { ##1; } ;
      }
    \cs_new_protected:Npx #1 ##1
      {
        \exp_not:c { @@_#2_o:w } ##1
      }
  }
\tl_map_inline:nn
  { {abs} {cos} {cot} {csc} {exp} {ln} {sec} {sin} {tan} {!} {-} }
  { \exp_args:Nc \@@_tmp:w { @@_prefix_#1:n } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Declaring variables and assigning values}
%
% \begin{macro}{\fp_new_var:n}
%    \begin{macrocode}
\cs_new:Npn \fp_new_var:n #1
  {
    \cs_if_exist:cTF { @@_parse_word_#1:N }
      {
        \__msg_kernel_error:nnx { fp-symbolic } { word-exists } {#1}
      }
      {
        \cs_new_protected:cpx { @@_variable_#1:n } ##1
          {
            \s_@@_symbolic \@@_symbolic_chk:w
              \exp_not:c { @@_variable_#1:n } {##1} ;
          }
        \cs_new_nopar:cpx { @@_parse_word_#1:N }
          {
            \exp_not:n
              {
                \@@_exp_after_symbolic_f:nw { \@@_parse_infix:NN }
                  \s_@@_symbolic \@@_symbolic_chk:w
              }
            \exp_not:c { @@_variable_#1:n } { } ;
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_set_var:nn}
%    \begin{macrocode}
\cs_new:Npn \fp_set_var:nn #1#2
  {
    \cs_set_protected:cpx { @@_variable_#1:n } ##1
      {
        \@@_parse:n {#2}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Conversions}
%
% \begin{macro}[EXP, int]
%   {
%     \@@_symbolic_to_decimal:w,
%     \@@_symbolic_to_int:w,
%     \@@_symbolic_to_scientific:w
%   }
%   Symbolic expressions cannot be converted to decimal, integer, or
%   scientific notation.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_symbolic_to_decimal:w
  { \@@_invalid_operation:nnw { 0 } { fp_to_decimal } }
\cs_new_nopar:Npn \@@_symbolic_to_int:w
  { \@@_invalid_operation:nnw { 0 } { fp_to_int } }
\cs_new_nopar:Npn \@@_symbolic_to_scientific:w
  { \@@_invalid_operation:nnw { 0 } { fp_to_scientific } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, int]{\@@_symbolic_to_tl:w}
% \begin{macro}[rEXP, aux]
%   {
%     \@@_symbolic_to_tl_aux:wwww,
%     \@@_symbolic_to_tl_aux_infix:nww
%   }
%   Converting a symbolic expression to a token list is possible.
%    \begin{macrocode}
\cs_new:Npn \@@_symbolic_to_tl:w
    \s_@@_symbolic \@@_symbolic_chk:w #1 #2;
  {
    \@@_expand:n
      {
        \exp_after:wN \@@_symbolic_to_tl_aux:wwww
          \token_to_str:N #1 ;
          #2 \s_@@_stop
      }
  }
\use:x
  {
    \cs_new:Npn \exp_not:N \@@_symbolic_to_tl_aux:wwww
        ##1 \tl_to_str:n { __fp_ } ##2 \token_to_str:N _
        ##3 \tl_to_str:n { :n } ; ##4 \s_@@_stop
  }
      {
        \str_case:nnn {#2}
          {
            {infix}
              { \@@_symbolic_to_tl_aux_infix:nww {#3} #4 \s_@@_stop }
            {prefix} { #3 ( \@@_array_to_clist:n {#4} ) }
          }
          {#3}
      }
\cs_new:Npn \@@_symbolic_to_tl_aux_infix:nww #1#2; #3 \s_@@_stop
  {
    %^^A todo: test that the array has two args.
    ( \@@_to_tl_dispatch:w #2;
    #1
    \@@_array_to_clist:n {#3} )
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\__msg_kernel_new:nnnn { fp-symbolic } { word-exists }
  { Floating~point~word~'#1'~exists. }
  {
    The~word~'#1'~already~has~a~meaning~in~floating~point~expressions,~
    and~it~cannot~be~defined~again.
  }
%    \end{macrocode}
%
% \subsection{Road-map}
%
% The following functions are not implemented: min, max, |?:|,
% comparisons, |round|.
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
