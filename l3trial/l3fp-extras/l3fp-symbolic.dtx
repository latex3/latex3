% \iffalse
%
%% File l3fp-symbolic.dtx (C) Copyright 2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental symbolic expressions}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3fp-symbolic} package\\ Symbolic expressions^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3fp-symbolic} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=fp>
%    \end{macrocode}
%
% \subsection{Misc}
%
% \begin{macro}[EXP, int]{\@@_parse_exp_after_array_f:w}
% \begin{macro}[EXP, aux]{\@@_parse_exp_after_stop_f:nw}
%   This is analoguous to \cs{@@_exp_after_array_f:w}, but it uses
%   |\__fp_parse_exp_after| functions.  In particular, a symbolic
%   expression is re-evaluated.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_exp_after_array_f:w #1
  {
    \cs:w @@_parse_exp_after \@@_type_from_scan:N #1 _f:nw \cs_end:
      { \@@_parse_exp_after_array_f:w }
    #1
  }
\cs_new_eq:NN \@@_parse_exp_after_stop_f:nw \use_none:nn
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Building blocks for expressions}
%
% Every symbolic expression has the form
% \begin{quote}
%   \cs{s_@@_symbolic} \cs{@@_symbolic_chk:w}
%   \cs{@@_\meta{op}_o:w} \Arg{arguments} |;|
% \end{quote}
% where the \meta{op} is an operation (|infix_+|, |infix_/|, |prefix_-|,
% |prefix_sin|, \ldots{}), and \meta{arguments} is an array of floating
% points or symbolic expressions, with the number of items expected for
% the given operation.  Variables are stored with a \meta{op} of
% |variable_|\meta{name}, with an empty \meta{argument} (the brace group
% is still there, though).
%
% Symbolic expressions are stored in a prefix form.  When encountering a
% symbolic expression in a floating point computation, we attempt to
% evaluate the operands as much as possible, and if that yields floating
% point numbers rather than expressions, we apply the operator which
% follows (if the function is known).
%
% For instance, the expression "a + b * sin(c)" is stored as
% \begin{verbatim}
% \s__fp_symbolic \__fp_symbolic_chk:w \__fp_infix_+_o:w
%   {
%     \s__fp_symbolic \__fp_symbolic_chk:w \__fp_variable_a_o:w { } ;
%     \s__fp_symbolic \__fp_symbolic_chk:w \__fp_infix_*_o:w
%       {
%         \s__fp_symbolic \__fp_symbolic_chk:w \__fp_variable_b_o:w { } ;
%         \s__fp_symbolic \__fp_symbolic_chk:w \__fp_prefix_sin_o:w
%           { \s__fp_symbolic \__fp_symbolic_chk:w \__fp_variable_c_o:w { } ; } ;
%       } ;
%   } ;
% \end{verbatim}
%
% \begin{variable}[int]{\s_@@_symbolic}
%   Scan mark indicating the start of a symbolic expression.
%    \begin{macrocode}
\__scan_new:N \s_@@_symbolic
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_symbolic_chk:w}
%   Analog of \cs{@@_chk:w} for symbolic expressions.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_symbolic_chk:w #1;
  {
    \__msg_kernel_error:nnx { kernel } { misused-fp }
      { \fp_to_tl:n { \s_@@_symbolic \@@_symbolic_chk:w #1; } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Expanding after a symbolic expression}
%
% \begin{macro}[aux, EXP]
%   {\@@_if_has_symbolic:nTF, \@@_if_has_symbolic_aux:w}
%   Tests if |#1| contains \cs{s_@@_symbolic} at top-level.  This test
%   should be precise enough to determine if a given an array contains a
%   symbolic expression or only consists in floating points.  See
%   \cs{@@_exp_after_symbolic_f:nw} for an application.
%    \begin{macrocode}
\cs_new:Npn \@@_if_has_symbolic:nTF #1
  {
    \@@_if_has_symbolic_aux:w
      #1             \q_mark \use_i:nn
      \s_@@_symbolic \q_mark \use_ii:nn
    \q_stop
  }
\cs_new:Npn \@@_if_has_symbolic_aux:w
    #1 \s_@@_symbolic #2 \q_mark #3#4 \q_stop { #3 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_exp_after_symbolic_f:nw}
%   This function does two things: trigger an \texttt{f}-expansion of
%   the argument |#1| after the following symbolic expression, and
%   evaluate all pieces of the expression that can be evaluated.
%    \begin{macrocode}
\cs_new:Npn \@@_exp_after_symbolic_f:nw
    #1 \s_@@_symbolic \@@_symbolic_chk:w #2 #3 ;
  {
    \exp_after:wN \s_@@_symbolic
    \exp_after:wN \@@_symbolic_chk:w
    \exp_after:wN #2
    \exp_after:wN
      {
        \tex_romannumeral:D -`0
        \@@_exp_after_array_f:w #3 \s_@@_stop
        \exp_after:wN
      }
      \exp_after:wN ;
    \tex_romannumeral:D -`0 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_parse_exp_after_symbolic_f:nw}
%   This function does two things: trigger an \texttt{f}-expansion of
%   the argument |#1| after the following symbolic expression, and
%   evaluate all pieces of the expression that can be evaluated.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_exp_after_symbolic_f:nw
    #1 \s_@@_symbolic \@@_symbolic_chk:w #2 #3 ;
  {
    \exp_after:wN #2 \tex_romannumeral:D -`0
    \@@_parse_exp_after_array_f:w #3 \s_@@_stop
    \exp_after:wN \s_@@_stop \tex_romannumeral:D -`0
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Applying infix operators to expressions}
%
% \begin{@makeother}{^} %^^A Hack!
% \begin{@makeother}{|} %^^A Hack!
% \begin{@makeother}{&} %^^A Hack!
% \begin{macro}[EXP, aux]
%   {
%     \@@_symbolic_+_symbolic_o:ww,
%     \@@_symbolic_+_o:ww,
%     \@@_+_symbolic_o:ww,
%     \@@_symbolic_-_symbolic_o:ww,
%     \@@_symbolic_-_o:ww,
%     \@@_-_symbolic_o:ww,
%     \@@_symbolic_*_symbolic_o:ww,
%     \@@_symbolic_*_o:ww,
%     \@@_*_symbolic_o:ww,
%     \@@_symbolic_/_symbolic_o:ww,
%     \@@_symbolic_/_o:ww,
%     \@@_/_symbolic_o:ww,
%     \@@_symbolic_^_symbolic_o:ww,
%     \@@_symbolic_^_o:ww,
%     \@@_^_symbolic_o:ww,
%     \@@_symbolic_|_symbolic_o:ww,
%     \@@_symbolic_|_o:ww,
%     \@@_|_symbolic_o:ww,
%     \@@_symbolic_&_symbolic_o:ww,
%     \@@_symbolic_&_o:ww,
%     \@@_&_symbolic_o:ww,
%   }
%    \begin{macrocode}
\cs_set:Npn \@@_tmp:w #1#2
  {
    \cs_new:cpn { @@_symbolic_#2_symbolic_o:ww } ##1; ##2;
      {
        \@@_exp_after_symbolic_f:nw { \exp_after:wN \exp_stop_f: }
          \s_@@_symbolic \@@_symbolic_chk:w #1 { ##1; ##2; } ;
      }
    \cs_new_eq:cc
      { @@_symbolic_#2         _o:ww }
      { @@_symbolic_#2_symbolic_o:ww }
    \cs_new_eq:cc
      { @@         _#2_symbolic_o:ww }
      { @@_symbolic_#2_symbolic_o:ww }
  }
\tl_map_inline:nn { + - * / ^ & | }
  { \exp_args:Nc \@@_tmp:w { @@_infix_#1_o:w } {#1} }
%    \end{macrocode}
% \end{macro}
% \end{@makeother}
% \end{@makeother}
% \end{@makeother}
%
% \subsection{Applying prefix functions to expressions}
%
% \begin{macro}[EXP, aux]
%   {
%     \@@_abs_symbolic_o:w  ,
%     \@@_cos_symbolic_o:w  ,
%     \@@_cot_symbolic_o:w  ,
%     \@@_csc_symbolic_o:w  ,
%     \@@_exp_symbolic_o:w  ,
%     \@@_ln_symbolic_o:w   ,
%     \@@_sec_symbolic_o:w  ,
%     \@@_sin_symbolic_o:w  ,
%     \@@_tan_symbolic_o:w  ,
%     \@@_!_symbolic_o:w    ,
%     \@@_-_symbolic_o:w    ,
%   }
%    \begin{macrocode}
\cs_set:Npn \@@_tmp:w #1#2
  {
    \cs_new:cpn { @@_#2_symbolic_o:w } ##1;
      {
        \@@_exp_after_symbolic_f:nw { \exp_after:wN \exp_stop_f: }
          \s_@@_symbolic \@@_symbolic_chk:w #1 { ##1; } ;
      }
  }
\tl_map_inline:nn
  { {abs} {cos} {cot} {csc} {exp} {ln} {sec} {sin} {tan} {!} {-} }
  { \exp_args:Nc \@@_tmp:w { @@_prefix_#1_o:w } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Conversions}
%
% \begin{macro}[EXP, int]
%   {
%     \@@_symbolic_to_decimal:w,
%     \@@_symbolic_to_int:w,
%     \@@_symbolic_to_scientific:w
%   }
%   Symbolic expressions cannot be converted to decimal, integer, or
%   scientific notation.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_symbolic_to_decimal:w
  { \@@_invalid_operation:nnw { 0 } { fp_to_decimal } }
\cs_new_nopar:Npn \@@_symbolic_to_int:w
  { \@@_invalid_operation:nnw { 0 } { fp_to_int } }
\cs_new_nopar:Npn \@@_symbolic_to_scientific:w
  { \@@_invalid_operation:nnw { 0 } { fp_to_scientific } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, int]{\@@_symbolic_to_tl:w}
% \begin{macro}[rEXP, aux]
%   {
%     \@@_symbolic_to_tl_aux:wwww,
%     \@@_symbolic_to_tl_aux_infix:nww
%   }
%   Converting a symbolic expression to a token list is possible.
%    \begin{macrocode}
\cs_new:Npn \@@_symbolic_to_tl:w
    \s_@@_symbolic \@@_symbolic_chk:w #1 #2;
  {
    \@@_expand:n
      {
        \exp_after:wN \@@_symbolic_to_tl_aux:wwww
          \token_to_str:N #1 ;
          #2 \s_@@_stop
      }
  }
\use:x
  {
    \cs_new:Npn \exp_not:N \@@_symbolic_to_tl_aux:wwww
        ##1 \tl_to_str:n { __fp_ } ##2 \token_to_str:N _
        ##3 \tl_to_str:n { _o:w } ; ##4 \s_@@_stop
  }
      {
        \str_case:nnn {#2}
          {
            {infix}
              { \@@_symbolic_to_tl_aux_infix:nww {#3} #4 \s_@@_stop }
            {prefix} { #3 ( \@@_array_to_clist:n {#4} ) }
          }
          {#3}
      }
\cs_new:Npn \@@_symbolic_to_tl_aux_infix:nww #1#2; #3 \s_@@_stop
  {
    %^^A todo: test that the array has two args.
    ( \@@_to_tl_dispatch:w #2;
    #1
    \@@_array_to_clist:n {#3} )
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Declaring variables and assigning values}
%
% Functions defined here are not necessarily tied to symbolic
% expressions.
%
% \begin{macro}{\fp_new_var:n}
%    \begin{macrocode}
\cs_new:Npn \fp_new_var:n #1
  {
    \cs_if_exist:cTF { @@_parse_word_#1:N }
      {
        \__msg_kernel_error:nnx { fp-symbolic } { word-exists } {#1}
      }
      {
        %^^A todo: check that #1 is a valid identifier.
        \cs_new_protected:cpx { @@_variable_#1_o:w } \s_@@_stop
          {
            \s_@@_symbolic \@@_symbolic_chk:w
              \exp_not:c { @@_variable_#1_o:w } {} ;
          }
        \cs_new_nopar:cpx { @@_parse_word_#1:N }
          {
            \exp_not:n
              {
                \@@_parse_exp_after_symbolic_f:nw
                  { \@@_parse_infix:NN }
                  \s_@@_symbolic \@@_symbolic_chk:w
              }
            \exp_not:c { @@_variable_#1_o:w } { } ;
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_set_var:nn}
%    \begin{macrocode}
\cs_new:Npn \fp_set_var:nn #1#2
  {
    \cs_set_protected:cpx { @@_variable_#1_o:w } \s_@@_stop
      {
        \@@_parse:n {#2}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\__msg_kernel_new:nnnn { fp-symbolic } { word-exists }
  { Floating~point~word~'#1'~exists. }
  {
    The~word~'#1'~already~has~a~meaning~in~floating~point~expressions,~
    and~it~cannot~be~defined~again.
  }
%    \end{macrocode}
%
% \subsection{Road-map}
%
% The following functions are not implemented: min, max, |?:|,
% comparisons, |round|.
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
