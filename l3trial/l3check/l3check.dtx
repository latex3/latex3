% \iffalse
%
%% File l3check.dtx (C) Copyright 2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{l3names}
\GetIdInfo$Id$
  {L3 Checking and debugging LaTeX3 code}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3check} package\\ Checking and debugging \LaTeX3 code^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{\pkg{l3check} documentation}
%
% \subsection{Internal commands}
%
% \begin{function}[int]{\__check_patch_protected:Npnn}
% \begin{function}[int]{\__check_patch:Npnn}
%   \begin{syntax}
%     \cs{__check_patch_protected:Npnn} \meta{function} \meta{parameters_1} \Arg{parameters_2} \Arg{replacement text}
%   \end{syntax}
%   Uses the \meta{defining function} to redefine the \meta{function}.
%   The \meta{function} will take the \meta{parameters} and expand to
%   the \meta{replacement text}, followed by a copy of the original
%   function acting on the \meta{parameters_2}, which should be
%   identical to the \meta{parameters_1}, but wrapped within braces.
%   For instance,
%   \begin{quote}
%     \cs{__check_patch_protected:Npnn} \cs{tl_set:Nn} |#1| |{ #1 }| \\
%       |{| \cs{__check_cs_exist:N} |#1| |}|
%   \end{quote}
%   redefines \cs{tl_set:Nn} to check that its first argument exists
%   before performing its initial duty.
% \end{function}
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3check} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=check>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%    \end{macrocode}
%
% \subsection{Patching commands}
%
% \begin{macro}[int]{\@@_patch_protected:Npnn}
% \begin{macro}[aux]{\@@_patch_protected_aux:NNnnn}
%   The current code of |#1| is copied into a private control sequence,
%   whose name we build and pass to the auxiliary.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_patch_protected:Npnn #1#2#
  {
    \exp_args:Nc \@@_patch_protected_aux:NNnnn
      { @@_patched_ \cs_to_str:N #1 } #1 {#2}
  }
\cs_new_protected:Npn \@@_patch_protected_aux:NNnnn #1#2#3#4#5
  {
    \cs_new_eq:NN #1 #2
    \cs_gset_protected:Npn #2 #3 { #5 #1 #4 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_patch:Npnn}
% \begin{macro}[aux]{\@@_patch_aux:NNnnn}
%   The current code of |#1| is copied into a private control sequence,
%   whose name we build and pass to the auxiliary.
%    \begin{macrocode}
\cs_new:Npn \@@_patch:Npnn #1#2#
  {
    \exp_args:Nc \@@_patch_aux:NNnnn
      { @@_patched_ \cs_to_str:N #1 } #1 {#2}
  }
\cs_new:Npn \@@_patch_aux:NNnnn #1#2#3#4#5
  {
    \cs_new_eq:NN #1 #2
    \cs_gset:Npn #2 #3 { #5 #1 #4 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{\pkg{l3basics}}
%
% Functions which we might want to hook into: \cs{cs_show:N},
% \cs{cs_show:c}, \cs{group_begin:}, \cs{group_end:},
% \cs{group_insert_after:N}, \cs{exp_args:Nc}.
%
% The $48$ assignment functions: |set|, |gset|, |new|; |protected| or
% not, |nopar| or not, |n| or |x|, with |p| or not.  Of course, this
% automatically extends to the |c| variants.  We could
% \begin{itemize}
%   \item check that \enquote{nopar} is used properly;
%   \item list any undefined token appearing in any cs definition, in
%     particular variants;
%   \item perhaps detect functions from the \enquote{msg} module, and
%     check that the corresponding message exists.
% \end{itemize}
%
% The $3$ copying functions: |set|, |gset|, |new|, extending
% automatically to the |c| variants.  We could trigger an error if the
% second argument is not defined and is not exactly \cs{scan_stop:} or
% \cs{c_undefined:D}.
%
% \subsection{\pkg{l3expan}}
%
% \begin{variable}{\q_@@}
% \begin{macro}{\@@_tl_head:w}
%    \begin{macrocode}
\quark_new:N \q_@@
\cs_new:Npn \@@_tl_head:w #1#2 \q_@@ {#1}
\cs_new:Npn \@@_tl_head:n #1
  { \etex_unexpanded:D \exp_after:wN { \@@_tl_head:w #1 { } \q_@@ } }
%    \end{macrocode}
% \end{macro}
% \end{variable}
%
% The \cs{cs_generate_variant:Nn} function should be altered, to check
% that it is only doing sensible replacements in the arg spec.
%
% \begin{macro}[EXP]{\use:c}
% \begin{macro}[aux, EXP]{\@@_cs_use:N}
%   Add to \cs{use:c} a check that the control sequence thus constructed
%   is defined.  We need to be extra careful in case |#1| is one of the
%   alignment primitives.
%    \begin{macrocode}
\cs_gset_nopar:Npn \use:c { \exp_args:Nc \@@_cs_use:N }
\cs_new:Npn \@@_cs_use:N #1
  {
    \group_align_safe_begin:
      \cs_if_exist:NF #1
        { \ERROR }
    \group_align_safe_end:
    #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\::N, \::V, \::V_unbraced}
% \begin{macro}[aux, EXP]{\@@_if_N_type:nF}
%   Two of the expansion types expect a single token.  Otherwise, raise
%   an error.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_N_type:n #1 { F }
  {
    \str_if_eq_x:nnTF
      { \exp_after:wN \exp_not:n \exp_after:wN { \use:n #1 { } } }
      { \exp_not:n { #1 { } } }
      {
        \str_if_eq_x:nnTF { \exp_not:n {#1} } { \@@_tl_head:n {#1} }
          { \prg_return_true: }
          { \prg_return_false: }
      }
      { \prg_return_false: }
  }
\@@_patch:Npnn \::N #1 \::: #2#3 { {#1} \::: {#2} {#3} }
  {
    \@@_if_N_type:nF {#3} { \ERROR }
  }
\@@_patch:Npnn \::V #1 \::: #2#3 { {#1} \::: {#2} {#3} }
  {
    \@@_if_N_type:nF {#3} { \ERROR }
  }
\@@_patch:Npnn \::V_unbraced \::: #1#2 { \::: {#1} {#2} }
  {
    \@@_if_N_type:nF {#2} { \ERROR }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\::o, \::f, \::o_unbraced, \::f_unbraced}
% \begin{macro}[aux, EXP]{\@@_if_head_is_expandable:nF}
%   These functions expand an argument, once or fully.  If the argument
%   does not expand at all under the specified expansion type, warn the
%   user.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_head_is_expandable:n #1 { F }
  {
    \str_if_eq_x:nnTF
      { \exp_after:wN \exp_not:n \exp_after:wN { \use:n #1 { } } }
      { \exp_not:n { #1 { } } }
      {
        \group_align_safe_begin:
          \exp_after:wN \token_if_expandable:NTF
            \@@_tl_head:w #1 \q_@@
            { \prg_return_true: }
            { \prg_return_false: }
        \group_align_safe_end:
      }
      { \prg_return_false: }
  }
\@@_patch:Npnn \::o #1 \::: #2#3 { {#1} \::: {#2} {#3} }
  {
    \@@_if_head_is_expandable:nF {#3} { \WARNING }
  }
\@@_patch:Npnn \::f #1 \::: #2#3 { {#1} \::: {#2} {#3} }
  {
    \tl_if_head_eq_catcode:nNF {#3} \c_space_token
      { \@@_if_head_is_expandable:nF {#3} { \WARNING } }
  }
\@@_patch:Npnn \::o_unbraced \::: #1#2 { \::: {#1} {#2} }
  {
    \@@_if_head_is_expandable:nF {#2} { \WARNING }
  }
\@@_patch:Npnn \::f_unbraced \::: #1#2 { \::: {#1} {#2} }
  {
    \tl_if_head_eq_catcode:nNF {#2} \c_space_token
      { \@@_if_head_is_expandable:nF {#2} { \WARNING } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]
%   {
%     \exp_args:No, \exp_args:NNo, \exp_args:NNNo, \exp_args:Nc,
%     \exp_args:Ncc, \exp_args:Nccc, \exp_args:NNc,
%     \exp_args:Nf, \exp_args:NV, \exp_args:Nv,
%     \exp_args:NNV, \exp_args:NNv, \exp_args:NNf,
%     \exp_args:NVV,
%     \exp_args:Ncf, \exp_args:Nco,
%     \exp_args:Ncco, \exp_args:NcNc, \exp_args:NcNo,
%     \exp_args:NNNV
%   }
%   Remove hand-tuning, to make sure that our modified \cs{::o} and
%   \cs{::f} are called.
%    \begin{macrocode}
\cs_gset_nopar:Npn \exp_args:No { \::o \::: }
\cs_gset_nopar:Npn \exp_args:NNo { \::N \::o \::: }
\cs_gset_nopar:Npn \exp_args:NNNo { \::N \::N \::o \::: }
\cs_gset_nopar:Npn \exp_args:Nc { \::c \::: }
\cs_gset_nopar:Npn \exp_args:Ncc { \::c \::c \::: }
\cs_gset_nopar:Npn \exp_args:Nccc { \::c \::c \::c \::: }
\cs_gset_nopar:Npn \exp_args:NNc { \::N \::c \::: }
\cs_gset_nopar:Npn \exp_args:Nf { \::f \::: }
\cs_gset_nopar:Npn \exp_args:Nv { \::v \::: }
\cs_gset_nopar:Npn \exp_args:NV { \::V \::: }
\cs_gset_nopar:Npn \exp_args:NNf { \::N \::f \::: }
\cs_gset_nopar:Npn \exp_args:NNv { \::N \::v \::: }
\cs_gset_nopar:Npn \exp_args:NNV { \::N \::V \::: }
\cs_gset_nopar:Npn \exp_args:Nco { \::c \::o \::: }
\cs_gset_nopar:Npn \exp_args:Ncf { \::c \::f \::: }
\cs_gset_nopar:Npn \exp_args:NVV { \::V \::V \::: }
\cs_gset_nopar:Npn \exp_args:NNNV { \::N \::N \::V \::: }
\cs_gset_nopar:Npn \exp_args:NcNc { \::c \::N \::c \::: }
\cs_gset_nopar:Npn \exp_args:NcNo { \::c \::N \::o \::: }
\cs_gset_nopar:Npn \exp_args:Ncco { \::c \::c \::o \::: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]
%   {
%     \exp_last_unbraced:NV,
%     \exp_last_unbraced:Nv,
%     \exp_last_unbraced:Nf,
%     \exp_last_unbraced:No,
%     \exp_last_unbraced:Nco,
%     \exp_last_unbraced:NcV,
%     \exp_last_unbraced:NNV,
%     \exp_last_unbraced:NNo,
%     \exp_last_unbraced:NNNV,
%     \exp_last_unbraced:NNNo,
%   }
%   Remove hand-tuning.
%    \begin{macrocode}
\cs_gset_nopar:Npn \exp_last_unbraced:NV { \::V_unbraced \::: }
\cs_gset_nopar:Npn \exp_last_unbraced:Nv { \::v_unbraced \::: }
\cs_gset_nopar:Npn \exp_last_unbraced:No { \::o_unbraced \::: }
\cs_gset_nopar:Npn \exp_last_unbraced:Nf { \::f_unbraced \::: }
\cs_gset_nopar:Npn \exp_last_unbraced:Nco { \::c \::o_unbraced \::: }
\cs_gset_nopar:Npn \exp_last_unbraced:NcV { \::c \::V_unbraced \::: }
\cs_gset_nopar:Npn \exp_last_unbraced:NNV { \::N \::V_unbraced \::: }
\cs_gset_nopar:Npn \exp_last_unbraced:NNo { \::N \::o_unbraced \::: }
\cs_gset_nopar:Npn \exp_last_unbraced:NNNV { \::N \::N \::V_unbraced \::: }
\cs_gset_nopar:Npn \exp_last_unbraced:NNNo { \::N \::N \::o_unbraced \::: }
%    \end{macrocode}
% \end{macro}
%
% We could want to also do something about
% \cs{exp_last_two_unbraced:Noo}.
%
% \begin{macro}[EXP]
%   {\exp_not:o, \exp_not:c, \exp_not:f, \exp_not:V, \exp_not:v}
%   Remove more hand-tuning.  We need to base \cs{exp_not:c} on the |N|
%   variant, because the |n| variant is a primitive, which does not
%   accept unbraced arguments.
%    \begin{macrocode}
\cs_gset_nopar:Npn \exp_not:o { \exp_args:No \exp_not:n }
\cs_gset_nopar:Npn \exp_not:c { \exp_args:Nc \exp_not:N }
\cs_gset_nopar:Npn \exp_not:f { \exp_args:Nf \exp_not:n }
\cs_gset_nopar:Npn \exp_not:V { \exp_args:NV \exp_not:n }
\cs_gset_nopar:Npn \exp_not:v { \exp_args:Nv \exp_not:n }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Misc showing commands}
%
% \begin{macro}{\cs_show:c}
%    \begin{macrocode}
\cs_gset_protected:Npn \cs_show:c #1
  {
    \group_begin:
      \exp_after:wN
    \group_end:
    \exp_after:wN \cs_show:N \cs:w #1 \cs_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\__msg_show_variable:n}
%    \begin{macrocode}
\cs_gset_protected:Npn \__msg_show_variable:n #1
  {
    \tl_set:Nn \l__msg_internal_tl {#1}
    \tl_if_empty:NTF \l__msg_internal_tl
      { \etex_showtokens:D \exp_after:wN { } }
      {
        \exp_after:wN \etex_showtokens:D \exp_after:wN
          {
            \tex_romannumeral:D -`0
            \exp_after:wN \exp_after:wN
            \exp_after:wN \__msg_show_variable:w
            \exp_after:wN \l__msg_internal_tl
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{\texttt{l3kernel} test files failures}
%
% \begin{itemize}
%   \item \file{m3prg002}: \cs{cs_show:c} shows a
%     slightly different output.
%   \item \file{m3basics002}: \cs{prg_new_conditional:Npnn} with an
%     unknown or empty condition leads to \cs{use:c} with undefined
%     argument.
%   \item \file{m3compare001}: an unknown comparison operator leads to
%     \cs{use:c} with undefined argument.
%   \item some \file{m3fp...}: raising an exception leads to a warning.
%     The implementation should use \cs{cs:w} \ldots{} \cs{cs_end:}.
%   \item \file{m3int001}, \file{m3int002}: \cs{int_from_base:nn} should
%     not |f|-expand its first argument!
%   \item A bunch of files expand their arg with no good reason.
% \end{itemize}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
