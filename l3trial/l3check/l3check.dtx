% \iffalse
%
%% File l3check.dtx (C) Copyright 2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{l3names}
\GetIdInfo$Id$
  {L3 Checking and debugging LaTeX3 code}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3check} package\\ Checking and debugging \LaTeX3 code^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{Checks made in \texttt{l3kernel}}
%
% The \pkg{l3check} package redefines some of the \LaTeX3 internals to
% look for potential errors in the code, such as calling a token list
% function with a sequence argument.  Those checks come with a
% performance penalty and are thus disabled by default; they are
% activated using \cs{check_on:n}.
%
% The list of checks that are performed is as follows:
% \begin{itemize}
%   \item \pkg{l3expan} |N|-type and |V|-type arguments must be single
%     tokens; |o| and |f|-type expansion should not be called on
%     arguments that do not expand.
%   \item \pkg{l3tl} when a \enquote{tl~var} argument is expected, the
%     name is checked to end with |_tl|.
% \end{itemize}
%
% \section{Turning checks on and off}
%
% \begin{function}{\check_on:n}
%   \begin{syntax}
%     \cs{check_on:n} \Arg{modules}
%   \end{syntax}
%   Turns checking on globally for functions in each of the
%   \meta{modules}, given as a comma list.  This comes with a large
%   performance penalty, thus should only be used for testing purposes.
%   The special module \texttt{l3kernel} is recognized and turns on
%   checking for all modules in the \pkg{l3kernel} bundle.
% \end{function}
%
% \begin{function}{\check_off:n}
%   \begin{syntax}
%     \cs{check_off:n} \Arg{module}
%   \end{syntax}
%   Turns checking off globally for functions in each of the
%   \meta{modules}, given as a comma list.  Note that this function
%   keeps the performance penalty of \cs{check_on:n}, and simply
%   silences error messages.  The special module \texttt{l3kernel} is
%   recognized and turns off checking for all modules in the
%   \pkg{l3kernel} bundle.
% \end{function}
%
% \section{Defining checks}
%
% \begin{function}{\check_new:nn}
%   \begin{syntax}
%     \cs{check_new:nn} \Arg{module} \Arg{code}
%   \end{syntax}
%   Defines the action of \cs{check_on:n} \Arg{module} to be the
%   \meta{code}.  Note that |#| does not need to be duplicated within
%   the \meta{code}.
% \end{function}
%
% \section{Internal commands}
%
% \begin{function}[EXP, pTF]{\__check_if_on:n}
%   \begin{syntax}
%     \cs{__check_if_on:nTF} \Arg{module} \Arg{true code} \Arg{false code}
%     \cs{__check_if_on_p:n} \Arg{module}
%   \end{syntax}
%   Returns \texttt{true} if the \meta{module}'s checks are currently
%   on, \texttt{false} otherwise, including if the \meta{module} does
%   not exist or has no checks.  This is meant to be used in the
%   \meta{module}'s checking code (defined with \cs{check_new:nn}), to
%   determine whether to raise errors or not.
% \end{function}
%
% \begin{function}[int]{\__check_patch_protected:Npnn}
% \begin{function}[int]{\__check_patch:Npnn}
%   \begin{syntax}
%     \cs{__check_patch_protected:Npnn} \meta{function} \meta{parameters_1} \Arg{parameters_2} \Arg{replacement text}
%   \end{syntax}
%   Redefine the \meta{function}.  The \meta{function} will take the
%   \meta{parameters} and expand to the \meta{replacement text},
%   followed by a copy of the original function acting on the
%   \meta{parameters_2}, which should be identical to the
%   \meta{parameters_1}, but wrapped within braces.  For instance,
%   \begin{quote}
%     \cs{__check_patch_protected:Npnn} \cs{tl_set:Nn} |#1| |{ #1 }| \\
%       |{| \cs{__cs_chk_exist:N} |#1| |}|
%   \end{quote}
%   redefines \cs{tl_set:Nn} to check that its first argument exists
%   before performing its initial duty.
% \end{function}
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3check} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=check>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%    \end{macrocode}
%
% \subsection{Infrastructure}
%
% ^^A todo: also check that modules exist in \cs{check_on/off:n}?
%
% \begin{variable}{\l_@@_module_tl}
%   Holds the name of the module for which we are currently defining the
%   checking code, both within the definition of \cs{check_new:nn}, and
%   when its second argument is used within a \cs{check_on:n} call.
%    \begin{macrocode}
\tl_new:N \l_@@_module_tl
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{User commands}
%
% \begin{macro}{\check_new:nn}
%   This function does not accept a comma-delimited list of modules,
%   only single modules, so we check and refuse that.  If the module
%   |#1| already has a checking code defined, raise an error, but
%   replace the code by the new code.  Store the \meta{code} |#2| in a
%   control sequence.
%    \begin{macrocode}
\cs_new_protected:Npn \check_new:nn #1#2
  {
    \tl_set:Nx \l_@@_module_tl { \tl_to_str:n {#1} }
    \tl_if_in:NnTF \l_@@_module_tl { , }
      {
        \__msg_kernel_error:nnxx { check } { multiple-modules }
          { \token_to_str:N \check_new:nn } { \l_@@_module_tl }
      }
      {
        \cs_if_exist:cT { @@_module_ \l_@@_module_tl : }
          {
            \__msg_kernel_error:nnx { check } { module-exists }
              { \l_@@_module_tl }
            \cs_undefine:c { @@_module_ \l_@@_module_tl : }
          }
        \cs_new_protected_nopar:cpx { @@_module_ \l_@@_module_tl : }
          { \exp_not:n {#2} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\@@_if_on:n}
%   This test is to be used within the second argument of
%   \cs{check_new:nn}.  It is for instance inserted by
%   \cs{@@_patch:Npnn}.  It would be cleaner to use
%   \cs{cs_if_exist_use:cF}, but this function uses expansion, which
%   leads to an infinite recursion when \pkg{l3expan} functions are
%   checking and call this test.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_on:n #1 { p , T , F , TF }
  {
    \exp_after:wN \if_meaning:w
      \cs:w @@_if_module_#1_on_return: \cs_end:
      \scan_stop:
      \prg_return_false:
    \else:
      \cs:w @@_if_module_#1_on_return: \cs_end:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\check_on:n}
%   The argument is turned to a string (paranoia), then loop over
%   \meta{modules} in the argument.  If the \texttt{return} function for
%   that \meta{module} is already defined, the checking code was loaded
%   already, so we simply set it to \texttt{true}.  Otherwise, load the
%   checking code if it exists, and define the \texttt{return} function.
%   Note that \cs{l_@@_module_tl} holds the name of the \meta{module}
%   whose code is loaded.  This allow \cs{@@_patch:Npnn} commands
%   appearing in that checking code to insert the correct
%   \enquote{\texttt{if_on}} tests.
%    \begin{macrocode}
\cs_new_protected:Npn \check_on:n #1
  {
    \exp_args:No \clist_map_variable:nNn
      { \tl_to_str:n {#1} }
      \l_@@_module_tl
      {
        \cs_if_exist:cTF
          { @@_if_module_ \l_@@_module_tl _on_return: }
          {
            \cs_gset_eq:cN
              { @@_if_module_ \l_@@_module_tl _on_return: }
              \prg_return_true:
          }
          {
            \cs_if_exist:cT { @@_module_ \l_@@_module_tl : }
              {
                \cs_new_eq:cN
                  { @@_if_module_ \l_@@_module_tl _on_return: }
                  \prg_return_true:
                \use:c { @@_module_ \l_@@_module_tl : }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\check_off:n}
%   For each \meta{module} in the argument, if the \texttt{return}
%   function for that \meta{module} is defined, set it to
%   \texttt{false}.
%    \begin{macrocode}
\cs_new_protected:Npn \check_off:n #1
  {
    \exp_args:No \clist_map_inline:nn
      { \tl_to_str:n {#1} }
      {
        \cs_if_exist:cT { @@_if_module_##1_on_return: }
          {
            \cs_gset_eq:cN { @@_if_module_##1_on_return: }
              \prg_return_false:
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Patching commands, errors and warnings}
%
% \begin{macro}[int]{\@@_patch_protected:Npnn, \@@_patch:Npnn}
% \begin{macro}[aux]{\@@_patch_aux:NnNNnnn}
%   The current code of |#1| is copied into a private control sequence,
%   whose name we build and pass to the auxiliary.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_patch_protected:Npnn #1#2#
  {
    \exp_args:Nco \@@_patch_aux:NnNNnnn
      { @@_patched_ \cs_to_str:N #1 }
      { \l_@@_module_tl }
      \cs_gset_protected:Npn
      #1 {#2}
  }
\cs_new:Npn \@@_patch:Npnn #1#2#
  {
    \exp_args:Nco \@@_patch_aux:NnNNnnn
      { @@_patched_ \cs_to_str:N #1 }
      { \l_@@_module_tl }
      \cs_gset:Npn
      #1 {#2}
  }
\cs_new:Npn \@@_patch_aux:NnNNnnn #1#2#3#4#5#6#7
  {
    \cs_new_eq:NN #1 #4
    #3 #4 #5
      {
        \@@_if_on:nT {#2} { \if_false: { \fi: #7 \if_false: } \fi: }
        #1 #6
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_error:nn, \@@_error:nnn}
% \begin{macro}[EXP]{\@@_expandable_error:nn, \@@_expandable_error:nnn}
%   Wrappers around errors, expandable or not.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_error:nn
  { \__msg_kernel_error:nnn { check } }
\cs_new_nopar:Npn \@@_error:nnn
  { \__msg_kernel_error:nnnn { check } }
\cs_new_nopar:Npn \@@_expandable_error:nn
  { \__msg_kernel_expandable_error:nnn { check } }
\cs_new_nopar:Npn \@@_expandable_error:nnn
  { \__msg_kernel_expandable_error:nnnn { check } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_warning:nn, \@@_warning:nnn}
% \begin{macro}[EXP]{\@@_expandable_warning:nn, \@@_expandable_warning:nnn}
%   A wrapper around warnings, expandable or not.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_warning:nn
  { \__msg_kernel_warning:nnn { check } }
\cs_new_nopar:Npn \@@_warning:nnn
  { \__msg_kernel_warning:nnnn { check } }
\cs_new_nopar:Npn \@@_expandable_warning:nn
  {
    \cs_if_exist_use:NF
      \__msg_kernel_expandable_warning:nnn
      \__msg_kernel_expandable_error:nnn
        { check }
  }
\cs_new_nopar:Npn \@@_expandable_warning:nnn
  {
    \cs_if_exist_use:NF
      \__msg_kernel_expandable_warning:nnnn
      \__msg_kernel_expandable_error:nnnn
        { check }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Helpers}
%
% \begin{macro}[int]{\@@_tl_set:Nn, \@@_tl_gset:Nn}
%   We copy those functions to avoid their type checking turned on by
%   \cs{check_on:n} |{ l3tl }|.  The copies may act on any tokens.
%    \begin{macrocode}
 % \cs_new_eq:NN \@@_tl_set:Nn \tl_set:Nn
 % \cs_new_eq:NN \@@_tl_gset:Nn \tl_gset:Nn
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\q_@@}
% \begin{macro}[int]{\@@_tl_head:w, \@@_tl_head:n}
%   Safe copies of \cs{tl_head:n} functions.
%    \begin{macrocode}
\quark_new:N \q_@@
\cs_new:Npn \@@_tl_head:w #1#2 \q_@@ {#1}
\cs_new:Npn \@@_tl_head:n #1
  { \etex_unexpanded:D \exp_after:wN { \@@_tl_head:w #1 { } \q_@@ } }
%    \end{macrocode}
% \end{macro}
% \end{variable}
%
% \begin{macro}[EXP, int]{\@@_variable_get_scope:N}
% \begin{macro}[EXP, aux]{\@@_variable_get_scope_aux:w}
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:n { `* }
  \char_set_lccode:nn { `* } { `_ }
  \tl_to_lowercase:n
    {
      \group_end:
      \cs_new:Npn \@@_variable_get_scope:N #1
        {
          \exp_after:wN \exp_after:wN
          \exp_after:wN \@@_variable_get_scope_aux:w
          \cs_to_str:N #1 * \q_stop
        }
      \cs_new:Npn \@@_variable_get_scope_aux:w #1 * #2 \q_stop {#1}
    }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP, int]{\@@_variable_get_type:N}
% \begin{macro}[EXP, aux]
%   {\@@_variable_get_type_aux:ww, \@@_variable_get_type_end:ww}
%    \begin{macrocode}
 % \group_begin:
 %   \char_set_catcode_other:n { `* }
 %   \char_set_lccode:nn { `* } { `_ }
 %   \tl_to_lowercase:n
 %     {
 %       \group_end:
 %       \cs_new:Npn \@@_variable_get_type:N #1
 %         {
 %           \exp_after:wN \exp_after:wN
 %           \exp_after:wN \@@_variable_get_type_aux:ww
 %           \exp_after:wN \exp_after:wN
 %           \exp_after:wN *
 %           \cs_to_str:N #1 * { \q_stop \@@_variable_get_type_end:ww } *
 %         }
 %       \cs_new:Npn \@@_variable_get_type_aux:ww #1 * #2 *
 %         {
 %           \use_none_delimit_by_q_stop:w #2 #1 \q_stop
 %           \@@_variable_get_type_aux:ww #2 *
 %         }
 %     }
 % \cs_new:Npn \@@_variable_get_type_end:ww #1 \q_stop #2#3#4#5 {#1}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF]{\@@_variable_if_tl:N}
% \begin{macro}[int, EXP]{\@@_variable_if_tl_return:N}
% \begin{macro}[aux, EXP]{\@@_variable_if_tl_aux:w}
%
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_variable_if_tl:N #1 { p , T , F , TF }
  { \@@_variable_if_tl_return:N #1 }
\group_begin:
\char_set_catcode_other:N M
\char_set_catcode_other:N A
\char_set_catcode_other:N C
\char_set_catcode_other:N R
\char_set_catcode_other:N O
\tl_to_lowercase:n
  {
    \group_end:
    \cs_new:Npn \@@_variable_if_tl_return:N #1
      {
        \exp_after:wN \__tl_if_empty_return:o \exp_after:wN
          {
            \exp_after:wN \@@_variable_if_tl_aux:w
              \token_to_meaning:N #1 MACRO \q_stop
          }
      }
    \cs_new:Npn \@@_variable_if_tl_aux:w #1 MACRO #2 \q_stop { #1 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_variable_if_seq_return:N}
%    \begin{macrocode}
\cs_new:Npn \@@_variable_if_seq_return:N #1
  {
    \cs_if_exist:NTF #1
      {
        \@@_variable_if_tl:NTF #1
          {
            \exp_after:wN \@@_variable_if_seq_return_aux:nn
            #1 \q_recursion_tail \q_recursion_tail \q_recursion_stop
          }
          { \prg_return_false: }
      }
      { \prg_return_false: }
  }
\cs_new:Npn \@@_variable_if_seq_return_aux:nn #1#2
  {
    \quark_if_recursion_tail_stop_do:nn {#1} { \prg_return_true: }
    \quark_if_recursion_tail_stop_do:nn {#2} { \prg_return_false: }
    \str_if_eq:nnTF {#1} { \__seq_item:n }
      { \@@_variable_if_seq_return_aux:nn }
      { \@@_variable_if_seq_return_aux:nn ? \q_recursion_tail }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Common tests}
%
% \begin{macro}[EXP, int]{\@@_N_type_expandable:n}
% \begin{macro}[int]{\@@_N_type:n}
% \begin{macro}[aux, EXP]{\@@_if_N_type:nF, \@@_if_N_type:nTF}
%   Those functions check if a token list is a single |N|-type token.
%   We cannot safely use some of the built-in \LaTeX{} functions since
%   the token list may contain \cs{q_stop}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_N_type:n #1 { F , TF }
  {
    \str_if_eq_x:nnTF
      { \exp_after:wN \exp_not:n \exp_after:wN { \use:n #1 { } } }
      { \exp_not:n { #1 { } } }
      {
        \str_if_eq_x:nnTF { \exp_not:n {#1} } { \@@_tl_head:n {#1} }
          { \prg_return_true: }
          { \prg_return_false: }
      }
      { \prg_return_false: }
  }
\cs_new_protected:Npn \@@_N_type:n #1
  {
    \@@_if_N_type:nF {#1}
      { \@@_error:nn { not-N-type } {#1} }
  }
\cs_new:Npn \@@_N_type_expandable:n #1
  {
    \@@_if_N_type:nF {#1}
      { \@@_expandable_error:nn { not-N-type } {#1} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP, int]{\@@_cs_exist_expandable:n}
% \begin{macro}[int]{\@@_cs_exist:n}
%   Check that the argument is a single existing token.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cs_exist:n #1
  {
    \@@_if_N_type:nTF {#1}
      { \cs_if_exist:NF #1 { \@@_error:nn { unknown-cs } {#1} } }
      { \@@_error:nn { not-N-type } {#1} }
  }
\cs_new:Npn \@@_cs_exist_expandable:n #1
  {
    \@@_if_N_type:nTF {#1}
      {
        \cs_if_exist:NF #1
          { \@@_expandable_error:nn { unknown-cs } {#1} }
      }
      { \@@_expandable_error:nn { not-N-type } {#1} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP, int]
%   {\@@_variable_type_expandable:nn, \@@_variable_type_only_expandable:nn}
% \begin{macro}[int]{\@@_variable_type:nn, \@@_variable_type_only:nn}
% \begin{macro}[aux, EXP]{\@@_if_variable_type:NnF}
%   Those functions check if the token list |#1| is a single |N|-type
%   token with type |#2|.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_variable_type:Nn #1#2 { F }
  { \cs:w @@_variable_if_ #2 _return:N \cs_end: #1 }
\cs_new:Npn \@@_variable_type_aux:NNNnn #1#2#3#4#5
  {
    \@@_if_N_type:nTF {#4}
      {
        \cs_if_exist:NTF #4
          {
            \@@_if_variable_type:NnF #4 {#5}
              { #1 { wrong-type } {#4} {#5} }
          }
          { #2 { non-declared-variable } {#4} }
      }
      { #3 { not-N-type } {#4} }
  }
\cs_new_protected_nopar:Npn \@@_variable_type:nn
  {
    \@@_variable_type_aux:NNNnn
      \@@_warning:nnn \@@_error:nn \@@_error:nn
  }
\cs_new_protected_nopar:Npn \@@_variable_type_only:nn
  {
    \@@_variable_type_aux:NNNnn
      \@@_warning:nnn \use_none:nn \@@_error:nn
  }
\cs_new_nopar:Npn \@@_variable_type_expandable:nn
  {
    \@@_variable_type_aux:NNNnn
      \@@_expandable_warning:nnn
      \@@_expandable_error:nn
      \@@_expandable_error:nn
  }
\cs_new_nopar:Npn \@@_variable_type_only_expandable:nn
  {
    \@@_variable_type_aux:NNNnn
      \@@_expandable_warning:nnn
      \use_none:nn
      \@@_expandable_error:nn
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP, int]{\@@_variable_scope_type_expandable:nnn}
% \begin{macro}[int]
%   {\@@_variable_scope_type:nnn, \@@_variable_scope_type_only:nnn}
% \begin{macro}[aux, EXP]{\@@_if_variable_scope:NnF}
%   Those functions check if the token list |#1| is a single |N|-type
%   token with scope |#2| and type |#3|.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_variable_scope:Nn #1#2 { F }
  {
    \__str_if_eq_x_return:nn
      { \@@_variable_get_scope:N #1 } {#2}
  }
\cs_new:Npn \@@_variable_scope_type_aux:NNNNnnn #1#2#3#4#5#6#7
  {
    \@@_if_N_type:nTF {#5}
      {
        \cs_if_exist:NTF #5
          {
            \@@_if_variable_type:NnF #5 {#7}
              { #1 { wrong-type } {#5} {#7} }
          }
          { #2 { non-declared-variable } {#5} }
        \@@_if_variable_scope:NnF #5 {#6}
          { #3 { wrong-scope } {#5} {#6} }
      }
      { #4 { not-N-type } {#5} }
  }
\cs_new_protected_nopar:Npn \@@_variable_scope_type:nnn
  {
    \@@_variable_scope_type_aux:NNNNnnn
      \@@_warning:nnn
      \@@_error:nn
      \@@_warning:nnn
      \@@_error:nn
  }
\cs_new_protected_nopar:Npn \@@_variable_scope_type_only:nnn
  {
    \@@_variable_scope_type_aux:NNNNnnn
      \@@_warning:nnn
      \use_none:nn
      \@@_warning:nnn
      \@@_error:nn
  }
\cs_new_nopar:Npn \@@_variable_scope_type_expandable:nnn
  {
    \@@_variable_scope_type_aux:NNNNnnn
      \@@_expandable_warning:nnn
      \@@_expandable_error:nn
      \@@_expandable_warning:nnn
      \@@_expandable_error:nn
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{General messages}
%
%
%    \begin{macrocode}
\__msg_kernel_new:nnn { check } { multiple-modules }
  { The~function~#1~expects~a~single~module,~not~'#2'. }
\__msg_kernel_new:nnn { check } { module-exists }
  { The~checking~code~for~module~'#1'~is~already~defined. }
%    \end{macrocode}
%
%    \begin{macrocode}
\__msg_kernel_new:nnn { check } { not-N-type }
  { Non~N~argument~#1 }
\__msg_kernel_new:nnn { check } { unknown-cs }
  { Unknown~command~#1 }
\__msg_kernel_new:nnn { check } { wrong-scope }
  { Variable~#1 should~start~with~'#2_' }
\__msg_kernel_new:nnn { check } { wrong-type }
  { Got~#1 instead~of~a~#2~variable }
%    \end{macrocode}
%
% \subsection{\texttt{l3kernel}}
%
% Start recording the code.  This ends after all the sections on
% specific modules.
%    \begin{macrocode}
\check_new:nn { l3kernel }
  {
%    \end{macrocode}
%
% \subsubsection{\pkg{l3basics}}
%
% Functions which we might want to hook into: \cs{group_begin:},
% \cs{group_end:}, \cs{group_insert_after:N}.
%
% The $48$ assignment functions: |set|, |gset|, |new|; |protected| or
% not, |nopar| or not, |n| or |x|, with |p| or not.  Of course, this
% automatically extends to the |c| variants.  We could
% \begin{itemize}
%   \item check that \enquote{nopar} is used properly;
%   \item list any undefined token appearing in any cs definition, in
%     particular variants;
%   \item perhaps detect functions from the \enquote{msg} module, and
%     check that the corresponding message exists.
% \end{itemize}
%
% \begin{macro}{\cs_set_eq:NN, \cs_gset_eq:NN, \cs_new_eq:NN}
%   The $3$ copying functions (extending automatically to the |c|
%   variants) expect their argument to be defined, unless it is exactly
%   \cs{scan_stop:}, \cs{tex_undefined:D}, or \cs{tex_relax:D}.
%    \begin{macrocode}
    % \tl_map_inline:nn { \cs_set_eq:NN , \cs_gset_eq:NN , \cs_new_eq:NN }
    %   {
    %     \@@_patch_protected:Npnn #1 ##1##2 { ##1 ##2 }
    %       {
    %         \str_case:nnn {##2}
    %           {
    %             { \tex_undefined:D } { }
    %             { \scan_stop: } { }
    %             { \tex_relax:D } { }
    %           }
    %           { \@@_cs_exist:n {##2} }
    %       }
    %   }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\__cs_check_exists:N}
%   We already check if the commands exist, so no need to keep the
%   \pkg{l3kernel} check.  We also redefine the message to remove a
%   space: |#1| will contain a trailing space in our case.
%    \begin{macrocode}
    \cs_gset_eq:NN \__cs_check_exists:N \use_none:n
    \__msg_kernel_set:nnnn { check } { non-declared-variable }
      {
        The~variable~\tl_trim_spaces:n{#1}~has~not~been~declared~
        \msg_line_context:.
      }
      {
        Checking~is~active,~and~you~have~tried~do~so~something~like: \\
        \ \ \tl_set:Nn ~ \tl_trim_spaces:n {#1} ~  \{ ~ ... ~ \} \\
        without~first~having: \\
        \ \ \tl_new:N ~ \tl_trim_spaces:n {#1} \\
        \\
        LaTeX~will~create~the~variable~and~continue.
      }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\pkg{l3expan}}
%
% The \cs{cs_generate_variant:Nn} function should be altered, to check
% that it is only doing sensible replacements in the arg spec.
%
% We could want to also do something about
% \cs{exp_last_two_unbraced:Noo}.
%
% \begin{macro}[EXP]{\use:c}
% \begin{macro}[aux, EXP]{\@@_cs_use:N}
%   Add to \cs{use:c} a check that the control sequence thus constructed
%   is defined.  We need the \texttt{align_safe} functions in case |#1|
%   is one of the alignment primitives.
%    \begin{macrocode}
    \cs_gset_nopar:Npn \use:c
      {
        \group_align_safe_begin:
          \exp_args:Nc \@@_cs_use:N
      }
    \cs_new:Npn \@@_cs_use:N #1
      {
          \cs_if_exist:NF #1
            { \@@_expandable_error:nn { unknown-cs } {#1} }
        \group_align_safe_end:
        #1
      }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\::N, \::V, \::V_unbraced}
%   Two of the expansion types expect a single token.  Otherwise, raise
%   an error.
%    \begin{macrocode}
    \@@_patch:Npnn \::N #1 \::: #2#3 { {#1} \::: {#2} {#3} }
      { \@@_N_type_expandable:n {#3} }
    \@@_patch:Npnn \::V #1 \::: #2#3 { {#1} \::: {#2} {#3} }
      { \@@_N_type_expandable:n {#3} }
    \@@_patch:Npnn \::V_unbraced \::: #1#2 { \::: {#1} {#2} }
      { \@@_N_type_expandable:n {#2} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\::o, \::f, \::o_unbraced, \::f_unbraced}
% \begin{macro}[aux, EXP]{\@@_if_head_is_expandable:nF}
%   These functions expand an argument, once or fully.  If the argument
%   does not expand at all under the specified expansion type, warn the
%   user.
%    \begin{macrocode}
    \prg_new_conditional:Npnn \@@_if_head_is_expandable:n #1 { F }
      {
        \str_if_eq_x:nnTF
          { \exp_after:wN \exp_not:n \exp_after:wN { \use:n #1 { } } }
          { \exp_not:n { #1 { } } }
          {
            \exp_after:wN \token_if_expandable:NTF
              \@@_tl_head:w #1 \q_@@
              { \prg_return_true: }
              { \prg_return_false: }
          }
          { \prg_return_false: }
      }
    \@@_patch:Npnn \::o #1 \::: #2#3 { {#1} \::: {#2} {#3} }
      {
        \@@_if_head_is_expandable:nF {#3}
          { \@@_expandable_warning:nn { no-expansion } {#3} }
      }
    \@@_patch:Npnn \::f #1 \::: #2#3 { {#1} \::: {#2} {#3} }
      {
        \tl_if_head_eq_catcode:nNF {#3} \c_space_token
          {
            \@@_if_head_is_expandable:nF {#3}
              { \@@_expandable_warning:nn { no-expansion } {#3} }
          }
      }
    \@@_patch:Npnn \::o_unbraced \::: #1#2 { \::: {#1} {#2} }
      {
        \@@_if_head_is_expandable:nF {#2}
          { \@@_expandable_warning:nn { no-expansion } {#2} }
      }
    \@@_patch:Npnn \::f_unbraced \::: #1#2 { \::: {#1} {#2} }
      {
        \tl_if_head_eq_catcode:nNF {#2} \c_space_token
          {
            \@@_if_head_is_expandable:nF {#2}
              { \@@_expandable_warning:nn { no-expansion } {#2} }
          }
      }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]
%   {
%     \exp_not:o, \exp_not:c, \exp_not:f, \exp_not:V, \exp_not:v,
%     \exp_args:No, \exp_args:NNo, \exp_args:NNNo, \exp_args:Nc,
%     \exp_args:Ncc, \exp_args:Nccc, \exp_args:NNc, \exp_args:Nf,
%     \exp_args:NV, \exp_args:Nv, \exp_args:NNV, \exp_args:NNv,
%     \exp_args:NNf, \exp_args:NVV, \exp_args:Ncf, \exp_args:Nco,
%     \exp_args:Ncco, \exp_args:NcNc, \exp_args:NcNo, \exp_args:NNNV,
%     \exp_last_unbraced:NV, \exp_last_unbraced:Nv,
%     \exp_last_unbraced:Nf, \exp_last_unbraced:No,
%     \exp_last_unbraced:Nco, \exp_last_unbraced:NcV,
%     \exp_last_unbraced:NNV, \exp_last_unbraced:NNo,
%     \exp_last_unbraced:NNNV, \exp_last_unbraced:NNNo,
%   }
%   Remove hand-tuning, to make sure that our modified \cs{::N},
%   \cs{::V}, \cs{::o} and \cs{::f} are called.  We need to base
%   \cs{exp_not:c} on the |N| variant, because the |n| variant is a
%   primitive, which does not accept unbraced arguments.
%    \begin{macrocode}
    \cs_gset_nopar:Npn \exp_not:o { \exp_args:No \exp_not:n }
    \cs_gset_nopar:Npn \exp_not:c { \exp_args:Nc \exp_not:N }
    \cs_gset_nopar:Npn \exp_not:f { \exp_args:Nf \exp_not:n }
    \cs_gset_nopar:Npn \exp_not:V { \exp_args:NV \exp_not:n }
    \cs_gset_nopar:Npn \exp_not:v { \exp_args:Nv \exp_not:n }
    \cs_gset_nopar:Npn \exp_args:No { \::o \::: }
    \cs_gset_nopar:Npn \exp_args:NNo { \::N \::o \::: }
    \cs_gset_nopar:Npn \exp_args:NNNo { \::N \::N \::o \::: }
    \cs_gset_nopar:Npn \exp_args:Nc { \::c \::: }
    \cs_gset_nopar:Npn \exp_args:Ncc { \::c \::c \::: }
    \cs_gset_nopar:Npn \exp_args:Nccc { \::c \::c \::c \::: }
    \cs_gset_nopar:Npn \exp_args:NNc { \::N \::c \::: }
    \cs_gset_nopar:Npn \exp_args:Nf { \::f \::: }
    \cs_gset_nopar:Npn \exp_args:Nv { \::v \::: }
    \cs_gset_nopar:Npn \exp_args:NV { \::V \::: }
    \cs_gset_nopar:Npn \exp_args:NNf { \::N \::f \::: }
    \cs_gset_nopar:Npn \exp_args:NNv { \::N \::v \::: }
    \cs_gset_nopar:Npn \exp_args:NNV { \::N \::V \::: }
    \cs_gset_nopar:Npn \exp_args:Nco { \::c \::o \::: }
    \cs_gset_nopar:Npn \exp_args:Ncf { \::c \::f \::: }
    \cs_gset_nopar:Npn \exp_args:NVV { \::V \::V \::: }
    \cs_gset_nopar:Npn \exp_args:NNNV { \::N \::N \::V \::: }
    \cs_gset_nopar:Npn \exp_args:NcNc { \::c \::N \::c \::: }
    \cs_gset_nopar:Npn \exp_args:NcNo { \::c \::N \::o \::: }
    \cs_gset_nopar:Npn \exp_args:Ncco { \::c \::c \::o \::: }
    \cs_gset_nopar:Npn \exp_last_unbraced:NV { \::V_unbraced \::: }
    \cs_gset_nopar:Npn \exp_last_unbraced:Nv { \::v_unbraced \::: }
    \cs_gset_nopar:Npn \exp_last_unbraced:No { \::o_unbraced \::: }
    \cs_gset_nopar:Npn \exp_last_unbraced:Nf { \::f_unbraced \::: }
    \cs_gset_nopar:Npn \exp_last_unbraced:Nco { \::c \::o_unbraced \::: }
    \cs_gset_nopar:Npn \exp_last_unbraced:NcV { \::c \::V_unbraced \::: }
    \cs_gset_nopar:Npn \exp_last_unbraced:NNV { \::N \::V_unbraced \::: }
    \cs_gset_nopar:Npn \exp_last_unbraced:NNo { \::N \::o_unbraced \::: }
    \cs_gset_nopar:Npn \exp_last_unbraced:NNNV { \::N \::N \::V_unbraced \::: }
    \cs_gset_nopar:Npn \exp_last_unbraced:NNNo { \::N \::N \::o_unbraced \::: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cs_show:c}
%   Now that we've removed hand-tuning from \cs{exp_args:Nc}, the output
%   of \cs{cs_show:c} becomes ugly.  We fix that by redefining the
%   function to use \cs{cs:w} directly.
%    \begin{macrocode}
    \cs_gset_protected:Npn \cs_show:c #1
      {
        \group_begin:
          \exp_after:wN
        \group_end:
        \exp_after:wN \cs_show:N \cs:w #1 \cs_end:
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\__msg_show_variable:n}
%   The internal \pkg{l3msg} function responsible for showing variables
%   is also redefined there to use the expansion underlying
%   \cs{exp_args:Nf} directly, for a better output.
%    \begin{macrocode}
    \cs_gset_protected:Npn \__msg_show_variable:n #1
      {
        \tl_set:Nn \l__msg_internal_tl {#1}
        \tl_if_empty:NTF \l__msg_internal_tl
          { \etex_showtokens:D \exp_after:wN { } }
          {
            \etex_showtokens:D \exp_after:wN
              {
                \tex_romannumeral:D -`0
                \exp_after:wN \exp_after:wN
                \exp_after:wN \__msg_show_variable:w
                \exp_after:wN \l__msg_internal_tl
              }
          }
      }
%    \end{macrocode}
% \end{macro}
%
%   Messages.
%    \begin{macrocode}
    \__msg_kernel_new:nnn { check } { no-expansion }
      { Redundant~expansion~in~#1 }
%    \end{macrocode}
%
% \subsubsection{\pkg{l3tl}}
%
% \begin{itemize}
%   \item We could check for a scope of \texttt{l} or \texttt{g} in
%     \cs{tl_new:N}.
%   \item The \cs{tl_if_exist:NTF} conditionals should also have a type
%     check, and their |c| variant should be a true variant.
%   \item The \texttt{rescan} functions could test that their argument
%     is rescan-safe perhaps.
%   \item \cs{tl_map_function:NN} could check that the second argument
%     has signature |:n|.
%   \item \cs{tl_map_break:} and other break functions could check if
%     they appear in a mapping, rather than break havoc otherwise.
% \end{itemize}
%
% \begin{macro}
%   {
%     \tl_set_eq:cN, \tl_set_eq:Nc, \tl_set_eq:cc,
%     \tl_gset_eq:cN, \tl_gset_eq:Nc, \tl_gset_eq:cc,
%   }
%   Redefine some functions as proper variants of their base functions.
%    \begin{macrocode}
    \cs_gset_protected_nopar:Npn \tl_set_eq:cN
      { \exp_args:Nc \tl_set_eq:NN }
    \cs_gset_protected_nopar:Npn \tl_set_eq:Nc
      { \exp_args:NNc \tl_set_eq:NN }
    \cs_gset_protected_nopar:Npn \tl_set_eq:cc
      { \exp_args:Ncc \tl_set_eq:NN }
    \cs_gset_protected_nopar:Npn \tl_gset_eq:cN
      { \exp_args:Nc \tl_gset_eq:NN }
    \cs_gset_protected_nopar:Npn \tl_gset_eq:Nc
      { \exp_args:NNc \tl_gset_eq:NN }
    \cs_gset_protected_nopar:Npn \tl_gset_eq:cc
      { \exp_args:Ncc \tl_gset_eq:NN }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tl_new:N, \tl_show:N, \tl_const:Nn, \tl_const:Nx}
%   Protected functions whose first argument is a token list which may
%   be undefined.
%    \begin{macrocode}
    \@@_patch_protected:Npnn \tl_new:N #1 { {#1} }
      { \@@_variable_type_only:nn {#1} { tl } }
    \@@_patch_protected:Npnn \tl_show:N #1 { {#1} }
      { \@@_variable_type_only:nn {#1} { tl } }
    \@@_patch_protected:Npnn \tl_const:Nn #1 { {#1} }
      { \@@_variable_scope_type_only:nnn {#1} { c } { tl } }
    \@@_patch_protected:Npnn \tl_const:Nx #1 { {#1} }
      { \@@_variable_scope_type_only:nnn {#1} { c } { tl } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\tl_if_exist:N}
%   Expandable test whose first argument is a token list which may be
%   undefined.
%    \begin{macrocode}
    \tl_map_inline:nn
      { \tl_if_exist:NTF \tl_if_exist:NT \tl_if_exist:NF \tl_if_exist_p:N }
      {
        \@@_patch:Npnn #1 ##1 { {##1} }
          { \@@_variable_type_only_expandable:nn {##1} { tl } }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \tl_set:Nn, \tl_set:No, \tl_set:Nx,
%     \tl_put_left:Nn, \tl_put_left:NV,
%     \tl_put_left:No, \tl_put_left:Nx,
%     \tl_put_right:Nn, \tl_put_right:NV,
%     \tl_put_right:No, \tl_put_right:Nx,
%     \tl_set_rescan:Nnn,
%     \tl_replace_once:Nnn, \tl_replace_all:Nnn,
%     \tl_trim_spaces:N, \tl_reverse:N,
%   }
%   Protected functions whose first argument is a defined, local token list.
%    \begin{macrocode}
    \tl_map_inline:nn
      {
        \tl_set:Nn \tl_set:No \tl_set:Nx
        \tl_put_left:Nn \tl_put_left:NV \tl_put_left:No \tl_put_left:Nx
        \tl_put_right:Nn \tl_put_right:NV \tl_put_right:No \tl_put_right:Nx
        \tl_set_rescan:Nnn
        \tl_replace_once:Nnn \tl_replace_all:Nnn
        \tl_trim_spaces:N \tl_reverse:N
      }
      {
        \@@_patch_protected:Npnn #1 ##1 { {##1} }
          { \@@_variable_scope_type:nnn {##1} { l } { tl } }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \tl_gset:Nn, \tl_gset:No, \tl_gset:Nx,
%     \tl_gput_left:Nn, \tl_gput_left:NV,
%     \tl_gput_left:No, \tl_gput_left:Nx,
%     \tl_gput_right:Nn, \tl_gput_right:NV,
%     \tl_gput_right:No, \tl_gput_right:Nx,
%     \tl_gset_rescan:Nnn,
%     \tl_greplace_once:Nnn, \tl_greplace_all:Nnn,
%     \tl_gtrim_spaces:N, \tl_greverse:N,
%   }
%   Protected functions whose first argument is a defined, global token list.
%    \begin{macrocode}
    \tl_map_inline:nn
      {
        \tl_gset:Nn \tl_gset:No \tl_gset:Nx
        \tl_gput_left:Nn \tl_gput_left:NV
        \tl_gput_left:No \tl_gput_left:Nx
        \tl_gput_right:Nn \tl_gput_right:NV
        \tl_gput_right:No \tl_gput_right:Nx
        \tl_gset_rescan:Nnn
        \tl_greplace_once:Nnn \tl_greplace_all:Nnn
        \tl_gtrim_spaces:N \tl_greverse:N
      }
      {
        \@@_patch_protected:Npnn #1 ##1 { {##1} }
          { \@@_variable_scope_type:nnn {##1} { g } { tl } }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tl_set_eq:NN, \tl_gset_eq:NN}
%   Protected functions whose first argument is a defined, local or
%   global token list, and whose second argument is a defined token
%   list.  Importantly, |#1| and |#2| are not braced in the first |n|
%   argument of \cs{@@_patch_protected:Npnn}.
%    \begin{macrocode}
    \@@_patch_protected:Npnn \tl_set_eq:NN #1#2 { #1 #2 }
      {
        \@@_variable_scope_type:nnn {#1} { l } { tl }
        \@@_variable_type:nn {#2} { tl }
      }
    \@@_patch_protected:Npnn \tl_gset_eq:NN #1#2 { #1 #2 }
      {
        \@@_variable_scope_type:nnn {#1} { g } { tl }
        \@@_variable_type:nn {#2} { tl }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tl_concat:NNN, \tl_gconcat:NNN}
%   Protected functions whose three arguments are defined token lists,
%   with a first argument local or global depending on the function.
%    \begin{macrocode}
    \@@_patch_protected:Npnn \tl_concat:NNN #1#2#3 { {#1} {#2} {#3} }
      {
        \@@_variable_scope_type:nnn {#1} { l } { tl }
        \@@_variable_type:nn {#2} { tl }
        \@@_variable_type:nn {#3} { tl }
      }
    \@@_patch_protected:Npnn \tl_gconcat:NNN #1#2#3 { {#1} {#2} {#3} }
      {
        \@@_variable_scope_type:nnn {#1} { g } { tl }
        \@@_variable_type:nn {#2} { tl }
        \@@_variable_type:nn {#3} { tl }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \tl_map_inline:Nn, \tl_map_variable:NNn,
%     \tl_if_in:NnTF, \tl_if_in:NnT, \tl_if_in:NnF,
%   }
%   Protected functions whose first argument is a defined token list.
%    \begin{macrocode}
    \tl_map_inline:nn
      {
        \tl_map_inline:Nn \tl_map_variable:NNn
        \tl_if_in:NnTF \tl_if_in:NnT \tl_if_in:NnF
      }
      {
        \@@_patch_protected:Npnn #1 ##1 { {##1} }
          { \@@_variable_type:nn {##1} { tl } }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\tl_if_empty:N, \tl_if_single:N}
% \begin{macro}[EXP]{\tl_map_function:NN, \tl_head:N, \tl_tail:N}
%   Expandable functions whose first argument is a defined token list.
%    \begin{macrocode}
    \tl_map_inline:nn
      {
        \tl_if_empty_p:N  \tl_if_empty:NTF
        \tl_if_empty:NT   \tl_if_empty:NF
        \tl_if_single_p:N \tl_if_single:NTF
        \tl_if_single:NT  \tl_if_single:NF
        \tl_map_function:NN \tl_head:N \tl_tail:N
      }
      {
        \@@_patch:Npnn #1 ##1 { {##1} }
          { \@@_variable_type_expandable:nn {##1} { tl } }
      }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\tl_if_eq:NN}
%   Expandable functions whose two arguments are defined token lists.
%    \begin{macrocode}
    \tl_map_inline:nn
      { \tl_if_eq_p:NN \tl_if_eq:NNTF \tl_if_eq:NNT \tl_if_eq:NNF }
      {
        \@@_patch:Npnn #1 ##1##2 { {##1} {##2} }
          {
            \@@_variable_type_expandable:nn {##1} { tl }
            \@@_variable_type_expandable:nn {##2} { tl }
          }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\tl_map_function:nN}
% \begin{macro}{\tl_map_variable:nNn}
%   An expandable and a protected functions whose second argument is defined.
%    \begin{macrocode}
    \@@_patch:Npnn \tl_map_function:nN #1#2 { {#1} {#2} }
      { \@@_cs_exist_expandable:n {#2} }
    \@@_patch_protected:Npnn \tl_map_variable:nNn #1#2 { {#1} {#2} }
      { \@@_cs_exist:n {#2} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\tl_to_str:N}
%   We need to redefine that one from scratch, since it may be expected
%   to expand in two steps.
%    \begin{macrocode}
    \cs_gset:Npn \tl_to_str:N #1
      {
        \etex_detokenize:D
          \@@_if_on:nT { l3tl }
            { \@@_variable_type_expandable:nn {#1} { tl } }
          \exp_after:wN {#1}
      }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\pkg{l3seq}}
%
% \begin{itemize}
%   \item The \cs{seq_if_exist:NTF} conditionals should also have a type
%     check, and their |c| variant should be a true variant.
% \end{itemize}
%
% \begin{macro}{\seq_new:N, \seq_show:N}
%   Protected functions whose first argument is a sequence which may be
%   undefined.
%    \begin{macrocode}
    \@@_patch_protected:Npnn \seq_new:N #1 { {#1} }
      { \@@_variable_type_only:nn {#1} { seq } }
    \@@_patch_protected:Npnn \seq_show:N #1 { {#1} }
      { \@@_variable_type_only:nn {#1} { seq } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\seq_if_exist:N}
%   Expandable test whose first argument is a sequence which may be
%   undefined.
%    \begin{macrocode}
    \tl_map_inline:nn
      { \seq_if_exist:NTF \seq_if_exist:NT \seq_if_exist:NF \seq_if_exist_p:N }
      {
        \@@_patch:Npnn #1 ##1 { {##1} }
          { \@@_variable_type_only_expandable:nn {##1} { seq } }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \seq_set_split:Nnn,
%     \seq_put_left:Nn, \seq_put_right:Nn, \seq_push:Nn,
%     \seq_remove_duplicates:N, \seq_remove_all:Nn
%   }
%   Protected functions whose first argument is a defined, local sequence.
%    \begin{macrocode}
    \tl_map_inline:nn
      {
        \seq_set_split:Nnn
        \seq_put_left:Nn \seq_put_right:Nn \seq_push:Nn
        \seq_remove_duplicates:N \seq_remove_all:Nn
      }
      {
        \@@_patch_protected:Npnn #1 ##1 { {##1} }
          { \@@_variable_scope_type:nnn {##1} { l } { seq } }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \seq_gset_split:Nnn,
%     \seq_gput_left:Nn, \seq_gput_right:Nn, \seq_gpush:Nn,
%     \seq_gremove_duplicates:N, \seq_gremove_all:Nn,
%   }
%   Check that arguments are defined, have the right type and scope.
%    \begin{macrocode}
    \tl_map_inline:nn
      {
        \seq_gset_split:Nnn
        \seq_gput_left:Nn \seq_gput_right:Nn \seq_gpush:Nn
        \seq_gremove_duplicates:N \seq_gremove_all:Nn
      }
      {
        \@@_patch_protected:Npnn #1 ##1 { {##1} }
          { \@@_variable_scope_type:nnn {##1} { g } { seq } }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\seq_set_eq:NN, \seq_gset_eq:NN}
%    \begin{macrocode}
    \@@_patch_protected:Npnn \seq_set_eq:NN #1#2 { #1 #2 }
      {
        \@@_variable_scope_type:nnn {#1} { l } { seq }
        \@@_variable_type:nn {#2} { seq }
      }
    \@@_patch_protected:Npnn \seq_gset_eq:NN #1#2 { #1 #2 }
      {
        \@@_variable_scope_type:nnn {#1} { g } { seq }
        \@@_variable_type:nn {#2} { seq }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\seq_concat:NNN, \seq_gconcat:NNN}
%    \begin{macrocode}
    \@@_patch_protected:Npnn \seq_concat:NNN #1#2#3 { {#1} {#2} {#3} }
      {
        \@@_variable_scope_type:nnn {#1} { l } { seq }
        \@@_variable_type:nn {#2} { seq }
        \@@_variable_type:nn {#3} { seq }
      }
    \@@_patch_protected:Npnn \seq_gconcat:NNN #1#2#3 { {#1} {#2} {#3} }
      {
        \@@_variable_scope_type:nnn {#1} { g } { seq }
        \@@_variable_type:nn {#2} { seq }
        \@@_variable_type:nn {#3} { seq }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\seq_new:c}
%   Some functions should be redefined as true variants of their base
%   function.
%    \begin{macrocode}
    \cs_gset_protected_nopar:Npn \seq_new:c
      { \exp_args:Nc \seq_new:N }
    \cs_gset_protected_nopar:Npn \seq_clear:c
      { \exp_args:Nc \seq_clear:N }
    \cs_gset_protected_nopar:Npn \seq_gclear:c
      { \exp_args:Nc \seq_gclear:N }
    \cs_gset_protected_nopar:Npn \seq_clear_new:c
      { \exp_args:Nc \seq_clear_new:N }
    \cs_gset_protected_nopar:Npn \seq_gclear_new:c
      { \exp_args:Nc \seq_gclear_new:N }
    \cs_gset_protected_nopar:Npn \seq_set_eq:cN
      { \exp_args:Nc \seq_set_eq:NN }
    \cs_gset_protected_nopar:Npn \seq_set_eq:Nc
      { \exp_args:NNc \seq_set_eq:NN }
    \cs_gset_protected_nopar:Npn \seq_set_eq:cc
      { \exp_args:Ncc \seq_set_eq:NN }
    \cs_gset_protected_nopar:Npn \seq_gset_eq:cN
      { \exp_args:Nc \seq_gset_eq:NN }
    \cs_gset_protected_nopar:Npn \seq_gset_eq:Nc
      { \exp_args:NNc \seq_gset_eq:NN }
    \cs_gset_protected_nopar:Npn \seq_gset_eq:cc
      { \exp_args:Ncc \seq_gset_eq:NN }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\seq_if_empty:c, \seq_if_exist:c}
%   Expandable functions which should be redefined as true variants of
%   their base function.
%    \begin{macrocode}
    \cs_gset_nopar:Npn \seq_if_empty:cTF
      { \exp_args:Nc \seq_if_empty:NTF }
    \cs_gset_nopar:Npn \seq_if_empty:cT
      { \exp_args:Nc \seq_if_empty:NT }
    \cs_gset_nopar:Npn \seq_if_empty:cF
      { \exp_args:Nc \seq_if_empty:NF }
    \cs_gset_nopar:Npn \seq_if_empty_p:c
      { \exp_args:Nc \seq_if_empty_p:N }
    \cs_gset_nopar:Npn \seq_if_exist:cTF
      { \exp_args:Nc \seq_if_exist:NTF }
    \cs_gset_nopar:Npn \seq_if_exist:cT
      { \exp_args:Nc \seq_if_exist:NT }
    \cs_gset_nopar:Npn \seq_if_exist:cF
      { \exp_args:Nc \seq_if_exist:NF }
    \cs_gset_nopar:Npn \seq_if_exist_p:c
      { \exp_args:Nc \seq_if_exist_p:N }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\seq_clear:N, \seq_gclear:N}
%   Clearing a sequence should be done by setting it equal to the empty
%   sequence, not a simple copy of the \cs{tl_clear:N} function anymore.
%    \begin{macrocode}
    \cs_gset_protected:Npn \seq_clear:N #1
      { \seq_set_eq:NN #1 \c_empty_seq }
    \cs_gset_protected:Npn \seq_gclear:N #1
      { \seq_gset_eq:NN #1 \c_empty_seq }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \seq_map_inline:Nn,
%     \seq_if_in:NnTF, \seq_if_in:NnT, \seq_if_in:NnF
%   }
%   Protected functions whose first argument is a defined sequence.
%    \begin{macrocode}
    \tl_map_inline:nn
      { \seq_map_inline:Nn \seq_if_in:NnTF \seq_if_in:NnT \seq_if_in:NnF }
      {
        \@@_patch_protected:Npnn #1 ##1 { {##1} }
          { \@@_variable_type:nn {##1} { seq } }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\seq_if_empty:N, \seq_if_eq:NN}
%   For these two tests, we check the type, expandably.
%    \begin{macrocode}
    \tl_map_inline:nn
      {
        \seq_if_empty_p:N \seq_if_empty:NTF
        \seq_if_empty:NT \seq_if_empty:NF
      }
      {
        \@@_patch:Npnn #1 ##1 { {##1} }
          { \@@_variable_type_expandable:nn {##1} { seq } }
      }
    \tl_map_inline:nn
      { \seq_if_eq_p:NN \seq_if_eq:NNTF \seq_if_eq:NNT \seq_if_eq:NNF }
      {
        \@@_patch:Npnn #1 ##1##2 { {##1} {##2} }
          {
            \@@_variable_type_expandable:nn {##1} { seq }
            \@@_variable_type_expandable:nn {##2} { seq }
          }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \seq_set_split:Nnn, \seq_gset_split:Nnn,
%     \seq_pop_left:NN, \seq_gpop_left:NN, \seq_pop:NN, \seq_gpop:NN,
%   }
%   We redefine those to use |\cs_| functions rather than |\tl_|
%   functions.
%    \begin{macrocode}
    % \cs_gset_protected_nopar:Npn \seq_set_split:Nnn
    %   { \__seq_set_split:NNnn \cs_set_nopar:Npx }
    % \cs_gset_protected_nopar:Npn \seq_gset_split:Nnn
    %   { \__seq_set_split:NNnn \cs_gset_nopar:Npx }
    % \cs_gset_protected_nopar:Npn \seq_pop_left:NN
    %   { \__seq_pop:NNNN \__seq_pop_left:NNN \@@_tl_set:Nn }
    % \cs_gset_protected_nopar:Npn \seq_gpop_left:NN
    %   { \__seq_pop:NNNN \__seq_pop_left:NNN \@@_tl_gset:Nn }
    % \cs_gset_eq:NN \seq_pop:NN \seq_pop_left:NN
    % \cs_gset_eq:NN \seq_gpop:NN \seq_gpop_left:NN
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \seq_map_variable:NNn ,
%     \seq_get_left:NN    , \seq_get_left:NNT    ,
%     \seq_get_left:NNF   , \seq_get_left:NNTF   ,
%     \seq_get_right:NN   , \seq_get_right:NNT   ,
%     \seq_get_right:NNF  , \seq_get_right:NNTF  ,
%     \seq_get:NN, \seq_get:NNT, \seq_get:NNF, \seq_get:NNTF,
%     \seq_pop_left:NN    , \seq_pop_left:NNT    ,
%     \seq_pop_left:NNF   , \seq_pop_left:NNTF   ,
%     \seq_pop_right:NN   , \seq_pop_right:NNT   ,
%     \seq_pop_right:NNF  , \seq_pop_right:NNTF  ,
%     \seq_pop:NN, \seq_pop:NNT, \seq_pop:NNF, \seq_pop:NNTF,
%     \seq_gpop_left:NN   , \seq_gpop_left:NNT   ,
%     \seq_gpop_left:NNF  , \seq_gpop_left:NNTF  ,
%     \seq_gpop_right:NN  , \seq_gpop_right:NNT  ,
%     \seq_gpop_right:NNF , \seq_gpop_right:NNTF ,
%     \seq_gpop:NN, \seq_gpop:NNT, \seq_gpop:NNF, \seq_gpop:NNTF,
%   }
%   One |seq| and one |tl| arguments.  The |pop| functions expect a
%   local sequence.  The |gpop| functions expect a global sequence.
%   Since the \cs{seq_map_variable:NNn} needs the same checks as the
%   |get| functions, we patch it here too.
%    \begin{macrocode}
    \tl_map_inline:nn
      {
        \seq_map_variable:NNn
        \seq_get_left:NN \seq_get_left:NNT
        \seq_get_left:NNF \seq_get_left:NNTF
        \seq_get_right:NN \seq_get_right:NNT
        \seq_get_right:NNF \seq_get_right:NNTF
        \seq_get:NN \seq_get:NNT \seq_get:NNF \seq_get:NNTF
      }
      {
        \@@_patch_protected:Npnn #1 ##1##2 { {##1} {##2} }
          {
            \@@_variable_type:nn {##1} { seq }
            \@@_variable_type:nn {##2} { tl }
          }
      }
    \tl_map_inline:nn
      {
        \seq_pop_left:NN \seq_pop_left:NNT
        \seq_pop_left:NNF \seq_pop_left:NNTF
        \seq_pop_right:NN \seq_pop_right:NNT
        \seq_pop_right:NNF \seq_pop_right:NNTF
        \seq_pop:NN \seq_pop:NNT \seq_pop:NNF \seq_pop:NNTF
      }
      {
        \@@_patch_protected:Npnn #1 ##1##2 { {##1} {##2} }
          {
            \@@_variable_scope_type:nnn {##1} { l } { seq }
            \@@_variable_type:nn {##2} { tl }
          }
      }
    \tl_map_inline:nn
      {
        \seq_gpop_left:NN \seq_gpop_left:NNT
        \seq_gpop_left:NNF \seq_gpop_left:NNTF
        \seq_gpop_right:NN \seq_gpop_right:NNT
        \seq_gpop_right:NNF \seq_gpop_right:NNTF
        \seq_gpop:NN \seq_gpop:NNT \seq_gpop:NNF \seq_gpop:NNTF
      }
      {
        \@@_patch_protected:Npnn #1 ##1##2 { {##1} {##2} }
          {
            \@@_variable_scope_type:nnn {##1} { g } { seq }
            \@@_variable_type:nn {##2} { tl }
          }
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\seq_map_function:NN}
%   Check that |#1| is a |seq| and |#2| is defined.
%    \begin{macrocode}
    \@@_patch:Npnn \seq_map_function:NN #1#2 { {#1} {#2} }
      {
        \@@_variable_type_expandable:nn {#1} { seq }
        \@@_cs_exist_expandable:n {#2}
      }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\pkg{l3int}}
%
% \subsubsection{\pkg{l3quark}}
%
% \subsubsection{\pkg{l3prg}}
%
%
%    \begin{macrocode}
  }
\check_on:n { l3kernel }
%    \end{macrocode}
%
% \subsection{\texttt{l3kernel} test files failures}
%
% \begin{itemize}
%   \item \file{m3basics002}: \cs{prg_new_conditional:Npnn} with an
%     unknown or empty condition leads to \cs{use:c} with undefined
%     argument.
%   \item \file{m3compare001}: an unknown comparison operator leads to
%     \cs{use:c} with undefined argument.
%   \item some \file{m3fp...}: raising an exception leads to a
%     \cs{use:c} warning.  The implementation should use \cs{cs:w}
%     \ldots{} \cs{cs_end:}.
%   \item \file{m3int001}, \file{m3int002}: \cs{int_from_base:nn} should
%     not |f|-expand its first argument!
%   \item A bunch of testfiles expand their arg with no good reason.
% \end{itemize}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
