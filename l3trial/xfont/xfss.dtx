% \iffalse
%
%% File xfss.dtx Copyright (C) 2011,2012,2013,2015-2019 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
%<*hook>
\RequirePackage{l3hooks}
%</hook>
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{xfss} package\\ Experimental Font Selection^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2018-04-30}
% \maketitle
% \tableofcontents
%
% \begin{documentation}
%
% \section{Introduction}
% A re-implementation of the NFSS in \pkg{expl3}.
% This has been written by dumping the plain un-commented
% code as part of the NFSS, then translating it piece-by-piece
% into the \pkg{expl3} syntax.
%
% As such, all code comments have been lost. (Most of) these will
% be restored as the code becomes functional.
%
% \section{Use}
% Load \pkg{xfss} as early as possible, preferably before the
% document class.
%
% \section{Third-party packages}
%
% The following packages will be incorporated into the functionality here.
% \begin{itemize}
% \item [everysel] Done.
%   Provides \cs{EverySelectfont} and \cs{AtNextSelectfont}.
% \item [relsize] Provides \cs{larger}, \cs{smaller} and similar commands.
% \item [extsizes]
% \end{itemize}
%
% \section{Commands}
%
% \subsection{User-level \LaTeXe{} commands}
%
% \begin{function}{\DeclareTextCommand,\ProvideTextCommand}
%   \begin{syntax}
%     \cs{DeclareTextCommand} <cmd> \Arg{enc.} <opt. arg> \Arg{def'n}
%   \end{syntax}
%   This defines <cmd> in the encoding <enc.> to have the definition <def'n>.
%   The optional argument can either follow the style of \cs{newcommand}
%   (two optional arguments: the number of arguments, and the default
%   argument in case the defined command should have an argument), or
%   the style of \pkg{xparse} (a braced argument specification).
% \end{function}
%
% \begin{function}{\DeclareTextCommandDefault,\ProvideTextCommandDefault}
%   \begin{syntax}
%     \cs{DeclareTextCommandDefault} <cmd> <opt. arg> \Arg{def'n}
%   \end{syntax}
% \end{function}
%
% \section{Internal commands}
%
% \begin{function}{\xfss_set_font_size_commands:n}
% \begin{syntax}
% "\xfss_set_font_size_commands:n {10}"
% \end{syntax}
% Sets the full range of size commands (\cs{small}, \cs{large}, etc.)
% according to the nominal font size "#1".
% In \LaTeXe, this command is executed \cs{AtBeginDocument} based on the
% current definition of \cs{normalsize} so the class font size is picked up.
% \end{function}
%
% \begin{function}{\xfss_switch_catcodes:}
% \begin{syntax}
% "  \group_begin:"\\
% "    \xfss_switch_catcodes:"\\
% "    ..."\\
% "  \group_end:"
% \end{syntax}
% Enables the catcode regime required for the parsing of font definition
% files.
% \begin{texnote}
% Was \LaTeXe's \cs{nfss@catcodes}
% \end{texnote}
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{xfss} implementation}
%
% The eventual goal is to have this package loadable both on top of
% \LaTeXe, overriding the NFSS, or in a standalone \LaTeX3 kernel.
%
%    \begin{macrocode}
%<*package|initex>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesExplPackage{xfss}{2018-04-30}{}
  {L3 Experimental font selection}
\RequirePackage{xparse}
\RequirePackage{l3font}

\bool_new:N \g_fss_undeclare_nfss_bool
\bool_new:N \g_fss_emulate_nfss_bool
\DeclareOption{clean} { \bool_set_true:N \g_fss_undeclare_nfss_bool }
\DeclareOption{compat}{ \bool_set_true:N \g_fss_emulate_nfss_bool   }
% \ExecuteOptions{clean,compat}% uncomment when it's working!
\ProcessOptions

%<*package>
\makeatletter
%</package>
%    \end{macrocode}
%
% \subsection{l3font candidates}
%
% \subsubsection{Math fonts}
%
% \begin{macro}{\c_max_math_fonts_int}
%   The maximum number of math fonts.\footnote{Bruno: is that the
%     same as math groups?}
%    \begin{macrocode}
\int_const:Nn \c_max_math_fonts_int {16}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\mathgroup_new:N,\mathgroup_new:c}
%   Allocating math groups. In package mode, we copy \cs{new@mathgroup}.
%   In format mode, we use \pkg{l3alloc}. The maximum number of
%   math groups is sixteen.\footnote{Bruno: is it the same as
%     \cs{c_max_math_fonts_int}? Are math groups and math fonts
%     the same concept?}
%    \begin{macrocode}
%<*package>
\cs_new_eq:NN \mathgroup_new:N \new@mathgroup
%</package>
%<*initex>
\__alloc_new:nnnN {mathgroup} { 0 } { 16 } \tex_chardef:D
%</initex>
\cs_generate_variant:Nn \mathgroup_new:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\mathgroup_use:N,\mathgroup_use:n}
%   Same as \TeX{}'s \tn{fam}. The \texttt{N} version is meant
%   to be used with actual \texttt{mathgroup} variables, while
%   the \texttt{n} version can be used with explicit numbers.
%   That one will be removed soon.
%    \begin{macrocode}
\cs_new_eq:NN \mathgroup_use:N \tex_fam:D
\cs_new:Npn \mathgroup_use:n #1
  { \tex_fam:D \int_eval:n {#1} \exp_stop_f: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\mathgroup}
%   Packages may expect \cs{mathgroup} to be \cs{tex_fam:D}.
%    \begin{macrocode}
%<package>\cs_set_eq:NN \mathgroup \mathgroup_use:N
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\newfam,\newfont}
% \cs{newfam} is a user function for creating new maths families.
% Shouldn't be necessary.
% Keep these here for the time being.
% \cs{newfont} is taken care of by \pkg{l3font}, so deprecate it.
%    \begin{macrocode}
%<*deprecated>
\cs_set_eq:NN \newfam  \mathgroup_new:N
\cs_set_eq:NN \newfont \fontface_new:Nn
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Unloading the original NFSS}
%
% These are only the commands required to be undefined before
% replacing them in all cases.
%
%    \begin{macrocode}
%<*package>
\tl_map_function:nN
  {
    \mathrm \mathnormal \mathcal \mathbf \mathsf \mathit \mathup \mathtt
    \rmdefault \sfdefault \ttdefault \bfdefault
    \mddefault \itdefault \sldefault \scdefault
    \updefault \encodingdefault \familydefault
    \seriesdefault \shapedefault
    \symlargesymbols \symsymbols \symoperators \symletters
    \small \footnotesize \scriptsize \tiny
    \large \Large \LARGE \huge \Huge
  }
  \cs_undefine:N
%</package>
%    \end{macrocode}
%
% However, if we wish to clean the slate an undeclare all NFSS commands:
% (see plain text source appended to xfss.dtx for where these come from)
%    \begin{macrocode}
%<*package>
\bool_if:NT \g_fss_undeclare_nfss_bool
  {
    \tl_map_function:nN
      {
        \normalsize
        \@nomath
        \new@mathgroup
        \DeclareFontShape
        \DeclareFontShape@
        \DeclareFixedFont
        \do@subst@correction
        \DeclareFontFamily
        \DeclareFontEncoding
        \DeclareFontEncoding@
        \LastDeclaredEncoding
        \DeclareFontSubstitution
        \DeclareFontEncodingDefaults
        \DeclarePreloadSizes
        \DeclareMathSizes
        \@DeclareMathSizes
        \@@enc@update
        \usefont
        \@defaultunits
        \strip@pt
        \pickup@font
        \curr@fontshape
        \define@newfont
        \try@load@fontshape
        \nfss@catcodes
        \DeclareErrorFont
        \wrong@fontshape
        \strip@prefix
        \extract@alph@from@version
        \math@egroup
        \calculate@math@sizes
        \defaultscriptratio
        \defaultscriptscriptratio
        \new@fontshape
        \subst@fontshape
        \extra@def
        \default@mextra
        \define@mathalphabet
        \define@mathgroup
        \scan@fontshape
        \addtoversion
        % \in@
        \select@group
        \init@restore@version
        \dorestore@version
        \document@select@group
        \process@table
        \DeclareMathVersion
        \new@mathversion
        \DeclareSymbolFont
        \new@symbolfont
        \SetSymbolFont
        \SetSymbolFont@
        \get@cdp
        \DeclareMathAlphabet
        \new@mathalphabet
        \SetMathAlphabet
        \SetMathAlphabet@
        \DeclareMathAccent
        \set@mathaccent
        \DeclareMathSymbol
        \set@mathchar
        \set@mathsymbol
        \DeclareMathDelimiter
        \@xxDeclareMathDelimiter
        \@DeclareMathDelimiter
        \@xDeclareMathDelimiter
        \set@mathdelimiter
        \set@@mathdelimiter
        \DeclareMathRadical
        \mathchar@type
        \DeclareSymbolFontAlphabet
        \DeclareSymbolFontAlphabet@
        \not@math@alphabet
        \boldmath
        \unboldmath
        \math@version
        \newfont
        \symbol
        \@setfontsize
        \@setsize
        \oldstylenums
        \hexnumber@
        \nfss@text
        \not@base
        \mho
        \Join
        \Box
        \Diamond
        \leadsto
        \sqsubset
        \sqsupset
        \lhd
        \unlhd
        \rhd
        \unrhd
        \tracingfonts
        \@font@info
        \@font@warning
        \extract@font
        \get@external@font
        \set@fontsize
        \glb@settings
        \baselinestretch
        \check@mathfonts
        \init@restore@glb@settings
        \restglb@settings
        \use@mathgroup
        \getanddefine@fonts
        \ifnot@nil
        \remove@to@nnil
        \remove@angles
        \remove@star
        \extract@sizefn
        \try@simple@size
        \set@simple@size@args
        \extract@rangefontinfo
        \is@range
        \check@range
        \check@single
        \set@size@funct@args
        \set@size@funct@args@
        \DeclareSizeFunction
        \execute@size@function
        \try@size@range
        \try@size@substitution
        \font@submax
        \fontsubfuzz
        \try@simples
        \empty@sfcnt
        \gen@sfcnt
        \genb@sfcnt
        \genb@x
        \genb@y
        \sub@sfcnt
        \subf@sfcnt
        \fixed@sfcnt
    }
      \cs_undefine:N
  }
%</package>
%    \end{macrocode}
%
%
%
% \subsection{expl3 extensions}
%^^A todo: accent wrapper
%
% \subsubsection{Function variants}
%
%    \begin{macrocode}
\cs_generate_variant:Nn \file_input:n { x }
\cs_generate_variant:Nn \prop_gput:Nnn {Nx, Nxx, cx,cxx}
\cs_generate_variant:Nn \prop_if_in:NnTF {Nx}
\cs_generate_variant:Nn \prop_gpop:NnNTF {Nx}
\cs_generate_variant:Nn \prop_gpop:NnNF {cx}
\cs_generate_variant:Nn \prop_gpop:NnN {cx}
\cs_generate_variant:Nn \prop_get:NnNT {cx}
\cs_generate_variant:Nn \str_foldcase:n { V }
%    \end{macrocode}
%
% \subsubsection{General}
%
% \begin{macro}{\cs_clear:N,\cs_gclear:N}
% Debatable names, but useful functions.
%    \begin{macrocode}
\cs_new_protected:Npn \cs_clear:N  #1 { \cs_set_eq:NN  #1 \prg_do_nothing: }
\cs_new_protected:Npn \cs_gclear:N #1 { \cs_gset_eq:NN #1 \prg_do_nothing: }
%    \end{macrocode}
% \end{macro}
%
% \begin{function}[TF]{\cs_meaning_if_in:NN}
%   \begin{syntax}
%     \cs{cs_meaning_if_in:NNTF} <cs_1> <cs_2> \Arg{true} \Arg{false}
%   \end{syntax}
%   These conditionals test if <cs_2> is used within the definition (or meaning)
%   of <cs_1>. Note this test can only make this test using string comparison,
%   so commands with escaped backslashes will still register as positives.
% \end{function}
%
% \begin{macro}[pTF]{\cs_meaning_if_in:NN}
%    \begin{macrocode}
\prg_new_conditional:Npnn \cs_meaning_if_in:NN #1#2 {TF,T,F}
  {
    \exp_args:Nxx \tl_if_in:nnTF
      { \cs_meaning:N #1 } { \token_to_str:N #2 }
      \prg_return_true: \prg_return_false:
  }
\cs_generate_variant:Nn \cs_meaning_if_in:NNTF {c}
\cs_generate_variant:Nn \cs_meaning_if_in:NNT  {c}
\cs_generate_variant:Nn \cs_meaning_if_in:NNF  {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\c_backslash_tl}
% A backslash `string'.
%    \begin{macrocode}
\tl_const:Nx \c_backslash_tl { \cs_to_str:N \\ }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Spaceskip and spacefactor}
%
% \begin{macro}{\font_set_spaceskip:n,\font_set_extra_spaceskip:n}
% Override the interword space that is usually specified on a per-font basis.
%    \begin{macrocode}
\cs_new:Npn \font_set_spaceskip:n       { \skip_set:Nn \tex_spaceskip:D  }
\cs_new:Npn \font_set_extra_spaceskip:n { \skip_set:Nn \tex_xspaceskip:D }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\font_reset_spaceskip:,\font_reset_xspaceskip:}
% Use the interword space specified by the font.
%    \begin{macrocode}
\cs_new:Npn \font_reset_spaceskip:       { \skip_zero:N \tex_spaceskip:D  }
\cs_new:Npn \font_reset_extra_spaceskip: { \skip_zero:N \tex_xspaceskip:D }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_spacefactor_save:,\xfss_spacefactor_restore:}
%   Sometimes we need to save and restore the space factor.
%   Not sure what the correct behaviour with respect to groups
%   should be.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_spacefactor_save:
  {
    \cs_gset_protected:Npx \xfss_spacefactor_restore:
      { \tex_spacefactor:D = \tex_the:D \tex_spacefactor:D \tex_relax:D }
  }
\cs_new_protected:Npn \xfss_spacefactor_restore: { \ERROR }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Dimensions and skips}
%
% \begin{macro}{\xfss_dim_strip_pt:n}
% \begin{macro}[aux]{\xfss_dim_strip_pt:w}
%   Mixture of \LaTeXe{}'s \cs{strip@pt} and \cs{@defaultunits}.
%   Accepts arguments valid for \cs{dim_eval:n} as well as real numbers
%   (whose default unit will be \texttt{pt}). Returns a dimension
%   without its \texttt{pt} unit.
%    \begin{macrocode}
\cs_new:Npn \xfss_dim_strip_pt:n #1
  {
    \exp_after:wN \exp_after:wN \exp_after:wN \xfss_dim_strip_pt:w
    \dim_eval:n { #1 pt } \q_stop
  }
\use:x
  {
    \cs_new:Npn \exp_not:N \xfss_dim_strip_pt:w
        ##1.##2 \tl_to_str:n {pt} ##3 \exp_not:N \q_stop
      {
        ##1
        \exp_not:N \int_compare:nNnT {##2} > { 0 } {.##2}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xfss_default_units:w}
%   Straight from \LaTeXe{}.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_default_units:w
  { \tex_afterassignment:D \use_none_delimit_by_q_nil:w }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_last_skip}
% This \emph{read-only} variable contains the amount of any glue
% placed into the output list directly prior to its being queried.
% \end{variable}
%
% \begin{macro}{\l_last_skip}
%    \begin{macrocode}
\cs_set_eq:NN \l_last_skip \tex_lastskip:D
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Props}
%
% \begin{function}{\prop_count:N}
%   \begin{syntax}
%     \cs{prop_count:N} <prop var>
%   \end{syntax}
%   Counts the number of key--value pairs in the property list.
%    \begin{macrocode}
\cs_set:Npn \prop_count:N #1
  {
    \int_eval:n
      {
        0
        \prop_map_function:NN #1 \prop_count_aux:nn
      }
  }
\cs_new:Npn \prop_count_aux:nn #1 #2 { + 1 }
%    \end{macrocode}
% \end{function}
%
% \subsubsection{Math}
%
% \begin{macro}{\mode_leave_vertical:}
% \begin{macro}{\xfss_text_in_math:n}
%   \pkg{expl3}'s \cs{mode_leave_vertical:} is different from \LaTeXe's.
%   \LaTeXe's \cs{leavevmode} and \cs{mbox}
%    \begin{macrocode}
 % \cs_new_protected:Npn \mode_leave_vertical:
 %   { \hbox_unpack_drop:N \c_empty_box }
\cs_if_free:NT \xfss_text_in_math:n
  {
    \cs_new_protected:Npn \xfss_text_in_math:n
      { \mode_leave_vertical: \hbox:n }
  }
\cs_set_protected:Npn \xfss_text_in_math:n #1 {{\mbox{#1}}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{function}{\math_inner:}
%   \begin{syntax}
%     "$"\cs{math_inner:} \dots{} "$"
%   \end{syntax}
%   This command is used inside an inline math environment; it removes
%   the surrounding space that normally appears around it in the text.
%   It is used when creating symbols and using maths inside tight boxes where
%   this space padding is unnecessary/inappropriate.
%   \begin{texnote}
%     This is \LaTeXe's \tn{m@th}.
%   \end{texnote}
% \end{function}
%
% \begin{macro}{\math_inner:}
% This is \LaTeXe's "\m@th".
%    \begin{macrocode}
\cs_new:Npn \math_inner: { \tex_mathsurround:D \c_zero_dim }
%<package>\cs_set_eq:NN \m@th \math_inner:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\math_nospace:}
%    \begin{macrocode}
\cs_new:Npn \math_nospace:
  {
    \tex_nulldelimiterspace:D \c_zero_dim
    \tex_mathsurround:D \c_zero_dim
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Hooks}
%
% \begin{macro}{\hook_kernel_omit_next:n}
%   Disclaimer: this won't work for the cr hook.
%    \begin{macrocode}
%<*hook>
\cs_new_protected:Npn \hook_kernel_omit_next:n #1
  {
    \tl_gset:cx { g_hook_kernel_ #1 _tl }
      {
        \tl_gset:Nn \exp_not:c { g_hook_kernel_ #1 _tl }
          { \exp_not:v { g_hook_kernel_ #1 _tl } }
      }
  }
%</hook>
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
% The message texts are set up within a group where spaces
% are not ignored.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_space:n {32}
%    \end{macrocode}
%
% \subsubsection{Info messages}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {overwrite-enc-defaults}
    {Overwriting encoding scheme #1 defaults}
  \msg_new:nnn {xfss} {try-load} {Trying to load font information for #1}
  \msg_new:nnn {xfss} {calc-math-sizes} {Calculating math sizes for size <#1>}
  \msg_new:nnn {xfss} {checking-defaults} {Checking defaults for #1}
  \msg_new:nnn {xfss} {okay!} { ... okay }
  \msg_new:nnn {xfss} {enc-change}
    {%
      Encoding `#1' has changed to `#2' for symbol font\\%
      `#3' in the math version `#4'%
    }
  \msg_new:nnn {xfss} {overwrite-symfont}
    {%
      Overwriting symbol font `#1' in version `#2'\\%
      \ \ \ \ #3 --> #4%
    }
  \msg_new:nnn {xfss} {overwrite-mathalph}
    {%
      Overwriting math alphabet `#1' in version `#2'\\%
      \ \ \ \ #3 --> #4%
    }
  \msg_new:nnn {xfss} {redeclaring} {Redeclaring #1 `#2'}
%    \end{macrocode}
%
%
% \subsubsection{Warnings}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {missing-font-shape}
    {Font shape `#1' undefined; using `#2' instead #3}
  \msg_new:nnn {xfss} {size-subst}
    {Size substitutions with differences of up to #1 have occurred.}
  \msg_new:nnn {xfss} {font-shape-unavail}
    {Font shape `#1' in size <#2> not available, size <#3> substituted.}
  \msg_new:nnn {xfss} {some-font-shapes-unavail}
    {Some font shapes were not available, defaults substituted.}
  \msg_new:nnn {xfss} {deprecated-function}
    {%
      The command #1 is deprecated and will be ignored. Any commands
      that are supposed to be defined here will not exist!%
    }
%    \end{macrocode}
%
% \subsubsection{Errors}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {cmd-defined} {Command `#1' already defined}
%    \end{macrocode}
%
% \subsubsection{Wrappers for messages}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {only-math-cmd} {#1 allowed only in math mode}
  \msg_new:nnn {xfss} {not-math-cmd} {Command #1 invalid in math mode}
  \msg_new:nnnn {xfss} {invalid-in-math}
    {Command \token_to_str:N #1 \ invalid in math mode}
    {%
       \str_if_eq:onTF {\exp_not:N #1} { \relax }
         {%
           Please define a new math alphabet
           if you want to use a special font in math mode%
         }
         {%
            Please use the math alphabet \token_to_str:N #2 \
            instead of the #1 command%
         }%
       .%
    }
%    \end{macrocode}
%
%    \begin{macrocode}
  \msg_new:nnnn {xfss} {no-math-alph}
    {%
      Math alphabet identifier #1 is undefined in math
      version `\l_xfss_math_version_tl'.%
    }
    {%
      Your requested math alphabet is undefined in the current
      math version. Check the spelling or use the
      \token_to_str:N \SetMathAlphabet \ command.%
    }
  \msg_new:nnnn {xfss} {no-math-alph-cmd}
    {Command `#1' not defined as a math alphabet.}
    {Use \token_to_str:N \DeclareMathAlphabet \ to define it.}
%    \end{macrocode}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {unavail-in-enc}
    {Command #1 unavailable in encoding \l_xfss_encoding_current_tl.}
  \msg_new:nnn {xfss} {font-family-unknown} {Font family `#1' unknown.}
  \msg_new:nnn {xfss} {font-enc-unknown} {Encoding scheme `#1' unknown.}
  \msg_new:nnn {xfss} {sym-font-unknown} {Symbol font `#1' not defined.}
  \msg_new:nnnn {xfss} {math-version-unknown}
    {Math version `#1' is not defined.}
    {%
      You probably misspelled the name of the math version.
      Or you have to specify an additional package.%
    }
  \msg_new:nnn {xfss} {font-not-found} {Font `#1' not found.}
  \msg_new:nnn {xfss} {too-many-alphabets}
    {Too many math alphabets used in version #1.}
  \msg_new:nnn {xfss} {not-cmd} {Not a command name: `#1'}
%    \end{macrocode}
%
%    \begin{macrocode}
  \msg_new:nnnn {xfss} {defaults-broken}
    {This XFSS system isn't set up properly.}
    {For encoding scheme #1 the defaults #2 do not form a valid font shape.}
  \msg_new:nnnn {xfss} {no-error-font} {This XFSS system isn't set up properly.}
    {%
      The system maintainer forgot to specify a suitable substitution
      font shape using the \token_to_str:N \DeclareErrorFont \ command.%
    }
%    \end{macrocode}
%
%    \begin{macrocode}
  \msg_new:nnnn {xfss} {encoding-file-missing}
    {%
      Encoding file `#1' not found.\\%
      You might have misspelt the name of the encoding.%
    }
    {%
      Necessary code for this encoding was not loaded.\\%
      Thus calling the encoding later on will produce further error messages.%
    }
%    \end{macrocode}
%
% \subsubsection{Font definition parsing messages}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {font-shape-scale}
    {%
      Font shape `\l_xfss_current_font_tl' will be
      scaled to size \dim_use:N \l_xfss_tmpb_dim.%
    }
  \msg_new:nnn {xfss} {font-shape-size-missing}
    {%
      Font shape `\l_xfss_current_font_tl' in size
      <\l_xfss_size_tl> not available.
      Font shape `\l_xfss_mandatory_arg_tl' tried instead.%
    }
  \msg_new:nnn {xfss} {font-shape-size-instead}
    {%
      Font shape `\l_xfss_current_font_tl' in size
      <\l_xfss_size_tl> not available.
      External font `\l_xfss_mandatory_arg_tl' used.%
    }
  \msg_new:nnn {xfss} {ext-font-loaded}
    {%
      External font `\l_xfss_external_font_tl' loaded for size
      <\l_xfss_size_tl>%
    }
%    \end{macrocode}
% Finally restore the normal catcode for the space character.
%    \begin{macrocode}
\group_end:
%    \end{macrocode}
%
% Three functions which only issue messages when in math mode.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_check_not_math:N #1
  {
    \mode_if_math:T
      { \msg_warning:nnx {xfss} {not-math-cmd} { \token_to_str:N #1 } }
  }
\cs_new_protected:Npn \xfss_check_not_math_alphabet:NN #1 #2
  {
    \mode_if_math:T
      { \msg_error:nnxx {xfss} {invalid-in-math} #1 #2 }
  }
\cs_new_protected:Npn \xfss_no_alphabet_error:N #1
  {
    \mode_if_math:T
      { \msg_error:nnx {xfss} {no-math-alph} { \token_to_str:N #1 } }
  }
%    \end{macrocode}
%
%
%
% \subsection{Preliminaries}
%
% \subsubsection{Encoding setup}
%
% Override/incorporate the fontenc package.
%
%    \begin{macrocode}
%<*package>
\cs_set_eq:NN \l_xfss_default_encoding_tl \encodingdefault
\cs_set_eq:NN \l_xfss_default_family_tl   \familydefault
\cs_set_eq:NN \l_xfss_default_series_tl   \seriesdefault
\cs_set_eq:NN \l_xfss_default_shape_tl    \shapedefault
%</package>
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \LoadFontEncoding #1
{
  \clist_map_inline:nn {#1}
  {
    \tl_set:Nn \l_xfss_default_encoding_tl {##1}
    \tl_set:Nx \l_fss_tmp_tl { \str_foldcase:n {##1} enc.def }
    \file_if_exist:nTF { \l_fss_tmp_tl }
      { \exp_args:Nx \file_input:n  { \l_fss_tmp_tl } }
      { \msg_error:nnx {xfss} {encoding-file-missing} {\l_fss_tmp_tl} }
  }
}
%    \end{macrocode}
%
% \subsubsection{Hooks}
%
% \begin{macro}{\g_hook_kernel_math_tl,\g_hook_kernel_display_tl}
%   Dirty kludge to remove the \cs{frozen@every} functions.
%   This should eventually move to the setup of \pkg{l3hooks}.
%    \begin{macrocode}
%<*hook>
\tl_gput_left:Nn \g_hook_kernel_math_tl    { \xfss_check_math_fonts: }
\tl_gput_left:Nn \g_hook_kernel_display_tl { \xfss_check_math_fonts: }
\seq_remove_all:Nn \g_hook_display_seq
  { \hook_item:n {\tex_the:D \frozen@everymath } }
\seq_remove_all:Nn \g_hook_display_seq
  { \hook_item:n {\tex_the:D \frozen@everydisplay } }
%</hook>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_hook_math_size_seq,\g_hook_kernel_math_size_tl}
%   Wrapper for the \LaTeXe{} \cs{every@math@size}.
%    \begin{macrocode}
%<*hook>
\hook_new:n { math_size }
%<package>\hook_pre_push:nn { math_size } { \tex_the:D \every@math@size }
%</hook>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_hook_selectfont_seq}
%   Used to support commands from the \texttt{everysel} package.
%    \begin{macrocode}
%<*hook>
\hook_new:n { selectfont }
%</hook>
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Variables, booleans, etc.}
%
%    \begin{macrocode}
\bool_new:N \l_xfss_math_fonts_bool
\bool_set_true:N \l_xfss_math_fonts_bool
%    \end{macrocode}
%
%    \begin{macrocode}
\bool_new:N \l_xfss_maybe_ic_bool
%    \end{macrocode}
%
%    \begin{macrocode}
\bool_new:N \l_xfss_tmp_bool
\skip_new:N \l_xfss_tmp_skip
\dim_new:N \l_xfss_tmpa_dim
\dim_new:N \l_xfss_tmpb_dim
\dim_new:N \l_xfss_tmpc_dim
\tl_new:N \l_xfss_tmpa_tl
\tl_new:N \l_xfss_tmpb_tl
\tl_new:N \l_xfss_tmpc_tl
\tl_new:N \l_xfss_tmpd_tl
\tl_new:N \l_xfss_tmpf_tl
%    \end{macrocode}
%
%    \begin{macrocode}
\tl_new:N \l_xfss_curr_math_size_tl
\tl_new:N \l_xfss_math_version_tl
\tl_new:N \l_xfss_default_family_tl
\tl_new:N \l_xfss_default_series_tl
\tl_new:N \l_xfss_default_shape_tl
\tl_new:N \l_xfss_optional_arg_tl
\tl_new:N \l_xfss_mandatory_arg_tl
\tl_new:N \l_xfss_external_font_tl
\tl_new:N \l_xfss_font_info_tl
\tl_new:N \l_xfss_sizefn_info_tl
%    \end{macrocode}
%
% Used to calculate font sizes and baselineskips automatically:
%    \begin{macrocode}
\fp_new:N \l_xfss_size_fp
\fp_new:N \l_xfss_bskip_fp
\fp_new:N \l_xfss_pow_fp
%    \end{macrocode}
%
% Used when parsing ranges for font substitution.
%    \begin{macrocode}
\dim_new:N \l_xfss_lower_bound_dim
\dim_new:N \l_xfss_upper_bound_dim
%    \end{macrocode}
%
% \begin{variable}{\g_xfss_math_alphabet_prop}
%   Maps math alphabets such as \texttt{mathit} to two control sequences:
%   either \cs{g_xfss_encoding_setup_math_}\meta{encoding}\texttt{_tl}
%   and a font name, or \cs{xfss_no_alphabet_error:N}, and the alphabet
%   as a cs.\footnote{Bruno: clarify.}
%    \begin{macrocode}
\prop_new:N \g_xfss_math_alphabet_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xfss_symbol_font_prop}
%   Maps a sym font name (in the form \enquote{\texttt{operators}}
%   rather than \LaTeXe{}'s \cs{symoperators}) to a corresponding
%   font name.
%    \begin{macrocode}
\prop_new:N \g_xfss_symbol_font_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xfss_cdp_prop}
%   Maps an encoding to the corresponding default font, in the form
%   \meta{family}/\meta{series}/\meta{shape}.
%    \begin{macrocode}
\prop_new:N \g_xfss_cdp_prop
%    \end{macrocode}
% \end{variable}
%
%    \begin{macrocode}
\tl_new:N \g_xfss_fontface_csname_tl
\tl_gclear:N \LastDeclaredEncoding
\bool_new:N \l_xfss_update_sizes_bool
\tl_new:N \l_xfss_family_tl
\tl_new:N \l_xfss_series_tl
\tl_new:N \l_xfss_shape_tl
\tl_new:N \l_xfss_size_tl
\tl_new:N \l_xfss_baselineskip_tl
\tl_new:N \l_xfss_linespread_tl
\tl_new:N \g_xfss_setup_currsize_tl
\bool_new:N \g_xfss_subst_warning_bool
\bool_new:N \l_xfss_catcodes_status_bool
\bool_new:N \g_xfss_restore_version_bool
%    \end{macrocode}
%    \begin{macrocode}
\tl_new:N \l_xfss_current_font_tl
\tl_set:Nn \l_xfss_current_font_tl
  {
    \l_xfss_encoding_tl / \l_xfss_family_tl /
    \l_xfss_series_tl   / \l_xfss_shape_tl
  }
%    \end{macrocode}
%
%
% \subsubsection{Tools}
%
% \begin{macro}{\xfss_switch_catcodes:}
% Turn on the catcode regime.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_switch_catcodes:
  {
    \bool_if:NF \l_xfss_catcodes_status_bool
      {
        \bool_set_true:N \l_xfss_catcodes_status_bool
        \makeatletter
        \char_set_catcode_ignore:n {32} % space
        \char_set_catcode_ignore:N \^^I
        \char_set_catcode_ignore:N \^^M
        \char_set_catcode_escape:N \\
        \char_set_catcode_group_begin:N \{
        \char_set_catcode_group_end:N \}
        \char_set_catcode_parameter:N \#
        \char_set_catcode_math_superscript:N \^
        \char_set_catcode_comment:N \%
        \char_set_catcode_other:N \<
        \char_set_catcode_other:N \>
        \char_set_catcode_other:N \*
        \char_set_catcode_other:N \.
        \char_set_catcode_other:N \-
        \char_set_catcode_other:N \/
        \char_set_catcode_other:N \[
        \char_set_catcode_other:N \]
        \char_set_catcode_other:N \`
        \char_set_catcode_other:N \'
        \char_set_catcode_other:N \"
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_use_to_slash_nil:ww}
%   Returns the first piece of
%   \meta{stuff}\texttt{/}\meta{stuff}\texttt{/}\ldots\cs{q_nil}
%    \begin{macrocode}
\cs_new:Npn \xfss_use_to_slash_nil:ww #1 / #2 \q_nil {#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_font_get_encoding:NN}
%   Given a font control sequence, we extract its encoding from its name.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_font_get_encoding:NN #1 #2
  {
    \tl_set:Nx #2
      {
        \exp_last_unbraced:Nf \xfss_use_to_slash_nil:ww
          { \cs_to_str:N #1 } \q_nil
      }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:N \/
  \cs_new:Npn \xfss_fontface_split:w #1/#2/#3/#4/#5 \q_nil
    {
      \xfss_set_encoding:x {#1}
      \xfss_set_family:x   {#2}
      \xfss_set_series:x   {#3}
      \xfss_set_shape:x    {#4}
      \tl_set:Nx \l_xfss_size_tl    {#5} %?
    }
\group_end:
%    \end{macrocode}
%
% \begin{macro}{\use_iv_to_str:nnnN}
%    \begin{macrocode}
\cs_new:Npn \use_iv_to_str:nnnN #1#2#3#4 { \cs_to_str:N #4 }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Select the fontface}
%
% \subsubsection{Encoding}
%
% These contain any default setup commands for when selecting the
% default text/math encodings.
%    \begin{macrocode}
\tl_new:N \g_xfss_encoding_setup_text_default_tl
\tl_new:N \g_xfss_encoding_setup_math_default_tl
%    \end{macrocode}
% Encoding wanted by the user, current encoding, and saved encoding
% for use in accents.
%    \begin{macrocode}
\tl_new:N \l_xfss_encoding_tl
\tl_new:N \l_xfss_encoding_current_tl
\tl_new:N \l_xfss_encoding_saved_tl
%    \end{macrocode}
%
% \begin{macro}{\xfss_encoding_check_exists:nT}
% \begin{macro}{\xfss_encoding_if_exist:nTF}
%   The \enquote{\texttt{check}} command raises an error
%   if the encoding does not exist.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_encoding_check_exists:nT #1 #2
  {
    \cs_if_exist:cTF {g_xfss_encoding_setup_text_ #1 _tl}
      { #2 }
      { \msg_error:nnx {xfss} {font-enc-unknown} {#1} }
  }
\prg_new_conditional:Npnn \xfss_encoding_if_exist:n #1 {TF}
  {
    \cs_if_exist:cTF {g_xfss_encoding_setup_text_ #1 _tl}
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xfss_set_encoding:x}
%   Sets the encoding to |#1|, checking that it exists.
%   However, no font change is made: we only set here what
%   we \emph{want} the encoding to become at the next font
%   change.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_encoding:x #1
  {
    \xfss_encoding_check_exists:nT {#1}
      { \tl_set:Nx \l_xfss_encoding_tl {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_encoding_use:x}
%   Change to the encoding |#1|, selecting the relevant font.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_encoding_use:x #1
  {
     \xfss_set_encoding:x {#1}
     \xfss_fontface_provide:c { \l_xfss_current_font_tl / \l_xfss_size_tl }
     \fontface_use:c { \g_xfss_fontface_csname_tl }
     \xfss_encoding_update:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_encoding_update:}
%    \begin{macrocode}
\cs_new_protected:Nn \xfss_encoding_update:
  {
    \cs_set_eq:cN { xfss_ \l_xfss_encoding_tl _cmd:NN } \xfss_current_cmd:NN
    \cs_set_eq:cN { xfss_ \l_xfss_encoding_current_tl _cmd:NN }
      \xfss_changed_cmd:NN
%<*package>
    \cs_set_eq:cN {\l_xfss_encoding_tl -cmd}         \xfss_current_cmd:NN
    \cs_set_eq:cN {\l_xfss_encoding_current_tl -cmd} \xfss_changed_cmd:NN
%</package>
    \xfss_encoding_setup_defaults:o { \l_xfss_encoding_tl }
    \use:c {g_xfss_encoding_setup_text_ \l_xfss_encoding_tl _tl}
    \tl_set_eq:NN \l_xfss_encoding_current_tl \l_xfss_encoding_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_encoding_setup_defaults:o}
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_encoding_setup_defaults:o #1
  {
    \prop_get:NoN \g_xfss_cdp_prop {#1} \l_xfss_tmpa_tl
    \exp_after:wN \xfss_encoding_setup_defaults_aux:w \l_xfss_tmpa_tl \q_stop
  }
\cs_new_protected:Npn
  \xfss_encoding_setup_defaults_aux:w #1 / #2 / #3 \q_stop
  {
    \tl_set:Nn \l_xfss_default_family_tl {#1}
    \tl_set:Nn \l_xfss_default_series_tl {#2}
    \tl_set:Nn \l_xfss_default_shape_tl  {#3}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareFontEncoding,\xfss_encoding_declare:nnn}
%    \begin{macrocode}
\cs_set_protected:Npn \DeclareFontEncoding
  {
    \group_begin:
    \xfss_switch_catcodes:
    \exp_after:wN \group_end:
    \xfss_encoding_declare:nnn
  }
\cs_new_protected:Npn \xfss_encoding_declare:nnn #1#2#3
  {
    \xfss_encoding_if_exist:nTF {#1}
      { \msg_info:nnxx {xfss} {redeclaring} {font~encoding} {#1} }
      {
        \prop_gput:Nxx \g_xfss_cdp_prop {#1}
          {
            \l_xfss_default_family_tl /
            \l_xfss_default_series_tl /
            \l_xfss_default_shape_tl
          }
        \cs_set_eq:cN {xfss_#1_cmd:NN} \xfss_changed_cmd:NN
%<package>        \cs_set_eq:cN {#1-cmd} \xfss_changed_cmd:NN
      }
    \tl_gclear_new:c {g_xfss_encoding_setup_text_ #1 _tl}
    \tl_gset:cn {g_xfss_encoding_setup_text_ #1 _tl}
      { \g_xfss_encoding_setup_text_default_tl #2 }
    \tl_gclear_new:c {g_xfss_encoding_setup_math_ #1 _tl}
    \tl_gset:cn {g_xfss_encoding_setup_math_ #1 _tl}
      { \g_xfss_encoding_setup_math_default_tl #3 }
    \tl_gset:Nx \LastDeclaredEncoding {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareFontSubstitution}
%   Change the default font for the given encoding.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontSubstitution {mmmm}
  {
    \xfss_encoding_check_exists:nT {#1}
      { \prop_gput:Nxn \g_xfss_cdp_prop {#1} { #2 / #3 / #4 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareFontEncodingDefaults}
%   This should be done with hooks.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontEncodingDefaults {mm}
  {
    \str_if_eq:nnF {\relax} {#1}
      {
        \tl_if_empty:NF \g_xfss_encoding_setup_text_default_tl
          { \msg_info:nnx {xfss} {overwrite-enc-defaults} {text} }
        \tl_gset:Nn \g_xfss_encoding_setup_text_default_tl {#1}
      }
    \str_if_eq:nnF {\relax} {#2}
      {
        \tl_if_empty:NF \g_xfss_encoding_setup_math_default_tl
          { \msg_info:nnx {xfss} {overwrite-enc-defaults} {math} }
        \tl_gset:Nn \g_xfss_encoding_setup_math_default_tl {#2}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Font family}
%
% \begin{macro}{\DeclareFontFamily}
%   Not sure what it does.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontFamily {mmm}
  {
    \xfss_encoding_check_exists:nT {#1}
      {
        \tl_gclear_new:c {#1+#2}
        \tl_gset:cn {#1+#2} {#3}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_font_try_load_family:}
%   If the encoding--family pair has already been loaded,
%   no need to do it again. Otherwise, read the font definition
%   file, with the relevant catcode setup. See the section on
%   parsing font definition files for details.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_font_try_load_family:
  {
    \cs_if_exist:cF {\l_xfss_encoding_tl+\l_xfss_family_tl}
      {
        \msg_info:nnx {xfss} {try-load}
          { \l_xfss_encoding_tl + \l_xfss_family_tl}
        \tl_new:c { \l_xfss_encoding_tl + \l_xfss_family_tl}
        \xfss_switch_catcodes:
        \tl_set:Nx \l_xfss_tmpa_tl {  \l_xfss_encoding_tl \l_xfss_family_tl .fd }
        \file_input:x
          { \str_foldcase:V \l_xfss_tmpa_tl }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Font series, and shape}
%
% \begin{macro}{\xfss_set_family:x,\xfss_set_series:x,\xfss_set_shape:x}
%   The analog \cs{xfss_set_encoding:x} is defined
%   in the section on encodings.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_family:x #1
  { \tl_set:Nx \l_xfss_family_tl {#1} }
\cs_new_protected:Npn \xfss_set_series:x #1
  { \tl_set:Nx \l_xfss_series_tl {#1} }
\cs_new_protected:Npn \xfss_set_shape:x #1
  { \tl_set:Nx \l_xfss_shape_tl  {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontencoding,\fontfamily,\fontseries,\fontshape}
% \begin{macro}{\usefont}
%    \begin{macrocode}
\DeclareDocumentCommand \fontencoding {m} { \xfss_set_encoding:x {#1} }
\DeclareDocumentCommand \fontfamily   {m} { \xfss_set_family:x   {#1} }
\DeclareDocumentCommand \fontseries   {m} { \xfss_set_series:x   {#1} }
\DeclareDocumentCommand \fontshape    {m} { \xfss_set_shape:x    {#1} }
\DeclareDocumentCommand \usefont {mmmm}
  {
    \xfss_fontface_split:w #1 / #2 / #3 / #4 / \l_xfss_size_tl \q_nil
    \selectfont
    \tex_ignorespaces:D
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\DeclareFontShape}
% \begin{macro}[aux]{\xfss_font_declare:nnnnnn}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontShape {}
  {
    \group_begin:
      \xfss_switch_catcodes:
      \exp_after:wN
    \group_end:
    \xfss_font_declare:nnnnnn
  }
\cs_new_protected:Npn \xfss_font_declare:nnnnnn #1#2#3#4#5#6
  {
    \cs_if_exist:cTF {#1+#2}
      {
        \cs_gset:cpx {#1/#2/#3/#4} {\exp_not:c {#5}}
        \cs_gset:cpn {#5} {#6}
      }
      { \msg_error:nnx {xfss} {font-family-unknown} {#1+#2} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\DeclareFixedFont}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFixedFont { mmm mmm }
  {
    \group_begin:
      \bool_set_false:N \l_xfss_math_fonts_bool
%<*hook>
      \tl_clear:N \g_hook_kernel_math_size_tl
%</hook>
      \xfss_set_fontsize:nnn {\baselinestretch} {#6} {\c_zero_dim}
      \xfss_fontface_split:w #2 / #3 / #4 / #5 / \l_xfss_size_tl \q_nil
      \selectfont
      \fontface_gset_to_current:N #1
    \group_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Font size, line spread and baselineskip}
%
% \begin{macro}{\linespread,\fontsize}
%   Both make use of \cs{xfss_set_fontsize:nnn}, but keep the old
%   settings of either the baseline stretch, or the size and baselineskip.
%    \begin{macrocode}
\DeclareDocumentCommand \linespread {m}
  { \xfss_set_fontsize:nnn {#1} \l_xfss_size_tl \l_xfss_baselineskip_tl }
\DeclareDocumentCommand \fontsize {mm}
  { \xfss_set_fontsize:nnn \baselinestretch {#1} {#2} }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_fontsize:nnn #1#2#3
  {
    \tl_set:Nx \l_xfss_size_tl { \xfss_dim_strip_pt:n {#2} }
    \xfss_default_units:w \l_xfss_tmp_skip #3 pt \relax \q_nil
    \tl_set:Nx \l_xfss_baselineskip_tl { \skip_use:N \l_xfss_tmp_skip }
    \tl_set:Nx \l_xfss_linespread_tl {#1}
    \tl_set_eq:NN \baselinestretch \l_xfss_linespread_tl
    \bool_set_true:N \l_xfss_update_sizes_bool
  }
\cs_new:Npn \xfss_update_sizes:
  {
    \dim_set:Nn \baselineskip {\l_xfss_baselineskip_tl}
    \dim_set:Nn \baselineskip {\l_xfss_linespread_tl\baselineskip}
    \dim_set:Nn \normalbaselineskip {\baselineskip}
%<*hook>
    \hook_kernel_omit_next:n { hbox }
%</hook>
    \hbox_set:Nn \strutbox
      {
        \vrule height .7\baselineskip
               depth  .3\baselineskip
               width 0pt
      }
    \bool_set_false:N \l_xfss_update_sizes_bool
  }
%    \end{macrocode}
%
% \begin{macro}{\DeclarePreloadSizes}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclarePreloadSizes {mm mmm}
  {
    \xfss_encoding_check_exists:nT {#1}
      {
        \group_begin:
          \clist_map_inline:nn {#5}
            {
              \xfss_fontface_provide:c {#1/#2/#3/#4/##1}
              \cs_undefine:c { \g_xfss_fontface_csname_tl }
            }
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Select the font}
%
% \begin{macro}{\selectfont}
%
%    \begin{macrocode}
\DeclareDocumentCommand \selectfont {}
  {
    \tl_if_eq:NNF \l_xfss_linespread_tl \baselinestretch
      { \linespread \baselinestretch }
    \xfss_fontface_provide:c { \l_xfss_current_font_tl / \l_xfss_size_tl }
    \fontface_use:c { \g_xfss_fontface_csname_tl }
%<*hook>
    \hook_use:n {selectfont}
%</hook>
    \bool_if:NT \l_xfss_update_sizes_bool { \xfss_update_sizes: }
    \tl_if_eq:NNF \l_xfss_encoding_current_tl \l_xfss_encoding_tl
      { \xfss_encoding_update: }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Find an existing fontface}
%
% Given a fontface specification, of the form
% \meta{encoding}/\meta{family}/\meta{series}/\meta{shape}/\meta{size},
% we wish to provide that fontface if it doesn't exist yet. If the fontface
% is not found, then an attempt is made to provide a similar fontface,
% and the resulting match is stored in \cs{g_xfss_fontface_csname_tl}.
%
% \begin{macro}{\xfss_fontface_provide:c}
%   Initially, we hope to find the exact fontface requested by the user,
%   and thus store it in \cs{g_xfss_fontface_csname_tl}. If that already
%   exists, then we are set, and nothing has to be done. Otherwise, split
%   the user's request into encoding, family, series, shape, and size.
%   Then try to load the corresponding encoding--family
%   font definition file if needed. If the \emph{font} exists, then
%   we find the correct size with \cs{xfss_fontface_find:}. Otherwise,
%   we try to find a similar font with \cs{xfss_wrong_font:}.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_fontface_provide:c #1
  {
    \tl_gset:Nx \g_xfss_fontface_csname_tl {#1}
    \cs_if_exist:cF { \g_xfss_fontface_csname_tl }
      {
        \group_begin:
          \int_set:Nn \tex_escapechar:D { -1 }
          \exp_after:wN \xfss_fontface_split:w \g_xfss_fontface_csname_tl \q_nil
          \xfss_font_try_load_family: % try always
          \cs_if_exist:cTF { \l_xfss_current_font_tl }
            { \xfss_fontface_find: }
            { \xfss_wrong_font: }
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_wrong_font:}
%   If the requested font does not exist, then attempt to recover
%   by changing the shape, series and family for the defaults of
%   the given encoding. First load those defaults.
%
%   The erroneous font is stored in \cs{l_xfss_wrong_font_tl} and
%   compared with the last erroneous font. If they match, then the
%   font selection mechanism is looping. Otherwise, change the shape
%   to the default shape (specific to that encoding), then the series,
%   then the family, until the corresponding font exists. It is assumed
%   that the default family--series--shape combination always exists.
%    \begin{macrocode}
\tl_new:N \l_xfss_wrong_font_tl
\tl_new:N \g_xfss_last_font_tl
\cs_new_protected:Npn \xfss_wrong_font:
  {
    % install defaults if in math:
    \xfss_encoding_setup_defaults:o { \l_xfss_encoding_tl }
    \tl_set:Nx \l_xfss_wrong_font_tl { \l_xfss_current_font_tl }
    \tl_if_eq:NNTF \g_xfss_last_font_tl \l_xfss_wrong_font_tl
      {
         \errmessage{Corrupted NFSS tables}
         \xfss_error_font:
      }
      {
        \tl_set_eq:NN \l_xfss_shape_tl \l_xfss_default_shape_tl
        \cs_if_exist:cF {\l_xfss_current_font_tl}
          {
            \tl_set_eq:NN \l_xfss_series_tl \l_xfss_default_series_tl
            \cs_if_exist:cF {\l_xfss_current_font_tl}
              { \tl_set_eq:NN \l_xfss_family_tl \l_xfss_default_family_tl }
          }
      }
    \msg_warning:nnxxx {xfss} {missing-font-shape} { \l_xfss_wrong_font_tl }
      { \l_xfss_current_font_tl } { \l_xfss_wrong_font_char_msg_tl }
    \tl_gset_eq:NN \g_xfss_last_font_tl \l_xfss_wrong_font_tl
    \bool_gset_true:N \g_xfss_subst_warning_bool
    \tl_gset_eq:cc { \l_xfss_wrong_font_tl } { \l_xfss_current_font_tl }
    \xfss_fontface_provide:c { \l_xfss_current_font_tl / \l_xfss_size_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareErrorFont}
%   In cases where the font selection scheme loops, it falls back
%   to a default \enquote{error} font. When \cs{xfss_error_font:}
%   is called, it will set the encoding, family, series, shape,
%   and size to those provided to \cs{DeclareErrorFont}.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareErrorFont {mm mmm}
  {
    \cs_gset:Npx \xfss_error_font:
      { \exp_not:N \xfss_fontface_split:w #1/#2/#3/#4/#5 \exp_not:N \q_nil }
    \tl_set:Nx \l_xfss_default_family_tl {#2}
    \tl_set:Nx \l_xfss_default_series_tl {#3}
    \tl_set:Nx \l_xfss_default_shape_tl  {#4}
    \tl_set_eq:NN \l_xfss_family_tl \l_xfss_default_family_tl
    \tl_set_eq:NN \l_xfss_series_tl \l_xfss_default_series_tl
    \tl_set_eq:NN \l_xfss_shape_tl  \l_xfss_default_shape_tl
    \tl_set:Nx \l_xfss_size_tl {#5}
    \tl_set:Nx \l_xfss_baselineskip_tl {#5pt}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_fontface_find:}
%   We now know that the font exists, and we need to find
%   the name of the fontface (in particular the size) for
%   \TeX{}. The call to \cs{xfss_fontface_find_external:} sets
%   \cs{l_xfss_external_font_tl} to the fontface information
%   needed by \TeX{}. We then select that as the current
%   fontface. Afterwards, two hooks are inserted: the first
%   corresponds to the encoding and family, while the second
%   one is specific to the font (encoding, family, series
%   and shape).
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_fontface_find:
  {
    \xfss_fontface_find_external:
    \fontface_gset:cn \g_xfss_fontface_csname_tl {\l_xfss_external_font_tl}
    \fontface_use:c { \g_xfss_fontface_csname_tl }
    \use:c { \l_xfss_encoding_tl + \l_xfss_family_tl }
    \use:c { \l_xfss_current_font_tl }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Parsing fd files}
%
% \subsubsection{Main picture}
%
% \begin{macro}{\xfss_fontface_find_external:}
%   Here, \cs{l_xfss_current_font_tl} has the form
%   \meta{enc}/\meta{fam}/\meta{sh}/\meta{ser}, and
%   the corresponding control sequence holds the size
%   information for that font. We store that information
%   into \cs{l_xfss_font_info_tl}, then loop over
%   the sizes, first looking for cases where the requested
%   size exactly fits in one of the defined ranges,
%   then attempting to find an approximate size if
%   the first attempt failed. As always, the fall-back
%   is to select the error font.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_fontface_find_external:
  {
    \tl_clear:N \l_xfss_external_font_tl
    \tl_set:Nx \l_xfss_font_info_tl
      {
        \exp_last_unbraced:Nv \token_to_str:N
          { \l_xfss_current_font_tl }
      }
    \xfss_try_size_range:F
      {
        \xfss_try_size_subst:F
          {
            \msg_error:nnx {xfss}
              {font-not-found} { \g_xfss_fontface_csname_tl }
            \xfss_error_font:
            \xfss_fontface_find_external:
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_try_size_range:F,\xfss_try_size_subst:F}
%    \begin{macrocode}
\prg_new_conditional:Npnn \xfss_try_size_range: {F}
  {
    \exp_after:wN
    \xfss_extract_rangefontinfo:w \l_xfss_font_info_tl <-*> \q_nil < \q_stop
    \tl_if_empty:NTF \l_xfss_external_font_tl
    \prg_return_false: \prg_return_true:
  }
\prg_new_conditional:Npnn \xfss_try_size_subst: {F}
  {
    \dim_set:Nn \l_xfss_tmpb_dim {\maxdimen}
    \tl_clear:N \l_xfss_best_size_tl
    \exp_after:wN
    \xfss_try_simples:w \l_xfss_font_info_tl <10000> \q_nil < \q_stop
    \tl_if_empty:NTF \l_xfss_external_font_tl
      \prg_return_false: \prg_return_true:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Reading size ranges}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_remove_angles:w #1 > { \xfss_set_simple_size_args:w }
\cs_new:Npn \xfss_remove_star:w #1 * {#1}
\cs_new:Npn \xfss_extract_sizefn:w #1 * #2 \q_nil
  {
    \if_charcode:w >#2>
      \xfss_set_size_funct_args:w #1 \q_nil
      \tl_clear:N \l_xfss_sizefn_info_tl
    \else:
      \exp_after:wN \xfss_set_size_funct_args:w \xfss_remove_star:w #2 \q_nil
      \tl_set:Nn \l_xfss_sizefn_info_tl {#1}
    \fi:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_try_simple_size:
  {
    \cs_set:Npn \xfss_tmp: {\cs_set:Npn \xfss_extract_font_info:w ####1 }
    \exp_after:wN \xfss_tmp: \exp_after:wN <\l_xfss_size_tl> ##2 < ##3 \q_stop
      {
        \quark_if_nil:nF {##2}
          {
            \xfss_set_simple_size_args:w ##2 < ##3 \q_stop
            \xfss_execute_size_function:n {\l_xfss_sizefn_info_tl}
          }
      }
    \exp_after:wN \exp_after:wN
    \exp_after:wN \xfss_extract_font_info:w
    \exp_after:wN \l_xfss_font_info_tl
    \exp_after:wN <\l_xfss_size_tl> \q_nil <\q_stop
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_set_simple_size_args:w #1 <
  {
    \if<#1<
      \exp_after:wN \xfss_remove_angles:w
    \else
      \xfss_extract_sizefn:w #1 * \q_nil
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi
  }
\cs_new:Npn \xfss_extract_rangefontinfo:w #1 <#2>
  { \xfss_is_range:wq #2 -> \q_nil #2> }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_is_range:wq #1-#2 \q_nil
  {
    \if_charcode:w >#2
      \exp_after:wN \xfss_check_single:wq
    \else:
      \exp_after:wN \xfss_check_range:wq
    \fi:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_check_range:wq #1 - #2 > #3 < #4 \q_stop
  {
    \quark_if_nil:nF {#3}
      {
        \tl_set:Nn \l_xfss_tmpf_tl
          { \xfss_extract_rangefontinfo:w < #4 \q_stop }
        \dim_set:Nn \l_xfss_upper_bound_dim { 0 #2 pt }
        \dim_compare:nNnT \l_xfss_upper_bound_dim = \c_zero_dim
          { \dim_set:Nn \l_xfss_upper_bound_dim {\maxdimen} }
        \dim_compare:nNnT {\l_xfss_size_tl pt} < \l_xfss_upper_bound_dim
          {
            \dim_set:Nn \l_xfss_lower_bound_dim { 0 #1 pt }
            \dim_compare:nNnF {\l_xfss_size_tl pt} < \l_xfss_lower_bound_dim
              {
                \xfss_set_simple_size_args:w#3<#4\q_stop
                \xfss_execute_size_function:n {\l_xfss_sizefn_info_tl}
                \tl_if_empty:NF \l_xfss_external_font_tl
                { \tl_clear:N \l_xfss_tmpf_tl }
              }
          }
        \l_xfss_tmpf_tl
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_check_single:wq #1 > #2 < #3 \q_stop
  {
    \tl_set:Nn \l_xfss_tmpf_tl { \xfss_extract_rangefontinfo:w < #3 \q_stop }
    \dim_compare:nNnT {\l_xfss_size_tl pt} = {#1pt}
      {
         \xfss_set_simple_size_args:w #2 < #3 \q_stop
         \xfss_execute_size_function:n {\l_xfss_sizefn_info_tl}
         \tl_if_empty:NF \l_xfss_external_font_tl
           { \tl_clear:N \l_xfss_tmpf_tl }
      }
    \l_xfss_tmpf_tl
  }
%    \end{macrocode}
%
% \subsubsection{Size functions}
%
%    \begin{macrocode}
\DeclareDocumentCommand \xfss_set_size_funct_args:w { O{} u{ \q_nil } }
  {
    \tl_set:Nn \l_xfss_optional_arg_tl  {#1}
    \tl_set:Nn \l_xfss_mandatory_arg_tl {#2}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareSizeFunction {mm}
  { \cs_set:cpn {xfss_size_function_ #1 :} {#2} }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_execute_size_function:n #1
  { \use:c {xfss_size_function_ #1 :} }
%    \end{macrocode}
%
%    \begin{macrocode}
\tl_new:N \g_xfss_font_submax_tl
\tl_gset:Nn \g_xfss_font_submax_tl {0pt}
\tl_set:Nn \fontsubfuzz{.4pt}
\cs_new_protected:Npn \xfss_try_simples:w #1 <#2>
  {
    \xfss_try_if_simple:w #2 -> \xfss_try_if_simple:w
  }
\cs_new_protected:Npn \xfss_try_if_simple:w #1-#2 \xfss_try_if_simple:w
  {
    \cs_set_eq:NN \xfss_tmpf:w \xfss_try_simples:w
    \if_charcode:w > #2
      \dim_compare:nNnTF {#1 pt} < { 10000pt }
        {
          \dim_set:Nn \l_xfss_tmpc_dim
            { \dim_abs:n { #1pt - \l_xfss_size_tl pt} }
          \dim_compare:nNnT \l_xfss_tmpc_dim < \l_xfss_tmpb_dim
            {
              \dim_set:Nn \l_xfss_tmpb_dim {\l_xfss_tmpc_dim}
              \tl_set:Nn \l_xfss_best_size_tl {#1}
            }
        }
        {
          \tl_if_empty:NT \l_xfss_external_font_tl
            {
              \tl_if_empty:NF \l_xfss_best_size_tl
                {
                  \dim_compare:nNnT \l_xfss_tmpb_dim > \g_xfss_font_submax_tl
                    {
                      \tl_gset:Nx \g_xfss_font_submax_tl {\the\l_xfss_tmpb_dim}
                    }
                  \tl_set_eq:NN \l_xfss_user_size_tl \l_xfss_size_tl
                  \tl_set_eq:NN \l_xfss_size_tl \l_xfss_best_size_tl
                  \dim_compare:nNnT \l_xfss_tmpb_dim > \fontsubfuzz
                    {
                      \msg_warning:nnxxx {xfss} {font-shape-unavail}
                      {\l_xfss_current_font_tl} {\l_xfss_user_size_tl}
                      {\l_xfss_size_tl}
                    }
                  \xfss_try_simple_size:
                  \xfss_activate_subst_correction:
                }
            }
          \cs_set_eq:NN \xfss_tmpf:w \use_none_delimit_by_q_stop:w
        }
    \fi:
    \xfss_tmpf:w
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{} { \xfss_empty_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{s}{ \xfss_empty_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_empty_size_fn:N #1
  {
    \dim_set:Nn \l_xfss_tmpb_dim {\l_xfss_size_tl pt}
    \tl_if_empty:NF \l_xfss_optional_arg_tl
      {
        \dim_set:Nn \l_xfss_tmpb_dim
          { \l_xfss_optional_arg_tl \l_xfss_tmpb_dim }
        #1 {xfss} {font-shape-scale}
      }
    \tl_set:Nx \l_xfss_external_font_tl
      { \l_xfss_mandatory_arg_tl\space at \dim_use:N \l_xfss_tmpb_dim }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{gen} { \xfss_gen_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{sgen}{ \xfss_gen_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_gen_size_fn:N
  {
    \tl_set:Nx \l_xfss_mandatory_arg_tl
      { \l_xfss_mandatory_arg_tl \l_xfss_size_tl }
    \xfss_empty_size_fn:N
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{genb} { \xfss_genb_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{sgenb}{ \xfss_genb_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_genb_size_fn:N
  {
    \tl_set:Nx \l_xfss_mandatory_arg_tl
      {
        \l_xfss_mandatory_arg_tl
        \exp_after:wN \xfss_gen_aux:w \l_xfss_size_tl .. \q_nil
      }
    \xfss_empty_size_fn:N
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_gen_aux:w #1.#2.#3 \q_nil
  {
    \int_compare:nNnT {#1} < {10} {0} \int_value:w #1 % LaTeX2e's "\two@digits"
    \xfss_gen_auxii:w #2 00 \q_nil
  }
\cs_new:Npn \xfss_gen_auxii:w #1 #2 #3 \q_nil { #1#2 }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{sub} { \xfss_sub_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{ssub}{ \xfss_sub_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_sub_size_fn:N #1
  {
    \tl_set:Nx \l_xfss_mandatory_arg_tl
      { \l_xfss_encoding_tl / \l_xfss_mandatory_arg_tl }
    \group_begin:
      \exp_after:wN \xfss_fontface_split:w \l_xfss_mandatory_arg_tl / \q_nil
      \xfss_font_try_load_family:
    \group_end:
    \tl_set_eq:NN \l_xfss_user_size_tl \l_xfss_size_tl
    \cs_if_exist:cTF { \l_xfss_mandatory_arg_tl }
      {
        #1 {xfss} {font-shape-size-missing}
        \exp_after:wN \xfss_fontface_split:w \l_xfss_mandatory_arg_tl / \q_nil
      }
      {
        \errmessage{No~declaration~for~shape~\l_xfss_mandatory_arg_tl}
        \xfss_error_font:
      }
    \tl_set:Nx \l_xfss_size_tl {\l_xfss_user_size_tl}
    \xfss_fontface_find_external:
    \xfss_activate_subst_correction:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{subf} { \xfss_subf_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{ssubf}{ \xfss_subf_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_subf_size_fn:N #1
  {
    #1 {xfss} {font-shape-size-instead}
    \xfss_empty_size_fn:N #1
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{fixed} { \xfss_fixed_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{sfixed}{ \xfss_fixed_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_fixed_size_fn:N #1
  {
    \tl_if_empty:NTF \l_xfss_optional_arg_tl
      { \tl_set_eq:NN \l_xfss_external_font_tl \l_xfss_mandatory_arg_tl }
      {
        \tl_set:Nx \l_xfss_external_font_tl
          { \l_xfss_mandatory_arg_tl\space at\l_xfss_optional_arg_tl pt }
      }
    #1 {xfss} {ext-font-loaded}
  }
%    \end{macrocode}
%
% \begin{macro}{\xfss_activate_subst_correction:}
%   Should it be here?
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_activate_subst_correction:
  {
    \cs_gset:Npx \xfss_subst_correction:
      {
        \fontface_use:c { \g_xfss_fontface_csname_tl }
        \fontface_gset:cn { \l_xfss_current_font_tl / \l_xfss_size_tl }
          { \exp_not:N \fontface_current_info: }
      }
    \group_insert_after:N \xfss_subst_correction:
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Process table at begin document}
%
% \begin{macro}{\xfss_process_table:}
%   This is executed in \cs{begin\{document\}}.
%   For each encoding, check that the default font actually exists.
%   The error font also needs to be set correctly.
%   Then set the default font attributes as they are
%   currently pointing to error font shape.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_process_table:
  {
    \xfss_process_table_check_defaults:
    \xfss_process_table_check_error_font:
    \xfss_set_encoding:x {\encodingdefault}
    \xfss_set_family:x   {\familydefault}
    \xfss_set_series:x   {\seriesdefault}
    \xfss_set_shape:x    {\shapedefault}
    \bool_gset_true:N \g_xfss_document_bool
  }
\cs_new_protected:Npn \xfss_process_table_check_defaults:
  {
    \prop_map_inline:Nn \g_xfss_cdp_prop
      {
        \msg_info:nnx {xfss} {checking-defaults} {##1/##2}
        \cs_if_exist:cF {##1/##2}
          {
            \group_begin:
              \xfss_set_encoding:x {##1}
              \xfss_set_family:x { \xfss_use_to_slash_nil:ww ##2 / \q_nil }
              \xfss_font_try_load_family:
            \group_end:
          }
        \cs_if_exist:cTF {##1/##2}
          { \msg_info:nn {xfss} {okay!} }
          { \msg_error:nnxx {xfss} {defaults-broken} {##1} {##2} }
      }
  }
\cs_new_protected:Npn \xfss_process_table_check_error_font:
  {
    \group_begin:
      \int_set:Nn \tex_escapechar:D { -1 }
      \xfss_error_font:
      \cs_if_exist:cF {\l_xfss_current_font_tl}
        {
          \group_begin:
            \xfss_font_try_load_family:
          \group_end:
        }
      \cs_if_exist:cF {\l_xfss_current_font_tl}
        { \msg_error:nn {xfss} {no-error-font} }
    \group_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Other}
%
%    \begin{macrocode}
\count18=0\scan_stop: % what is that for??
\cs_set:Npn \tracingfonts
  {
    \FIXME % implement
  }
\cs_set_eq:NN \mathalpha \scan_stop: % so that \mathalpha is non-expandable.
\cs_new_eq:NN \xfss_install_math_alphabet:Nn \cs_gset_protected:Npn
\tl_new:N \l_xfss_math_fonts_assign_tl
\cs_new_protected:Npn \xfss_calculate_math_sizes:
  {
    \msg_info:nnx {xfss} {calc-math-sizes} {\l_xfss_size_tl}
    \dim_set:Nn \l_xfss_tmpa_dim { \l_xfss_size_tl pt }
    \cs_gset:cpx { xfss_set_font_size_ \l_xfss_size_tl :}
      {
        \tl_gset:Nn \exp_not:N \g_xfss_tf_size_tl  { \l_xfss_size_tl }
        \tl_gset:Nn \exp_not:N \g_xfss_sf_size_tl
          { \dim_to_decimal:n { \defaultscriptratio \l_xfss_tmpa_dim } }
        \tl_gset:Nn \exp_not:N \g_xfss_ssf_size_tl
          { \dim_to_decimal:n { \defaultscriptscriptratio \l_xfss_tmpa_dim } }
        \bool_set_true:N \l_xfss_math_fonts_bool
      }
  }
%    \end{macrocode}
%
% fixme: what to do in initex?
%    \begin{macrocode}
%<*package>
\tl_new:N \l_no_accents_tl
\tl_set_eq:NN \l_no_accents_tl \noaccents@
%</package>
%<*initex>
\tl_new:N \l_no_accents_tl
%</initex>
%    \end{macrocode}
%
% \begin{macro}{\math_operator_font:}
% This command is used to switch to the font for typesetting operators
% such as \cs{lim}.
%    \begin{macrocode}
\cs_new_protected:Npn \math_operator_font:
  { \mathgroup_use:N \symoperators }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareMathSizes}
%   The starred form seems undocumented? (Haven't checked TLC.)
%   \begin{arguments}
%   \item \meta{star?}
%   \item text size \item math text size \item math script size
%   \item math scriptscript size
%   \end{arguments}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathSizes {s mm mm}
  {
    \tl_if_blank:nTF {#3}
      {
        \cs_gset:cpn {xfss_set_font_size_ \xfss_dim_strip_pt:n {#2} :}
          { \bool_set_false:N \l_xfss_math_fonts_bool }
      }
      {
        \cs_gset:cpx {xfss_set_font_size_ \xfss_dim_strip_pt:n {#2} :}
          {
            \tl_gset:Nn \exp_not:N \g_xfss_tf_size_tl  {#3}
            \tl_gset:Nn \exp_not:N \g_xfss_sf_size_tl  {#4}
            \tl_gset:Nn \exp_not:N \g_xfss_ssf_size_tl {#5}
            \IfBooleanT #1
              { \bool_set_false:N \l_xfss_math_fonts_bool }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\tl_new:N \g_xfss_global_settings_tl
\tl_gset:Nn \g_xfss_global_settings_tl
  {
    \cs_if_exist:cF { xfss_set_font_size_ \l_xfss_size_tl : }
      { \xfss_calculate_math_sizes: }
    \use:c { xfss_set_font_size_ \l_xfss_size_tl : }
    \bool_if:NT \l_xfss_math_fonts_bool
      {
        \group_begin:
          \int_set:Nn \tex_escapechar:D { -1 }
          \xfss_math_version_use:x { \l_xfss_math_version_tl }
          \l_xfss_math_fonts_assign_tl
          \tl_gset_eq:NN \g_xfss_setup_currsize_tl \l_xfss_size_tl
        \group_end:
%<*hook>
        \hook_use:n {math_size}
%</hook>
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_check_math_fonts:
  {
    \tl_if_eq:NNF \g_xfss_setup_currsize_tl \l_xfss_size_tl
      {
         \g_xfss_global_settings_tl
         \xfss_init_restore_glb_settings:
      }
    \tl_set_eq:NN \l_xfss_curr_math_size_tl \l_xfss_size_tl
    \cs_set:Npn \xfss_init_restore_glb_settings: {
      \group_insert_after:N \xfss_restore_glb_settings:
    }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_clear:N \xfss_init_restore_glb_settings:
\cs_new_protected:Npn \xfss_restore_glb_settings:
  {
    \group_begin:
      \tl_set_eq:NN \l_xfss_size_tl \l_xfss_curr_math_size_tl
      \tl_if_eq:NNF \g_xfss_setup_currsize_tl \l_xfss_size_tl
        {\g_xfss_global_settings_tl}
    \group_end:
  }
%    \end{macrocode}
%
% \begin{macro}{\xfss_get_and_define_fonts:nn}
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_get_and_define_fonts:nn #1 #2
  {
    \xfss_fontface_provide:c { \token_to_str:N #2 / \g_xfss_tf_size_tl }
    \tl_set_eq:NN \l_xfss_textfontface_csname_tl \g_xfss_fontface_csname_tl
    \xfss_fontface_provide:c { \token_to_str:N #2 / \g_xfss_sf_size_tl }
    \tl_set_eq:NN \l_xfss_scriptfontface_csname_tl \g_xfss_fontface_csname_tl
    \xfss_fontface_provide:c { \token_to_str:N #2 / \g_xfss_ssf_size_tl }
    \tl_put_right:Nx \l_xfss_math_fonts_assign_tl
      {
        \tex_global:D \tex_textfont:D         #1
          \use:c { \l_xfss_textfontface_csname_tl }
        \tex_global:D \tex_scriptfont:D       #1
          \use:c { \l_xfss_scriptfontface_csname_tl }
        \tex_global:D \tex_scriptscriptfont:D #1
          \use:c { \g_xfss_fontface_csname_tl }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Text commands, symbols, and accents}
%
% \begin{macro}[aux]{\xfss_declare_text_command:NNn}
%   A given glyph can be found at different slots depending on the
%   encoding of the font. Hence, text commands must check the encoding
%   and use the definition relevant for the current encoding.
%   The \cs{xfss_declare_text_command:NNn} function defines the text
%   command |#2| in the encoding |#3| using the declaration command
%   |#1|, either \cs{DeclareRobustCommand}, xparse's
%   \cs{DeclareDocumentCommand}, or the \cs{tex_chardef:D}, \emph{etc.}
%   The \cs{xfss_\meta{enc.}_cmd:NN} function at the start of the definition
%   of |#2| is responsible for either using \cs{\meta{enc.}\#2} if
%   the current encoding coincides with \meta{enc.}, or finding the
%   correct encoding-specific command to use in the current encoding.
%   It is always either \cs{xfss_current_cmd:NN} or
%   \cs{xfss_changed_cmd:NN}.\footnote{Bruno: add check that encoding exists?}
%    \begin{macrocode}
\cs_new:Npn \xfss_declare_text_command:NNn #1#2#3
  {
    \cs_set_protected:Npx #2
      {
        \exp_not:c {xfss_#3_cmd:NN}
        \exp_not:N #2
        \exp_not:c {#3\token_to_str:N#2}
      }
    \exp_args:Nc #1 {#3\token_to_str:N#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_current_cmd:NN,\xfss_changed_cmd:NN}
% \begin{macro}{\xfss_text_symbol_unavailable:N}
%   These two functions take a text command, and an encoding-specific
%   version of it as their arguments. The \cs{xfss_current_cmd:NN}
%   function is used when the current encoding coincides with
%   the encoding of the text command. Hence, it can simply leave
%   its second argument to be typeset. The \cs{xfss_changed_cmd:NN}
%   function is used when the encodings differ. Then, the version
%   of the text command specific to the current encoding is built
%   and used. If it does not exist, then there is an attempt to
%   use the default \texttt{?} command. If all else fails, the
%   symbol is simply not available in the current encoding,
%   and we must resign with an error.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_current_cmd:NN #1#2
  {
    \xfss_check_not_math:N #1
    #2
  }
\cs_new_protected:Npn \xfss_changed_cmd:NN #1#2
  {
    \xfss_check_not_math:N #1
    \cs_if_exist_use:cF { \l_xfss_encoding_current_tl \token_to_str:N #1 }
      {
        \cs_if_exist_use:cF { ? \token_to_str:N #1 }
          { \xfss_text_symbol_unavailable:N #1 }
      }
  }
\cs_new_protected:Npn \xfss_text_symbol_unavailable:N #1
  { \msg_error:nnx {xfss} {unavail-in-enc} { \token_to_str:N #1 } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xfss_?_cmd:NN}
%   Always other than the current encoding. Used for instance
%   by \cs{UndeclareTextCommand}.
%    \begin{macrocode}
\cs_new_eq:cN {xfss_?_cmd:NN} \xfss_changed_cmd:NN
%<package>\cs_set_eq:cN {?-cmd} \xfss_changed_cmd:NN
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Using characters, accents, symbols, encodings}
%
% \begin{macro}{\symbol}
%   Typeset the symbol corresponding to the slot \meta{integer}
%   of the current font.
%    \begin{macrocode}
\DeclareDocumentCommand \symbol {m}
  { \tex_char:D \int_eval:n {#1} \exp_stop_f: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_add_accent:nn}
%   We figure out what the correct spacefactor should be by typesetting
%   the accentee in a box and saving the relevant spacefactor,
%   then restoring it after the box has ended.\footnote{Bruno:
%     do we care about supporting multiple accents on one char? How?
%     Do we care about kerning before/after the accented character?}
%    \begin{macrocode}
\cs_new:Npn \xfss_add_accent:nn #1#2
  {
    \mode_leave_vertical:
    {
      \cs_set_eq:NN \xfss_outer_group_hmode:n \use:n
%<*hook>
      \hook_kernel_omit_next:n { hbox }
%</hook>
      \hbox_set:Nn \l_tmpa_box { #2 \xfss_spacefactor_save: }
      \tex_accent:D #1 #2
    }
    \xfss_spacefactor_restore:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UseTextAccent}
%   Bruno: we need to take into account Javier Bezos accents package.
%   See pr/3160 for a discussion of the current implementation. I don't
%   understand why \cs{xfss_outer_group_hmode:n} should be \cs{use:n}
%   rather than \cs{prg_do_nothing:} within another accent.
%    \begin{macrocode}
\DeclareDocumentCommand \UseTextAccent {mmm}
  {
    \xfss_outer_group_hmode:n
      {
        \cs_set_eq:NN \xfss_outer_group_hmode:n \use:n
        \tl_set_eq:NN \l_xfss_encoding_saved_tl \l_xfss_encoding_current_tl
        \xfss_encoding_use:x {#1}
        #2 { \xfss_encoding_use:x { \l_xfss_encoding_saved_tl } #3 }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UseTextSymbol}
%    \begin{macrocode}
\tl_new:N \l_xfss_wrong_font_char_msg_tl
\DeclareDocumentCommand \UseTextSymbol {mm}
  {
    \xfss_outer_group_hmode:n
      {
        \tl_set:Nn \l_xfss_wrong_font_char_msg_tl
          { ~for~symbol~`\token_to_str:N#2' }
        \xfss_encoding_use:x {#1}
        #2
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_outer_group_hmode:n}
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_outer_group_hmode:n #1
  { \mode_leave_vertical: {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_orig_accent:N}
%   This lets the user/programmer access the original accent
%   corresponding to its argument, even if that control sequence
%   was redefined.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_orig_accent:N #1
  { \exp_args:Nc \xfss_changed_cmd:NN { \token_to_str:N #1 } \scan_stop: }
\cs_set_eq:NN \a \xfss_orig_accent:N
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Defining text commands}
%
% \begin{macro}{\DeclareTextCompositeCommand}
%   We should use a prop to store the list of exceptions with their def.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextCompositeCommand {mmmm}
  {
    \cs_set_eq:Nc \xfss_tmp:w { #2 \token_to_str:N #1 }
    \exp_args:No \tl_if_head_eq_meaning:nNF
      { \xfss_tmp:w \scan_stop: \scan_stop: }
      \xfss_text_composite:w
      {
        \use:x
          {
            \cs_set:cpn { #2 \token_to_str:N #1 } \exp_not:n {##1}
              {
                \exp_not:N \xfss_text_composite:w
                \exp_not:c { #2 \token_to_str:N #1 }
                \exp_not:n { ##1 \c_empty_tl \q_nil }
                { \exp_not:o { \xfss_tmp:w {##1} } }
              }
          }
      }
    \tl_clear_new:c { \token_to_str:c {#2} \tl_to_str:n {#1-#3} }
    \tl_set:cn { \token_to_str:c {#2} \tl_to_str:n {#1-#3} } {#4}
  }
\cs_new:Npn \xfss_text_composite:w #1#2#3 \q_nil
  { \cs_if_exist_use:cF { \token_to_str:N #1 - \token_to_str:N #2 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareTextComposite}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextComposite {mmmm}
  {
    \use:x
      {
        \exp_not:n { \DeclareTextCompositeCommand #1 {#2} {#3} }
          \char_generate:nn {#4} { 12 }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareTextSymbolDefault,\DeclareTextAccentDefault}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextSymbolDefault {mm}
  { \DeclareTextCommandDefault #1 { \UseTextSymbol {#2} #1 } }
\DeclareDocumentCommand \DeclareTextAccentDefault {mm}
  { \DeclareTextCommandDefault #1 { \UseTextAccent {#2} #1 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UndeclareTextCommand}
%    \begin{macrocode}
\DeclareDocumentCommand \UndeclareTextCommand {mm}
  {
    \cs_if_exist:cT { #2 \token_to_str:N #1 }
      {
        \cs_undefine:c { #2 \token_to_str:N #1 }
        \exp_after:wN \exp_after:wN \exp_after:wN
        \cs_if_free:NT \exp_after:wN \use_iii:nnn #1
          {
            \tl_gset:Nx #1
              {
                \exp_not:c {xfss_?_cmd:NN}
                \exp_not:N #1
                \exp_not:c { ? \token_to_str:N #1 }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareTextSymbol}
%   The simplest declaration for a text command that should simply
%   typeset a given character of the current font. Of course,
%   the number |#3| is only correct in the declared encoding, |#2|.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextSymbol {mmm}
  { \xfss_declare_text_command:NNn \tex_chardef:D #1 {#2} #3 \scan_stop: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareTextCommand,\ProvideTextCommand}
% \begin{macro}[aux]{\xfss_args_old_or_new_style:TFnnnn}
%   These two commands accept either \cs{newcommand}-style optional
%   arguments, or an \pkg{xparse}-style argument specification.
%   The only difference between \cs{DeclareTextCommand} and
%   \cs{ProvideTextCommand} is what function they use in the \pkg{xparse}
%   case.
%   The \cs{xfss_old_or_new_style:TFnnnn} function analyses its last
%   four arguments to decide whether they are in the old
%   (\cs{newcommand}) style, or the new xparse style.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextCommand {mmoomg}
  {
    \xfss_args_old_or_new_style:TFnnnn
      { \xfss_declare_text_command:NNn \DeclareRobustCommand   #1 {#2} }
      { \xfss_declare_text_command:NNn \DeclareDocumentCommand #1 {#2} }
      {#3} {#4} {#5} {#6}
  }
\DeclareDocumentCommand \ProvideTextCommand {mmoomg}
  {
    \xfss_args_old_or_new_style:TFnnnn
      { \xfss_declare_text_command:NNn \DeclareRobustCommand   #1 {#2} }
      { \xfss_declare_text_command:NNn \ProvideDocumentCommand #1 {#2} }
      {#3} {#4} {#5} {#6}
  }
\cs_new_protected:Npn \xfss_args_old_or_new_style:TFnnnn #1#2#3#4#5#6
  {
    \IfValueTF {#3}
      {% old-style argument
        \IfValueTF {#4}
          { #1 [{#3}] [{#4}] {#5} } % with default arg
          { #1 [{#3}]        {#5} } % no default arg
        \IfValueTF {#6} { \ERROR {#6} } % don't mix xparse with old-style!
      }
      {
        \IfValueTF {#6}
          { #2 {#5} {#6} } % xparse argument
          { #2 {  } {#5} } % no argument
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\DeclareTextCommandDefault,\ProvideTextCommandDefault}
%   Setup the default behaviour of the text command in an unknown encoding.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextCommandDefault {m}
  { \DeclareTextCommand #1 {?} }
\DeclareDocumentCommand \ProvideTextCommandDefault {m}
  { \ProvideTextCommand #1 {?} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TextSymbolUnavailable}
%    \begin{macrocode}
%<*deprecated>
\DeclareDocumentCommand \TextSymbolUnavailable {m}
  { \xfss_text_symbol_unavailable:N #1 }
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareTextAccent}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextAccent {mmm}
  {
    \xfss_declare_text_command:NNn
      \DeclareDocumentCommand #1 {#2} {m} { \xfss_add_accent:nn {#3} {##1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Math versions, alphabets, symbol fonts}
%
% When \LaTeX{} reads a formula, each glyph is assigned a math group.
% The default math groups are $\cs{symoperators}=0$, $\cs{symletters}=1$,
% $\cs{symsymbols}=2$, and $\cs{symlargesymbols}=3$. At the end of
% the formula, the glyphs are typeset in the fontface corresponding to
% their math group and their style (textstyle, scriptstyle,
% or scriptscriptstyle).
%
% When a math alphabet such as \cs{mathbf} is used, a new math group
% is created, and the corresponding \cs{tex_textfont:D},
% \cs{tex_scriptfont:D} and \cs{tex_scriptscriptfont:D} are assigned
% the correct fontfaces. All glyphs of class $7$ (typically letters)
% appearing within its argument are then set with that math group:
% at the end of the formula, they are thus typeset in the relevant fontface.
% Since \TeX{}'s supply of math groups is very limited ($16$ in the
% \pdfTeX{} engine for instance), the same math group must be used
% for every occurrence of a given alphabet. Thus, the selection of
% a math group corresponding to a given alphabet, and the assignment
% of fontfaces, must be done globally: consider for instance
% |$a_{\mathbf{b}}+\mathbf{c}$|. Thus, each math alphabet uses
% a given math group once and for all.
%
% Nesting math formulas then becomes an issue since the settings
% of inner math formulas will clobber the math fontfaces chosen
% for the outer formula. Consider for instance
% |$\mathbf{a}\ \mbox{\small $\mathbf{a}$}$|.
%
% A further complication is the \enquote{math version}: in fact,
% the correspondence between math alphabets and math groups depends
% on the version, which can only be changed outside math mode.
%
% \subsubsection{Math versions}
%
% \begin{variable}{\l_xfss_math_version_seq}
%   List of all math versions. Contrarily to \LaTeXe{}'s \cs{version@list},
%   the items are \texttt{normal} and \texttt{bold} rather than
%   \cs{mv@normal} and \cs{mv@bold}.
%    \begin{macrocode}
\seq_new:N  \l_xfss_math_version_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\xfss_math_version_check_exists:nT}
% \begin{macro}{\xfss_math_version_if_exist:nTF}
%   Error if the math version does not exist.
%   Should it use \cs{seq_if_in:Nn} \cs{l_xfss_math_version_seq}?
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_math_version_check_exists:nT #1 #2
  {
    \int_if_exist:cTF { g_xfss_mversion_ #1 _int }
      {#2}
      { \msg_error:nnx {xfss} {math-version-unknown} {#1} }
  }
\cs_new_protected:Npn \xfss_math_version_if_exist:nTF #1
  { \int_if_exist:cTF { g_xfss_mversion_ #1 _int } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xfss_math_version_use:x}
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_math_version_use:x #1
  {
    \prop_map_inline:cn { g_xfss_math_version_ #1 _gdf_prop }
      { \xfss_get_and_define_fonts:nn {##1} {##2} }
    \prop_map_inline:cn { g_xfss_math_version_ #1 _ins_prop }
      { \exp_args:Nc \xfss_install_math_alphabet:Nn {##1} {##2} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\mathversion}
%    \begin{macrocode}
\DeclareDocumentCommand \mathversion {m}
  {
    \xfss_check_not_math:N \mathversion
    \xfss_math_version_check_exists:nT {#1}
      {
        \tl_set:Nx \l_xfss_math_version_tl {#1}
        \tl_gclear:N \g_xfss_setup_currsize_tl
        \group_insert_after:N \g_xfss_global_settings_tl
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_init_restore_version:,
%     \xfss_restore_version:,\xfss_restore_mathversion:}
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_init_restore_version:
  {
    \bool_gset_false:N \g_xfss_restore_version_bool
    \cs_gset_protected:Npx \xfss_restore_mathversion:
      {
        \xfss_math_version_use:x { \l_xfss_math_version_tl }
        \exp_not:N \int_gset:cn
          { g_xfss_mversion_ \l_xfss_math_version_tl _int }
          { \int_use:c {g_xfss_mversion_ \l_xfss_math_version_tl _int} }
      }
    \group_insert_after:N \xfss_restore_version:
  }
\cs_new_protected:Npn \xfss_restore_version:
  {
    \mode_if_math:TF
      { \group_insert_after:N \xfss_restore_version: }
      {
        \bool_gset_true:N \g_xfss_restore_version_bool
        \group_begin:
          \cs_set_eq:NN \xfss_get_and_define_fonts:nn \use_none:nn
          \xfss_restore_mathversion:
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{User commands}
%
% We define
% \begin{itemize}
% \item \cs{DeclareMathVersion} \Arg{version name}
% \item \cs{DeclareMathAlphabet} \meta{alphabet} \meta{font specification}
% \item \cs{SetMathAlphabet} \meta{alphabet} \Arg{version}
%   \meta{font specification}
% \item \cs{DeclareSymbolFont} \Arg{sym name} \meta{font specification}
% \item \cs{SetSymbolFont} \Arg{sym name} \Arg{version name}
%   \meta{font specification}
% \item \cs{DeclareSymbolFontAlphabet} \meta{alphabet} \Arg{sym name}
% \end{itemize}
% where \meta{version name} is typically \texttt{normal} or \texttt{bold},
% \meta{alphabet} can be for instance \cs{mathit} or \cs{mathnormal},
% \meta{font specification} is four brace groups (the encoding, the family,
% the series, and the shape), and \meta{sym name} is typically
% \texttt{operators}, \texttt{letters}, \texttt{symbols}, or
% \texttt{largesymbols}.
%
% \begin{macro}{\DeclareMathVersion}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathVersion {m}
  {
    \xfss_math_version_if_exist:nTF {#1}
      { \msg_info:nnxx {xfss} {redeclaring} {math~version} {#1} }
      {
        \int_new:c {g_xfss_mversion_ #1 _int}
        \seq_put_right:Nn \l_xfss_math_version_seq {#1}
      }
    \int_gset:cn { g_xfss_mversion_ #1 _int }
      { \prop_count:N \g_xfss_symbol_font_prop }
    \prop_gclear_new:c { g_xfss_math_version_ #1 _gdf_prop }
    \prop_gclear_new:c { g_xfss_math_version_ #1 _ins_prop }
    \prop_map_inline:Nn \g_xfss_symbol_font_prop
      { % can really be optimized
        \prop_gput:cxx { g_xfss_math_version_ #1 _gdf_prop }
          { \int_use:c { sym ##1 } } { \exp_not:c {##2} }
      }
    \prop_map_inline:Nn \g_xfss_math_alphabet_prop
      { % can really be optimized
        \prop_gput:cxx { g_xfss_math_version_ #1 _ins_prop }
          {##1}
          {
            \exp_after:wN \cs_if_eq:NNTF
              \use_i:nn ##2
              \xfss_no_alphabet_error:N
              {
                \exp_not:N \xfss_no_alphabet_error:N
                \exp_not:c {##1}
              }
              {
                \exp_not:N \xfss_select_math_group:Nnnn
                \exp_not:c {##1}
                \exp_not:n {##2}
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareSymbolFont}
%   \begin{macrocode}
\DeclareDocumentCommand \DeclareSymbolFont {mm mmm}
  {
    \xfss_encoding_check_exists:nT {#2}
      {
        \cs_if_free:cTF {sym#1}
          {
            \mathgroup_new:c {sym#1}
            \xfss_new_symbol_font:nnnnn {#1} {#2}{#3}{#4}{#5}
          }
          {
            \msg_info:nnxx {xfss} {redeclaring} {symbol~font} {#1}
            \prop_gput:Nxx \g_xfss_symbol_font_prop {#1} { #2 / #3 / #4 / #5 }
            \seq_map_inline:Nn \l_xfss_math_version_seq
              {
                \exp_args:Nc \xfss_set_symbol_font:Nnn
                  {#2/#3/#4/#5} {#1} {##1}
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_new_symbol_font:nnnnn #1#2#3#4#5
  {
    \prop_gput:Nxx \g_xfss_symbol_font_prop {#1} { #2 / #3 / #4 / #5 }
    \seq_map_inline:Nn \l_xfss_math_version_seq
      {
        \prop_gput:cxx { g_xfss_math_version_ ##1 _gdf_prop }
          { \int_use:c {sym#1} } { \exp_not:c {#2/#3/#4/#5} }
        \int_gincr:c { g_xfss_mversion_ ##1 _int }
      }
  }
%    \end{macrocode}
%
% \begin{macro}{\SetSymbolFont}
%   This function packs the information for the font
%   into an NFSS font identifier, checking that the
%   encoding exists.
%    \begin{macrocode}
\DeclareDocumentCommand \SetSymbolFont {mmm mmm}
  {
    \xfss_encoding_check_exists:nT {#3}
      {
        \exp_args:Nc \xfss_set_symbol_font:Nnn
          {#3/#4/#5/#6} {#1} {#2}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_set_symbol_font:Nnn}
%   \begin{arguments}
%   \item \meta{NFSS font identifier} (\cs{enc/fam/series/shape})
%   \item \meta{symbol font}
%   \item \meta{math version}
%   \end{arguments}
%   Stripped from the checks and messages, this function would be
% \begin{verbatim}
% \prop_gput:cxn { g_xfss_math_version_ #3 _gdf_prop }
%   { \int_use:c {sym#2} } {#1}
% \end{verbatim}
%   in other words: \enquote{in the math version \texttt{\#3},
%     symbols of type \texttt{\#2} are typeset with font \texttt{\#1}}.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_symbol_font:Nnn #1#2#3
  {
    \xfss_math_version_check_exists:nT {#3}
      {
        \xfss_check_symbol_font_exists:nT {#2}
          {
            \prop_get:cxNT
              { g_xfss_math_version_ #3 _gdf_prop }
              { \int_use:c {sym#2} }
              \l_xfss_tmpc_tl
              {
                \xfss_font_get_encoding:NN #1 \l_xfss_tmpa_tl
                \exp_after:wN \xfss_font_get_encoding:NN
                  \l_xfss_tmpc_tl \l_xfss_tmpb_tl
                \cs_if_eq:NNF \l_xfss_tmpa_tl \l_xfss_tmpb_tl
                   {
                      \msg_info:nnxxxx {xfss} {enc-change}
                        {\l_xfss_tmpb_tl} {\l_xfss_tmpa_tl}
                        { #2 } { #3 }
                   }
                 \msg_info:nnxxxx {xfss} {overwrite-symfont}
                   { #2 } { #3 }
                   { \exp_after:wN \cs_to_str:N \l_xfss_tmpc_tl }
                   { \cs_to_str:N #1 }
               }
            \prop_gput:cxn { g_xfss_math_version_ #3 _gdf_prop }
              { \int_use:c {sym#2} } {#1}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareMathAlphabet}
%   \begin{arguments}
%   \item command to switch math alphabet font
%   \item encoding \item fam \item series \item shape
%   \end{arguments}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathAlphabet {mm mmm}
  {
    \xfss_encoding_check_exists:nT {#2}
      {
        \cs_if_free:NTF #1
          { \xfss_new_math_alphabet:Nnnnn #1 {#2}{#3}{#4}{#5} }
          {
            \cs_meaning_if_in:NNTF #1 \xfss_select_math_group:Nnnn
              {
                \msg_info:nnxx {xfss}
                  {redeclaring} {math~alphabet} { \token_to_str:N #1 }
                \seq_map_inline:Nn \l_xfss_math_version_seq
                  {
                    \xfss_set_math_alphabet:Nnnn
                      #1
                      {##1}
                      {#2}
                      {#2/#3/#4/#5}
                  }
              }
              {
                \cs_meaning_if_in:NNTF #1 \xfss_use_math_group:nn
                  {
                    \msg_info:nnxx {xfss}
                      {redeclaring} {math~alphabet} { \token_to_str:N #1 }
                    \xfss_new_math_alphabet:Nnnnn #1 {#2}{#3}{#4}{#5}
                  }
                  {
                    \msg_error:nnx {xfss} {cmd-defined} { \token_to_str:N #1 }
                  }
              }
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_new_math_alphabet:Nnnnn #1#2#3#4#5
  {
    \cs_set_protected:Npx #1
      {
        \tl_if_empty:nTF {#5}
          {
            \exp_not:N \xfss_no_alphabet_error:N
            \exp_not:N #1
          }{
            \exp_not:N \xfss_select_math_group:Nnnn
            \exp_not:N #1
            \exp_not:c { g_xfss_encoding_setup_math_ #2 _tl }
            \exp_not:c {#2/#3/#4/#5}
          }
      }
    \prop_gput:Nxx \g_xfss_math_alphabet_prop { \cs_to_str:N #1 }
      {
        \tl_if_empty:nTF {#5}
          {
            \exp_not:N \xfss_no_alphabet_error:N
            \exp_not:N \xfss_no_alphabet_error:N
          }{
            \exp_not:c { g_xfss_encoding_setup_math_ #2 _tl}
            \exp_not:c {#2/#3/#4/#5}
          }
      }
    \seq_map_inline:Nn \l_xfss_math_version_seq
      {
        \prop_gput:cxx { g_xfss_math_version_ ##1 _ins_prop }
          { \cs_to_str:N #1 } { \exp_not:o {#1} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SetMathAlphabet}
%   Arguments are: \meta{control sequence}, \meta{math version},
%   \meta{encoding}, \meta{family}, \meta{series}, \meta{shape}.
%    \begin{macrocode}
\DeclareDocumentCommand \SetMathAlphabet {mmm mmm}
  {
    \xfss_math_version_check_exists:nT {#2}
      {
        \xfss_encoding_check_exists:nT {#3}
          {
            \xfss_set_math_alphabet:Nnnn
              #1
              {#2}
              {#3}
              {#3/#4/#5/#6}
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_math_alphabet:Nnnn #1#2#3#4
  {% <cs> {version} {encoding} {font name}
    \prop_if_in:NxTF \g_xfss_math_alphabet_prop { \cs_to_str:N #1 }
      { \xfss_set_math_alphabet_existing:Nnnn #1 {#2} {#3} {#4} }
      {
        \cs_meaning_if_in:NNTF #1 \xfss_use_math_group:nn
          { \xfss_set_math_alphabet_umg:Nnnn #1 {#2} {#3} {#4} }
          {
            \msg_error:nnx {xfss}
              {no-math-alph-cmd} { \token_to_str:N #1 }
          }
      }
  }
\cs_new_protected:Npn \xfss_set_math_alphabet_existing:Nnnn #1#2#3#4
  {
    \prop_get:cxNT { g_xfss_math_version_ #2 _ins_prop }
      { \cs_to_str:N #1 }
      \l_xfss_tmpd_tl
      {
        \msg_info:nnxxxx {xfss} {overwrite-mathalph}
          { \token_to_str:N #1 } {#2}
          { \exp_after:wN \use_iv_to_str:nnnN \l_xfss_tmpd_tl } {#4}
      }
    \prop_gput:cxx { g_xfss_math_version_ #2 _ins_prop }
      { \cs_to_str:N #1 }
      {
        \exp_not:N \xfss_select_math_group:Nnnn
        \exp_not:N #1
        \exp_not:c { g_xfss_encoding_setup_math_ #3 _tl }
        \exp_not:c {#4}
      }
  }
\cs_new_protected:Npn \xfss_set_math_alphabet_umg:Nnnn #1#2#3#4
  {
    \cs_set:Npn \xfss_tmp:w ##1 \xfss_use_math_group:nn ##2 ##3
      {
        \tl_set:Nn \l_xfss_tmpb_tl {##3}
        \tl_set:Nn \l_xfss_tmpc_tl {##2}
      }
    \exp_after:wN \xfss_tmp:w #1
    \seq_map_inline:Nn \l_xfss_math_version_seq
      {
        \prop_get:cxNT { g_xfss_math_version_ ##1 _gdf_prop }
          { \int_eval:n { \l_xfss_tmpb_tl } } %^^A overkill
          \l_xfss_tmpd_tl
          {
            \prop_gput:cxx { g_xfss_math_version_ ##1 _ins_prop }
              { \cs_to_str:N #1 }
              {
                \exp_not:N \xfss_select_math_group:Nnnn
                \exp_not:N #1
                \exp_not:o { \l_xfss_tmpc_tl }
                \exp_not:o { \l_xfss_tmpd_tl }
              }
          }
      }
    \prop_gput:Nxn \g_xfss_math_alphabet_prop
      { \cs_to_str:N #1 }
      { \xfss_no_alphabet_error:N } %should be doubled??
    \tl_gset:Nn #1 { \xfss_no_alphabet_error:N #1 }% fake things :-)
    \xfss_set_math_alphabet:Nnnn #1 {#2} {#3} {#4}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareSymbolFontAlphabet}
% First step: find out if everything is in place to define the alphabet,
% setting the tmp boolean to false if it isn't. Then do the second step
% conditionally. What does \enquote{everything is in place mean?}
% \begin{itemize}
% \item If the math alphabet exists, then remove it from the alphabet prop,
%   then remove the corresponding \cs{xfss_install_math_alphabet:Nn}
%   |####1 {####2}| from each
%   \cs{g_xfss_math_version_}\meta{math version}\texttt{_tl} in the version seq.
% \item If the control sequence doesn't exist, everything is ok.
% \item If it contains \cs{xfss_use_math_group:nn} then it is also a math
%   alphabet.
% \item Otherwise, we're trying to redefine some random cs, and that's not ok.
% \end{itemize}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareSymbolFontAlphabet {mm}
  { \exp_args:NNx \xfss_declare_symbol_font_alphabet:Nn #1 {#2} }
\cs_new_protected:Npn \xfss_declare_symbol_font_alphabet:Nn #1#2
  {
    \bool_set_true:N \l_xfss_tmp_bool
    \xfss_check_symbol_font_exists:nTF {#2}
      {
        \prop_gpop:NxNTF
          \g_xfss_math_alphabet_prop { \cs_to_str:N #1 } \l_xfss_tmpa_tl
          {
            \msg_info:nnxx {xfss}
              {redeclaring} {math~alphabet} { \token_to_str:N #1 }
            \seq_map_inline:Nn \l_xfss_math_version_seq
              {
                \prop_gpop:cxN { g_xfss_math_version_ ##1 _ins_prop }
                  { \cs_to_str:N #1 } \l_xfss_tmpb_tl
              }
          }{
            \cs_if_exist:NT #1
              {
                \cs_meaning_if_in:NNTF #1 \xfss_use_math_group:nn
                  {
                    \msg_info:nnxx {xfss}
                      {redeclaring} {math~alphabet} { \token_to_str:N #1 }
                    % when does this happen?
                  }
                  {
                    \bool_set_false:N \l_xfss_tmp_bool
                    \msg_error:nnx {xfss} {cmd-defined}
                      { \token_to_str:N #1 }
                  }
              }
          }
      }
      { \bool_set_false:N \l_xfss_tmp_bool }
    \bool_if:NT \l_xfss_tmp_bool
      {
        \prop_get:NnNTF \g_xfss_symbol_font_prop {#2} \l_xfss_tmpa_tl
          {
            \tl_set:Nx \l_xfss_tmpa_tl % pick up the encoding.
              {
                \exp_after:wN \xfss_use_to_slash_nil:ww
                \l_xfss_tmpa_tl / \q_nil
              }
          }
          { \ERROR \tl_set:Nn \l_xfss_tmpa_tl {?} }
        \cs_set_protected:Npx #1
          {
            \exp_not:n { \mode_if_math:F {
                \msg_error:nnx {xfss} {only-math-cmd} { \token_to_str:N #1 } } }
            \exp_not:N \xfss_use_math_group:nn
            \exp_not:c {g_xfss_encoding_setup_math_ \l_xfss_tmpa_tl _tl}
            \use:c {sym #2}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Select a math group}
%
% \begin{macro}{\xfss_select_math_group:Nnnn}
%    \begin{macrocode}
\bool_new:N \g_xfss_document_bool
\cs_new_protected:Npn \xfss_select_math_group:Nnnn #1#2#3#4
  {
    \c_group_begin_token % \group_begin: ?
      \mode_if_math:TF
        {
          \exp_args:Nc \int_compare:nNnTF
            { g_xfss_mversion_ \l_xfss_math_version_tl _int }
            < \c_max_math_fonts_int
            {
              \group_begin:
                \int_set:Nn \tex_escapechar:D { -1 }
                \exp_args:Nv \xfss_get_and_define_fonts:nn
                  {g_xfss_mversion_ \l_xfss_math_version_tl _int} #3
                \l_xfss_math_fonts_assign_tl
              \group_end:
              \bool_if:NTF \g_xfss_document_bool
                {
                  \exp_args:Nv \xfss_math_version_fix_alphabet:nnN
                    {g_xfss_mversion_ \l_xfss_math_version_tl _int}
                    { \l_xfss_math_version_tl }
                    #1
                }
                {
                  \bool_if:NT \g_xfss_restore_version_bool
                    { \xfss_init_restore_version: }
                  \tl_gset:Nx #1
                    {
                      \exp_not:N \xfss_use_math_group:nn \exp_not:N #2
                        {
                          \int_use:c
                            {g_xfss_mversion_ \l_xfss_math_version_tl _int}
                        }
                    }
                }
              \int_gincr:c {g_xfss_mversion_ \l_xfss_math_version_tl _int}
            }
            {
              \cs_undefine:N #1
              \msg_error:nnx {xfss}
                {too-many-alphabets} {\l_xfss_math_version_tl}
            }
        }
        { \msg_error:nnx {xfss} {only-math-cmd} { \token_to_str:N #1 } }
      #1{#4}
    \c_group_end_token
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_math_version_fix_alphabet:nnN}
%   \cs{xfss_math_version_fix_alphabet:nnN}
%   \Arg{int} \Arg{math version} \meta{math alphabet}
%   pops the declaration of the math alphabet from the math version,
%   and replaces it by a definition with a fixed math group number,
%   \meta{int}, using \cs{xfss_use_math_group:nn}.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_math_version_fix_alphabet:nnN #1#2#3
  {
    \prop_gpop:cxN { g_xfss_math_version_ #2 _ins_prop }
      { \cs_to_str:N #3 } \l_xfss_tmpb_tl
    \cs_set:Npn \xfss_tmp:w \xfss_select_math_group:Nnnn #3 ##1 ##2 \q_nil
      {
        \cs_gset_protected:Npn #3
          {
            \mode_if_math:F
              { \msg_error:nnx {xfss} {only-math-cmd} { \token_to_str:N #3 } }
            \xfss_use_math_group:nn ##1 {#1}
          }
        \prop_gput:cxn { g_xfss_math_version_ #2 _gdf_prop } {#1} {##2}
        \prop_gput:cxx { g_xfss_math_version_ #2 _ins_prop }
          { \cs_to_str:N #3 } { \exp_not:o {#3} }
      }
    \exp_after:wN \xfss_tmp:w \l_xfss_tmpb_tl \q_nil
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_use_math_group:nn}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_use_math_group:nn #1#2
  {
    \mode_if_math:T
      {
        \c_group_begin_token
          \tl_if_eq:NcF
            #1
            { g_xfss_encoding_setup_math_ \l_xfss_encoding_tl _tl }
            {#1}
          \mathgroup_use:n {#2}
        \xfss_math_egroup:n
      }
  }
\cs_new_protected:Npn \xfss_math_egroup:n #1 { #1 \egroup }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Defining math symbols, accents, delimiters, radicals}
%
% \begin{macro}{\DeclareMathSymbol}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathSymbol {mmmm}
  {
    \xfss_check_symbol_font_exists:nT {#3}
      {
        \token_if_cs:NTF #1
          {
            \cs_meaning_if_in:NNTF #1 \tex_mathchar:D
              {
                \msg_info:nnxx {xfss}
                  {redeclaring} {math~symbol} { \token_to_str:N #1 }
                \math_gset_symbol:NNnn #1 #2 { \use:c {sym #3} } {#4}
              }
              { \math_new_symbol:NNnn #1 #2 { \use:c {sym #3} } {#4} }
          }
          {
            \math_gset_mathcode:NNnn #1 #2 { \use:c{sym #3} } {#4}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareMathAccent}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathAccent {mmmm}
  {
    \xfss_check_symbol_font_exists:nT {#3}
      {
        \token_if_cs:NTF #1
          {
            \cs_meaning_if_in:NNTF #1 \tex_mathaccent:D
              {
                \msg_info:nnxx {xfss}
                  {redeclaring} {math~accent} { \token_to_str:N #1 }
                \math_gset_accent:NNnn #1 #2 { \use:c {sym #3} } {#4}
              }
              { \math_new_accent:NNnn #1 #2 { \use:c {sym #3} } {#4} }
          }
          { \msg_error:nnx {xfss} {not-cmd} { \token_to_str:N #1 } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\DeclareMathDelimiter}
%
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathDelimiter {m}
  {
    \token_if_cs:NTF #1
      \xfss_declare_math_delimiter_cs:NNnnnn
      \xfss_declare_math_delimiter_aux:nnnn
    #1
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_declare_math_delimiter_aux:nnnn #1#2#3#4
  {
    \DeclareMathSymbol #1 {#2} {#3} {#4}
    \xfss_declare_math_delimiter_auxii:nnnnn #1 {#3} {#4}
  }
\cs_new_protected:Npn \xfss_declare_math_delimiter_auxii:nnnnn #1#2#3#4#5
  {
    \xfss_check_symbol_font_exists:nT {#2}
      {
        \xfss_check_symbol_font_exists:nT {#4}
          {
            \math_gset_delcode:Nnnnn #1 {#2} { \use:c {sym #3} } {#4} {#5}
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_declare_math_delimiter_cs:NNnnnn #1#2#3#4#5#6
  {
    \xfss_check_symbol_font_exists:nT {#3}
      {
        \xfss_check_symbol_font_exists:nT {#5}
          {
            \cs_meaning_if_in:NNTF #1 \tex_delimiter:D
              {
                \math_gset_delimiter:NNnnnn #1 #2
                  { \use:c {sym #3} } {#4}
                  { \use:c {sym #5} } {#6}
                \msg_info:nnxx {xfss}
                  {redeclaring} {math~delimiter} { \token_to_str:N #1 }
              }
              {
                \math_new_delimiter:NNnnnn #1 #2
                  { \use:c {sym #3} } {#4}
                  { \use:c {sym #5} } {#6}
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareMathRadical}
%
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathRadical {mm mmm}
  {
    \xfss_check_symbol_font_exists:nT {#2}
      {
        \xfss_check_symbol_font_exists:nT {#4}
          {
            \cs_meaning_if_in:NNTF #1 \tex_radical:D
              {
                \msg_info:nnxx {xfss}
                  {redeclaring} {math~radical} { \token_to_str:N #1 }
                \math_gset_radical:Nnnnn #1
                  { \use:c {sym #2} } {#3}
                  { \use:c {sym #4} } {#5}
              }
              {
                \math_new_radical:Nnnnn #1
                  { \use:c {sym #2} } {#3}
                  { \use:c {sym #4} } {#5}
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Conditionals}
%
% \begin{macro}{\xfss_check_symbol_font_exists:nT}
%   If false returns an error.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \xfss_check_symbol_font_exists:n #1 {T,TF}
  {
    \prop_if_in:NxTF \g_xfss_symbol_font_prop {#1}
      { \prg_return_true: }
      {
        \msg_error:nnx {xfss} {sym-font-unknown} {#1}
        \prg_return_false:
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Font commands}
%
% From file: ltfntcmd.dtx
%
% \begin{macro}{\DeclareTextFontCommand}
%
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextFontCommand {mm}
  {
    \DeclareDocumentCommand #1 {m}
      {
        \mode_if_math:TF
          { \xfss_text_in_math:n {#2##1} }
          {
            \mode_leave_vertical:
            \bgroup
              \xfss_text_command:n {##1}
              #2 \xfss_check_ic_l: ##1 \xfss_check_ic_r:
            \egroup
          }
      }
  }
%    \end{macrocode}
%
% \subsubsection{Italic correction}
%
%    \begin{macrocode}
\cs_set_eq:NN \nocorr \scan_stop: % to make \nocorr unexpandable, presumably
\cs_clear:N \xfss_check_ic_l:
\cs_clear:N \xfss_check_ic_r:
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_text_command:n #1
  {
    \tl_if_blank:nTF {#1}
    {
      \cs_clear:N \xfss_check_ic_l:
      \cs_clear:N \xfss_check_ic_r:
    }
    { \xfss_check_nocorr:w #1\nocorr \q_nil }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_check_nocorr:w #1#2 \nocorr #3 \q_nil
  {
    \cs_set_eq:NN \xfss_check_ic_l: \xfss_maybe_ic:
    \cs_set:Npn \xfss_check_ic_r:
      { \mode_if_vertical:F { \group_insert_after:N \xfss_maybe_ic: } }
    \tl_if_eq:nnTF {\nocorr} {#1} % seems odd.
      {
        \tl_if_empty:nTF {#3}
          { \cs_clear:N \xfss_check_ic_l: }
          {
            \cs_clear:N \xfss_check_ic_l:
            \cs_clear:N \xfss_check_ic_r:
          }
      }
      {
        \tl_if_empty:nF {#3} { \cs_clear:N \xfss_check_ic_r: }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_maybe_ic:
  { \peek_after:Nw \xfss_maybe_ic_aux: }
\cs_new_protected:Npn \xfss_maybe_ic_aux:
  {
    \dim_compare:nNnF \fontface_current_slant: > \c_zero_dim
      {
        \bool_set_true:N \l_xfss_maybe_ic_bool
        \tl_map_function:NN \nocorrlist \xfss_test_nocorr:N
        \bool_if:NT \l_xfss_maybe_ic_bool { \xfss_sw_slant: }
      }
  }
%    \end{macrocode}
% Surely it is faster to do the mapping as a function rather than inline.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_test_nocorr:N #1
  {
    \token_if_eq_meaning:NNT #1 \l_peek_token
    {
      \bool_set_false:N \l_xfss_maybe_ic_bool
      \tl_map_break:
    }
  }
\cs_new_protected:Npn \xfss_sw_slant:
  {
    \dim_compare:nNnTF \l_last_skip = \c_zero_dim
      { \xfss_fix_penalty: }
      {
        \l_xfss_tmp_skip \l_last_skip
        \unskip
        \xfss_fix_penalty:
        \hskip \l_xfss_tmp_skip
      }
  }
\cs_new_protected:Npn \xfss_fix_penalty:
  {
    \int_compare:nNnTF \tex_lastpenalty:D = 0
      { \tex_italiccorrection:D }
      {
        \int_set:Nn \l_xfss_tmpa_int \tex_lastpenalty:D
        \tex_unpenalty:D
        \tex_italiccorrection:D
        \tex_penalty:D \l_xfss_tmpa_int
      }
  }
\tl_set:Nn \nocorrlist {,.}
%    \end{macrocode}
% fixme: "\tex_unpenalty:D", etc., wrappers
%
%    \begin{macrocode}
\int_new:N \l_xfss_tmpa_int
%    \end{macrocode}
%
% \end{macro}
%
%
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareOldFontCommand {mmm}
  {
    \msg_warning:nnx {xfss} {deprecated-function}
      { \token_to_str:N \DeclareOldFontCommand }
  }
%    \end{macrocode}
%
% \subsection{Sizing}
%
%
% \begin{macro}{\xfss_current_fontsize_switch:}
%    \begin{macrocode}
\cs_new:Npn \xfss_current_fontsize_switch: {}
%    \end{macrocode}
% \end{macro}
%
%
% Temporary just to get things working. Todo: incorporate packages
% \textsf{relsize} and \textsf{extsizes}. N.B. changing the font size
% should be orthogonal to design decisions, probably.
%
% N.B. \LaTeXe\ uses non-integer sizes here so we're being hugely
% incompatible at the moment.
%
% \begin{macro}{\xfss_set_font_size_commands:n}
% Sets the fontsize changing commands automatically based on the following
% relationships:
% \[
% f = f_0 \times 2^{n/8} \qquad b = f^{1.08}
% \]
% where $f$ and $b$ are the fontsize and baselineskip based on a nominal
% fontsize of $f_0$ and size index $n$.
% These equations were derived empirically pretty quickly
% and could be improved.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_font_size_commands:n #1
  {
    \xfss_declare_font_cmd:Nnn \tiny         {#1} {-8}
    \xfss_declare_font_cmd:Nnn \scriptsize   {#1} {-4}
    \xfss_declare_font_cmd:Nnn \footnotesize {#1} {-2}
    \xfss_declare_font_cmd:Nnn \small        {#1} {-1}
    \xfss_declare_font_cmd:Nnn \normalsize   {#1} {0}
    \xfss_declare_font_cmd:Nnn \large        {#1} {2}
    \xfss_declare_font_cmd:Nnn \Large        {#1} {4}
    \xfss_declare_font_cmd:Nnn \LARGE        {#1} {6}
    \xfss_declare_font_cmd:Nnn \huge         {#1} {8}
    \xfss_declare_font_cmd:Nnn \Huge         {#1} {10}
    \normalsize
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\xfss_declare_font_cmd:Nnn}
% \begin{arguments}
% \item command
% \item nominal size
% \item size index
% \end{arguments}
% As mentioned above, this is the command that does the calculations
% for the font sizing.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_declare_font_cmd:Nnn #1#2#3
  {
    \fp_set:Nn \l_xfss_pow_fp {1.0905} % 2^(1/8)
    \fp_pow:Nn \l_xfss_pow_fp {#3}
    \fp_set:Nn \l_xfss_size_fp {#2}
    \fp_mul:Nn \l_xfss_size_fp {\l_xfss_pow_fp}
    \fp_set:Nn \l_xfss_bskip_fp {\l_xfss_size_fp}
    \fp_pow:Nn \l_xfss_bskip_fp {1.08} % empirical
    \xfss_declare_font_cmd_aux:Nxx #1
      {\fp_to_dim:N \l_xfss_size_fp} {\fp_to_dim:N \l_xfss_bskip_fp}
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_declare_font_cmd_aux:Nnn #1#2#3
  {
    \DeclareDocumentCommand #1
      { } { \xfss_set_font_size:Nnn #1 {#2} {#3} }
  }
\cs_generate_variant:Nn \xfss_declare_font_cmd_aux:Nnn {Nxx}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_font_size:Nnn #1#2#3
  {
    \xfss_check_not_math:N #1
    \cs_set_eq:NN \xfss_current_fontsize_switch: #1
    \xfss_set_fontsize:nnn \baselinestretch {#2}{#3}
    \selectfont
  }
%    \end{macrocode}
%
%
% When used in \LaTeXe, extract the font size from \cs{normalsize}
% and replace the font changing commands with \pkg{xfss} methods.
% Note that \cs{small}, etc., no longer contain alterations to list settings,
% and so on.
%    \begin{macrocode}
%<*!initex>
\cs_new:Npn \xfss_extract_normalsize:
  {
    \exp_after:wN \xfss_extract_size_aux:Nnnw
    \normalsize \q_nil
  }
\cs_new:Npn \xfss_extract_size_aux:Nnnw #1#2#3#4 \q_nil {#3}
\AtBeginDocument
  {
    \exp_args:Nx \xfss_set_font_size_commands:n
      {\xfss_extract_normalsize:}
  }
%</!initex>
%    \end{macrocode}
%
%
% \subsection{NFSS interaction}
% Not yet comprehensive.
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% \subsubsection{Unloading the old commands}
%
%    \begin{macrocode}
\cs_undefine:N \font@name
%    \end{macrocode}
%
% \subsubsection{Supporting NFSS internal commands}
%
%    \begin{macrocode}
\tl_set:Nn \glb@settings {\g_xfss_global_settings_tl}
\tl_new:N \tf@size
\tl_set:Nn \tf@size  {\g_xfss_tf_size_tl}
\tl_new:N \sf@size
\tl_set:Nn \sf@size  {\g_xfss_sf_size_tl}
\tl_new:N \ssf@size
\tl_set:Nn \ssf@size {\g_xfss_ssf_size_tl}
\tl_set:Nn \noaccents@ {\l_no_accents_tl}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set_protected:Npn \operator@font {\math_operator_font:}
%    \end{macrocode}
%
%    \begin{macrocode}
\tl_replace_once:Nnn \document {\process@table} {\xfss_process_table:}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set:Npn \xfss_tmp:w #1 \@dofilelist #2 \@defaultsubs #3 \q_nil
  {
    \exp_not:n { #1 \@dofilelist }
    \exp_not:N \xfss_size_diff_warning:
    \exp_not:n {#3}
  }
\tl_set:Nx \enddocument { \exp_after:wN \xfss_tmp:w \enddocument \q_nil }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_size_diff_warning:
  {
    \dim_compare:nNnT \g_xfss_font_submax_tl > \fontsubfuzz
      { \msg_warning:nnx {xfss} {size-subst} {\g_xfss_font_submax_tl} }
    \bool_if:NT \g_xfss_subst_warning_bool
      { \msg_warning:nn {xfss} {some-font-shapes-unavail} }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set_eq:NN \reset@font \normalfont
%    \end{macrocode}
%
% fixme: perhaps patch these in the 2e kernel?
%    \begin{macrocode}
\cs_set_eq:NN \@acci \'
\cs_set_eq:NN \@accii \`
\cs_set_eq:NN \@acciii \=
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \subsection{Support for everysel}
%
% \begin{macro}{\EverySelectFont,\AtNextSelectFont}
%    \begin{macrocode}
%<*hook>
\DeclareDocumentCommand \EverySelectFont {m}
  { \hook_post_push:nn {selectfont} {#1} }
\DeclareDocumentCommand \AtNextSelectFont {m}
  { \hook_post_once:nn {selectfont} {#1} }
%</hook>
%    \end{macrocode}
% \end{macro}
%
% \subsection{Epilogue}
%
% \begin{macro}{\file_input:n}
%   Setup all the symbols, font etc.
%    \begin{macrocode}
\file_input:n {xfss-setup.cfg}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@onlypreamble}
% These are out-commented because for Unicode maths we no
% longer have the restriction of loading a small number of fonts.
%
% Some of them may still be wanted, though, so we'll keep them around
% until we know they're no longer required.
%    \begin{macrocode}
%<*package>
% \@onlypreamble\DeclareTextCommand
% \@onlypreamble\DeclareTextSymbol
% \@onlypreamble\DeclareTextCommandDefault
% \@onlypreamble\DeclareTextAccent
% \@onlypreamble\DeclareTextCompositeCommand
% \@onlypreamble\DeclareTextComposite
% \@onlypreamble\DeclareTextSymbolDefault
% \@onlypreamble\DeclareTextAccentDefault
% \@onlypreamble\UndeclareTextCommand
% \@onlypreamble\mathgroup_new:N
% \@onlypreamble\DeclareFontEncoding
% \@onlypreamble\DeclareFontEncoding@
% \@onlypreamble\DeclareFontSubstitution
% \@onlypreamble\DeclareFontEncodingDefaults
% \@onlypreamble\DeclarePreloadSizes
% \@onlypreamble\DeclareMathSizes
% \@onlypreamble\@DeclareMathSizes
% \@onlypreamble\DeclareErrorFont
% \@onlypreamble\DeclareSizeFunction
% \@onlypreamble\xfss_restore_mathversion:
% \@onlypreamble\xfss_init_restore_version:
% \@onlypreamble\xfss_restore_version:
\@onlypreamble \xfss_process_table:
% \@onlypreamble\DeclareMathVersion
% \@onlypreamble\xfss_new_math_version:N
% \@onlypreamble\DeclareSymbolFont
% \@onlypreamble\xfss_new_symbol_font:nnnnn
% \@onlypreamble\SetSymbolFont
% \@onlypreamble\xfss_set_symbol_font:nNn
% \@onlypreamble\xfss_get_cdp:wqN
% \@onlypreamble\DeclareMathAlphabet
% \@onlypreamble\xfss_new_math_alphabet:Nnnnn
% \@onlypreamble\SetMathAlphabet
% \@onlypreamble\xfss_set_math_alphabet:?
% \@onlypreamble\DeclareMathAccent
% \@onlypreamble\math_gset_accent:NNnn
% \@onlypreamble\DeclareMathSymbol
% \@onlypreamble\math_gset_mathcode:NNnn
% \@onlypreamble\math_gset_symbol:NNnn
% \@onlypreamble\DeclareMathDelimiter
% \@onlypreamble\xfss_declare_math_delimiter_aux:nnnn
% \@onlypreamble\xfss_declare_math_delimiter_cs:NNnnnn
% \@onlypreamble\xfss_declare_math_delimiter_auxii:nnnnn
% \@onlypreamble\math_gset_delimiter:NNnnnn
% \@onlypreamble\math_gset_delcode:Nnnnn
% \@onlypreamble\DeclareMathRadical
% \@onlypreamble\xfss_mclass_to_int:N
% \@onlypreamble\DeclareSymbolFontAlphabet
% \@onlypreamble\DeclareSymbolFontAlphabet@
% \@onlypreamble\DeclareTextFontCommand
%</package>
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package|initex>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
%
% \endinput
\endinput

From `grep -E -o '^\\def\\[a-zA-Z@]*' ltfntcmd.dtx ltfss* `:


ltfntcmd.dtx:

\normalsize


ltfssbas.dtx:

\@nomath
\new@mathgroup
\DeclareFontShape
\DeclareFontShape@
\DeclareFixedFont
\do@subst@correction
\DeclareFontFamily
\DeclareFontEncoding
\DeclareFontEncoding@
\LastDeclaredEncoding
\DeclareFontSubstitution
\DeclareFontEncodingDefaults
\DeclarePreloadSizes
\DeclareMathSizes
\@DeclareMathSizes
\@@enc@update
\usefont
\@defaultunits
\strip@pt
\pickup@font
\curr@fontshape
\define@newfont
\try@load@fontshape
\nfss@catcodes
\DeclareErrorFont
\wrong@fontshape
\strip@prefix
\extract@alph@from@version
\math@egroup
\calculate@math@sizes
\defaultscriptratio
\defaultscriptscriptratio


ltfsscmp.dtx:

\new@fontshape
\subst@fontshape
\extra@def
\default@mextra
\define@mathalphabet
\define@mathgroup
\scan@fontshape
\addtoversion


ltfssdcl.dtx:

\in@
\select@group
\init@restore@version
\dorestore@version
\document@select@group
\process@table
\DeclareMathVersion
\new@mathversion
\DeclareSymbolFont
\new@symbolfont
\SetSymbolFont
\SetSymbolFont@
\get@cdp
\DeclareMathAlphabet
\new@mathalphabet
\SetMathAlphabet
\SetMathAlphabet@
\DeclareMathAccent
\set@mathaccent
\DeclareMathSymbol
\set@mathchar
\set@mathsymbol
\DeclareMathDelimiter
\@xxDeclareMathDelimiter
\@DeclareMathDelimiter
\@xDeclareMathDelimiter
\set@mathdelimiter
\set@@mathdelimiter
\DeclareMathRadical
\mathchar@type
\DeclareSymbolFontAlphabet
\DeclareSymbolFontAlphabet@


ltfssini.dtx:

\not@math@alphabet
\boldmath
\unboldmath
\math@version
\newfont
\symbol
\@setfontsize
\@setsize
\oldstylenums
\hexnumber@
\nfss@text
\not@base
\mho
\Join
\Box
\Diamond
\leadsto
\sqsubset
\sqsupset
\lhd
\unlhd
\rhd
\unrhd


ltfsstrc.dtx:

\tracingfonts
\@font@info
\@font@warning
\extract@font
\get@external@font
\set@fontsize
\glb@settings
\baselinestretch
\check@mathfonts
\init@restore@glb@settings
\restglb@settings
\use@mathgroup
\getanddefine@fonts
\ifnot@nil
\remove@to@nnil
\remove@angles
\remove@star
\extract@sizefn
\try@simple@size
\set@simple@size@args
\extract@rangefontinfo
\is@range
\check@range
\check@single
\set@size@funct@args
\set@size@funct@args@
\DeclareSizeFunction
\execute@size@function
\try@size@range
\try@size@substitution
\font@submax
\fontsubfuzz
\try@simples
\empty@sfcnt
\gen@sfcnt
\genb@sfcnt
\genb@x
\genb@y
\sub@sfcnt
\subf@sfcnt
\fixed@sfcnt
