% \iffalse meta-comment
%
%% File l3ldb.dtx (C) Copyright 2011 Frank Mittelbach, The LaTeX Project
%%                (C) Copyright 2012,2013,2016-2017,2021 The LaTeX Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with The LaTeX Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{textcomp}
% \usepackage{xlists,xlists-samples}
% \usepackage{ldcdoc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3ldb} package\\ LaTeX3 Resource Database^^A
% }
%
% \author{^^A
%  The \LaTeX{} Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2018-04-30}
%
% \maketitle
%
% \begin{documentation}
%
% \section{The \LaTeX3 Resource Database}
%
% The \LaTeX3 Resource Database (or Ldb for short) is a system that
% provide parameter settings depending on the ``context'' where this
% context is defined by the current nesting and sequencing of structural
% elements in the document.
%
% Roughly speaking certain (but not all) document elements (typically
% environments) are declared to belong to one or more element
% classes. Whenever such an element is encountered in the document the
% LDB is consulted to provide parameter updates due to the changed
% context.
%
% In case of environments both the start and the end of the environment
% result in a context change so that sequences of begin or end tags can
% be specially handled.
%
% \subsection{Context}
%
% When setting up the database the following conventions are used
% \begin{description}
% \item[\texttt{<foo}] denotes the begin tag of class \texttt{foo}.
% \item[\texttt{foo>}] denotes the end tag of class \texttt{foo}.
% \item[\texttt{<foo>}] denotes a the occurrence of a whole environment
%   for use in sequencing specs.
% \item[\texttt{<-}] is a begin elision tag spec and denotes a possibly
%   empty sequence of begin tags (not implemented).
% \item[\texttt{->}] is an end elision tag spec (also not implemented).
% \end{description}
%
% Tags are related through each other through nesting or sequencing.
% This is denoted by a \enquote{\texttt{.}} (dot) for direct nesting,
% \enquote{\texttt{*}} (star) for nesting at arbitrary depth, and the
% absence of a binding denotes sequencing (\emph{i.e.}, when two tags
% occur with nothing in between).
%
% In BNF notation this would be represented as
% \begin{verbatim}
%   context == spec [[binding] spec]*
%   binding == "." | "*"
%   spec    == ["<"] id [">"] | <- | ->
% \end{verbatim}
%
% There are additional restriction on the form of admissible context
% specifications.  The context matching approach requires that we keep a
% stack of tags to represent the current situation so that we can match
% it with entries in the database.  The desire to keep the size of this
% stack under control leads us to formulate a number of restrictions
% which will allow us to trim the stack as much and as soon as possible.
% Also there are semantic difficulties which also suggest certain
% restrictions.
% \begin{enumerate}
% \item The scope of \texttt{<foo} extends to the end of the context
%   specification.
% \item Specs to the right of \texttt{foo>} can only involve sequencing.
% \item \texttt{<foo>} occurs right-most, or must be followed by `<baz'
%   or \texttt{<baz>}.
% \item \texttt{<foo>} cannot occur to the right of \texttt{baz>}.
% \end{enumerate}
%
% With these restrictions, we arrive at the following formulation for
% admissible context specifications.  A context specification has 3
% parts:
% \begin{enumerate}
% \item The 1st part consists solely of begin tags \texttt{<foo}, begin
%   elision tags \texttt{<-}, and completed tags \texttt{<foo>}
%   interspersed here and there with tight and loose bindings.
% \item The 2nd part consists only of a sequence of end tags
%   \texttt{foo>} and end elision tags \texttt{->}.  If both the 1st and
%   the 2nd parts are non-empty, then they must be separated by a loose
%   binding.
% \item The 3rd part consists only of a sequence of begin tags
%   \texttt{<foo} and begin elision tags \texttt{<-}.
% \end{enumerate}
%
% Here is an example in which the 3 parts have been deliberately
% separated for ease of recognition:
% \begin{verbatim}
% 	<A1.<A2><A3><-<A4*<A5   *   B1>B2>->B3>   <C1<-<C2
% \end{verbatim}
% The reason we need a loose binding between the 1st and 2nd part is
% that a context like \texttt{<A.B>A>C>} could never match anything
% since the scope of \texttt{<A} extends all the way to the right, yet
% the scope of the environment \texttt{A} doesn't extend past
% \texttt{A>} (which in this situation must obviously correspond to
% \texttt{<A}). \texttt{<A*B>A>C>} may match certain situations where we
% have another environment \texttt{A} indirectly nested in the first
% one.
%
% The reason end tags can only appear as a sequence in the 2nd part is
% that, as soon as possible, we want to collapse the sequence
% \texttt{B1>B2>B3>} into the completed env \texttt{<B3>}.  When we do
% this, we just throw away \texttt{B1>} and \texttt{B2>} and forget
% everything about them.  As soon as possible is when we cannot extend
% the sequence of tags (\emph{e.g.}, because the new tag wasn't in
% sequence, or because we are in the situation where we found a sequence
% of end tags followed by a sequence of begin tags and the new tag is an
% end tag again).
%
% \subsection{The issue of specificity}
%
% Whenever there are several LDB entries matching the current situation
% and proposing different assignments to the same parameter, we must
% choose the most specific entry.  Here are some rules that govern the
% issue of specificity:
% \begin{enumerate}
% \item Any spec is more specific than another one to its left.  In
%   other words, specificity increases from left to right.  In terms of
%   nesting: specificity decreases from the inside out.
% \item Sequencing is more specific than nesting.
% \item \texttt{<foo} is more specific than \texttt{<-}.
% \item \texttt{foo>} is more specific than \texttt{->} which is more
%   specific than \texttt{<foo>}.
% \item \texttt{.foo} is more specific than \texttt{*foo}.
% \end{enumerate}
%
% \subsection{Tag classes}
%
% The identifier \texttt{foo} in a spec like \texttt{<foo} names a class
% rather than an environment called \texttt{foo}.  Each environment is
% associated with a list of classes.  The order is meaningful: it goes
% from most to least specific.  Typically, the most specific class has
% the same name as the environment.
%
% The purpose of classes is to allow a form of inheritance.  The idea is
% that an environment like \texttt{enumerate} is also an instance of a
% \texttt{list}.  Thus \texttt{enumerate} should be able to inherit the
% LDB entries for \texttt{list} but also be allowed to have additional
% and/or overriding entries.  The list of classes for \texttt{enumerate}
% probably ought to be the list of classes for \texttt{list} augmented
% at the front with the class \texttt{enumerate}.
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3ldb} implementation (FMi version)}
%
% \textbf{WARNING:} This is a more or less straight adaption of code
% written about 20 years ago. Yes there was some version of expl3 back
% then but it looked sufficiently different so that it was hard going to
% get this working without rewriting it from scratch.  Consequently a
% lot of the documentation is wrong or strange as back then we
% experimented with several versions and traces of this can be found in
% the code still, \emph{e.g.}, in form of references to commands and
% variables that no longer exist in the code.
%
% \textbf{All of that needs to be rewritten!} These days \texttt{expl3}
% has much better data and control structures, so that a lot of the
% manual code could be streamlined (and some of the speed optimizations
% that make the code very difficult to read and understand aren't that
% important which much faster processors.  \textbf{:WARNING END}
%
% \subsection{Package start}
%
% Set up certain defaults including to ignore white space within the
% body of this package.
%    \begin{macrocode}
%<*package>
\RequirePackage{expl3}
\ProvidesExplPackage{l3ldb}{2018-04-30}{}
  {L3 Experimental resource database}
%    \end{macrocode}
%
% Load auxiliary packages.
%    \begin{macrocode}
\RequirePackage{l3precom,l3ldbparse}
%    \end{macrocode}
%
% \subsection{Variables and helpers}
%
%    \begin{macrocode}
\tl_new:N \l_ldb_new_sbml_tl
%    \end{macrocode}
%
% \begin{variable}{\l_ldb_internal_tl, \g_ldb_internal_tl}
%   Scratch variables used for various purposes.
%    \begin{macrocode}
\tl_new:N \l_ldb_internal_tl
\tl_new:N \g_ldb_internal_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\ldb_add_right:nN}
%   Undoc.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_add_right:nN #1#2
  {
%<*trace>
    \trace_ldb_internal:n { \ldb_add_right:nN {#1} #2 }
%</trace>
    \quark_if_nil:nF {#1}
      {
        \cs_set:Npn \ldb_tmp:w ##1 #1 ##2 \ldb_tmp:w
          {
%<*trace>
            \trace_ldb_internal:e
              {
                ... will~
                \tl_if_empty:nTF {##2} { add~ } { move~ } \token_to_str:N#1~
                to~the~right~of~\token_to_str:N#2~containing
                \iow_newline: \iow_newline:
                <<\tl_to_str:N#2>>
                \iow_newline:
              }
%</trace>
            \tl_if_empty:nTF {##2}
              { \tl_set:Nn #2 { ##1 #1 } }
              { \tl_set:Nn #2 { ##1 ##2 } }
          }
        \exp_after:wN \ldb_tmp:w #2 #1 \ldb_tmp:w
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection {Entering new entries}
%
% \begin{macro}{\LDBenter}
%    This fixes a bug.
%    \begin{macrocode}
\cs_new_protected:Npn \LDBenter
  {
    \group_begin:
      \ExplSyntaxOn
      \exp_after:wN
    \group_end:
    \ldb_enter:nnn
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\LDBupdateBegin, \LDBupdateEnd}
%   FMi for testing without env integration.
%   This is not the way this should work!
%    \begin{macrocode}
\cs_new_protected:Npn \LDBupdateBegin #1 { \ldb_update_begin:n { #1 } }
\cs_new_protected:Npn \LDBupdateEnd   #1 { \ldb_update_end:n { #1 } }
\cs_new_protected:Npn \LDBdeclDefParm #1 { \ldb_decl_defparm:N #1 }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Building the database}
%
% \begin{variable}{\g_ldb_begin_root_prop, \g_ldb_end_root_prop}
%    We allocate property lists for the two roots of the database tree.
%    \begin{macrocode}
\prop_new:N \g_ldb_begin_root_prop
\prop_new:N \g_ldb_end_root_prop
%<precompile>\cs_record_name:N \g_ldb_begin_root_prop
%<precompile>\cs_record_name:N \g_ldb_end_root_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_ldb_curr_node_tl}
% \begin{variable}{\l_trace_tl}
%    The allocation of two token lists which will contain the current
%    node in the tree and some tracing information.
%    \begin{macrocode}
\tl_new:N \l_ldb_curr_node_tl
\tl_new:N \l_trace_tl
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{macro}{\ldb_enter:nnn}
%   This enters information in the database.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_enter:nnn #1#2#3
  {
    \ldb_parse:n {#1}
%<trace>    \trace_ldb_internal:e { { lex:~ \tl_to_str:N \g_ldb_triples_tl } }
%    \end{macrocode}
%   Depending on the type of parameter we do different things: a
%   register gets updated using direct assignments internally, a
%   \enquote{tl} type of parameter is updated using \cs{tl_set:Nn} and
%   in case \enquote{functions} that should somehow manipulate the data
%   we use yet another mechanism.
%    \begin{macrocode}
    \seq_if_in:NnTF \l_ldb_def_parm_seq #2
      { \tl_set:Nn \l_ldb_parm_tl { \show_def_update:Nnn } }
      {
        \seq_if_in:NnTF \l_ldb_function_seq {#2}
          { \tl_set:Nn \l_ldb_parm_tl { \collect_function_update:Nnn } }
          { \tl_set:Nn \l_ldb_parm_tl { \show_register_update:Nnn } }
      }
    \tl_put_right:Nn \l_ldb_parm_tl { #2 {#3} {#1} }
%    \end{macrocode}
%   Now we move down the tree to put the new assignment into the
%   database thereby adding new nodes and pointers if necessary.  This
%   is done by simply calling \cs{g_ldb_triples_tl} which contains a
%   function in front of every triple so that we can safely proceed.
%    \begin{macrocode}
    \exp_after:wN \ldb_decide_root:nn \g_ldb_triples_tl \c__ldb_other_bdg \c__ldb_begin_type
%<trace>    \show_ldb_entry:nnn {#1} {#2} {#3}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_decide_root:nn}
%
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_decide_root:nn #1#2
  {
    \if_meaning:w #1 \c__ldb_sequenced_bdg
      \if_meaning:w #2 \c__ldb_begin_type
        \tl_set:Nn \l_ldb_curr_node_tl { \g_ldb_begin_root_prop }
      \else:
        \tl_set:Nn \l_ldb_curr_node_tl { \g_ldb_end_root_prop }
      \fi:
    \else:
      \ERROR % should not happen I think
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_ldb_parm_tl}
%   The \cs{l_ldb_parm_tl} holds the new assignment that will be added
%   to the data cell of one node in the tree.
%    \begin{macrocode}
\tl_new:N \l_ldb_parm_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\ldb_decl_defparm:N}
% \begin{variable}{\l_ldb_def_parm_seq}
%   At the moment, we have to specify that a parameter belongs to the
%   class of parameters that are set using \cs{cs_set:Npn}.  Of course,
%   this can be found out without human intervention if we keep a proper
%   record of all parameters that are set using \cs{int_new:N},
%   \cs{skip_new:N}, \emph{etc.}, \emph{i.e.}, redefining those macros
%   to save their arguments on some lists which are then examined in
%   \cs{ldb_enter:nnn}.  But for the moment I thought it is easier to
%   specify the \cs{cs_set:Npn} parameters using \cs{ldb_decl_defparm:N}
%   in the document style.\footnote{Bruno: we can examine the
%     \tn{meaning} of the parameter to determine if it is a register, a
%     parameterless macro, or a macro with parameters.}
%   \cs{ldb_decl_defparm:N} will write its argument onto a list (sorry
%   sequence) which is searched for parameter names in
%   \cs{ldb_enter:nnn}.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_decl_defparm:N #1
  { \seq_put_right:Nn \l_ldb_def_parm_seq #1 }
\seq_new:N \l_ldb_def_parm_seq
%<precompile>\cs_record_name:N \l_ldb_def_parm_seq
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \begin{macro}{\ldb_decl_function:N}
% \begin{variable}{\l_ldb_function_seq}
%   Declare an LDB parameter to be of type \enquote{function} which
%   means that it operates on the values rather than simply storing
%   them.
%   \cs{ldb_decl_function:N} will write its argument onto a list (sorry
%   sequence) which is searched for parameter names in \cs{ldb_enter:nnn}.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_decl_function:N #1
  { \seq_put_right:Nn \l_ldb_function_seq {#1} }
\seq_new:N \l_ldb_function_seq
%<precompile>\cs_record_name:N \l_ldb_function_seq
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \begin{macro}{\ldb_triple:nNN}
%   The \cs{ldb_triple:nNN} function is the heart of the database
%   generation.
%
%   In \cs{l_ldb_curr_node_tl} we keep a pointer to the current node of
%   our data structure as we go along.
%
%   The token list pointers \cs{l_ldb_tight_tl}, \cs{l_ldb_loose_tl},
%   \emph{etc.}, will contain pointers to subtrees, \emph{i.e.}, they
%   are one step ahead of \cs{l_ldb_curr_node_tl} (they are also
%   pointers to nodes not nodes!).  The idea is to
%   \begin{itemize}
%   \item look for the class in \cs{l_ldb_curr_node_tl}.  If it isn't
%     there so far it will be created in the following process.
%   \item Then take a look at the second arg. If we have exhausted the
%     sequence of classes and bindings (\emph{i.e.}, if the second arg
%     is \cs{q_stop}) we update the \cs{l_ldb_assign_tl} write
%     everything back into the \cs{l_ldb_curr_node_tl} and terminate.
%   \item Otherwise the second argument is a binding and go down one
%     level by changing \cs{l_ldb_curr_plist} to contain the
%     corresponding plist. However, we first have to allocate a new
%     symbol for this node in case it is still pointing to \cs{q_nil}.
%   \end{itemize}
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_triple:nNN #1#2#3
  {
%<trace>    \trace_ldb_internal:n { \ldb_triple:nNN {#1} {#2} {#3} }
    \exp_after:wN \ldb_lookup:Nn \l_ldb_curr_node_tl {#1}
%    \end{macrocode}
%   Otherwise we check that the pointer to binding or sequencing is
%   already there; if not we generate it. We then save its name in
%   \cs{l_ldb_internal_tl} for later update of \cs{l_ldb_curr_node_tl}.
%    \begin{macrocode}
    \if_case:w #2
      \if_case:w #3 % begin
        \if_meaning:w \l_ldb_sb_tl \q_nil
          \cs_ggen_prop:N \l_ldb_sb_tl
        \fi:
        \tl_set_eq:NN \l_ldb_internal_tl \l_ldb_sb_tl
      \or: % end
        \if_meaning:w \l_ldb_se_tl \q_nil
          \cs_ggen_prop:N \l_ldb_se_tl
        \fi:
        \tl_set_eq:NN \l_ldb_internal_tl \l_ldb_se_tl
      \or: % complete
        \if_meaning:w \l_ldb_sc_tl \q_nil
          \cs_ggen_prop:N \l_ldb_sc_tl
        \fi:
        \tl_set_eq:NN \l_ldb_internal_tl \l_ldb_sc_tl
      \fi:
    \or: % tight binding
      \if_case:w #3 % begin
        \if_meaning:w \l_ldb_tb_tl \q_nil
          \cs_ggen_prop:N \l_ldb_tb_tl
        \fi:
        \tl_set_eq:NN \l_ldb_internal_tl \l_ldb_tb_tl
      \or: % end
        \msg_expandable_error:nn { ldb } { impossible }
      \or: % complete
        \if_meaning:w \l_ldb_tc_tl \q_nil
          \cs_ggen_prop:N \l_ldb_tc_tl
        \fi:
        \tl_set_eq:NN \l_ldb_internal_tl \l_ldb_tc_tl
      \fi:
    \or: % loose binding
      \if_case:w #3 % begin
        \if_meaning:w \l_ldb_lb_tl \q_nil
          \cs_ggen_prop:N \l_ldb_lb_tl
        \fi:
        \tl_set_eq:NN \l_ldb_internal_tl \l_ldb_lb_tl
      \or: % end
        \if_meaning:w \l_ldb_le_tl \q_nil
          \cs_ggen_prop:N \l_ldb_le_tl
        \fi:
        \tl_set_eq:NN \l_ldb_internal_tl \l_ldb_le_tl
      \or: % complete
        \if_meaning:w \l_ldb_lc_tl \q_nil
          \cs_ggen_prop:N \l_ldb_lc_tl
        \fi:
        \tl_set_eq:NN \l_ldb_internal_tl \l_ldb_lc_tl
      \fi:
    \or: % parsing finished we now update assignments
%<trace>      \trace_ldb_internal:e { qstop~found:~update~parm }
      \if_meaning:w \l_ldb_assign_tl \q_nil
%FMi this one really holds tokens not a pointer (which is a prop)
        \cs_ggen_sym:N \l_ldb_assign_tl
      \fi:
      \exp_after:wN \tl_gput_right:No \l_ldb_assign_tl \l_ldb_parm_tl
    \fi:
%    \end{macrocode}
%   Put the node back (in case one have changed from \cs{q_nil} to a
%   symbol or the node wasn't present at all before).
%    \begin{macrocode}
    \ldb_put_class:n {#1}
%    \end{macrocode}
%   Move down the tree. The use of \cs{tl_set_eq:NN} results in
%    \begin{macrocode}
    \tl_set_eq:NN \l_ldb_curr_node_tl \l_ldb_internal_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_lookup:Nn}
%   The \cs{ldb_lookup:Nn} function gets a pointer to a class list, a
%   class, and will return the subtree pointers in the token list
%   pointers \cs{l_ldb_loose_tl}, \cs{l_ldb_tight_tl}, \emph{etc.}  If
%   the class isn't present in |#1|, then \cs{q_nil} will be written
%   into all token list pointers.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_lookup:Nn #1#2
  {
    \prop_get:NnNTF #1 {#2} \l_ldb_internal_tl
      {
        \exp_after:wN \ldb_get_pointers:w \l_ldb_internal_tl
          \q_nil \q_nil \q_nil \q_nil \q_nil \q_nil \q_nil \q_nil \q_stop
      }
      {
        \tl_set_eq:NN \l_ldb_sb_tl \q_nil
        \tl_set_eq:NN \l_ldb_se_tl \q_nil
        \tl_set_eq:NN \l_ldb_sc_tl \q_nil
        \tl_set_eq:NN \l_ldb_tb_tl \q_nil
        \tl_set_eq:NN \l_ldb_tc_tl \q_nil
        \tl_set_eq:NN \l_ldb_lb_tl \q_nil
        \tl_set_eq:NN \l_ldb_le_tl \q_nil
        \tl_set_eq:NN \l_ldb_lc_tl \q_nil
        \tl_set_eq:NN \l_ldb_assign_tl \q_nil
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_get_pointers:w}
%    Routine that separates the pointers.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_get_pointers:w #1#2#3#4#5#6#7#8#9
  {
    \tl_set:Nn \l_ldb_assign_tl {#1}
    \tl_set:Nn \l_ldb_lb_tl {#2}
    \tl_set:Nn \l_ldb_sb_tl {#3}
    \tl_set:Nn \l_ldb_tb_tl {#4}
    \tl_set:Nn \l_ldb_se_tl {#5}
    \tl_set:Nn \l_ldb_le_tl {#6}
    \tl_set:Nn \l_ldb_tc_tl {#7}
    \tl_set:Nn \l_ldb_lc_tl {#8}
    \tl_set:Nn \l_ldb_sc_tl {#9}
    \ldb_gobble:w
  }
\cs_new_eq:NN \ldb_gobble:w \use_none_delimit_by_q_stop:w
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_put_class:n}
%   Routine that writes a node back into the database using reverse
%   order.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_put_class:n #1
  {
    \tl_clear:N \l_tmpb_tl
    \ldb_put_class_aux:N \l_ldb_sc_tl
    \ldb_put_class_aux:N \l_ldb_lc_tl
    \ldb_put_class_aux:N \l_ldb_tc_tl
    \ldb_put_class_aux:N \l_ldb_le_tl
    \ldb_put_class_aux:N \l_ldb_se_tl
    \ldb_put_class_aux:N \l_ldb_tb_tl
    \ldb_put_class_aux:N \l_ldb_sb_tl
    \ldb_put_class_aux:N \l_ldb_lb_tl
    \ldb_put_class_aux:N \l_ldb_assign_tl
    \exp_after:wN \prop_gput:Nno \l_ldb_curr_node_tl {#1} \l_tmpb_tl
  }
\cs_new_protected:Npn \ldb_put_class_aux:N #1
  {
    \if_meaning:w #1 \q_nil
      \if_meaning:w \l_tmpb_tl \c_empty_tl
      \else:
        \tl_put_left:Nn \l_tmpb_tl \q_nil
      \fi:
    \else:
      \tl_put_left:No \l_tmpb_tl #1
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}
%   {
%     \l_ldb_sb_tl, \l_ldb_se_tl, \l_ldb_sc_tl,
%     \l_ldb_tb_tl,               \l_ldb_tc_tl,
%     \l_ldb_lb_tl, \l_ldb_le_tl, \l_ldb_lc_tl,
%     \l_ldb_assign_tl
%   }
%   We define the pointers from above.
%    \begin{macrocode}
\tl_new:N \l_ldb_sb_tl
\tl_new:N \l_ldb_se_tl
\tl_new:N \l_ldb_sc_tl
\tl_new:N \l_ldb_tb_tl
\tl_new:N \l_ldb_tc_tl
\tl_new:N \l_ldb_lb_tl
\tl_new:N \l_ldb_le_tl
\tl_new:N \l_ldb_lc_tl
\tl_new:N \l_ldb_assign_tl
%    \end{macrocode}
% \end{variable}
%
% \subsection{Updating parameters}
%
% \begin{macro}{\ldb_update_begin:n}
%   Routine called to update parameters at the \enquote{begin} of some
%   structure.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_update_begin:n #1
  {
%<*trace>
    \tl_set:Ne \l_ldb_internal_tl { \if_mode_vertical: (sequenced) ~ \fi: }
    \trace_ldb:e { }
    \trace_ldb:e
      {
        Begin~Processing~*****~#1~*****~ \l_ldb_internal_tl
        \msg_line_context:
      }
%</trace>
    \if_mode_vertical:
    \else:
      \tl_gclear:N \g_ldb_sbml_tl
      \tl_gclear:N \g_ldb_seml_tl
      \tl_gclear:N \g_ldb_next_scml_tl
    \fi:
%
    \tl_set_eq:NN \l_ldb_scml_tl \g_ldb_next_scml_tl
%     \tl_gclear:N \g_ldb_next_scml_tl
    \tl_clear:N \l_ldb_new_scml_tl
%
    \tl_set_eq:NN \l_ldb_lcml_tl \g_ldb_next_lcml_tl
    \tl_set_eq:NN \l_ldb_new_lcml_tl \g_ldb_next_lcml_tl
%
    \tl_set_eq:NN \l_ldb_tcml_tl \g_ldb_next_tcml_tl
    \tl_set_eq:NN \l_ldb_new_tcml_tl \g_ldb_next_tcml_tl
%
    \tl_set_eq:NN \l_ldb_new_leml_tl \l_ldb_leml_tl
    \tl_set_eq:NN \l_ldb_new_lbml_tl \l_ldb_lbml_tl
    \tl_clear:N \l_ldb_new_tbml_tl
    \tl_clear:N \l_ldb_new_sbml_tl
%    \end{macrocode}
%   We while process the new class(es) we assign new parameter values
%   while we go along. However for \enquote{functions} that manipulate
%   their values rather than storing it we wait with that until we are
%   completely done.  So initially we just add them to a tl.  We start
%   with making this tl empty. Then we process the new classes in turn
%   one by one.  \cs{ldb_update_begin_aux:n} processes a single class
%   and is mapped over the clist.  Then execute the collected function
%   updates:
%    \begin{macrocode}
    \tl_gclear:N \g_ldb_collected_function_updates_tl
    \clist_map_function:nN {#1} \ldb_update_begin_aux:n
    \g_ldb_collected_function_updates_tl
%    \end{macrocode}
%    Finally we set the new match candidates.
%    \begin{macrocode}
    \ldb_show_new_mls:
    \tl_set_eq:NN \l_ldb_lbml_tl \l_ldb_new_lbml_tl
    \tl_set_eq:NN \l_ldb_tbml_tl \l_ldb_new_tbml_tl
    \tl_set_eq:NN \l_ldb_leml_tl \l_ldb_new_leml_tl
    \tl_gset_eq:NN \g_ldb_sbml_tl \l_ldb_new_sbml_tl
    \tl_gset_eq:NN \g_ldb_next_scml_tl \l_ldb_new_scml_tl
    \tl_gset_eq:NN \g_ldb_next_lcml_tl \l_ldb_new_lcml_tl
    \tl_gset_eq:NN \g_ldb_next_tcml_tl \l_ldb_new_tcml_tl
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: move
% \begin{macro}{\ldb_do_new_ml:NNn}
%    \begin{macrocode}
\tl_new:N \l_ldb_class_tl
\cs_new_protected:Npn \ldb_do_new_ml:NNn #1#2#3
  {
%<speed>    \if_meaning:w \c_empty_tl #1 \else:
%<*trace>
    \tl_set:Nn \l_trace_tl { #3 ML }
    \trace_ldb_internal:e
      {
        Updating~parms~with~class~`\tl_to_str:N \l_ldb_class_tl'~
        using~#3~list:~`\tl_to_str:N #1'
      }
%</trace>
    \tl_map_function:NN #1 #2
%<speed>    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_update_begin_aux:n}
%   A helper function to \cs{ldb_update_begin:n}.
%   Otherwise we first try to match the class in |#1| looking at the
%   loose candidates.  Then look at the tight candidates.  The next step
%   is to look into begin-sequencing.  Now the begin-begin match list.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_update_begin_aux:n #1
  {
%<trace>    \trace_ldb_internal:n { \ldb_update_begin_aux:n {#1} }
    \tl_set:Nn \l_ldb_class_tl {#1}
    \ldb_do_new_ml:NNn \l_ldb_lbml_tl \ldb_update_single:N {LB}
    \ldb_do_new_ml:NNn \l_ldb_tbml_tl \ldb_update_single:N {TB}
    \ldb_do_new_ml:NNn \g_ldb_sbml_tl \ldb_update_single:N {SB}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_update_single:N}
%   Undoc
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_update_single:N #1
  {
%<trace>    \trace_ldb_internal:n { \ldb_update_single:N #1 }
    \ldb_update_single_aux:NN \ldb_update_bmls:w #1
  }
\cs_new_protected:Npn \ldb_update_single_aux:NN #1#2
  {
%<*trace>
    \trace_ldb_internal:e
      {
        ..~looking~for~\tl_to_str:N \l_ldb_class_tl \c_space_tl
        in~\l_trace_tl\space\token_to_str:N#2~containing
        \iow_newline: \iow_newline:
        <<\tl_to_str:N#2>>
        \iow_newline:
      }
%</trace>
    \prop_get:NoNTF #2 \l_ldb_class_tl \l_ldb_internal_tl
      {
%<trace>      \trace_ldb_internal:e {...~found~\tl_to_str:N \l_ldb_internal_tl}
        \exp_after:wN #1 \l_ldb_internal_tl
          \q_nil \q_nil \q_nil \q_nil \q_nil \q_nil \q_nil \q_nil \q_stop
      }
      {
%<trace>      \trace_ldb_internal:e {...~no~match~found}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_update_end_single:N}
%   Undoc
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_update_end_single:N
  { \ldb_update_single_aux:NN \ldb_update_emls:w }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_update_bmls:w}
%   Routine that separates the pointers.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_update_bmls:w #1#2#3#4#5#6#7#8#9
  {
%<trace>    \trace_ldb_internal:n { \ldb_update_bmls:w }
    \if_meaning:w #1 \q_nil \else:
%<*trace>
      \trace_ldb_internal:n { ...~execute~#1 }
      \ldb_show_pointer:N #1
%</trace>
      #1 % execute values
    \fi:
    \ldb_add_right:nN #2 \l_ldb_new_lbml_tl
    \ldb_add_right:nN #3 \l_ldb_new_sbml_tl
    \ldb_add_right:nN #4 \l_ldb_new_tbml_tl
%    \end{macrocode}
%   We shouldn't find \texttt{se} matches with a begin tag since there
%   must be a |*| between the first and the second part of a spec.
%    \begin{macrocode}
    \ldb_check_nil:nN {se} #5
    \ldb_add_right:nN #6 \l_ldb_new_leml_tl
%     \ldb_check_nil:nN {tc} #7
    \ldb_add_right:nN #7 \l_ldb_new_tcml_tl
    \ldb_add_right:nN #8 \l_ldb_new_lcml_tl
    \ldb_add_right:nN #9 \l_ldb_new_scml_tl
    \use_none_delimit_by_q_stop:w
  }
\cs_new_protected:Npn \ldb_check_nil:nN #1#2
  {
    \if_meaning:w \q_nil #2
    \else:
      \msg_expandable_error:nnfff { ldb } { not-nil }
        { \tl_to_str:n {#1} } { \token_to_str:N #2 } { \tl_to_str:N #2 }
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_update_end:n}
%    Similar beast for the \enquote{end}.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_update_end:n #1
  {
%<*trace>
    \tl_set:Ne \l_ldb_internal_tl { \if_mode_vertical: (sequenced)~ \fi: }
    \trace_ldb:e { }
    \trace_ldb:e
      {
        End~Processing~*****~#1~*****~\l_ldb_internal_tl
        \msg_line_context:
      }
%</trace>
    \if_mode_vertical:
    \else:
      \tl_gclear:N \g_ldb_sbml_tl
      \tl_gclear:N \g_ldb_seml_tl
      \tl_clear:N  \l_ldb_scml_tl
    \fi:
    \ldb_show_mls:
%    \end{macrocode}
%   In the end tag matches in the current sbml list are no longer
%   valid so we clear them. As a result only new matches involving
%   this end tag are assigned to |\g_ldb_sbml_tl| below.
%    \begin{macrocode}
    \tl_clear:N \l_ldb_new_sbml_tl
%    \end{macrocode}
%   We also initialize \cs{l_ldb_new_seml_tl} to hold the new
%   \texttt{se} matches with the current end tag.
%    \begin{macrocode}
    \tl_clear:N \l_ldb_new_seml_tl
%    \end{macrocode}
%   New sc are possible so we clear the \cs{l_ldb_new_scml_tl}.
%    \begin{macrocode}
    \tl_clear:N \l_ldb_new_scml_tl
%    \end{macrocode}
%
%    \begin{macrocode}
    \tl_set_eq:NN \l_ldb_new_lcml_tl \l_ldb_lcml_tl
%    \end{macrocode}
%
%    \begin{macrocode}
    \tl_clear:N \l_ldb_new_tcml_tl
%    \end{macrocode}
%   \cs{ldb_update_end_aux:n} processes a single class and is mapped
%   over the clist.  Then execute the collected function updates:
%    \begin{macrocode}
    \tl_gclear:N \g_ldb_collected_function_updates_tl
    \clist_map_function:nN {#1} \ldb_update_end_aux:n
    \g_ldb_collected_function_updates_tl
%    \end{macrocode}
%   Finally we set the new match candidates.
%    \begin{macrocode}
    \ldb_show_new_mls:
    \tl_gset_eq:NN \g_ldb_sbml_tl \l_ldb_new_sbml_tl
    \tl_gset_eq:NN \g_ldb_seml_tl \l_ldb_new_seml_tl
%
    \tl_gset_eq:NN \g_ldb_next_scml_tl \l_ldb_new_scml_tl
    \tl_gset_eq:NN \g_ldb_next_lcml_tl \l_ldb_new_lcml_tl
    \tl_gset_eq:NN \g_ldb_next_tcml_tl \l_ldb_new_tcml_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_update_end_aux:n}
%   Undoc
%   We first try to match the class in |#1| in the LE match list.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_update_end_aux:n #1
  {
%<trace>    \trace_ldb_internal:n { \ldb_update_end_aux:n {#1} }
    \tl_set:Nn \l_ldb_class_tl {#1}
    \ldb_do_new_ml:NNn \l_ldb_leml_tl \ldb_update_end_single:N {LE}
    \ldb_do_new_ml:NNn \g_ldb_seml_tl \ldb_update_end_single:N {SE}
    \ldb_do_new_ml:NNn \l_ldb_lcml_tl \ldb_update_end_single:N {LC}
    \ldb_do_new_ml:NNn \l_ldb_tcml_tl \ldb_update_end_single:N {TC}
    \ldb_do_new_ml:NNn \l_ldb_scml_tl \ldb_update_end_single:N {SC}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_update_emls:w}
%   Routine that separates the pointers.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_update_emls:w #1#2#3#4#5#6#7#8#9
  {
    \if_meaning:w #1 \q_nil \else:
%<*trace>
      \trace_ldb:e {...~execute~\token_to_str:N #1}
      \ldb_show_pointer:N #1
%</trace>
      #1 % execute values
    \fi:
%    \end{macrocode}
%   Some of the pointers have to be \cs{q_nil} according to our
%   restrictions so we could make everything faster and more compact by
%   providing different data structures both types.
%    \begin{macrocode}
    \ldb_check_nil:nN {lb} #2
    \ldb_add_right:nN #3 \l_ldb_new_sbml_tl
    \ldb_check_nil:nN {tb} #4
    \ldb_add_right:nN #5 \l_ldb_new_seml_tl
    \ldb_check_nil:nN {le} #6
    \ldb_check_nil:nN {tc} #7
    \ldb_check_nil:nN {lc} #8
    \ldb_add_right:nN #9 \l_ldb_new_scml_tl
    \use_none_delimit_by_q_stop:w
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\ldb_set_classes:nn}
%   Undoc
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_set_classes:nn #1#2
  {
    \tl_clear_new:c {l_ldb_cl_#1}
    \clist_map_inline:nn {#2}
      { \tl_put_right:cc { l_ldb_cl_#1 } { env_begin_code_ ##1 : } }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\ldb_new_context:n}
%   The \cs{ldb_new_context:n} command will flush the current rdb
%   history and will start fresh with classes given in the argument.
%    \begin{macrocode}
% \cs_new_protected:Npn \ldb_new_context:n
%   {
%     \tl_set_eq:NN \l_ldb_lbml_tl \g_ldb_begin_root_prop
%     \tl_clear:N \l_ldb_tbml_tl
%     \tl_gclear:N \g_ldb_sbml_tl
%     \ldb_update_begin:n
%   }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_ldb_lbml_tl, \l_ldb_leml_tl, \l_ldb_tbml_tl}
%   Tight and loose match lists are local, they get restored by the
%   grouping mechanism. The initial value for the loose match list is
%   the pointer to the root.
%    \begin{macrocode}
\tl_new:N \l_ldb_lbml_tl
\tl_new:N \l_ldb_leml_tl
\tl_new:N \l_ldb_tbml_tl
\tl_set:Nn \l_ldb_lbml_tl {\g_ldb_begin_root_prop}
\tl_set:Nn \l_ldb_leml_tl {\g_ldb_end_root_prop}
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_ldb_sbml_tl, \g_ldb_seml_tl}
%   \enquote{begin-begin} and \enquote{end-begin} match lists are global
%   since their contents is needed between environments. The restoring
%   for them is therefore done explicitly.  grouping mechanism.
%    \begin{macrocode}
\tl_new:N \g_ldb_sbml_tl
\tl_new:N \g_ldb_seml_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {\g_ldb_next_scml_tl, \g_ldb_next_lcml_tl, \g_ldb_next_tcml_tl}
%    More match lists.
%    \begin{macrocode}
\tl_new:N \g_ldb_next_scml_tl
\tl_new:N \g_ldb_next_lcml_tl
\tl_new:N \g_ldb_next_tcml_tl
%    \end{macrocode}
% \end{variable}
%
%
% \begin{variable}
%   {
%     \l_ldb_new_lbml_tl, \l_ldb_new_leml_tl, \l_ldb_new_lcml_tl,
%     \l_ldb_new_tbml_tl,                   , \l_ldb_new_tcml_tl,
%                         \l_ldb_new_seml_tl, \l_ldb_new_scml_tl,
%   }
%   Undoc
%    \begin{macrocode}
\tl_new:N \l_ldb_new_lbml_tl
\tl_new:N \l_ldb_new_leml_tl
\tl_new:N \l_ldb_new_lcml_tl
\tl_new:N \l_ldb_new_tbml_tl
\tl_new:N \l_ldb_new_tcml_tl
\tl_new:N \l_ldb_new_seml_tl
\tl_new:N \l_ldb_new_scml_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_ldb_scml_tl, \l_ldb_lcml_tl, \l_ldb_tcml_tl}
%   undoc
%    \begin{macrocode}
\tl_new:N \l_ldb_scml_tl
\tl_new:N \l_ldb_lcml_tl
\tl_new:N \l_ldb_tcml_tl
%    \end{macrocode}
% \end{variable}
%
% \subsection{Tracing the database operations}
%
% The code in this section is included only if we are tracing the
% mechanism. To keep the other code compact most tracing stuff is packed
% in separate macros.
%
%    \begin{macrocode}
%<*trace>
%    \end{macrocode}
%
% \begin{macro}{\trace_ldb:e, \trace_ldb_internal:e}
% \begin{variable}{\g_trace_ldb_status}
%   \cs{trace_ldb_internal:e} shows some internal infos if requested.
%    \begin{macrocode}
\cs_new_protected:Npn \trace_ldb:e #1
  {
    \if_int_compare:w \g_trace_ldb_status > \c_zero_int
      \iow_term:e { LDB:~ #1 }
    \fi:
  }
\cs_new_protected:Npn \trace_ldb_internal:e #1
  {
    \if_int_compare:w \g_trace_ldb_status > \c_one_int
      \iow_term:e { LDB:~ #1 }
    \fi:
  }
\cs_new_protected:Npn \trace_ldb_internal:n #1
  { \trace_ldb_internal:e { \exp_not:n {#1} } }
\int_new:N \g_trace_ldb_status
%    \end{macrocode}
%   Default is to show a bit.
%    \begin{macrocode}
\int_gincr:N \g_trace_ldb_status
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \begin{macro}{\show_ldb_entry:nnn}
%   \cs{show_ldb_entry:nnn} will take the arguments of
%   \cs{ldb_enter:nnn} and displays them on the terminal.
%    \begin{macrocode}
\cs_new_protected:Npn \show_ldb_entry:nnn #1#2#3
  {
    \tl_gset:Nn \g_ldb_internal_tl {#3}
    \trace_ldb:e
      {
        Set~\token_to_str:N#2~
        with~value~\tl_to_str:N \g_ldb_internal_tl \space in~#1
      }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</trace>
%    \end{macrocode}
%
% \begin{macro}{\show_def_update:Nn}
%   \cs{show_def_update:Nn} will show the update of a parameter via
%   \cs{cs_set:Npn} by displaying first the old then the new value. To
%   keep the number of tokens produced in precompiling low, the actual
%   assignment is also carried out in this macro.
%    \begin{macrocode}
\cs_new_protected:Npn \show_def_update:Nnn #1#2#3
  {
%<*trace>
    \tl_gset:Nn \g_ldb_internal_tl {#2}
    \trace_ldb:e { .....~ Change~ \token_to_str:N#1~because~ of~ `#3':}
    \trace_ldb:e
      { ..........~\exp_not:o {#1}~->~ \tl_to_str:N \g_ldb_internal_tl }
%</trace>
    \cs_set:Npn #1 {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\collect_function_update:Nn}
%   A \enquote{function} parameter is not directly executed but only
%   after we are done with all real assignments. The reason is that
%   otherwise we get in conflict with assigning the instance name via
%   \texttt{<env} but try to do parameter manipulation for this instance
%   (that need this name) via something like \texttt{<class} which is
%   less specific and comes therefore first.\footnote{this is not clean
%     and needs further thought!}
%    \begin{macrocode}
\cs_new_protected:Npn \collect_function_update:Nnn #1#2#3
  {
    \tl_gput_right:Nn \g_ldb_collected_function_updates_tl
      { \show_function_update:Nnn #1 {#2}{#3} }
  }
\tl_new:N \g_ldb_collected_function_updates_tl
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\show_function_update:Nn}
%   \cs{show_function_update:Nn} will show the update due to a function
%   call.
%    \begin{macrocode}
\cs_new_protected:Npn \show_function_update:Nnn #1#2#3
  {
%<*trace>
    \trace_ldb:e { .....~ Execute~ function~ because~ of~ `#3':}
    \trace_ldb:e { ......=>..~\exp_not:n{#1}~ \exp_not:n{ {#2} } }
%</trace>
    #1 {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\show_register_update:Nn}
%   Same game for normal parameters (counts, skips, \emph{etc.}).
%    \begin{macrocode}
\cs_new_protected:Npn \show_register_update:Nnn #1#2#3
  {
%<*trace>
    \tl_gset:Nn \g_ldb_internal_tl {#2}
    \trace_ldb:e { .....~ Change~ \token_to_str:N#1 ~ because~ of~ `#3': }
    \trace_ldb:e
      { ..........~ \tex_the:D#1~ ->~ \tl_to_str:N \g_ldb_internal_tl }
%</trace>
    #1 #2 \scan_stop:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_show_pointer:N}
%    Show the contents of what a pointer is pointing to.
%^^A todo: move that within <*trace> </trace> ?
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_show_pointer:N #1
  {
    \trace_ldb:e
      {
        Value~ of~\token_to_str:N#1~containing\iow_newline:
        <<\tl_to_str:N#1>>
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_show_mls:}
%    Show the matching lists.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_show_mls:
  {
    \ldb_show_pointer:N \l_ldb_lcml_tl
    \ldb_show_pointer:N \l_ldb_tcml_tl
    \ldb_show_pointer:N \l_ldb_scml_tl
    \ldb_show_pointer:N \l_ldb_leml_tl
    \ldb_show_pointer:N \l_ldb_lbml_tl
    \ldb_show_pointer:N \l_ldb_tbml_tl
    \ldb_show_pointer:N \g_ldb_sbml_tl
    \ldb_show_pointer:N \g_ldb_seml_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ldb_show_new_mls:}
%    Show the new matching lists.
%    \begin{macrocode}
\cs_new_protected:Npn \ldb_show_new_mls:
  {
    \ldb_show_pointer:N \l_ldb_new_lcml_tl
    \ldb_show_pointer:N \l_ldb_new_tcml_tl
    \ldb_show_pointer:N \l_ldb_new_scml_tl
    \ldb_show_pointer:N \l_ldb_new_leml_tl
    \ldb_show_pointer:N \l_ldb_new_lbml_tl
    \ldb_show_pointer:N \l_ldb_new_tbml_tl
    \ldb_show_pointer:N \l_ldb_new_sbml_tl
    \ldb_show_pointer:N \l_ldb_new_seml_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\nopointer}
%    A function to switch off the showing of pointers.
%    \begin{macrocode}
\cs_new_protected:Npn \nopointer
  { \cs_set_eq:NN \ldb_show_pointer:N \use_none:n }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Tracing modules}
%
% \begin{macro}{\traceon,\traceoff}
%   Turning the tracing of modules on or off. (primitive version).
%    \begin{macrocode}
%<*trace>
\cs_new_protected:Npn \traceon #1
  {
    \clist_map_inline:nn{#1}
      {
        \cs_if_exist:cT {g_trace_ ##1 _status}
          { \int_gincr:c {g_trace_ ##1 _status} }
      }
  }
\cs_new_protected:Npn \traceoff #1
  {
    \clist_map_inline:nn {#1}
      {
        \cs_if_exist:cT {g_trace_ ##1 _status}
          { \int_gdecr:c {g_trace_ ##1 _status} }
      }
  }
%</trace>
%<-trace>\cs_new_eq:NN \traceon \use_none:n
%<-trace>\cs_new_eq:NN \traceoff \use_none:n
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\msg_new:nnn { ldb } { impossible } { Not~possible }
\msg_new:nnn { ldb } { not-nil } { Not~ nil~ #1:~ #2~containing:~#3 }
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \endinput
%
%
% \subsection{Functions}
%
% \begin{function}{\ldb_enter:nnn}
%   \begin{syntax}
%     "\ldb_enter:nnn" "{"<class list>"}" "{"<parm>"}" "{"<value>"}"
%   \end{syntax}
%   This function is used to enter values for parameters in a given
%   context. The context is described by <class list> which is a list of
%   class names (character strings) separated by either "." (tight
%   binding), "*" (loose binding), "!" (direct nested \cs{begin}), or
%   \texttt{\string<} (sequence of \cs{end} followed by \cs{begin}. From
%   left to right the classes represent the order of nesting to which
%   the parameter change should apply, that is the left-most class is
%   the one that was entered last (Denys syntax). To the left and the
%   right there is an implicit "*" assumed which means that the
%   parameter change will apply until overwritten by a more specific
%   entry (left star) and also will apply the first time a specified
%   <class list> matches independent of the fact where in the stack of
%   classes this happens.
%
%   <parm> can be either a \TeX{} parameter like a <counter> or a <tlp>,
%   \emph{e.g.} a function with no arguments. This isn't a real
%   restriction since such a token list pointer can of course then hold
%   a function with arbitrary arguments as its <value>.  At the moment
%   <parm>s that are <tlp> have to be declared but this can be avoided
%   later.
%
%   <value> might be any value which is sensible for the corresponding
%   <parm>.
%
%   All assignments done by this function are local so that they restore
%   themselves when a group (\emph{e.g.} an environment) ends.
% \end{function}
%
% \begin{function}{\ldb_decl_defparm:N}
%   \begin{syntax}
%     "\ldb_decl_defparm:N" <parm>
%   \end{syntax}
%   <parm> is declared as a parameter that gets its value assigned via a
%   definition routine of \TeX{}, \emph{i.e.}, is not one of \TeX{}'s
%   internal registers. This is a temporary function since the type of
%   parameter can be determined by \LaTeX3 itself.
% \end{function}
%
% \begin{function}{\ldb_set_classes:nn}
% \end{function}
%
% \subsection{Internal functions}
%
% Not described, probably of no interest to the implementor of higher
% level modules.
%
% \subsection{Variables}
%
% \begin{variable}{\l_ldb_lml_tl}
%   Current loose match list holding possible candidates for loose
%   matches with further nested environments.  When a new environment
%   <env> starts the LDB manager looks for loose matches in this
%   list. If a match is found the corresponding pointers are handled in
%   the following way:
%   \begin{itemize}
%   \item The loose pointer if not nil is added (or moved if already
%     present) to the right in \cs{l_ldb_curr_lml_tl}.
%   \item The tight pointer if not nil is added (or moved if already
%     present) to the right in \cs{l_ldb_curr_tml_tl}.
%   \item The begin-begin pointer if not nil is added (or moved if
%     already present) to the right in \cs{l_ldb_curr_bbml_tl}.
%   \item The end-begin pointer if not nil is added (or moved if already
%     present) to the right in \cs{l_ldb_curr_ebml_tl}.
%   \item The assign-begin pointer if not nil is evaluated resulting in
%     local assignments to a set of parameters.
%   \end{itemize}
%   When the LDB manager has finished looking for matches (which
%   involves also looking for tight, \emph{etc.} matches)
%   \cs{l_ldb_lml_tl} gets assigned the contents of
%   \cs{l_ldb_curr_lml_tl}. This means that the contents of the loose
%   match list will be restored when the environment ends.
% \end{variable}
%
% \begin{variable}{\l_ldb_tml_tl}
%   Current tight match list holding possible candidates for tight
%   matches. When a new environment starts this list is checked after
%   checking the loose match list. Found matches are handled in the same
%   way as above.  When the LDB manager has finished looking for matches
%   \cs{l_ldb_tml_tl} gets assigned the contents of
%   \cs{l_ldb_curr_tml_tl}.  This means that the contents of the tight
%   match list will be restored when the environment ends.
% \end{variable}
%
% \begin{variable}{\g_ldb_bbml_tl}
%   Current begin-begin match list holding possible candidates for
%   begin-begin matches. When a new environment starts this list is
%   checked after checking the tight match list. Found matches are
%   handled in the same way as above.  When the LDB manager has finished
%   looking for matches \cs{g_ldb_bbml_tl} gets globally assigned the
%   contents of \cs{l_ldb_curr_bbml_tl}.  When some environment ends
%   this list is globally cleared.
% \end{variable}
%
% \begin{variable}{\g_ldb_ebml_tl}
%   Current begin-end match list holding possible candidates for
%   begin-end matches. When a new environment starts this list is
%   checked if the begin-begin match list is empty (only one of both can
%   possibly contain candidates). Found matches are handled in the same
%   way as above.  When the LDB manager has finished looking for
%   matches, \cs{g_ldb_ebml_tl} gets globally cleared to avoid spurious
%   matches within this environment. When the end tag of this
%   environment is reached the \cs{g_ldb_ebml_tl} is checked again
%   for match but this time only pointers to begin-end are processed
%   (\emph{i.e.} added or moved to the right in \cs{l_ldb_curr_ebml_tl}
%   (which already holds the matches found at the beginning of the
%   environment)). Then \cs{g_ldb_ebml_tl} is assigned globally the
%   contents of \cs{l_ldb_curr_ebml_tl}. The reason for checking twice
%   is that the matches found at the beginning are those that come from
%   LDB entries like \enquote{\ttfamily env1\string<env2*env3} where
%   \texttt{env2} is actually a full environment (begin and end
%   tag). The check at the end then captures entries like
%   \enquote{\ttfamily env1\string<env2\string<env3} where \texttt{env2}
%   stands for an end tag that is directly preceded by the end tag of
%   \texttt{env3}.
%   \begin{quote}
%     (Deep breath.) You got that? [\TeX{}book p.~125]
%   \end{quote}
% \end{variable}
%
% \begin{variable}{\l_ldb_curr_lml_tl}
%   Temp variable holding found loose matches (candidates for the next
%   environment). Since older loose match candidates are also candidates
%   for further nested environments this variable gets assigned the
%   contents of \cs{l_ldb_lml_tl} when the LDB starts processing a begin
%   tag.
% \end{variable}
%
% \begin{variable}{\l_ldb_curr_tml_tl}
%   Temp variable holding found tight matches (candidates for the next
%   environment). Since older tight match candidates are no longer
%   candidates for further nested environments this variable is cleared
%   when the LDB starts processing a begin tag.
% \end{variable}
%
% \begin{variable}{\l_ldb_curr_bbml_tl}
%   Temp variable holding found begin-begin matches (candidates for the
%   next environment). Since older match candidates are no longer
%   candidates for further nested environments this variable is cleared
%   when the LDB starts processing a begin tag.
% \end{variable}
%
% \begin{variable}{\l_ldb_curr_ebml_tl}
%   Temp variable holding found begin-end matches (candidates for the
%   next environment). Since older match candidates are no longer
%   candidates for further nested environments this variable is cleared
%   when the LDB starts processing a begin tag. The values of this
%   variable is actually used in the end tag where it is further updated
%   (see \cs{g_ldb_ebml_tl}). Then its contents is assigned globally to
%   \cs{g_ldb_ebml_tl} so that it survives the closing group of the end
%   tag.
% \end{variable}
%
% To interrupt sequencing information the begin of a paragraph
% (normally) clears \cs{g_ldb_bbml_tl} the end (normally) clears
% \cs{g_ldb_ebml_tl} and \cs{l_ldb_curr_ebml_tl}.
%
% \subsection{Tracing infos}
%
% The LDB mechanism is traced via \texttt{rdb}.  This time two levels of
% tracing information are provided.
%
% Turning on \texttt{rdb} once will trace:
% \begin{itemize}
% \item LDB lookup for begin and end tags,
% \item the changing of parameter values due to LDB queries.
% \end{itemize}
%
% Turning on \texttt{rdb} twice will additionally trace:
% \begin{itemize}
% \item adding new entries to the LDB data structure,
% \item the internal mechanism of the LDB, \emph{e.g.}, changes of match
%   lists (moving or adding items to a match list), the search for
%   matches, \emph{etc.}
% \end{itemize}
%
% \subsubsection{Functions}
%
% \begin{function}{\trace_ldb:e}
%   \begin{syntax}
%     \cs{trace_ldb:n} \Arg{text}
%   \end{syntax}
% \end{function}
%
% \begin{function}{\trace_ldb_internal:e}
%   \begin{syntax}
%     \cs{trace_ldb_internal:e} \Arg{text}
%   \end{syntax}
% \end{function}
