% \iffalse meta-comment
%
%% File: xmarks.dtx Copyright (C) 2018 Frank Mittelbach, The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "l3trial bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver|package>
\RequirePackage{xparse}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{xmarks2.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{xmarks2} package\\Marks^^A
% }
%
% \author{^^A
%  Frank Mittelbach, \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }

% \date{Released --- not yet}
%
% \maketitle
%
% \begin{documentation}
%
% Marks are used to communicate information about the content of a page
% to the output routine. Perhaps the clearest form of mark is that needed
% for sections. In order to construct running headers, the output routine
% needs information about which section names are present on a page, and this
% information is passed by the mark system. However, marks may also be used
% for other purposes. This module provides a generalised mechanism for marks
% of independent types.
%
% \section{Design-level interface}
%
% \begin{function}{\DeclareMarkType}
%   \begin{syntax}
%     \cs{DeclareMarkType} \Arg{type}
%   \end{syntax}
%   Declares a \meta{type} of mark to be tracked by \LaTeX{}. Each \meta{type}
%   must be declared before it is used.
% \end{function}
%
% \begin{function}{\PutMark}
%   \begin{syntax}
%     \cs{PutMark} \Arg{type} \Arg{entry}
%   \end{syntax}
%   Adds a mark to the current page for the \meta{type}, containing the
%   \meta{entry} text.
% \end{function}
%
% \begin{function}[EXP]{\PreviousMark, \FirstMark, \LastMark}
%   \begin{syntax}
%     \cs{PreviousMark} \oarg{region} \Arg{type}
%     \cs{FirstMark}    \oarg{region} \Arg{type}
%     \cs{LastMark}     \oarg{region} \Arg{type}
%   \end{syntax}
%   These functions expand to the appropriate mark \meta{entry} for
%   the given \meta{type} in the specified \meta{region} by default
%   \texttt{page}. The \enquote{first} and \enquote{last} marks are
%   those seen first and last in the current dregionpage, respectively. The
%   \enquote{previous} mark is the last mark of the \meta{type} seen
%   in an earlier region, i.e. what would be \enquote{current} at the
%   very top of the region.
%
% \end{function}
%
% ^^A footnotes not supported in function!
%
%   Supported regions beside \texttt{page} are \texttt{verso} and
%   \texttt{recto} if you are producing a \enquote{twosided}
%   document. If you are on a recto (odd) page you can then use the
%   \texttt{verso} region to refer to the marks on the opposite
%   page. Note, that right now this doesn't work in the opposite
%   direction: you can't refer to the following recto page if you are
%   on a verso page (you will see the marks only from already handled
%   regions\footnote{This restriction might get lifted eventually.}).
%   The \texttt{page} region always refers to the current page, i.e., it is
%   either the same as using \texttt{recto} or \texttt{verso}
%   depending on where you are. If your document is one-sided then all
%   three regions return the same data.\footnote{Or verso returns the
%   empty string --- to be decided.}
%
%   A similar concept exists for two column documents: \texttt{1col}
%   and \texttt{2col} refers to the left and right column region
%   respectively.
%

%
%
% \section{Code-level interface}
%
% \begin{function}{\marks_new:n}
%   \begin{syntax}
%     \cs{marks_new:n} \Arg{type}
%   \end{syntax}
%   Declares a \meta{type} of mark to be tracked by \LaTeX{}. Each \meta{type}
%   must be declared before it is used.
% \end{function}
%
% \begin{function}{\marks_put:nn}
%   \begin{syntax}
%     \cs{marks_put:nn} \Arg{type} \Arg{entry}
%   \end{syntax}
%   Adds a mark to the current page for the \meta{type}, containing the
%   \meta{entry} text. The \meta{entry} is expanded at the time of use.
% \end{function}
%
%
%
%
% \begin{function}[EXP]
%   {\marks_use_previous:nn, \marks_use_first:nn, \marks_use_last:nn}
%   \begin{syntax}
%     \cs{marks_use_previous:nn} \Arg{region} \Arg{type}
%     \cs{marks_use_first:nn}    \Arg{region} \Arg{type}
%     \cs{marks_use_last:nn}     \Arg{region} \Arg{type}
%   \end{syntax}
%   These functions expand to the appropriate mark \meta{entry} for
%   the given \meta{type} in the specified \meta{region}. The \enquote{first} and
%   \enquote{last} marks are those seen first and last in the region,
%   respectively. The \enquote{previous} mark is the last mark of the
%   \meta{type} seen on earlier regions. These functions should be used only in
%   output routines after \cs{marks_update_structure:nnn} has acted, otherwise their
%   values will be wrong.
% \end{function}
%
% \subsection{Output routine functions}
%
% These functions are tied to the output routine. 
%
% \begin{function}{\marks_update_structure:nnn}
%   \begin{syntax}
%     \cs{marks_update_structure:nnN} \Arg{last} \Arg{current} \Arg{material with marks}
%   \end{syntax}
%   \meta{last} is the region from which to take the last marks to
%   make them new top marks. \meta{current} is the region to update
%   and \meta{material} holds material that contain new marks.  Thus if this
%   material consists of boxes we need to do the unpacking with the
%   argument so that the marks can be seen.
% \end{function}
%
%
%
% \begin{function}{\marks_update_structure_alias:nn}
%   \begin{syntax}
%     \cs{marks_update_structure_alias:nn} \Arg{alias} \Arg{source}
%   \end{syntax}
%   Assigns all marks for the \meta{source} region also to
%   \meta{alias}, e.g., if we finished a a \texttt{verso} page we
%   could make the generic \texttt{page} region hold the same
%   marks. In most cases this is automatically done already by
%   \cs{marks_update_structure:nnN} so this is only needed in a few
%   cases.
% \end{function}
%
%
% \begin{function}{\marks_update_singlecol_structure:n}
%   \begin{syntax}
%     \cs{marks_update_singlecol_structure:n} \Arg{material with marks}
%   \end{syntax}
%   \LaTeXe{} integration function receiving the content of box 255 for
%   mark processing when we are doing single column documents.
% \end{function}
%
%
% \begin{function}{\marks_update_dblcol_structure:nn}
%   \begin{syntax}
%     \cs{marks_update_singlecol_structure:n} \Arg{current column material}
%                                             \Arg{whole page material}
%   \end{syntax}
%   \LaTeXe{} integration function mark processing when we are doing
%   double column documents. The first argument handles the column marks
%   and the second the marks for the complete page and is only
%   relevant if we are doing the second column.
% \end{function}
%
%
%
% \section{Legacy \LaTeXe{} interface}
%
% \subsection{Legacy design-level and document-level interfaces}
%
% \begin{function}{\markboth, \markright}
%   \begin{syntax}
%     \cs{markboth}   \Arg{left} \Arg{right}
%     \cs{markright}  \Arg{right}
%   \end{syntax}
% \LaTeXe{} uses two marks which aren't fully independent. A
%   \enquote{left} mark generated by the first argument of \cs{markboth}
%   and a \enquote{right} mark generated by the second argument of
%   \cs{markboth} or by the only argument of \cs{markright}. The
%   command \cs{markboth} and \cs{markright} are in turn called from
%   heading commands such as \cs{chaptermark} or \cs{sectionmark} and
%   their behavior is controlled by the document class.
%
% For example, in the \cls{article} class with \texttt{twoside} in
%   force the \cs{sectionmark} will issue \cs{markboth} with an empty
%   second argument and \cs{subsectionmark} will issue
%   \cs{markright}. As a result the left mark will contain chapter
%   titles and the right mark subsection titles.
%
% Note, however, that in one-sided documents the standard behavior is
%   that only \cs{markright} is used, i.e., there will only be
%   right-marks but no left marks!
% \end{function}
%
% \begin{function}[EXP]{\leftmark, \rightmark}
%   \begin{syntax}
%     \cs{leftmark}
%     \cs{rightmark}
%   \end{syntax}
%   These functions return the appropriate mark value from the current page
%   and work as before, that is \cs{leftmark} will get the first (!)
%   left mark from the page and \cs{rightmark} the last (!) right
%   mark.
%
%   In other words they work well if you want to show the section
%   title that is current when the page begins (and there is not
%   further section on that page) or the first section that started on
%   this page (if there is one) and also show the subsection title
%   that is current when the page ends. Other combination can't be
%   shown using this interface. 
% \end{function}
%
%
% \subsection{Legacy interface extensions}
%
%   The \pkg{xmarks2} package adds three mark types \texttt{ltxleft},
%   \texttt{ltxright} and \texttt{ltxrightnonempty} and patches
%   \cs{markboth} and \cs{markright} slightly so that they in addition
%   to the above interface also update these mark types.
%
%   The difference between \texttt{ltxright} and
%   \texttt{ltxrightnonempty}  is that the latter will only be updated
%   if the material for the mark is not empty.
%
%   As a result you can use \verb=\FirstMark{ltxleft}= and
%   \verb=\LastMark{{ltxright}= instead of \cs{leftmark} and
%   \cs{rightmark}. But more important you can use any of the other
%   retrival commands to get a different status value from those
%   marks, e.g., \verb=\FirstMark{ltxright}= would return the first
%   subsection on the page (instead of the last) that would be
%   returned by \cs{rightmark}.
%
%   The difference between \texttt{ltxright} and
%   \texttt{ltxrightnonempty}  is that the latter will only be updated
%   if the material for the mark is not empty. Thus
%   \verb=\markboth{title}{}= as issued by, say \cs{sectionmark},
%   will set a \texttt{ltxleft} mark with \texttt{title} and a
%   \texttt{ltxright} mark with the empty string but will not add a
%   \texttt{ltxrightnonempty} mark.
%
%   Thus, if you have a section at the start of a page and you would
%   ask for \verb=\FirstMark{ltxright}= you would get an empty string
%   even if there are subsections on that page. But
%   \texttt{ltxrightnonempty} would then give you the first subsection
%   on that page. Of course, nothing is simple. If there are no
%   subsection it would tell you the last subsection from an earlier
%   page. We therefore need comparison tools, e.g., if previous and
%   first are identical you know that the value is
%   bogus.\footnote{Those tools need still doing!}
%
%
%
% \end{documentation}
%
%
%
%
%
%
%
% \begin{implementation}
%
% \section{\pkg{xmarks2} Implementation}
%
% \subsection{Notes on the mechanism}
%
% \eTeX{} extends the \TeX{} mark system to allow multiple independent
% marks. However, it does not solve a problem which means that \LaTeX{} needs
% to manage marks almost independently of \TeX{}. The reason for this is that
% the complex output routine used by \LaTeX{} to handle floats (and related
% structures) means that \tn{topmark(s)} are not reliable. Each time the
% output routine is fired up, \TeX{} moves \tn{botmark} to \tn{topmark}, and
% while \eTeX{} extends this the fundamental concept remains the same. That
% means that instead the state of marks needs to be tracked by
%   \LaTeX{} itself. An early implementation of this package used
%   \TeX{}'s \tn{botmark} only to ensure the correct interaction with
% the output routine (this was before the \eTeX{} mechanism was even
%   available. However, other than in a prototype implementation for
%   \LaTeX3 this package was never made public.
%
% The new implementation now does use \eTeX{}'s marks as they have
%   some advantages as with them we can leave the mark text within the
%   galley and only extract the marks during the output routine when
%   we are finally shipping out a page or storing away a column for
%   use in the next page. That means we do not have to maintain a
%   global data structure that we have to keep in sync with
%   informational marks in the galley but can rely on everything being
%   in one place and thus manipulations (e.g. reordering of material)
%   will take the marks with them without a need for updating a
%   fragile linkage.

% To allow for completely independent marks we use the following
% procedure:
% \begin{itemize}
%   \item
%     For every mark of type \meta{type} we allocate a mark class so
%   that in the output routine \TeX{} can calculate for each type top,
%   first and bottom mark independently.
%
%   \item As already mentioned firing up an output routine without
%   shipping out a page means that \TeX's top marks get wrong so it is
%   impossible to rely on \TeX's approach directly. What we do instead
%   is to keep  track of the real marks (from last page or
%   more generally last region) in some global variables.
%
%   \item These variables are updated in the ouput routine at defined
%   places, i.e., when we do real output processing but not if we use
%   special output routines to do internal housekeeping.
%
%   \item The trick we use to get correctly updated variables is the
%   following: the material that contains new marks (for example the
%   page to be shipped out) is stored in a box. We then use \TeX{}
%   primitive box splitting functions by splitting off the largest
%   amount possible (which should be the whole box if nothing goes
%   really wrong). While that seems a rather pointless thing to do, it
%   has one important side effect: \TeX{} sets up first and bottom
%   marks for each mark class from the material it has split off. This
%   way we get the first and last marks (if there have been any) from
%   the material in the box.
%
%   \item The top marks are simply the last marks from the previous
%   page or region. And if there hasn't been a first or bottom mark in
%   the box then the new top mark also becomes new first and last mark
%   for that class.
%  \end{itemize}
%  That's about it in a nutshell. Of course, there are some details to
%   be taken care off and those are discussed further below.
%
%
%
% \subsection{Lead-off code}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=marks>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage{xmarks2}{2018-11-20}{}
  {L3 Experimental marks}
%</package>
%    \end{macrocode}
%
%
% \begin{variable}{\g_@@_types_seq}
%   A list of all of the mark types in use.
%    \begin{macrocode}
\seq_new:N \g_@@_types_seq
%    \end{macrocode}
% \end{variable}
%
%
%  \begin{macro}{\g_@@_class_int}
%    We assume that nobody is using extended marks!!!  The alternative
%    is to use \cs{newmarks} from \LaTeXe{} or provide an interface in
%    expl3. One or the other should be dne!
%    \begin{macrocode}
\int_new:N \g_@@_class_int
%    \end{macrocode}
%  \end{macro}
%
%
%    
% \begin{macro}{\marks_new:n}
% \begin{macro}{\@@_new:n}
%    A mark type is created by initialising a number of data
%    structures.  First, we get a number to refer to the mark class.
%    The new mark type is then added to a sequence to be able to
%    easily loop over all types.  finally a number of top-level global
%    token lists are generated that hold various versions of the mark
%    for access.
%    \begin{macrocode}
\cs_new_protected:Npn \marks_new:n #1
{
  \seq_if_in:NnTF \g_@@_types_seq {#1}
      {
        \__kernel_msg_error:nnn { marks } { type-already-defined }
          {#1}
      }
      { \@@_new:n {#1} }
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new_protected:Npn \@@_new:n #1
{
%<*trace>
  \@@_trace:n { new~mark:~ #1 }
%</trace>
  \int_gincr:N \g_@@_class_int
  \int_const:cn {c_@@_class_ #1 _int}{ \g_@@_class_int }
  \seq_gput_right:Nn \g_@@_types_seq {#1}
  \tl_new:c   { g_@@_page_top_ #1 _tl }
  \tl_new:c   { g_@@_page_first_ #1 _tl }
  \tl_new:c   { g_@@_page_last_ #1 _tl }
  \tl_new:c   { g_@@_verso_top_ #1 _tl }
  \tl_new:c   { g_@@_verso_first_ #1 _tl }
  \tl_new:c   { g_@@_verso_last_ #1 _tl }
  \tl_new:c   { g_@@_recto_top_ #1 _tl }
  \tl_new:c   { g_@@_recto_first_ #1 _tl }
  \tl_new:c   { g_@@_recto_last_ #1 _tl }
%    \end{macrocode}
%    ``col'' is really useless and should get dropped or rethought
%    \begin{macrocode}
  \tl_new:c   { g_@@_col_top_ #1 _tl }
  \tl_new:c   { g_@@_col_first_ #1 _tl }
  \tl_new:c   { g_@@_col_last_ #1 _tl }
%    \end{macrocode}
%    
%    \begin{macrocode}
  \tl_new:c   { g_@@_1col_top_ #1 _tl }
  \tl_new:c   { g_@@_1col_first_ #1 _tl }
  \tl_new:c   { g_@@_1col_last_ #1 _tl }
  \tl_new:c   { g_@@_2col_top_ #1 _tl }
  \tl_new:c   { g_@@_2col_first_ #1 _tl }
  \tl_new:c   { g_@@_2col_last_ #1 _tl }
}    
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
%    
%    \begin{macrocode}

  \box_new:N \@@_box

  \tl_new:N \g_@@_tmp_tl
  \tl_new:N \g_@@_new_top_tl
  
%    \end{macrocode}
%    

%  \begin{macro}{\marks_update_structure:nnn}

%    This function updates the mark structure. The first argument is
%    the region from which we pick up the last mark to make it the new
%    top mark. The second argument is the region for which we produce
%    mark value and the third argument is the material that holds the
%    marks. Out of this material we extract the first and last mark
%    (if there are any) to do the assignments.
%
%    The second argument is always a specific region, e.g.,
%    \texttt{verso} while the first is always the generic name, e.g.,
%    \texttt{page}. Since when updating a specific region the
%    corresponding generic one will receive the same values, this
%    allows us to do both assignments at the same time (without the
%    need for \cs{marks_update_structure_alias:nn}) which save a bit of
%    processing time as we don't have to construct csnames unnecessarily.
%    \begin{macrocode}
\cs_new:Npn \marks_update_structure:nnn #1#2#3
{
  \group_begin:
%    \end{macrocode}
%    Getting the first and last marks out of the material in \verb=#3=
%    is done by putting the material in a box and then doing a
%    split operation to the maximum size possible (which hopefully
%    means all of the content.\footnote{We could verify this, maybe we
%    should.} As this is a temporary thing we don't want any underfull
%    box warnings so we turn those off.
%    \begin{macrocode}
    \dim_set:Nn \tex_splitmaxdepth:D \c_max_dim
    \int_set:Nn \tex_vbadness:D      \c_max_int
    \vbox_set:Nn \@@_box {#3}
    \vbox_set_split_to_ht:NNn \@@_box \@@_box \c_max_dim
%    \end{macrocode}
%    After this action we can get first and last marks of the various
%    types through \cs{tex_splitfirstmarks:D} and
%    \cs{tex_splitbotmarks:D}. So now we loop over all types stored in
%    \cs{g_@@_types_seq}.
%    \begin{macrocode}
    \seq_map_inline:Nn \g_@@_types_seq
      {
%    \end{macrocode}
%    First action: get the last mark from the previous region. As we
%    need this value in various assignments we store it away which
%    avoids uncessary csname generations.
%    \begin{macrocode}
        \tl_gset_eq:Nc \g_@@_new_top_tl { g_@@_ #1 _last_  ##1 _tl }
%    \end{macrocode}
%    This will first of all become the new top mark.
%    \begin{macrocode}
        \tl_gset_eq:cN { g_@@_ #1 _top_ ##1 _tl } \g_@@_new_top_tl
        \tl_gset_eq:cN { g_@@_ #2 _top_ ##1 _tl } \g_@@_new_top_tl
%    \end{macrocode}
%    Next action is to get ourselves the new last mark from the
%    material supplied.
%    \begin{macrocode}
        \tl_gset:No \g_@@_tmp_tl
           { \tex_splitbotmarks:D \use:c{c_@@_class_ ##1 _int} }
%    \end{macrocode}
%    If this mark doesn't exist then obviously first mark neither, so both
%    become the last mark from previous region. We have to be a little
%    careful here: something like \verb=\marks_put{foo}{}= adds an
%    \enquote{empty} mark that should not be confused with no mark at
%    all. But no mark in our material will result in \cs{g_@@_tmp_tl}
%    being empty. This is why we have to make sure that the empty from
%    \cs{marks_put:nn} only appears to be empty but fails the next test:
%    \begin{macrocode}
        \tl_if_empty:NTF \g_@@_tmp_tl 
           {
             \tl_gset_eq:cN { g_@@_ #1 _last_  ##1 _tl } \g_@@_new_top_tl
             \tl_gset_eq:cN { g_@@_ #2 _last_  ##1 _tl } \g_@@_new_top_tl
             \tl_gset_eq:cN { g_@@_ #1 _first_ ##1 _tl } \g_@@_new_top_tl
             \tl_gset_eq:cN { g_@@_ #2 _first_ ##1 _tl } \g_@@_new_top_tl
           }
%    \end{macrocode}
%    If it wasn't empty, ie had a real value then we use this value
%    for our new last mark.
%    \begin{macrocode}
           {
             \tl_gset_eq:cN { g_@@_ #1 _last_ ##1 _tl } \g_@@_tmp_tl
             \tl_gset_eq:cN { g_@@_ #2 _last_ ##1 _tl } \g_@@_tmp_tl
%    \end{macrocode}
%    Since we had a bottom mark we will also have a first mark (which
%    might be the same, but might be not), so we pick that up and
%    assign it to the appropriate token lists.
%    \begin{macrocode}
             \tl_gset:No \g_@@_tmp_tl
                         { \splitfirstmarks \use:c{c_@@_class_ ##1 _int} }
             \tl_gset_eq:cN { g_@@_ #1 _first_ ##1 _tl } \g_@@_tmp_tl
             \tl_gset_eq:cN { g_@@_ #2 _first_ ##1 _tl } \g_@@_tmp_tl
           }
      }
  \group_end:
}
%    \end{macrocode}
%  \end{macro}
%
%

%  \begin{macro}{\marks_update_structure_alias:nn}
%    
%    \begin{macrocode}
\cs_new:Npn \marks_update_structure_alias:nn #1#2
{
  \seq_map_inline:Nn \g_@@_types_seq
      {
        \tl_gset_eq:cc { g_@@_ #1 _top_   ##1 _tl }{ g_@@_ #2 _top_   ##1 _tl }
        \tl_gset_eq:cc { g_@@_ #1 _first_ ##1 _tl }{ g_@@_ #2 _first_ ##1 _tl }
        \tl_gset_eq:cc { g_@@_ #1 _last_  ##1 _tl }{ g_@@_ #2 _last_  ##1 _tl }
      }
}
%    \end{macrocode}
%  \end{macro}
%
%    
%  \begin{macro}{\marks_put:nn}
%    
%    \begin{macrocode}
\cs_new_protected:Npn \marks_put:nn #1#2
{
  \seq_if_in:NnTF \g_@@_types_seq {#1}
      {
%    \end{macrocode}
%    We need to pass the evaluated string into the mark (and we don't
%    have \cs{expanded} yet) so we use the \cs{protect} approach of
%    \LaTeXe{} here including disabling \cs{label} and the
%    like.\footnote{Straight copy from \texttt{latex.ltx} but is this
%    even correct? At least a label in a running header makes little
%    sense if it get set several times! Maybe that needs looking at in
%    the 2e kernel.}
%    \begin{macrocode}
        \group_begin:
          \cs_set_eq:NN \label    \scan_stop:
          \cs_set_eq:NN \index    \scan_stop:
          \cs_set_eq:NN \glossary \scan_stop:
          \unrestored@protected@xdef \g_@@_tmp_tl {#2}
%<*trace>
          \@@_trace:n { set~#1~<-~ '\tl_to_str:V \g_@@_tmp_tl' }
%</trace>
          \tex_marks:D \use:c{c_@@_class_ #1 _int}
              {
                \exp_not:n{ \prg_do_nothing: }
                \g_@@_tmp_tl
              }
        \group_end:
      }
      {
        \__kernel_msg_error:nnx { marks } { unknown-type }
          { \tl_to_str:n {#1} }
      }
}
%    \end{macrocode}
%  \end{macro}
%
%
%    
% \begin{macro}[EXP]
%   {\marks_get_first:nn, \marks_get_last:nn, \marks_get_previous:nn}
%   To retrieve the first, last or previous region mark, we grab the appropriate
%   value stored in some tl var. These functions should be used only in
%   output routines after \cs{marks_update_structure:nnn} has acted, otherwise their
%   value will be wrong.
%    \begin{macrocode}
\cs_new:Npn \marks_use_first:nn #1#2
   { \use:c { g_@@_ #1 _first_ #2 _tl } }
\cs_new:Npn \marks_use_last:nn #1#2
  {  \use:c { g_@@_ #1 _last_ #2 _tl }  }
\cs_new:Npn \marks_use_previous:nn #1#2
  {  \use:c { g_@@_ #1 _top_ #2 _tl }  }
%    \end{macrocode}
% \end{macro}
%
%
%
%  \begin{macro}{\marks_status:n}
%  \begin{macro}{\marks_status:nn}
%    Some simple tracing, should be changed \ldots
%    \begin{macrocode}
\cs_new:Npn \marks_status:n #1
   {
     \seq_map_inline:Nn \g_@@_types_seq { \marks_status:nn {#1} {##1} }
   }
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \marks_status:nn #1#2
   {
     \int_compare:nNnT \tracingmarks > 1
         {
           \typeout{#1~ #2:}
           \typeout{\@spaces page~ (current):
             | \tl_use:c { g_@@_page_top_ #2 _tl }
             | \tl_use:c { g_@@_page_first_ #2 _tl }
             | \tl_use:c { g_@@_page_last_ #2 _tl }     |}
           \typeout{\@spaces page~ (verso):
             | \tl_use:c { g_@@_verso_top_ #2 _tl }
             | \tl_use:c { g_@@_verso_first_ #2 _tl }
             | \tl_use:c { g_@@_verso_last_ #2 _tl }     |}
           \typeout{\@spaces page~ (recto):
             | \tl_use:c { g_@@_recto_top_ #2 _tl }
             | \tl_use:c { g_@@_recto_first_ #2 _tl }
             | \tl_use:c { g_@@_recto_last_ #2 _tl }     |}
           %
           \typeout{\@spaces column~ (current):
             | \tl_use:c { g_@@_col_top_ #2 _tl }
             | \tl_use:c { g_@@_col_first_ #2 _tl }
             | \tl_use:c { g_@@_col_last_ #2 _tl }     |}
           \typeout{\@spaces column~ (first):
             | \tl_use:c { g_@@_1col_top_ #2 _tl }
             | \tl_use:c { g_@@_1col_first_ #2 _tl }
             | \tl_use:c { g_@@_1col_last_ #2 _tl }     |}
           \typeout{\@spaces column~ (second):
             | \tl_use:c { g_@@_2col_top_ #2 _tl }
             | \tl_use:c { g_@@_2col_first_ #2 _tl }
             | \tl_use:c { g_@@_2col_last_ #2 _tl }     |}
         }
}       
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%    
%
%
%
%    \begin{macrocode}
%    \end{macrocode}
%
%
%
%
%    
%    \begin{macrocode}
%    \end{macrocode}
%
%
%
%    
%    \begin{macrocode}
%    \end{macrocode}
%
%
% \subsection{Trace support}
%
% \begin{variable}{\tracingmarks}
%   Used to control the amount of trace material placed in the log.
%    \begin{macrocode}
\int_new:N \tracingmarks
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_trace:n, \@@_trace_internal:n}
%   Two trace functions, one more verbose than the other.
%    \begin{macrocode}
%<*trace>
\cs_new_protected:Npn \@@_trace:n #1
  {
    \int_compare:nNnT \tracingmarks > 0
      { \iow_term:x { Marks:~#1~ \msg_line_context: } }
  }
\cs_new_protected:Npn \@@_trace_internal:n #1
  {
    \int_compare:nNnT \tracingmarks > 1
      { \iow_term:x { Marks:~#1 } }
  }
%</trace>
%    \end{macrocode}
% \end{macro}
%
%    
%
% \subsection{Messages}
%
%    \begin{macrocode}
\__kernel_msg_new:nnnn { marks } { type-already-defined }
  { Mark~type~'#1'~already~defined }
  {
    \c__msg_coding_error_text_tl
    LaTeX~was~asked~to~define~a~new~mark~type~called~'#1':~
    this~mark~type~already~exists.
    \c__msg_return_text_tl
  }
\__kernel_msg_new:nnnn { marks } { unknown-type }
  { Unknown~mark~type~'#1'. }
  {
    \c__msg_coding_error_text_tl
    LaTeX~was~asked~to~manipulate~a~mark~of~type~'#1',~but~this~type~of~mark~
    does~not~exist.
  }
%    \end{macrocode}

%    
%
% \subsection{Designer-level interfaces}
%
%    
% \begin{macro}{\DeclareMarkType}
% \begin{macro}{\PutMark}
% \begin{macro}[EXP]{\PreviousMark, \FirstMark, \LastMark}
%   Largely simple copies: may change.
%    \begin{macrocode}
%    \begin{macrocode}
\cs_new_eq:NN \DeclareMarkType \marks_new:n
\cs_new_eq:NN \PutMark         \marks_put:nn
%    \end{macrocode}
%    The following commands take an optional argument that defaults to
%   page. There is no checking that the region is actually valid. If
%   not there is simply an empty return.
%    \begin{macrocode}
\NewExpandableDocumentCommand \FirstMark { O{page} m }
                    { \marks_use_first:nn {#1}{#2} }
                      
\NewExpandableDocumentCommand \LastMark { O{page} m }
                    { \marks_use_last:nn {#1}{#2} }
                      
\NewExpandableDocumentCommand \PreviousMark { O{page} m }
{ \marks_use_previous:nn {#1}{#2} }
                      
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
%  \section{\LaTeXe{} integration} 
%
%  \begin{macro}[TF, int]{\legacy_switch_if:n}
%    To evaluate \LaTeXe{} boolean switches in a nice way, we need a
%    conditional. Eventually this will probably make it into the \pkg{expl3}
%    code in this or a similar form, but right now it is missing.
%    \begin{macrocode}
\prg_new_conditional:Npnn \legacy_switch_if:n #1 {p, T , F , TF }
  { \exp_args:Nc\if_meaning:w { if#1 } \iftrue \prg_return_true:
                                        \else: \prg_return_false: \fi: }
%    \end{macrocode}
%  \end{macro}
%
%
%    \begin{macrocode}
\RequirePackage{etoolbox}
%    \end{macrocode}
%    
%    
%    \begin{macrocode}
\marks_new:n {ltxleft}     
\marks_new:n {ltxright}     
\marks_new:n {ltxrightnonempty}     
%    \end{macrocode}
%
%    
%  \begin{macro}{\markboth}
%  \begin{macro}{\markright}
%    In addition to generating the legacy mark we output the
%    individual ones as well at the very same point.
%    \begin{macrocode}
\patchcmd\markboth
    {\mark}
    {
      \marks_put:nn{ltxleft}{#1}
      \marks_put:nn{ltxright}{#2} 
      \tl_if_empty:nF{#2}{ \marks_put:nn{ltxrightnonempty}{#2} }
      \mark
    }      
  {\typeout{\noexpand\markboth patch~ successful}}
  {\typeout{\noexpand\markboth patch~ failed}}
%    \end{macrocode}
%    Same game with \cs{markright} except that we only add one mark.    
%    \begin{macrocode}
\patchcmd\markright
    {\mark}
    {
      \marks_put:nn{ltxright}{#1}
      \tl_if_empty:nF{#1}{ \marks_put:nn{ltxrightnonempty}{#1} }
      \mark
    }
  {\typeout{\noexpand\markright patch~ successful}}
  {\typeout{\noexpand\markright patch~ failed}}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\@opcol}
%    \cs{@opcol} handles outputting single or two-column pages. So we
%    need to patch it in each branch to get our mark data structure
%    updated.
%    \begin{macrocode}
\patchcmd\@opcol
  {\@outputpage}
  {
    \marks_update_singlecol_structure:n 
       { \unvcopy\@outputbox\unskip }
    \@outputpage
  }
  {\typeout{\noexpand\@opcol patch~ 1~ successful}}
  {\typeout{\noexpand\@opcol patch~ 1~ failed}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\patchcmd\@opcol
  {\@outputdblcol}
  {
    \marks_update_dblcol_structure:nn
       { \unvcopy\@outputbox\unskip }
       { \unvcopy\@leftcolumn\unskip
         \unvcopy\@outputbox\unskip }
    \@outputdblcol
  }
  {\typeout{\noexpand\@opcol patch~ 2~ successful}}
  {\typeout{\noexpand\@opcol patch~ 2~ failed}}
%    \end{macrocode}
%  \end{macro}
%
%    
%  \begin{macro}{\marks_update_singlecol_structure:n}
%    
%    \begin{macrocode}
\cs_new:Npn \marks_update_singlecol_structure:n #1
   {
     \legacy_switch_if:nTF {@twoside}
     {
      \int_if_odd:nTF \c@page
        { \marks_update_structure:nnn {page}{recto}{#1} }
        { \marks_update_structure:nnn {page}{verso}{#1} }
     }
     {
       \marks_update_structure:nnn {page}{recto}{#1}
       \marks_update_structure_alias:nn {verso}{page}
     }
    \marks_update_structure_alias:nn {col}{page}  
    \marks_update_structure_alias:nn {1col}{page}  
    \marks_update_structure_alias:nn {2col}{page}
%<*trace>
    \marks_status:n
     { OR:~(
       \legacy_switch_if:nTF {@twoside}
              { twoside-
                \int_if_odd:nTF \c@page
                    { odd }{ even }
              }
              { oneside }
       )
     }
%</trace>
   }
%    \end{macrocode}
%  \end{macro}
%    
%  \begin{macro}{\marks_update_dblcol_structure:nn}
%    
%    \begin{macrocode}
\cs_new:Npn \marks_update_dblcol_structure:nn #1#2
   {
    \legacy_switch_if:nTF {@firstcolumn}
      { \marks_update_structure:nnn {col}{1col}{#1} }
      {
        \marks_update_structure:nnn {col}{2col}{#1}
        \legacy_switch_if:nTF {@twoside}
               {
                 \int_if_odd:nTF \c@page
                     { \marks_update_structure:nnn {page}{recto}{#2} }
                     { \marks_update_structure:nnn {page}{verso}{#2} }
               }
               { \marks_update_structure:nnn {page}{recto}{#2} }
      }
%<*trace>
   \marks_status:n
     { OR:~(
       \legacy_switch_if:nTF {@twoside}
              { twoside-
                \int_if_odd:nTF \c@page
                    { odd }{ even }
              }
              { oneside }
      \space
      \legacy_switch_if:nTF {@firstcolumn}
             { first~ }{ second~ }
      column )
     }
%</trace>
   }
%    \end{macrocode}
%  \end{macro}
%    
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \section{Supporting marks in floats}
%
% At the moment, marks that are placed into floats do not migrate out
% and thus are never seen. Below are some ideas how the scheme could
% be extended to support use cases that involve marks inside
% floats.
%
% The basic idea is that when the floats are combined to be placed
% into their areas we make a copy of that in an additional box (but
% using \cs{unvcopy} so that the fload body is at top-level in that
% box. Later when getting the marks in the OR via \cs{vsplit} we can
% then  use this content so that any marks inside will be seen too.
%
% \cs{@combinefloats} is not the only place that would need patching
% in that case, the same needs to be done for spanning floats and also
% to the code that adds inline floats. So this is just an outline really.
%    \begin{macrocode}
%<*floats>
%    \end{macrocode}
%    
%    \begin{macrocode}
\box_new:N \@@_floats_box
\box_new:N \@@_tfloats_box
\box_new:N \@@_bfloats_box
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \@combinefloats {%
    \setbox\@@_floats_box\vbox{}%
    \ifx \@toplist\@empty \else
      \@cflt
      \setbox\@@_tfloats_box\vbox{\unvbox\@@_floats_box}
      \setbox\@@_floats_box\vbox{}%
    \fi
    \ifx \@botlist\@empty \else \@cflb \fi
    \setbox\@@_bfloats_box\vbox{\unvbox\@@_floats_box}
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def\@comflelt#1{%
  \setbox\@@_floats_box\vbox{%
    \unvbox\@@_floats_box \unvcopy #1}%  % may need to check that it
                                         %  is a vbox!
      \setbox\@tempboxa
      \vbox{\unvbox\@tempboxa\box #1\vskip\floatsep}}
%    \end{macrocode}
%
%    When getting the marks we then have to look not only at the
%    galley but also at the content of \cs{@@_tfloats_box} etc. In
%    reality that gets even more complex for two columns as we have
%    more float areas then.
%    \begin{macrocode}
     \marks_update_structure:nnn
     {#1}{#2}
     { \unvcopy\@@_tfloats_box
       \unvcopy #3 \unskip
       \unvcopy\@@_bfloats_box }
%    \end{macrocode}
%    
%    \begin{macrocode}
%</floats>
%    \end{macrocode}
%    
%
% \end{implementation}
%
% \PrintIndex
                    
  

  
