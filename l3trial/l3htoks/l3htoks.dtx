% \iffalse
%
%% File l3htoks.dtx Copyright (C) 2013-2023 The LaTeX Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3htoks} package\\ Converting tokens to text^^A
% }
%
% \author{^^A
%  The \LaTeX{} Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2018-04-30}
%
% \maketitle
%
% \begin{documentation}
%
% \section{\pkg{l3htoks} user functions}
%
% \begin{function}{\htoks_set:Nn}
%   \begin{syntax}
%     \cs{htoks_set:Nn} \meta{tl~var} \Arg{tokens}
%   \end{syntax}
%   Typesets the \meta{tokens} as horizontal material into an internal
%   box variable, and simultaneously stores the corresponding text into
%   the \meta{tl~var}.  Ideally, typesetting the \meta{tl~var} produces
%   precisely the same result as typesetting the original \meta{tokens}.
%   Since the parser only recognizes some of the primitives, only code
%   that is adapted for this module using \cs{only_typeset:n} and
%   \cs{only_tl:n} will work.
% \end{function}
%
% \begin{function}{\htoks_code:n}
% \begin{function}{\htoks_tokens:n, \htoks_tokens:V, \htoks_tokens:e}
%   \begin{syntax}
%     \cs{htoks_code:n} \Arg{code}
%     \cs{htoks_tokens:n} \Arg{tokens}
%   \end{syntax}
%   These commands should only be used within the \meta{tokens} argument
%   of \cs{htoks_set:Nn}.  The \meta{code} is performed by \TeX{} without
%   going through the \pkg{l3htoks} parser, which then resumes its work.
%   This is useful to perform assignments, and many other non-expandable
%   commands (horizontal spaces, etc.).  The \meta{tokens}, on
%   the other hand, are inserted directly in the result of
%   \cs{htoks_set:Nn}.  For instance, one can code a version of
%   \tn{mbox} compatible with \pkg{l3htoks} as follows.
%   \begin{verbatim}
%     \DeclareDocumentCommand { \mbox } { m }
%       {
%         \htoks_code:n { \leavevmode \hbox \bgroup }
%         #1
%         \htoks_code:n { \egroup }
%       }
%   \end{verbatim}
% \end{function}
% \end{function}
%
% \begin{function}{\htoks_if_parse:TF}
%   Test whether the parsing is active.
% \end{function}
%
% \section{Typesetting functions adapted to \pkg{l3htoks}}
%
% \begin{itemize}
%   \item \cs{hspace}
%   \item \cs{mbox}
%   \item \cs{null}
%   \item \cs{GenericWarning}
%   \item \cs{leavevmode}
%   \item \cs{textbf}, \cs{Large}, and other font changing commands
%   \item \cs{label}, \cs{ref}, \cs{pageref}
% \end{itemize}
%
% \section{Internal \pkg{l3htoks} functions}
%
% \begin{function}{\__htoks_parse:w}
%   \begin{syntax}
%     \cs{__htoks_parse:w} \meta{tokens}
%   \end{syntax}
%   Expands fully the following \meta{tokens}, and checks if the
%   resulting primitive or register is associated to an action for
%   \pkg{l3htoks}.  If it is, the action is performed, and
%   \cs{__htoks_parse:w} is called again.  Otherwise, \pkg{l3htoks}
%   throws an error, not knowing how to handle that case.
% \end{function}
%
% \begin{function}{\__htoks_parse_end:}
%   \begin{syntax}
%     \cs{__htoks_parse:w} \cs{__htoks_parse_end:}
%   \end{syntax}
%   When \cs{__htoks_parse:w} encounters (the expansion of)
%   \cs{__htoks_parse_end:}, parsing stops.  It can be resumed by
%   calling \cs{__htoks_parse:w}.
% \end{function}
%
% \begin{function}{\__htoks_if_parse:TF}
%   \begin{syntax}
%     \cs{__htoks_if_parse:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   If this command appears within the realm of action of
%   \cs{__htoks_parse:w}, the \meta{true code} is performed.  Otherwise,
%   the \meta{false code} is.
% \end{function}
%
% Bugs.
% \begin{itemize}
%   \item |^\noexpand\foo| may misbehave.
% \end{itemize}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3htoks} implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesExplPackage{l3htoks}{2018-04-30}{}
  {L3 Experimental conversion of tokens to text}
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=htoks>
%    \end{macrocode}
%
% \subsection{Variables and helpers}
%
% \subsubsection{Variables}
%
% \begin{variable}{\@@_tmp:w}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tmp:w { }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_peek_token}
%    \begin{macrocode}
\cs_new_eq:NN \l_@@_peek_token ?
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_removed_token}
%    \begin{macrocode}
\cs_new_eq:NN \l_@@_removed_token ?
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_peek_next_tl}
%    \begin{macrocode}
\tl_new:N \l_@@_peek_next_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_peek_meaning_tl}
%    \begin{macrocode}
\tl_new:N \l_@@_peek_meaning_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\s_@@}
%    \begin{macrocode}
\scan_new:N \s_@@
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_stored_result_tl, \g_@@_result_tl}
%    \begin{macrocode}
\tl_new:N \l_@@_stored_result_tl
\tl_new:N \g_@@_result_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_internal_int}
%   Used to parse integer values.
%    \begin{macrocode}
\int_new:N \l_@@_internal_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_internal_box}
%    \begin{macrocode}
\box_new:N \l_@@_internal_box
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_afterassignment_tl}
%   Inserted after every assignment.
%    \begin{macrocode}
\tl_new:N \g_@@_afterassignment_tl
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{Looking into the token stream}
%
% \begin{macro}{\@@_peek_x:n}
% \begin{macro}[aux]{\@@_peek_x_aux:, \@@_peek_x_auxii:}
%   Similar to \TeX{}'s own |get_x_token| procedure, expands fully what
%   follows its argument. The first non-expandable token is left in the
%   input stream, and it is also the value of \cs{l_@@_peek_token}.  As
%   all outer tokens are expandable, this token can only be outer while
%   performing the expansion, hence is guaranteed to be \enquote{safe}
%   in the rest of the package.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_peek_x:n #1
  {
    \tl_set:Nn \l_@@_peek_next_tl {#1}
    \@@_peek_x_aux:
  }
\cs_new_protected:Npn \@@_peek_x_aux:
  {
    \tex_futurelet:D \l_@@_peek_token
    \@@_peek_x_auxii:
  }
\cs_new_protected:Npn \@@_peek_x_auxii:
  {
    \exp_after:wN \if_meaning:w
        \exp_not:N \l_@@_peek_token \l_@@_peek_token
      \exp_after:wN \l_@@_peek_next_tl
    \else:
      \exp_after:wN \exp_after:wN
      \exp_after:wN \@@_peek_x_aux:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\@@_ignore_spaces:nw}
% \begin{macro}[aux]
%   {
%     \@@_ignore_spaces_auxi:,
%     \@@_ignore_spaces_auxii:,
%     \@@_ignore_spaces_auxiii:NNw
%   }
%   As long as the next token is a space or is expandable,
%   \texttt{f}-expand (this removes one space), and look for the next
%   token.  Once we find a non-expandable non-space token,
%   \cs{@@_ignore_spaces_auxiii:NNw} cleans up.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_ignore_spaces:nw #1
  {
    \tl_set:Nn \l_@@_peek_next_tl {#1}
    \@@_ignore_spaces_auxi:
  }
\cs_new_protected:Npn \@@_ignore_spaces_auxi:
  { \tex_futurelet:D \l_@@_peek_token \@@_ignore_spaces_auxii: }
\cs_new_protected:Npn \@@_ignore_spaces_auxii:
  {
    \if_catcode:w \exp_not:N \l_@@_peek_token \c_space_token
    \else:
      \exp_after:wN \if_meaning:w
          \exp_not:N \l_@@_peek_token \l_@@_peek_token
        \@@_ignore_spaces_auxiii:NNw
      \fi:
    \fi:
    \exp_after:wN \@@_ignore_spaces_auxi: \exp:w \exp_end_continue_f:w
  }
\cs_new_protected:Npn \@@_ignore_spaces_auxiii:NNw #1#2#3 \exp_end_continue_f:w
  { #1 #2 \l_@@_peek_next_tl }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Adding tokens to the result}
%
% \begin{macro}[aux]{\@@_put_group_begin:, \@@_put_group_end:}
%   Place the appropriate \cs{if_false:} \ldots{} \cs{fi:} construction.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_put_group_begin:
  { \tl_gput_right:Nn \g_@@_result_tl { { \if_false: } \fi: } }
\cs_new_protected:Npn \@@_put_group_end:
  { \tl_gput_right:Nn \g_@@_result_tl { \if_false: { \fi: } } }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Other helpers}
%
% \begin{macro}[aux]
%   {\@@_strip_escape:w, \@@_strip_escape_aux:N, \@@_strip_escape_aux:w}
%   At the time of writing, this is almost copy of \cs{cs_to_str:N}.
%   It is meant to remove an escape character from what follows in the
%   input stream (which must be already turned into a string).  More
%   precisely, if the escape character code is negative or too large
%   then do nothing; if it is a space, then hit what follows with
%   \cs{tex_romannumeral:D} |0| hence remove a space (this breaks if
%   what follows starts with a digit); and in all other cases, do
%   \cs{use_none:n}.
%    \begin{macrocode}
\cs_new:Npn \@@_strip_escape:w
  {
    \tex_romannumeral:D
      \if:w \token_to_str:N \ \@@_strip_escape_aux:w \fi:
      \@@_strip_escape_aux:N
  }
\cs_new:Npn \@@_strip_escape_aux:N #1 { \c_zero_int }
\cs_new:Npn \@@_strip_escape_aux:w #1#2
  { - \int_value:w #1 \c_zero_int }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Parsing loop}
%
% \subsubsection{Main loop}
%
% \begin{macro}[int]{\@@_parse:w, \@@_parse_test:}
% \begin{macro}[aux]{\@@_parse_register:w}
%   Following the lead of \TeX{}'s main loop, most of the work is done
%   in a single loop.  First get the following token after
%   \texttt{x}-expansion, then evaluate (and clean up) its \tn{meaning}.
%   We then dispatch according to this meaning: for all characters and
%   for some primitives, there will exist a |\@@_primitive_| function.
%   For tokens with a meaning such as \texttt{select font ??} or
%   |\skip123|, there can be no such function, and we build an alternate
%   function using the first few characters of the meaning instead of
%   the full meaning, to get rid of the dependence on the register
%   number.  After a primitive does its work, it will typically call
%   \cs{@@_parse:w} to read further in the token stream.  For some of
%   the primitives (\emph{e.g.}, \tn{ignorespaces}), the next token has
%   already been expanded: those primitives call \cs{@@_parse_test:}
%   directly.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse:w
  { \@@_peek_x:n { \@@_parse_test: } }
\cs_new_protected:Npn \@@_parse_test:
  {
    \@@_meaning:
    \cs_if_exist_use:cF { @@_primitive_ \l_@@_peek_meaning_tl :w }
      {
        \exp_after:wN \@@_parse_register:w
          \l_@@_peek_meaning_tl ? ? ? ? \q_stop
      }
  }
\cs_new:Npn \@@_parse_register:w #1 #2 #3 #4 #5 \q_stop
  {
    \cs_if_exist_use:cF { @@_register_ #1 #2 #3 #4 :w }
      { \@@_not_implemented: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_parse_next:w}
%   Ignore the next token then calls \cs{@@_parse:w}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_next:w
  {
    \tex_afterassignment:D \@@_parse:w
    \tex_let:D \l_@@_removed_token = ~
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_not_implemented:}
%   If a primitive is not implemented, throw an error, and try to
%   retrieve control using \cs{tex_afterassignment:D}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_not_implemented:
  {
    \msg_error:nne { htoks } { primitive-not-implemented }
      { \l_@@_peek_meaning_tl }
    \tex_afterassignment:D \@@_parse:w
  }
\msg_new:nnnn { htoks } { primitive-not-implemented }
  { The~\iow_char:N \\#1~primitive~is~not~implemented. }
  {
    The~htoks~package~is~not~programmed~to~handle~
    \iow_char:N\\#1.~Please~wrap~such~code~within~
    \iow_char:N\\htoks_code:n.~An~attempt~will~be~
    made~to~retrieve~control~after~the~next~assignment.
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Filtering the meaning of a token}
%
% \begin{macro}[int]{\@@_meaning:}
% \begin{macro}[aux]{\@@_meaning_character:w}
%   The token can be
%   \begin{itemize}
%   \item a (non-active) character with some category code;
%   \item a benign primitive whose meaning is an escape character
%     followed by letters;
%   \item \enquote{\texttt{end of alignment template}};
%   \item \enquote{\texttt{select font ??}};
%   \item |\char"F|, |\mathchar"ABC|, \cs{count123}, \cs{dimen123},
%     \cs{muskip123}, \cs{skip123}, or \cs{toks123}.
%   \end{itemize}
%   The result is as follows.
%   \begin{itemize}
%   \item Characters give \texttt{begin-group_character},
%     \texttt{end-group_character}, \texttt{math_shift},
%     \texttt{alignment_tab}, \texttt{macro_parameter},
%     \texttt{superscript_character}, \texttt{subscript_character},
%     \texttt{blank_space}, \texttt{the_letter}, \texttt{the_other}.
%   \item Nice primitives give their meaning, stripped of the escape
%     character.
%   \item The end template gives \texttt{end of alignment template} or
%     \texttt{nd of alignment template} (note the missing \texttt{e}),
%     depending on the value of the escape character.
%   \item Font selection commands give either \texttt{select font ??} or
%     \texttt{elect font ??} (with a missing \texttt{s}).
%   \item |char"F|, |mathchar"ABC|, \texttt{count123},
%     \texttt{dimen123}, \texttt{muskip123}, \texttt{skip123}, or
%     \texttt{toks123}.
%   \end{itemize}
%   The characters, primitives, and end-template will correspond
%   directly to control sequences of the form |\@@_primitive_|, while
%   other commands, which are parametrized by some value (font,
%   hexadecimal integer, or decimal integer), cannot be mapped directly.
%   Instead, the code for \cs{@@_parse:w} finds out that there is no
%   matching |\@@_primitive_| function, trims the meaning down to its
%   first four letters, and calls an alternate function to do the work.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_meaning:
  {
    \group_align_safe_begin:
    \token_if_eq_catcode:NNTF \l_@@_peek_token \tex_relax:D
      {
        \tl_set:Ne \l_@@_peek_meaning_tl
          {
            \exp_after:wN \@@_strip_escape:w
            \token_to_meaning:N \l_@@_peek_token
          }
      }
      {
        \tl_set:Ne \l_@@_peek_meaning_tl
          {
            \exp_after:wN \@@_meaning_character:w
            \token_to_meaning:N \l_@@_peek_token \q_stop
          }
      }
    \group_align_safe_end:
  }
\cs_new:Npn \@@_meaning_character:w #1 ~ #2 ~ #3 \q_stop { #1_#2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{From character tokens to characters}
%
% \begin{macro}[int]{\@@_token_to_charcode:N}
% \begin{macro}[aux]
%   {
%     \@@_token_to_charcode_auxi:w,
%     \@@_token_to_charcode_auxii:w,
%     \@@_token_to_charcode_auxiii:w
%   }
%   This currently fails for non BMP characters in \XeTeX{}.
%    \begin{macrocode}
\cs_new:Npn \@@_token_to_charcode:N
  {
    \int_value:w
      \exp_after:wN \@@_token_to_charcode_auxi:w
      \token_to_meaning:N
  }
\group_begin:
  \char_set_catcode_other:N \m
  \cs_new:Npn \@@_token_to_charcode_auxi:w #1 ~ #2 ~
    {
      \if_catcode:w ^ \@@_token_to_charcode_auxii:w #1 m ^
        \exp_after:wN `
      \else:
        \exp_after:wN \@@_token_to_charcode_auxiii:w
      \fi:
    }
  \cs_new:Npn \@@_token_to_charcode_auxii:w #1 m { }
  \cs_new:Npn \@@_token_to_charcode_auxiii:w #1 ~ { ` }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Implementation of primitives}
%
% \subsubsection{Character tokens}
%
% \begin{macro}[int]
%   {
%     \@@_primitive_begin-group_character:w,
%     \@@_primitive_end-group_character:w
%   }
%   If the next token has category code~$1$ or~$2$, put the relevant
%   brace into \cs{g_@@_result_tl}, leave that brace in the input
%   stream, and skip it before parsing further.
%    \begin{macrocode}
\cs_new_protected:cpn { @@_primitive_begin-group_character:w }
  {
    \@@_put_group_begin:
    \l_@@_peek_token
    \@@_parse_next:w
  }
\cs_new_protected:cpn { @@_primitive_end-group_character:w }
  {
    \@@_put_group_end:
    \l_@@_peek_token
    \@@_parse_next:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_primitive_math_shift:w}
%   Check for a second math shift (this should actually depend on the
%   current mode), and put that in the result, before entering (or
%   leaving) math mode and parsing what follows.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_math_shift:w #1
  {
    \peek_catcode:NTF #1
      {
        \tl_gput_right:Nn \g_@@_result_tl { $ $ }
        #1#1 \@@_parse_next:w
      }
      {
        \tl_gput_right:Nn \g_@@_result_tl { $ } %^^A $
        #1 \@@_parse:w
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{itemize}
%   \item \texttt{alignment tab} not implemented, because we have not
%     decided yet what to do with tables.
%   \item \texttt{macro parameter} not implemented, because those may
%     not reach \TeX{}'s stomach.
% \end{itemize}
%
% \begin{macro}[int]
%   {
%     \@@_primitive_superscript_character:w,
%     \@@_primitive_subscript_character:w
%   }
% \begin{macro}[aux]
%   {
%     \@@_subsuper_auxi:NN,
%     \@@_subsuper_auxii:,
%     \@@_subsuper_auxiii:N
%   }
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_superscript_character:w
  { \@@_subsuper_auxi:NN ^ }
\cs_new_protected:Npn \@@_primitive_subscript_character:w
  { \@@_subsuper_auxi:NN _ }
\cs_new_protected:Npn \@@_subsuper_auxi:NN #1#2
  {
    \mode_if_math:F
      {
        \msg_error:nnn { htoks } { subsuper-in-text } {#1}
        \tl_gput_right:Nn \g_@@_result_tl { $ } %^^A $
        \c_math_toggle_token
      }
    \tl_gput_right:Nn \g_@@_result_tl {#1}
    \@@_put_group_begin:
    #2 \c_group_begin_token
    \@@_ignore_spaces:nw { \@@_subsuper_auxii: }
  }
\cs_new_protected:Npn \@@_subsuper_auxii:
  {
    \token_if_eq_catcode:NNTF \l_@@_peek_token \c_group_begin_token
      { \@@_parse_next:w }
      { \@@_subsuper_auxiii:N }
  }
\cs_new_protected:Npn \@@_subsuper_auxiii:N #1
  {
    \msg_warning:nnnn { htoks } { subsuper-no-brace } {#1}
    \@@_parse:w
    #1
    \c_group_end_token
  }
\msg_new:nnn { htoks } { subsuper-in-text }
  { Subscripts~and~superscripts~may~only~appear~in~math~mode. }
\msg_new:nnn { htoks } { subsuper-no-brace }
  { The~subscript~or~superscript~'#1'~may~need~to~be~surrounded~with~braces. }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_primitive_blank_space:w}
%   Put a space in the result, and typeset it, then skip over the space
%   token to continue parsing.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_blank_space:w
  {
    \tl_gput_right:Nn \g_@@_result_tl { ~ }
    \c_space_token
    \@@_parse_next:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_primitive_the_letter:w, \@@_primitive_the_character:w}
%   Grab the token and leave it in the input stream, then within a group
%   build an explicit letter token with that character code (note that
%   we cannot simply use |#1| since this may be an implicit character
%   token).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_the_letter:w #1
  {
    #1
    \tl_gput_right:Ne \g_@@_result_tl
      { \char_generate:nn { \@@_token_to_charcode:N #1 } { 11 } }
    \@@_parse:w
  }
\cs_new_protected:Npn \@@_primitive_the_character:w #1
  {
    #1
    \tl_gput_right:Ne \g_@@_result_tl
      { \char_generate:nn { \@@_token_to_charcode:N #1 } { 12 } }
    \@@_parse:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_primitive_char:w, \@@_primitive_mathchar:w}
%    \begin{macrocode}
\cs_new_eq:NN \@@_primitive_char:w \@@_not_implemented:
\cs_new_eq:NN \@@_primitive_mathchar:w \@@_not_implemented:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_register_char:w, \@@_register_math:w}
%    \begin{macrocode}
\cs_new_eq:NN \@@_register_char:w \@@_not_implemented:
\cs_new_eq:NN \@@_register_math:w \@@_not_implemented:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_register_sele:w, \@@_register_elec:w}
% \begin{macro}[aux]{\htoks_font:n}
%   Those functions are called for selecting a font.  It is not quite
%   clear what should be put in the resulting token list.
%    \begin{macrocode}
\cs_new_protected:Npn \htoks_font:n #1
  {
    \tex_font:D \@@_tmp:w #1 \scan_stop:
    \@@_tmp:w \scan_stop:
  }
\cs_new_protected:Npn \@@_register_sele:w #1
  {
    \tl_gput_right:Ne \g_@@_result_tl
      { \htoks_font:n { \tex_fontname:D #1 } }
    #1
    \@@_parse:w
  }
\cs_new_eq:NN \@@_register_elec:w \@@_register_sele:w
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Assignments and afterassignment}
%
% \begin{macro}[int]{\@@_primitive_afterassignment:w}
% \begin{macro}[aux]
%   {
%     \@@_afterassignment_auxi:,
%     \@@_afterassignment_auxii:N
%   }
%   We need to support |\afterassignment\x\def\x{}|, so we do our best
%   to grab the next token as a macro argument and store it in
%   \cs{g_@@_afterassignment_tl}: if it is a begin-group, end-group or
%   space token, we put the relevant token into
%   \cs{g_@@_afterassignment_tl}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_afterassignment:w #1
  { \tex_futurelet:D \l_@@_peek_token \@@_afterassignment_auxi: }
\cs_new_protected:Npn \@@_afterassignment_auxi:
  {
    \tl_gclear:N \g_@@_afterassignment_tl
    \if_catcode:w \exp_not:N \l_@@_peek_token \c_group_begin_token
      \tl_gset:Nn \g_@@_afterassignment_tl { \c_group_begin_token }
    \fi:
    \if_catcode:w \exp_not:N \l_@@_peek_token \c_group_end_token
      \tl_gset:Nn \g_@@_afterassignment_tl { \c_group_end_token }
    \fi:
    \if_meaning:w \l_@@_peek_token \c_space_token
      \tl_gset:Nn \g_@@_afterassignment_tl { \c_space_token }
    \fi:
    \tl_if_empty:NTF \g_@@_afterassignment_tl
      { \exp_after:wN \@@_afterassignment_auxii:N \exp_not:N }
      { \@@_parse_next:w }
  }
\cs_new_protected:Npn \@@_afterassignment_auxii:N #1
  {
    \group_begin:
      \tex_let:D #1 \scan_stop:
      \tl_gset:Nn \g_@@_afterassignment_tl {#1}
    \group_end:
    \@@_parse:w
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_assignment:w}
% \begin{macro}[aux]{\@@_assignment_aux:}
%   When the next token starts an assignment, we can retrieve control
%   with \cs{tex_afterassignment:D}.  Before starting to parse again,
%   though, we insert the contents of \cs{g_@@_afterassignment_tl} (a
%   single token).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_assignment:w
  { \tex_afterassignment:D \@@_assignment_aux: }
\cs_new_protected:Npn \@@_assignment_aux:
  {
    \exp_last_unbraced:NNNo
      \tl_gclear:N \g_@@_afterassignment_tl
      \@@_parse:w \g_@@_afterassignment_tl
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_primitive_def:w,
%     \@@_primitive_edef:w,
%     \@@_primitive_gdef:w,
%     \@@_primitive_xdef:w,
%     \@@_primitive_advance:w,
%     \@@_primitive_multiply:w,
%     \@@_primitive_divide:w,
%     \@@_primitive_chardef:w,
%     \@@_primitive_mathchardef:w,
%     \@@_primitive_let:w,
%     \@@_primitive_futurelet:w,
%     \@@_primitive_global:w,
%     \@@_primitive_long:w,
%     \@@_primitive_outer:w,
%     \@@_primitive_protected:w,
%     \@@_primitive_endlinechar:w,
%     \@@_primitive_newlinechar:w,
%     \@@_primitive_escapechar:w,
%     \@@_primitive_read:w,
%     \@@_primitive_readline:w,
%     \@@_primitive_lccode:w,
%     \@@_primitive_uccode:w,
%     \@@_primitive_catcode:w,
%     \@@_primitive_sfcode:w,
%     \@@_primitive_delcode:w,
%     \@@_primitive_mathcode:w,
%   }
%    \begin{macrocode}
\tl_map_inline:nn
  {
    {def} {edef} {gdef} {xdef}
    {advance} {multiply} {divide}
    {chardef} {mathchardef}
    {let} {futurelet}
    {global} {long} {outer} {protected}
    {endlinechar} {newlinechar} {escapechar}
    {read} {readline}
    {lccode} {uccode} {catcode} {sfcode} {delcode} {mathcode}
  }
  { \cs_new_eq:cN { @@_primitive_#1:w } \@@_assignment:w }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_register_coun:w,
%     \@@_register_dime:w,
%     \@@_register_musk:w,
%     \@@_register_skip:w,
%     \@@_register_toks:w
%   }
%   This covers the primitives \tn{count}, \tn{dimen}, \tn{muskip},
%   \tn{skip}, \tn{toks}, and \tn{countdef}, \tn{dimendef},
%   \tn{muskipdef}, \tn{skipdef}, \tn{toksdef}, as well as registers of
%   those five types.
%    \begin{macrocode}
\tl_map_inline:nn { {coun} {dime} {musk} {skip} {toks} }
  { \cs_new_eq:cN { @@_register_#1:w } \@@_assignment:w }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_primitive_adjdemerits:w,
%     \@@_primitive_doublehyphendemerits:w,
%     \@@_primitive_finalhyphendemerits:w,
%     \@@_primitive_binoppenalty:w,
%     \@@_primitive_brokenpenalty:w,
%     \@@_primitive_clubpenalty:w,
%     \@@_primitive_linepenalty:w,
%     \@@_primitive_emergencystretch:w,
%     \@@_primitive_postdisplaypenalty:w,
%     \@@_primitive_predisplaypenalty:w,
%     \@@_primitive_relpenalty:w,
%     \@@_primitive_hangindent:w,
%     \@@_primitive_hbadness:w,
%     \@@_primitive_hfuzz:w,
%     \@@_primitive_lastlinefit:w,
%     \@@_primitive_lineskip:w,
%     \@@_primitive_nulldelimiterspace:w,
%     \@@_primitive_pretolerance:w,
%     \@@_primitive_errorcontextlines:w,
%     \@@_primitive_everydisplay:w,
%     \@@_primitive_everymath:w,
%     \@@_primitive_everycr:w,
%     \@@_primitive_everyeof:w,
%     \@@_primitive_everyhbox:w,
%     \@@_primitive_everyvbox:w,
%     \@@_primitive_everyjob:w,
%     \@@_primitive_everypar:w,
%     \@@_primitive_time:w,
%     \@@_primitive_day:w,
%     \@@_primitive_month:w,
%     \@@_primitive_year:w,
%     \@@_primitive_luatexversion:w,
%     \@@_primitive_prevdepth:w,
%     \@@_primitive_showboxbreadth:w,
%     \@@_primitive_showboxdepth:w,
%     \@@_primitive_spaceskip:w,
%     \@@_primitive_tolerance:w,
%     \@@_primitive_tracingassigns:w,
%     \@@_primitive_tracingcommands:w,
%     \@@_primitive_tracingnesting:w,
%     \@@_primitive_tracingmacros:w,
%     \@@_primitive_tracingonline:w,
%     \@@_primitive_tracingrestores:w,
%     \@@_primitive_uchyph:w,
%     \@@_primitive_vbadness:w,
%     \@@_primitive_vfuzz:w,
%     \@@_primitive_xspacefactor:w,
%     \@@_primitive_boxmaxdepth:w,
%     \@@_primitive_deadcycles:w,
%     \@@_primitive_defaulthyphenchar:w,
%     \@@_primitive_interlinepenalty:w,
%     \@@_primitive_leftskip:w,
%     \@@_primitive_mathsurround:w,
%     \@@_primitive_parfillskip:w,
%     \@@_primitive_rightskip:w,
%     \@@_primitive_scriptfont:w,
%     \@@_primitive_scriptscriptfont:w,
%     \@@_primitive_textfont:w,
%     \@@_primitive_displaywidowpenalties:w,
%     \@@_primitive_exhyphenpenalty:w,
%     \@@_primitive_lefthyphenmin:w,
%     \@@_primitive_output:w,
%     \@@_primitive_parindent:w,
%     \@@_primitive_parskip:w,
%     \@@_primitive_prevgraf:w,
%     \@@_primitive_topskip:w,
%     \@@_primitive_widowpenalties:w,
%     \@@_primitive_xspaceskip:w,
%     \@@_primitive_baselineskip:w,
%     \@@_primitive_errhelp:w,
%     \@@_primitive_pagegoal:w,
%     \@@_primitive_pagetotal:w,
%     \@@_primitive_spacefactor:w,
%     \@@_primitive_clubpenalties:w,
%     \@@_primitive_vsize:w,
%     \@@_primitive_hsize:w,
%     \@@_primitive_fontdimen:w,
%     \@@_primitive_parshape:w,
%     \@@_primitive_holdinginserts:w,
%     \@@_primitive_fam:w,
%     \@@_primitive_interlinepenalties:w,
%     \@@_primitive_font:w,
%     \@@_primitive_outputpenalty:w,
%     \@@_primitive_pdfcompresslevel:w,
%     \@@_primitive_pdfdecimaldigits:w,
%     \@@_primitive_pdfhorigin:w,
%     \@@_primitive_pdfminorversion:w,
%     \@@_primitive_pdfobjcompresslevel:w,
%     \@@_primitive_pdfoutput:w,
%     \@@_primitive_pdfpkresolution:w,
%     \@@_primitive_pdfvorigin:w,
%     \@@_primitive_hyphenchar:w,
%   }
%   It is not clear whether we should include those.
%    \begin{macrocode}
\tl_map_inline:nn
  {
    {adjdemerits} {doublehyphendemerits} {finalhyphendemerits}
    {binoppenalty} {brokenpenalty} {clubpenalty} {linepenalty}
    {emergencystretch} {postdisplaypenalty} {predisplaypenalty}
    {relpenalty} {hangindent} {hbadness} {hfuzz} {lastlinefit}
    {lineskip} {nulldelimiterspace} {pretolerance} {errorcontextlines}
    {everydisplay} {everymath} {everycr} {everyeof} {everyhbox}
    {everyvbox} {everyjob} {everypar} {time} {day} {month} {year}
    {luatexversion} {prevdepth} {showboxbreadth} {showboxdepth}
    {spaceskip} {tolerance} {tracingassigns} {tracingcommands}
    {tracingnesting} {tracingmacros} {tracingonline} {tracingrestores}
    {uchyph} {vbadness} {vfuzz} {xspacefactor} {boxmaxdepth}
    {deadcycles} {defaulthyphenchar} {interlinepenalty} {leftskip}
    {mathsurround} {parfillskip} {rightskip} {scriptfont}
    {scriptscriptfont} {textfont} {displaywidowpenalties}
    {exhyphenpenalty} {lefthyphenmin} {output} {parindent} {parskip}
    {prevgraf} {topskip} {widowpenalties} {xspaceskip} {baselineskip}
    {errhelp} {pagegoal} {pagetotal} {spacefactor} {clubpenalties}
    {vsize} {hsize} {fontdimen} {parshape} {holdinginserts} {fam}
    {interlinepenalties} {font} {outputpenalty} {pdfcompresslevel}
    {pdfdecimaldigits} {pdfhorigin} {pdfminorversion}
    {pdfobjcompresslevel} {pdfoutput} {pdfpkresolution} {pdfvorigin}
    {hyphenchar}
  }
  { \cs_new_eq:cN { @@_primitive_#1:w } \@@_assignment:w }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Other primitives}
%
% \begin{macro}[int]{\@@_primitive_ignorespaces:w}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_ignorespaces:w #1
  { \@@_ignore_spaces:nw { \@@_parse_test: } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\@@_do_general_text:nw, \@@_do_general_text_aux:}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_do_general_text:nw #1
  {
    \group_begin:
      \cs_set_protected:Npn \@@_tmp:w ##1
        { \group_end: #1 }
      \tex_afterassignment:D \@@_do_general_text_aux:
      \tex_toks:D \c_zero_int
  }
\cs_new_protected:Npn \@@_do_general_text_aux:
  { \exp_args:No \@@_tmp:w { \tex_the:D \tex_toks:D \c_zero_int } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_primitive_lowercase:w, \@@_primitive_uppercase:w}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_lowercase:w #1
  { \@@_do_general_text:nw { #1 { \@@_parse:w ##1 } } }
\cs_new_eq:NN \@@_primitive_uppercase:w \@@_primitive_lowercase:w
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_primitive_message:w,
%     \@@_primitive_errmessage:w,
%     \@@_primitive_special:w,
%     \@@_primitive_pdfliteral:w
%   }
%   Not sure if the primitives \tn{special} and \tn{pdfliteral} only
%   accept a general text, or more.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_message:w #1
  { \@@_do_general_text:nw { #1 {##1} \@@_parse:w } }
\cs_new_eq:NN \@@_primitive_errmessage:w \@@_primitive_message:w
\cs_new_eq:NN \@@_primitive_special:w \@@_primitive_message:w
\cs_new_eq:NN \@@_primitive_pdfliteral:w \@@_primitive_message:w
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]
%   {
%     \@@_primitive_begingroup:w,
%     \@@_primitive_endgroup:w
%   }
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_begingroup:w #1
  {
    #1
    \tl_gput_right:Nn \g_@@_result_tl { \group_begin: }
    \@@_parse:w
  }
\cs_new_protected:Npn \@@_primitive_endgroup:w #1
  {
    #1
    \tl_gput_right:Nn \g_@@_result_tl { \group_end: }
    \@@_parse:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_primitive_ :w}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_primitive_ ~ :w } #1
  {
    #1
    \tl_gput_right:Nn \g_@@_result_tl { \ }
    \@@_parse:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_primitive_penalty:w}
% \begin{macro}[aux]{\@@_primitive_penalty_aux:}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_penalty:w #1
  {
    \tex_afterassignment:D \@@_primitive_penalty_aux:
    \l_@@_internal_int = ~
  }
\cs_new_protected:Npn \@@_primitive_penalty_aux:
  {
    \tex_penalty:D \l_@@_internal_int
    \tl_gput_right:Ne \g_@@_result_tl
      { \penalty \int_use:N \l_@@_internal_int \c_space_tl }
    \@@_parse:w
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% The following primitives are used somewhere within the \texttt{svn}
% repository.  I do not know yet what I should do with those.  Probably
% list the main topics in the documentation of \pkg{l3htoks}, and tell
% people to use \cs{htoks_code:n} to wrap those.
% \begin{itemize}
%   \item Box functions \tn{setbox}, \tn{lastbox}, \tn{insert},
%     \tn{vadjust}, \tn{lower}, \tn{moveleft}, \tn{moveright},
%     \tn{raise}, \tn{unhbox}, \tn{unhcopy}, \tn{unvbox}, \tn{unvcopy},
%     \tn{vsplit}, \tn{copy}, \tn{hbox}, \tn{vbox}, \tn{vtop}, \tn{box},
%     \tn{indent}, \tn{noindent}, \tn{par};
%   \item Typesetting functions \tn{penalty}, \tn{hfil}, \tn{vss},
%     \tn{hss}, \tn{hskip}, \tn{mskip}, \tn{vskip}, \tn{kern},
%     \tn{unkern}, \tn{unpenalty}, \tn{unskip}, \tn{hrule}, \tn{vrule},
%     \tn{italiccorrection}, \tn{nullfont}, other \texttt{select font
%       \ldots{}}, \tn{accent};
%   \item I/O functions \tn{closein}, \tn{closeout}, \tn{latelua},
%     \tn{mark}, \tn{openin}, \tn{openout}, \tn{immediate}, \tn{write};
%   \item Math mode \tn{mathbin}, \tn{mathclose}, \tn{mathop},
%     \tn{mathopen}, \tn{mathord}, \tn{mathpunct}, \tn{mathrel},
%     \tn{delimiter}, \tn{mathaccent}, \tn{radical};
%   \item Show commands \tn{show}, \tn{showbox}, \tn{showtokens},
%     \tn{showthe}, \tn{showgroups}, \tn{showifs};
%   \item Alignments \tn{halign}, \tn{cr}, \tn{noalign};
%   \item \LuaTeX{}'s \tn{initcatcodetable}, \tn{catcodetable},
%     \tn{savecatcodetable};
%   \item \pdfTeX{}'s \tn{pdfsave}, \tn{pdfsetmatrix},
%     \tn{pdfcolorstack}, \tn{pdfrestore};
%   \item A couple odd primitives \tn{dump}, \tn{end}, \tn{aftergroup},
%     \tn{endinput}.
% \end{itemize}
%
% Some primitives are invalid in any mode.  To avoid letting the parser
% choke on those, and to get a nicer error message, we count implement
% them to produce an error message (\emph{e.g.}, \cs{endcsname} and
% |macro_parameter|).
%
% \subsection{Stopping the parsing, and conditionals}
%
% \begin{macro}[int]{\@@_primitive_relax:w}
%   If \cs{@@_parse:w} sees \cs{s_@@} (equal to \tn{relax}), it removes
%   the next token and stops parsing.  Otherwise, the \tn{relax} is
%   removed, and we continue parsing.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_primitive_relax:w #1
  { \str_if_eq:nnTF {#1} { \s_@@ } { \use_none:n } { \@@_parse:w } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_end:}
%   If parsing is not active, this does nothing (well, a trivial
%   assignment and \tn{relax}).  If parsing is active,
%   \cs{@@_primitive_let:w} is called, then \cs{@@_primitive_relax:w},
%   which recognizes \cs{s_@@} and removes the next token
%   \cs{prg_do_nothing:}.  The dummy assignment is there to catch the
%   case where \cs{@@_parse:w} encountered an unknown primitive: the
%   parser tries to recover using \cs{tex_afterassignment:D}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_end:
  {
    \cs_set_eq:NN \s_@@ \s_@@
    \s_@@ \prg_do_nothing:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\htoks_if_parse:TF, \@@_if_parse:NNnn}
%   If parsing is active, the first two tokens of \cs{htoks_if_parse:TF}
%   are removed, leaving \cs{@@_parse:w} to start parsing again, and
%   \cs{use_i:nn} to select the \texttt{true} branch.  Otherwise,
%   \cs{@@_if_parse:NNnn} selects the \texttt{false} branch.
%    \begin{macrocode}
\cs_new_protected:Npn \htoks_if_parse:TF
  { \s_@@ \@@_if_parse:NNnn \@@_parse:w \use_i:nn }
\cs_new_protected:Npn \@@_if_parse:NNnn #1#2#3#4 {#4}
%    \end{macrocode}
% \end{macro}
%
% \subsection{User functions}
%
% \begin{macro}{\htoks_set:Nn}
% \begin{macro}[aux]{\@@_set:NNNn}
%    \begin{macrocode}
\cs_new_protected:Npn \htoks_set:Nn
  {
    \htoks_if_parse:TF
      { \@@_set:NNNn \@@_parse_end: \@@_parse:w }
      { \@@_set:NNNn \prg_do_nothing: \prg_do_nothing: }
  }
\cs_new_protected:Npn \@@_set:NNNn #1#2#3#4
  {
    #1
    \hbox_set:Nw \l_@@_internal_box
      \tl_set_eq:NN \l_@@_stored_result_tl \g_@@_result_tl
      \tl_gclear:N \g_@@_result_tl
      \@@_parse:w #4 \@@_parse_end:
      \use:e
        {
          \exp_not:n { \tl_gset_eq:NN \g_@@_result_tl \l_@@_stored_result_tl }
          \hbox_set_end:
          \exp_not:n { \tl_set:Nn #3 } { \g_@@_result_tl }
        }
    #2
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\htoks_code:n}
%    \begin{macrocode}
\cs_new_protected:Npn \htoks_code:n #1
  {
    \htoks_if_parse:TF
      { \@@_parse_end: #1 \@@_parse:w }
      {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\htoks_tokens:n, \htoks_tokens:V, \htoks_tokens:e}
%    \begin{macrocode}
\msg_new:nnn { htoks } { not-parsing }
  { The~function~#1~can~only~be~used~within~#2. }
\cs_new_protected:Npn \htoks_tokens:n #1
  {
    \htoks_if_parse:TF
      {
        \@@_parse_end:
        \tl_gput_right:Nn \g_@@_result_tl {#1}
        \@@_parse:w
      }
      {
        \msg_error:nnee { htoks } { not-active }
          { \token_to_str:N \htoks_tokens:n }
          { \token_to_str:N \htoks_set:Nn }
      }
  }
\cs_generate_variant:Nn \htoks_tokens:n { V , e }
\msg_new:nnn { htoks } { not-active }
  { The~#1~command~was~used~outside~#2. }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Reimplementing document-level functions}
%
% \begin{macro}{\hspace}
%   We reimplement here \LaTeXe{}'s \tn{hspace} macro.
%    \begin{macrocode}
\DeclareDocumentCommand { \hspace } { s m }
  {
    \skip_set:Nn \l_tmpa_skip {#2}
    \IfBooleanTF {#1}
      {
        \htoks_tokens:e { \hspace* { \skip_use:N \l_tmpa_skip } }
        \htoks_code:n
          {
            \tex_vrule:D width \c_zero_dim \scan_stop:
            \tex_penalty:D 10000 \scan_stop:
            \tex_hskip:D \l_tmpa_skip
            \tex_hskip:D \c_zero_skip
          }
      }
      {
        \htoks_tokens:n { \hspace { \skip_use:N \l_tmpa_skip } }
        \htoks_code:n { \tex_hskip:D \l_tmpa_skip }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\mbox}
%    \begin{macrocode}
\DeclareDocumentCommand { \mbox } { m }
  {
    \htoks_code:n
      {
        \leavevmode
        \hbox \c_group_begin_token
      }
    #1
    \htoks_code:n { \c_group_end_token }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\null}
%    \begin{macrocode}
\DeclareDocumentCommand { \null } { }
  { \htoks_code:n { \hbox:n { } } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GenericWarning}
%    \begin{macrocode}
\DeclareDocumentCommand { \GenericWarning } { mm }
  {
    \begingroup
      \def \MessageBreak {^^J#1}
      \set@display@protect
      \htoks_code:n { \immediate \write \@unused {^^J#2\on@line .} }
    \endgroup
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\leavevmode}
%    \begin{macrocode}
\DeclareDocumentCommand { \leavevmode } { }
  { \mode_if_vertical:T { \htoks_code:n { \tex_indent:D } } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\set@fontsize}
%   Wrap a \tn{setbox} construction within \cs{htoks_code:n}.  The code
%   for \cs{set@fontsize} is otherwise unchanged.
%    \begin{macrocode}
\cs_set_protected:Npn \set@fontsize #1#2#3
  {
    \@defaultunits \@tempdimb #2pt\relax \@nnil
    \edef \f@size {\strip@pt \@tempdimb }
    \@defaultunits \@tempskipa #3pt\relax \@nnil
    \edef \f@baselineskip {\the \@tempskipa }
    \edef \f@linespread {#1}
    \let \baselinestretch \f@linespread
    \def \size@update
      {
        \baselineskip \f@baselineskip \relax
        \baselineskip \f@linespread \baselineskip
        \normalbaselineskip \baselineskip
        \htoks_code:n
          {
            \setbox \strutbox \hbox
              {
                \vrule \@height .7\baselineskip
                  \@depth .3\baselineskip \@width \z@
              }
          }
        \let \size@update \relax
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fix@penalty, \sw@slant}
%   It is not clear whether something should be inserted in the token
%   list result for the italic correction.
%    \begin{macrocode}
\cs_set_protected:Npn \fix@penalty
  {
    \htoks_code:n
      {
        \ifnum \lastpenalty =\z@
          \@@@@italiccorr
        \else
          \count@ \lastpenalty
          \unpenalty
          \@@@@italiccorr
          \penalty \count@
        \fi
      }
  }
\cs_set_protected:Npn \sw@slant
  {
    \htoks_code:n
      {
        \ifdim \lastskip =\z@
          \fix@penalty
        \else
          \skip@ \lastskip
          \unskip
          \fix@penalty
          \hskip \skip@
        \fi
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\check@nocorr@}
%   The \tn{aftergroup} primitive is not yet implemented.  It should be.
%    \begin{macrocode}
\cs_set_protected:Npn \check@nocorr@ #1#2\nocorr #3\@nil
  {
    \let \check@icl \maybe@ic
    \def \check@icr
      {\ifvmode \else \htoks_code:n { \aftergroup \maybe@ic } \fi }
    \def \reserved@a {\nocorr }
    \def \reserved@b {#1}
    \def \reserved@c {#3}
    \ifx \reserved@a \reserved@b
      \ifx \reserved@c \@empty
        \let \check@icl \@empty
      \else
        \let \check@icl \@empty
        \let \check@icr \@empty
      \fi
    \else
      \ifx \reserved@c \@empty
      \else
        \let \check@icr \@empty
      \fi
    \fi
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\protected@write}
%    \begin{macrocode}
\cs_set_protected:Npn \protected@write #1#2#3
  {
    \begingroup
      \let \thepage \relax
      #2
      \let \protect \@unexpandable@protect
      \edef \reserved@a {\write #1{#3}}
      \htoks_if_parse:TF
        { \htoks_tokens:V { \reserved@a } }
        { }
      \htoks_code:n { \reserved@a }
    \endgroup
    \if@nobreak \ifvmode \nobreak \fi \fi
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
