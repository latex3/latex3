% \iffalse
%
%% File l3kernel-extras.dtx (C) Copyright 2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental add ons to l3file}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3kernel-extras} package\\ Add ons to \pkg{l3file}^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{\pkg{l3kernel-extras} documentation}
%
% \subsection{\pkg{l3skip}}
%
% \begin{function}[EXP]{\skip_abs:n}
%   \begin{syntax}
%     \cs{skip_abs:n} \Arg{skipexpr}
%   \end{syntax}
%   Converts each component (main, shrink, stretch) of the
%   \meta{skipexpr} to its absolute value, leaving the result in the
%   input stream as an \meta{skip denotation}.
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {
%     \skip_compare_main:nNn,
%     \skip_compare_stretch:nNn,
%     \skip_compare_shrink:nNn,
%   }
%   \begin{syntax}
%     \cs{skip_compare_main_p:nNn} \Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2} \\
%     \cs{skip_compare_main:nNnTF}
%     ~~\Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions} as
%   described for \cs{skip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {\skip_compare_main:n, \skip_compare_stretch:n, \skip_compare_shrink:n}
%   \begin{syntax}
%     \cs{skip_compare_main_p:n} \{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \} \\
%     \cs{skip_compare_main:nTF}
%     ~~\{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions} as
%   described for \cs{skip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\skip_compare:nNn}
%   \begin{syntax}
%     \cs{skip_compare_p:nNn} \Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2} \\
%     \cs{skip_compare:nNnTF}
%     ~~\Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions}
%   as described for \cs{skip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\skip_compare:n}
%   \begin{syntax}
%     \cs{skip_compare_p:n} \{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \} \\
%     \cs{skip_compare:nTF}
%     ~~\{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions}
%   as described for \cs{skip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP]{\muskip_abs:n}
%   \begin{syntax}
%     \cs{muskip_abs:n} \Arg{muexpr}
%   \end{syntax}
%   Converts each component (main, shrink, stretch) of the
%   \meta{muexpr} to its absolute value, leaving the result in the
%   input stream as an \meta{muskip denotation}.
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {
%     \muskip_compare_main:nNn,
%     \muskip_compare_stretch:nNn,
%     \muskip_compare_shrink:nNn,
%   }
%   \begin{syntax}
%     \cs{muskip_compare_main_p:nNn} \Arg{muexpr_1} \meta{relation} \Arg{muexpr_2} \\
%     \cs{muskip_compare_main:nNnTF}
%     ~~\Arg{muexpr_1} \meta{relation} \Arg{muexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions} as
%   described for \cs{muskip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {\muskip_compare_main:n, \muskip_compare_stretch:n, \muskip_compare_shrink:n}
%   \begin{syntax}
%     \cs{muskip_compare_main_p:n} \{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \} \\
%     \cs{muskip_compare_main:nTF}
%     ~~\{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions} as
%   described for \cs{muskip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\muskip_compare:nNn}
%   \begin{syntax}
%     \cs{muskip_compare_p:nNn} \Arg{muexpr_1} \meta{relation} \Arg{muexpr_2} \\
%     \cs{muskip_compare:nNnTF}
%     ~~\Arg{muexpr_1} \meta{relation} \Arg{muexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions}
%   as described for \cs{muskip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\muskip_compare:n}
%   \begin{syntax}
%     \cs{muskip_compare_p:n} \{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \} \\
%     \cs{muskip_compare:nTF}
%     ~~\{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions}
%   as described for \cs{muskip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \subsubsection{\pkg{l3tl}}
%
% \begin{function}{\tl_item:nnF, \tl_item:NnF, \tl_item:cnF}
% \end{function}
%
% \subsubsection{\pkg{l3seq} and \pkg{l3clist}}
%
% \begin{function}{\seq_item:nnF, \seq_item:NnF, \seq_item:cnF}
% \end{function}
%
% \begin{function}{\seq_head:N, \seq_head:NF}
%   \begin{syntax}
%     \cs{seq_head:NF} \meta{sequence} \Arg{default value}
%   \end{syntax}
%
% \end{function}
% \begin{function}{\seq_get_head:NN}
% \end{function}
%
% \begin{function}{\seq_get_left:NN}
% \begin{function}[TF]{\seq_get_left:NN}
% \end{function}
% \end{function}
%
% \begin{function}{\seq_get_right:NN}
% \begin{function}[TF]{\seq_get_right:NN}
% \end{function}
% \end{function}
%
% \begin{function}{\seq_get_item:NnN}
% \begin{function}[TF]{\seq_get_item:NnN}
% \end{function}
% \end{function}
%
% \subsection{\pkg{l3prop}}
%
% \begin{function}{\prop_value:Nn, \prop_value:NnF}
% \end{function}
%
% \begin{function}{\prop_get_value:NnN}
% \begin{function}[TF]{\prop_get_value:NnN}
% \end{function}
% \end{function}
%
% \subsection{\pkg{l3basics}}
%
% \begin{function}{\group_insert_after:n, \group_insert_after:x}
%   \begin{syntax}
%     \cs{group_insert_after:n} \Arg{tokens}
%   \end{syntax}
%   Places the \meta{tokens} in the input stream once the current group
%   ends.  If this function is called multiple times, the \meta{tokens}
%   will be inserted in the same order.  Note that a construction such as
%   \begin{verbatim}
%     \tl_set:Nn \l_example_tl { outside }
%     \group_begin:
%       \tl_set:Nn \l_example_tl { inside }
%       \group_insert_after:n { \tl_use:N \l_example_tl }
%     \group_end:
%   \end{verbatim}
%   will use the value of \cs{l_example_tl} when \cs{tl_use:N}, which is
%   outside the group.  Using \cs{group_insert_after:x} would instead
%   use \enquote{\texttt{inside}}.
% \end{function}
%
% \begin{function}{\group_after_set:NNn}
%   \begin{syntax}
%     \cs{group_after_set:NNn} <`set' function> <variable> \Arg{value}
%   \end{syntax}
%   Locally sets the <variable> to some <value> using the specified
%   <`set' function>.  The variable is set up to be locally defined in
%   the group one level higher.  Used as:
%   \begin{verbatim}
%     \group_begin:
%       \group_begin:
%         \group_after_set:NNn \int_set:Nn \y {3}
%         % \y == 3
%       \group_end:
%       % \y == 3
%     \group_end:
%     \y == undefined
%   \end{verbatim}
%   Only variables can be set in this way (e.g., \texttt{tl},
%   \texttt{clist}, \texttt{int}, etc.).  There is not yet an analogous
%   method for functions set with the \cs{cs_set:Npn} family of commands.
% \end{function}
%
% \subsection{\pkg{l3int}}
%
% \begin{function}[EXP]{\int_mul_truncate:nn}
%   \begin{syntax}
%     \cs{int_mult_truncate:Nn} \Arg{intexpr} \Arg{value}
%   \end{syntax}
%   Multiples the <integer expression> by <value>, which may be any real
%   value.  The result is truncated and left in the input stream as an
%   \meta{integer denotation} after two expansions.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3kernel-extras} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%    \end{macrocode}
%
% \subsection{Using sequences, clists, and tls}
%
% \begin{function}[EXP]{\tl_use:Nnnn}
%   \begin{syntax}
%     \cs{tl_use:Nnnn} \meta{tl~var} \Arg{separator~between~two} \Arg{separator~between~more~than~two} \Arg{separator~between~final~two}
%   \end{syntax}
%   Places the contents of the \meta{tl~var} in the input stream, with
%   the appropriate \meta{separator} between the items.  Namely, if the
%   token list has more than $2$ items, the \meta{separator between more
%     than two} is placed between each pair of items except the last,
%   for which the \meta{separator between final two} is used.  If the
%   token list has $2$ items, then they are placed in the input stream
%   separated by the \meta{separator between two}.  If the token list
%   has $1$ item, it is placed in the input stream, and a blank token
%   list produces no output.  An error will be raised if the variable
%   does not exist or if it is invalid.  Items are inserted without
%   their surrounding braces.
%
%   For example,
%   \begin{verbatim}
%     \tl_set:Nn \l_tmpa_tl { a b c {de} f }
%     \tl_use:Nnnn \l_tmpa_tl { ~and~ } { ,~ } { ,~and~ }
%   \end{verbatim}
%   will insert \enquote{\texttt{a, b, c, de, and f}} in the input
%   stream.  The first separator argument is not used in this case
%   because the token list has more than $2$ items.
%   \begin{texnote}
%     The result is returned within the \tn{unexpanded}
%     primitive (\cs{exp_not:n}), which means that the \meta{item}
%     will not expand further when appearing in an \texttt{x}-type
%     argument expansion.
%   \end{texnote}
% \end{function}
%
% \begin{macro}[EXP]{\tl_use:Nnnn}
% \begin{macro}[EXP, aux]
%   {\tl_use_aux:nnn, \tl_use_aux_ii:nnnnnwnwn, \tl_use_aux_iii:nnwn}
%   First check that the variable exists.  Then count the items in the
%   token list.  If it is blank (no items), output nothing.  If it has
%   one item, output that item, brace stripped, and without leading or
%   trailing spaces.  If it has two, place the
%   \meta{separator~between~two} in the middle.  Otherwise,
%   \cs{tl_use_aux_ii:nnnnnwnwn} takes the following arguments: a
%   \meta{separator}, four items from the token list (or quarks), junk,
%   a \meta{continuation} function (\texttt{aux_ii} or \texttt{aux_iii}
%   with its \meta{separator} argument), junk, and the temporary result,
%   which is built in a brace group following \cs{q_stop}.  The first of
%   the four items is placed with the separator in the result, then we
%   use the \meta{continuation}, placing the three items after it.  In
%   the beginning, the four items really belong to the token list, the
%   first \cs{q_mark} is taken as a delimiter to the \texttt{aux_ii}
%   function, and the continuation is \texttt{aux_ii} itself.  When we
%   reach the last two items of the original token list, \cs{q_nil} and
%   \cs{q_mark} are taken as third and fourth items, and now the seconf
%   \cs{q_mark} serves as a delimiter to \texttt{aux_ii}, switching to
%   the other \meta{continuation}, \texttt{aux_iii}, which uses the
%   \meta{separator between final two}.  We need to end the token list
%   with \cs{q_nil} to make sure that using an argument delimited by
%   \cs{q_mark} does not lose the braces of the last item in the token
%   list.
%    \begin{macrocode}
\cs_new:Npn \tl_use:Nnnn #1#2#3#4
  {
    \tl_if_exist:NTF #1
      {
        \int_case:nnn { \tl_count:N #1 }
          {
            { 0 } { }
            { 1 } { \exp_after:wN \tl_use_aux:nnn #1 { } { } }
            { 2 } { \exp_after:wN \tl_use_aux:nnn #1 {#2} }
          }
          {
            \exp_after:wN \tl_use_aux_ii:nnnnnwnwn
            \exp_after:wN { \exp_after:wN } #1 \q_nil
            \q_mark { \tl_use_aux_ii:nnnnnwnwn {#3} }
            \q_mark { \tl_use_aux_iii:nnwn {#4} }
            \q_stop { }
          }
      }
      { \msg_expandable_kernel_error:nnn { kernel } { bad-variable } {#1} }
  }
\cs_new:Npn \tl_use_aux:nnn #1#2#3 { \exp_not:n { #1 #3 #2 } }
\cs_new:Npn \tl_use_aux_ii:nnnnnwnwn
    #1#2#3#4#5#6 \q_mark #7#8 \q_stop #9
  { #7 {#3} {#4} {#5} #6 \q_mark {#7} #8 \q_stop { #9 #1 #2 } }
\cs_new:Npn \tl_use_aux_iii:nnwn #1#2#3 \q_stop #4
  { \exp_not:n { #4 #1 #2 } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\clist_use:Nnnn}
% \begin{macro}[EXP, aux]
%   {\clist_use_aux:wwn, \clist_use_aux_ii:nwwwwnwn, \clist_use_aux_iii:nwwn}
%   See \cs{tl_use:Nnnn} for a general explanation.  Here we add commas
%   at various places.  The main difference is the lack of \cs{q_nil}:
%   the trailing comma already avoids losing braces for the last item.
%    \begin{macrocode}
\cs_new:Npn \clist_use:Nnnn #1#2#3#4
  {
    \clist_if_exist:NTF #1
      {
        \int_case:nnn { \clist_count:N #1 }
          {
            { 0 } { }
            { 1 } { \exp_after:wN \clist_use_aux:wwn #1 , , { } }
            { 2 } { \exp_after:wN \clist_use_aux:wwn #1 , {#2} }
          }
          {
            \exp_after:wN \clist_use_aux_ii:nwwwwnwn
            \exp_after:wN { \exp_after:wN } #1 ,
            \q_mark , { \clist_use_aux_ii:nwwwwnwn {#3} }
            \q_mark , { \clist_use_aux_iii:nwwn {#4} }
            \q_stop { }
          }
      }
      { \msg_expandable_kernel_error:nnn { kernel } { bad-variable } {#1} }
  }
\cs_new:Npn \clist_use_aux:wwn #1 , #2 , #3 { \exp_not:n { #1 #3 #2 } }
\cs_new:Npn \clist_use_aux_ii:nwwwwnwn
    #1#2 , #3 , #4 , #5 \q_mark , #6#7 \q_stop #8
  { #6 {#3} , {#4} , #5 \q_mark , {#6} #7 \q_stop { #8 #1 #2 } }
\cs_new:Npn \clist_use_aux_iii:nwwn #1#2 , #3 \q_stop #4
  { \exp_not:n { #4 #1 #2 } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\seq_use:Nnnn}
% \begin{macro}[EXP, aux]
%   {\seq_use_aux:NnNnn, \seq_use_aux_ii:nwwwwnwn, \seq_use_aux_iii:nwwn}
%   See \cs{tl_use:Nnnn} for a general explanation.  Here we add
%   \cs{seq_item:n} at various places.  The main difference is the lack
%   of \cs{q_nil}, we use instead \cs{seq_item:n}.
%    \begin{macrocode}
\cs_new:Npn \seq_use:Nnnn #1#2#3#4
  {
    \seq_if_exist:NTF #1
      {
        \int_case:nnn { \seq_count:N #1 }
          {
            { 0 } { }
            { 1 } { \exp_after:wN \seq_use_aux:NnNnn #1 \seq_item:n { } { } }
            { 2 } { \exp_after:wN \seq_use_aux:NnNnn #1 {#2} }
          }
          {
            \exp_after:wN \seq_use_aux_ii:nwwwwnwn
            \exp_after:wN { \exp_after:wN } #1 \seq_item:n
            \q_mark { \seq_use_aux_ii:nwwwwnwn {#3} }
            \q_mark { \seq_use_aux_iii:nwwn {#4} }
            \q_stop { }
          }
      }
      { \msg_expandable_kernel_error:nnn { kernel } { bad-variable } {#1} }
  }
\cs_new:Npn \seq_use_aux:NnNnn \seq_item:n #1 \seq_item:n #2#3
  { \exp_not:n { #1 #3 #2 } }
\cs_new:Npn \seq_use_aux_ii:nwwwwnwn
    #1 \seq_item:n #2 \seq_item:n #3 \seq_item:n #4#5
    \q_mark #6#7 \q_stop #8
  {
    #6 \seq_item:n {#3} \seq_item:n {#4} #5
    \q_mark {#6} #7 \q_stop { #8 #1 #2 }
  }
\cs_new:Npn \seq_use_aux_iii:nwwn #1 \seq_item:n #2 #3 \q_stop #4
  { \exp_not:n { #4 #1 #2 } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Additions to \pkg{l3skip}}
%
% \begin{macro}[EXP]{\skip_abs:n}
% \begin{macro}[EXP,aux]{\skip_abs_aux:wwN}
%   Evaluate the \meta{skipexpr}, then remove all |-|.  Namely,
%   \cs{skip_abs_aux:wwN} receives a \meta{skip} followed by some
%   trailing material.  If the \meta{skip} contains a |-| sign, then
%   |#3| is \cs{skip_abs_aux:wwN} itself, and that step of expansion
%   simply removes the |-|, leaving everything else unchanged.  Once
%   there are no more |-| in the \meta{skip}, |#2| and |#3| become
%   empty, and |#1| is our result, followed by \cs{use_none:nn}
%   \cs{scan_stop:} \cs{skip_abs_aux:wwN}. This disappears, and the
%   overall \meta{skipexpr} is closed by \cs{scan_stop:} inserted by our
%   auxiliary.
%    \begin{macrocode}
\cs_new:Npn \skip_abs:n #1
  {
    \skip_use:N \etex_glueexpr:D
      \exp_after:wN \skip_abs_aux:wwN
      \skip_use:N \etex_glueexpr:D #1 \scan_stop:
      \use_none:nn \scan_stop: \skip_abs_aux:wwN
      - \scan_stop: { }
  }
\cs_new:Npn \skip_abs_aux:wwN #1 - #2 \scan_stop: #3
  { #3 #1 #2 \scan_stop: #3 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]
%   {
%     \skip_compare_main:nNn,
%     \skip_compare_stretch:nNn,
%     \skip_compare_shrink:nNn,
%   }
% \begin{macro}[EXP, aux]{\skip_compare_component_aux:wwNNN}
%   Similar to \cs{dim_compare:nNnTF}.  For the main component,
%   \cs{if_dim:w} automatically casts the \meta{skip} to a
%   \meta{dimension}.  For the other components, first we evaluate the
%   glue expressions, then compare the appropriate glue components.
%   Infinite glues complicate the picture: if one of the operands has a
%   higher order infinity than the other, replace the negligible glue by
%   zero.  The use of \cs{etex_glueexpr:D} and \cs{scan_stop:} ensures
%   that the arguments of \cs{if_dim:w} are entirely found before the
%   expansion hits \cs{prg_return_true:}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \skip_compare_main:nNn #1#2#3 { p , T , F , TF }
  {
    \if_dim:w \etex_glueexpr:D #1 #2 \etex_glueexpr:D #3 \scan_stop:
      \prg_return_true: \else: \prg_return_false: \fi:
  }
\prg_new_conditional:Npnn \skip_compare_stretch:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_glueexpr:D #3 ;
      #2
      \etex_gluestretchorder:D
      \etex_gluestretch:D
  }
\prg_new_conditional:Npnn \skip_compare_shrink:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_glueexpr:D #3 ;
      #2
      \etex_glueshrinkorder:D
      \etex_glueshrink:D
  }
\cs_new:Npn \skip_compare_component_aux:wwNNN #1;#2;#3#4#5
  {
    \if_dim:w
        \if_int_compare:w #4#1<#4#2
          \c_zero_dim
        \else:
          #5 \etex_glueexpr:D #1 \scan_stop:
        \fi:
        #3
        \if_int_compare:w #4#1>#4#2
          \c_zero_dim
        \else:
          #5 \etex_glueexpr:D #2 \scan_stop:
        \fi:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\skip_compare:nNn}
% \begin{macro}[EXP, aux]{\skip_compare_aux:wwN, \skip_compare_aux_ii:wwN}
%   Goal: compare $a\ \mathtt{plus}\ b\ \mathtt{minus}\ c$ with $a'\
%   \mathtt{plus}\ b'\ \mathtt{minus}\ c'$.  Those are equal if and only
%   if $a=a'$, $b=b'$ and $c=c'$.  The first is less than the second if
%   and only if $a<a'$, $|b|<|b'|$, and $|c'|<|c|$.
%    \begin{macrocode}
\prg_new_conditional:Npnn \skip_compare:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_aux:wwN
      \skip_use:N \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_glueexpr:D #3 ;
      #2
  }
\cs_new:Npn \skip_compare_aux:wwN #1; #2; #3
  {
    \if_charcode:w = #3
      \str_if_eq_x_return:nn {#1} {#2}
    \else:
      \if_dim:w \etex_glueexpr:D #1 #3 \etex_glueexpr:D #2 \scan_stop:
        \exp_after:wN \skip_compare_aux_ii:wwN
          \skip_use:N \etex_glueexpr:D \skip_abs:n {#1} \exp_after:wN ;
          \skip_use:N \etex_glueexpr:D \skip_abs:n {#2} ;
          #3
      \else:
        \prg_return_false:
      \fi:
    \fi:
  }
\cs_new:Npn \skip_compare_aux_ii:wwN #1;#2;#3
  {
    \skip_compare_stretch:nNnTF {#2} #3 {#1}
      { \prg_return_false: }
      {
        \skip_compare_shrink:nNnTF {#1} #3 {#2}
          { \prg_return_false: }
          { \prg_return_true: }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\muskip_abs:n}
%   This relies on the same auxiliary as \cs{skip_abs:n}.  See this
%   function for an explanation of the code.
%    \begin{macrocode}
\cs_new:Npn \muskip_abs:n #1
  {
    \muskip_use:N \etex_muexpr:D
      \exp_after:wN \skip_abs_aux:wwN
      \muskip_use:N \etex_muexpr:D #1 \scan_stop:
      \use_none:nn \scan_stop: \skip_abs_aux:wwN
      - \scan_stop: { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,pTF]
%   {
%     \muskip_compare_main:nNn,
%     \muskip_compare_stretch:nNn,
%     \muskip_compare_shrink:nNn,
%   }
%   Those functions are based on the same auxiliaries as their
%   \texttt{skip} counterparts, but mu expressions must be converted to
%   glue using the \eTeX{} primitive \tn{mutoglue}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \muskip_compare_main:nNn #1#2#3 { p , T , F , TF }
  {
    \if_dim:w \etex_mutoglue:D \etex_muexpr:D #1
           #2 \etex_mutoglue:D \etex_muexpr:D #3 \scan_stop:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\prg_new_conditional:Npnn \muskip_compare_stretch:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_mutoglue:D \etex_muexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_mutoglue:D #3 ;
      #2
      \etex_gluestretchorder:D
      \etex_gluestretch:D
  }
\prg_new_conditional:Npnn \muskip_compare_shrink:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_mutoglue:D \etex_muexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_mutoglue:D \etex_muexpr:D #3 ;
      #2
      \etex_glueshrinkorder:D
      \etex_glueshrink:D
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\muskip_compare:nNn}
%   This function uses the same auxiliaries as \cs{skip_compare:nNn},
%   first converting the mu units to points.
%    \begin{macrocode}
\prg_new_conditional:Npnn \muskip_compare:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_aux:wwN
      \skip_use:N \etex_mutoglue:D \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_mutoglue:D \etex_glueexpr:D #3 ;
      #2
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{\pkg{l3basics}}
%
% \begin{macro}{\group_insert_after:n, \group_insert_after:x}
% \begin{macro}[EXP]{\group_insert_after_aux:NNn}
%   The material to insert at the end of a given group is stored in a
%   global variable, whose name is built from the
%   \tn{currentgrouplevel}.  We build the variable's name once, then
%   feed it to an auxiliary.  First make sure the variable exists by
%   defining it if needed.  If it is empty, this is the first time
%   \cs{group_insert_after:n} is called in this group.  Use the \TeX{}
%   primitive \tn{aftergroup} to insert that token list, which is
%   initialized to clear itself (emptyness is used as a flag).  Finally
%   append the new material to the token list being inserted.
%    \begin{macrocode}
\cs_new_protected:Npn \group_insert_after:n
  {
    \exp_args:NNc \group_insert_after_aux:NNn \tl_gput_right:Nn
      { g_group_after_ \int_use:N \etex_currentgrouplevel:D _tl }
  }
\cs_new_protected:Npn \group_insert_after:x
  {
    \exp_args:NNc \group_insert_after_aux:NNn \tl_gput_right:Nx
      { g_group_after_ \int_use:N \etex_currentgrouplevel:D _tl }
  }
\cs_new_protected:Npn \group_insert_after_aux:NNn #1#2#3
  {
    \tl_if_exist:NF #2 { \tl_new:N #2 }
    \tl_if_empty:NT #2
      {
        \tex_aftergroup:D #2
        \tl_gset:Nn #2 { \tl_gclear:N #2 }
      }
    #1 #2 {#3}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\group_insert_after:N, \group_insert_after:c}
%   We cannot define \cs{group_insert_after:N} directly as the \TeX{}
%   primitive \tn{aftergroup}, because the order would not be preserved
%   between tokens inserted with the \texttt{n}-type variant and the
%   \texttt{N}-type variant.  Instead, we simply copy the definition of
%   the \texttt{n}-type function.
%    \begin{macrocode}
\cs_gset_eq:NN \group_insert_after:N \group_insert_after:n
\cs_generate_variant:Nn \group_insert_after:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\group_after_set:NNn}
%   A bad name that allows local variables to \enquote{escape} out of
%   the current group.  (Without being global.)  Set the variable
%   locally for use inside the group, then after the group place the
%   assignment and the value of the variable.  We don't use |#3| as a
%   value, because this may involve functions or variables which are
%   only defined in the group.
%    \begin{macrocode}
\cs_new_protected:Npn \group_after_set:NNn #1#2#3
  {
    #1 #2 {#3}
    \group_insert_after:x { \exp_not:n { #1 #2 } { \exp_not:V #2 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{\pkg{l3int}}
%
% \begin{macro}{\int_mul_truncate:nn}
%   Analogous to and more useful than \cs{int_div_truncate:nn}.  Uses
%   the integer representation of lengths in \texttt{sp} for the
%   calculation.  Since we cannot have fractional amounts of an
%   \texttt{sp}, we must define |#1| to be the integer expression to be
%   multiplied, and |#2| to be the (real) scaling factor.
%    \begin{macrocode}
\cs_new:Npn \int_mul_truncate:nn #1 #2
  {
    \__int_value:w
      \dim_eval:w
        #2 \dim_eval:w \__int_eval:w #1 \__int_eval_end: sp \dim_eval_end:
      \dim_eval_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Optimizations for \pkg{l3seq} }
%
% The idea here is that most modules could gain a factor of $2$ in
% speed, but at the price of having obfuscated code.  So those
% optimizations shall wait until we have a better idea of what are the
% bottlenecks in a \LaTeX3 format.
%
% \begin{macro}{\seq_pop_left:NN, \seq_pop_left:cN}
% \UnitTested
% \begin{macro}{\seq_gpop_left:NN, \seq_gpop_left:cN}
% \UnitTested
% \begin{macro}[aux]{\seq_pop_left_aux:NNN}
% \begin{macro}[aux]{\seq_pop_left_aux:NNNn}
%    \begin{macrocode}
\cs_gset_protected_nopar:Npn \seq_pop_left:NN
  { \seq_pop_left_aux:NNN \tex_edef:D }
\cs_gset_protected_nopar:Npn \seq_gpop_left:NN
  { \seq_pop_left_aux:NNN \tex_xdef:D }
\cs_gset_protected:Npn \seq_pop_left_aux:NNN #1#2#3
  {
    \tex_edef:D #3
      {
        \if_meaning:w #2 \c_empty_tl
          \exp_not:N \q_no_value
        \else:
          \if_false: { \fi:
            \exp_after:wN \seq_pop_left_aux:NNNn
            \exp_after:wN #1
            \exp_after:wN #2
            #2
          }
        \fi:
      }
  }
\cs_gset:Npn \seq_pop_left_aux:NNNn #1#2 \seq_item:n #3
  {
    \exp_not:n {#3} \if_false: { \fi: }
    #1 #2 { \etex_unexpanded:D \exp_after:wN { \if_false: } } \fi:
  }
\cs_generate_variant:Nn \seq_pop_left:NN  { c }
\cs_generate_variant:Nn \seq_gpop_left:NN { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{For deprecated commands}
%
% \begin{macro}{\cs_deprecated_used:}
%   This macro is undefined at the beginning of the \TeX{} run, and is
%   set to be equal to \cs{scan_stop:} as soon as a deprecated function
%   is used.
% \end{macro}
%
% \begin{variable}{\g_cs_deprecated_functions_tl}
%   A list of all deprecated functions in \LaTeX3.
%    \begin{macrocode}
\tl_new:N \g_cs_deprecated_functions_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\cs_gset_removal_date:nn, \cs_gset_protected_removal_date:nn}
%   Those functions mark every function in their arguments (either all
%   expandable or all protected) as deprecated at the given date.
%    \begin{macrocode}
\cs_new_protected:Npn \cs_gset_removal_date:nn #1#2
  {
    \tl_map_inline:nn {#1}
      {
        \tl_gput_right:Nn \g_cs_deprecated_functions_tl { ##1 }
        \tl_const:cn { g_cs_deprecated_ \cs_to_str:N ##1 _date_tl } {#2}
        \cs_new_eq:cN { cs_deprecated_ \cs_to_str:N ##1 } ##1
        \cs_gset_nopar:Npx ##1
          {
            \exp_not:n { \exp_args:Nc \use_none:n }
              { cs_used_ \exp_not:n { \cs_to_str:N ##1 } }
            \exp_not:n { \exp_args:Nc \use_none:n }
              { cs_used: }
            \exp_not:c { cs_deprecated_ \cs_to_str:N ##1 }
          }
      }
  }
\cs_new_protected:Npn \cs_gset_protected_removal_date:nn #1#2
  {
    \tl_map_inline:nn {#1}
      {
        \tl_gput_right:Nn \g_cs_deprecated_functions_tl { ##1 }
        \tl_const:cn { g_cs_deprecated_ \cs_to_str:N ##1 _date_tl } {#2}
        \cs_gset_eq:cN { cs_deprecated_ \cs_to_str:N ##1 } ##1
        \cs_gset_protected_nopar:Npx ##1
          {
            \cs_gset_eq:cN
              { cs_used_ \exp_not:N \cs_to_str:N ##1 } \scan_stop:
            \cs_gset_eq:cN { cs_used: } \scan_stop:
            \exp_not:c { cs_deprecated_ \cs_to_str:N ##1 }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% At the end of the \TeX{} go through the list of all deprecated
% functions, checking if they were used, and displaying those that were,
% with the date.
%    \begin{macrocode}
\cs_new_protected:Npn \cs_deprecated_check:
  {
    \tl_gset:Nx \g_cs_deprecated_functions_tl
      {
        \tl_map_function:NN \g_cs_deprecated_functions_tl
          \cs_deprecated_check_aux:N
      }
    \tl_if_empty:NF \g_cs_deprecated_functions_tl
      {
        \iow_term:x
          {
            The~ following~ deprecated~ functions~ were~ used~ in~ this~ run.
            \g_cs_deprecated_functions_tl
          }
      }
  }
\cs_new:Npn \cs_deprecated_check_aux:N #1
  {
    \if_cs_exist:w cs_used_ \cs_to_str:N #1 \cs_end:
      \iow_newline: > ~
      \token_to_str:N #1 ~ => ~
      \tl_use:c { g_cs_deprecated_ \cs_to_str:N #1 _date_tl }
    \fi:
  }
\AtEndDocument { \cs_deprecated_check: }
%    \end{macrocode}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex