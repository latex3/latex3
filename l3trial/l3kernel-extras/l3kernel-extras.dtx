% \iffalse
%
%% File l3kernel-extras.dtx (C) Copyright 2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental add ons to l3file}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3kernel-extras} package\\ Add ons to \pkg{l3file}^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{\pkg{l3kernel-extras} documentation}
%
% \subsection{\pkg{l3skip}}
%
% \begin{function}[EXP]{\skip_abs:n}
%   \begin{syntax}
%     \cs{skip_abs:n} \Arg{skipexpr}
%   \end{syntax}
%   Converts each component (main, shrink, stretch) of the
%   \meta{skipexpr} to its absolute value, leaving the result in the
%   input stream as an \meta{skip denotation}.
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {
%     \skip_compare_main:nNn,
%     \skip_compare_stretch:nNn,
%     \skip_compare_shrink:nNn,
%   }
%   \begin{syntax}
%     \cs{skip_compare_main_p:nNn} \Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2} \\
%     \cs{skip_compare_main:nNnTF}
%     ~~\Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions} as
%   described for \cs{skip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {\skip_compare_main:n, \skip_compare_stretch:n, \skip_compare_shrink:n}
%   \begin{syntax}
%     \cs{skip_compare_main_p:n} \{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \} \\
%     \cs{skip_compare_main:nTF}
%     ~~\{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions} as
%   described for \cs{skip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\skip_compare:nNn}
%   \begin{syntax}
%     \cs{skip_compare_p:nNn} \Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2} \\
%     \cs{skip_compare:nNnTF}
%     ~~\Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions}
%   as described for \cs{skip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\skip_compare:n}
%   \begin{syntax}
%     \cs{skip_compare_p:n} \{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \} \\
%     \cs{skip_compare:nTF}
%     ~~\{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions}
%   as described for \cs{skip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP]{\muskip_abs:n}
%   \begin{syntax}
%     \cs{muskip_abs:n} \Arg{muexpr}
%   \end{syntax}
%   Converts each component (main, shrink, stretch) of the
%   \meta{muexpr} to its absolute value, leaving the result in the
%   input stream as an \meta{muskip denotation}.
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {
%     \muskip_compare_main:nNn,
%     \muskip_compare_stretch:nNn,
%     \muskip_compare_shrink:nNn,
%   }
%   \begin{syntax}
%     \cs{muskip_compare_main_p:nNn} \Arg{muexpr_1} \meta{relation} \Arg{muexpr_2} \\
%     \cs{muskip_compare_main:nNnTF}
%     ~~\Arg{muexpr_1} \meta{relation} \Arg{muexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions} as
%   described for \cs{muskip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {\muskip_compare_main:n, \muskip_compare_stretch:n, \muskip_compare_shrink:n}
%   \begin{syntax}
%     \cs{muskip_compare_main_p:n} \{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \} \\
%     \cs{muskip_compare_main:nTF}
%     ~~\{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions} as
%   described for \cs{muskip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\muskip_compare:nNn}
%   \begin{syntax}
%     \cs{muskip_compare_p:nNn} \Arg{muexpr_1} \meta{relation} \Arg{muexpr_2} \\
%     \cs{muskip_compare:nNnTF}
%     ~~\Arg{muexpr_1} \meta{relation} \Arg{muexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions}
%   as described for \cs{muskip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\muskip_compare:n}
%   \begin{syntax}
%     \cs{muskip_compare_p:n} \{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \} \\
%     \cs{muskip_compare:nTF}
%     ~~\{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions}
%   as described for \cs{muskip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \subsubsection{\pkg{l3tl}}
%
% \begin{function}{\tl_item:nnF, \tl_item:NnF, \tl_item:cnF}
% \end{function}
%
% \subsubsection{\pkg{l3seq} and \pkg{l3clist}}
%
% \begin{function}{\seq_item:nnF, \seq_item:NnF, \seq_item:cnF}
% \end{function}
%
% \begin{function}{\seq_head:N, \seq_head:NF}
%   \begin{syntax}
%     \cs{seq_head:NF} \meta{sequence} \Arg{default value}
%   \end{syntax}
%
% \end{function}
% \begin{function}{\seq_get_head:NN}
% \end{function}
%
% \begin{function}{\seq_get_left:NN}
% \begin{function}[TF]{\seq_get_left:NN}
% \end{function}
% \end{function}
%
% \begin{function}{\seq_get_right:NN}
% \begin{function}[TF]{\seq_get_right:NN}
% \end{function}
% \end{function}
%
% \begin{function}{\seq_get_item:NnN}
% \begin{function}[TF]{\seq_get_item:NnN}
% \end{function}
% \end{function}
%
% \subsection{\pkg{l3prop}}
%
% \begin{function}{\prop_value:Nn, \prop_value:NnF}
% \end{function}
%
% \begin{function}{\prop_get_value:NnN}
% \begin{function}[TF]{\prop_get_value:NnN}
% \end{function}
% \end{function}
%
% \subsection{\pkg{l3basics}}
%
% \begin{function}{\group_after_set:NNn}
% \begin{syntax}
% "\group_after_set:NNn" <`set' function> <variable> \Arg{value}
% \end{syntax}
% Locally sets the <variable> to some <value> using the specified <`set' function>.
% The variable is set up to be locally defined in the group one level higher.
% Used as:
% \begin{verbatim}
%   \group_begin:
%     \group_begin:
%       \group_after_set:NNn \int_set:Nn \y {3}
%       % \y == 3
%     \group_end:
%     % \y == 3
%   \group_end:
%   \y == undefined
% \end{verbatim}
% Only variables can be set in this way (e.g., \texttt{tl}, \texttt{clist}, \texttt{int}, etc.).
% There is not yet an analogous method for functions set with the "\cs_set:Npn" family of commands.
% \end{function}
%
% \subsection{\pkg{l3int}}
%
% \begin{function}[EXP]{\int_mul_truncate:nn}
% \begin{syntax}
% "\int_mult_truncate:Nn" \Arg{integer expr.} \Arg{value}
% \end{syntax}
% Multiples the <integer expr.> by <value>, which may be any real value.
% The result is truncated and left in the input stream after two expansions.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3kernel-extras} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%    \end{macrocode}
%
% \begin{macro}[EXP]{\skip_abs:n}
% \begin{macro}[EXP,aux]{\skip_abs_aux:wwN}
%   Evaluate the \meta{skipexpr}, then remove all |-|.  Namely,
%   \cs{skip_abs_aux:wwN} receives a \meta{skip} followed by some
%   trailing material.  If the \meta{skip} contains a |-| sign, then
%   |#3| is \cs{skip_abs_aux:wwN} itself, and that step of expansion
%   simply removes the |-|, leaving everything else unchanged.  Once
%   there are no more |-| in the \meta{skip}, |#2| and |#3| become
%   empty, and |#1| is our result, followed by \cs{use_none:nn}
%   \cs{scan_stop:} \cs{skip_abs_aux:wwN}. This disappears, and the
%   overall \meta{skipexpr} is closed by \cs{scan_stop:} inserted by our
%   auxiliary.
%    \begin{macrocode}
\cs_new:Npn \skip_abs:n #1
  {
    \skip_use:N \etex_glueexpr:D
      \exp_after:wN \skip_abs_aux:wwN
      \skip_use:N \etex_glueexpr:D #1 \scan_stop:
      \use_none:nn \scan_stop: \skip_abs_aux:wwN
      - \scan_stop: { }
  }
\cs_new:Npn \skip_abs_aux:wwN #1 - #2 \scan_stop: #3
  { #3 #1 #2 \scan_stop: #3 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]
%   {
%     \skip_compare_main:nNn,
%     \skip_compare_stretch:nNn,
%     \skip_compare_shrink:nNn,
%   }
% \begin{macro}[EXP, aux]{\skip_compare_component_aux:wwNNN}
%   Similar to \cs{dim_compare:nNnTF}.  For the main component,
%   \cs{if_dim:w} automatically casts the \meta{skip} to a
%   \meta{dimension}.  For the other components, first we evaluate the
%   glue expressions, then compare the appropriate glue components.
%   Infinite glues complicate the picture: if one of the operands has a
%   higher order infinity than the other, replace the negligible glue by
%   zero.  The use of \cs{etex_glueexpr:D} and \cs{scan_stop:} ensures
%   that the arguments of \cs{if_dim:w} are entirely found before the
%   expansion hits \cs{prg_return_true:}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \skip_compare_main:nNn #1#2#3 { p , T , F , TF }
  {
    \if_dim:w \etex_glueexpr:D #1 #2 \etex_glueexpr:D #3 \scan_stop:
      \prg_return_true: \else: \prg_return_false: \fi:
  }
\prg_new_conditional:Npnn \skip_compare_stretch:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_glueexpr:D #3 ;
      #2
      \etex_gluestretchorder:D
      \etex_gluestretch:D
  }
\prg_new_conditional:Npnn \skip_compare_shrink:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_glueexpr:D #3 ;
      #2
      \etex_glueshrinkorder:D
      \etex_glueshrink:D
  }
\cs_new:Npn \skip_compare_component_aux:wwNNN #1;#2;#3#4#5
  {
    \if_dim:w
        \if_num:w #4#1<#4#2
          \c_zero_dim
        \else:
          #5 \etex_glueexpr:D #1 \scan_stop:
        \fi:
        #3
        \if_num:w #4#1>#4#2
          \c_zero_dim
        \else:
          #5 \etex_glueexpr:D #2 \scan_stop:
        \fi:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\skip_compare:nNn}
% \begin{macro}[EXP, aux]{\skip_compare_aux:wwN, \skip_compare_aux_ii:wwN}
%   Goal: compare $a\ \mathtt{plus}\ b\ \mathtt{minus}\ c$ with $a'\
%   \mathtt{plus}\ b'\ \mathtt{minus}\ c'$.  Those are equal if and only
%   if $a=a'$, $b=b'$ and $c=c'$.  The first is less than the second if
%   and only if $a<a'$, $|b|<|b'|$, and $|c'|<|c|$.
%    \begin{macrocode}
\prg_new_conditional:Npnn \skip_compare:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_aux:wwN
      \skip_use:N \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_glueexpr:D #3 ;
      #2
  }
\cs_new:Npn \skip_compare_aux:wwN #1; #2; #3
  {
    \if_charcode:w = #3
      \str_if_eq_return:xx {#1} {#2}
    \else:
      \if_dim:w \etex_glueexpr:D #1 #3 \etex_glueexpr:D #2 \scan_stop:
        \exp_after:wN \skip_compare_aux_ii:wwN
          \skip_use:N \etex_glueexpr:D \skip_abs:n {#1} \exp_after:wN ;
          \skip_use:N \etex_glueexpr:D \skip_abs:n {#2} ;
          #3
      \else:
        \prg_return_false:
      \fi:
    \fi:
  }
\cs_new:Npn \skip_compare_aux_ii:wwN #1;#2;#3
  {
    \skip_compare_stretch:nNnTF {#2} #3 {#1}
      { \prg_return_false: }
      {
        \skip_compare_shrink:nNnTF {#1} #3 {#2}
          { \prg_return_false: }
          { \prg_return_true: }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\muskip_abs:n}
%   This relies on the same auxiliary as \cs{skip_abs:n}.  See this
%   function for an explanation of the code.
%    \begin{macrocode}
\cs_new:Npn \muskip_abs:n #1
  {
    \muskip_use:N \etex_muexpr:D
      \exp_after:wN \skip_abs_aux:wwN
      \muskip_use:N \etex_muexpr:D #1 \scan_stop:
      \use_none:nn \scan_stop: \skip_abs_aux:wwN
      - \scan_stop: { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,pTF]
%   {
%     \muskip_compare_main:nNn,
%     \muskip_compare_stretch:nNn,
%     \muskip_compare_shrink:nNn,
%   }
%   Those functions are based on the same auxiliaries as their
%   \texttt{skip} counterparts, but mu expressions must be converted to
%   glue using the \eTeX{} primitive \tn{mutoglue}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \muskip_compare_main:nNn #1#2#3 { p , T , F , TF }
  {
    \if_dim:w \etex_mutoglue:D \etex_muexpr:D #1
           #2 \etex_mutoglue:D \etex_muexpr:D #3 \scan_stop:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\prg_new_conditional:Npnn \muskip_compare_stretch:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_mutoglue:D \etex_muexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_mutoglue:D #3 ;
      #2
      \etex_gluestretchorder:D
      \etex_gluestretch:D
  }
\prg_new_conditional:Npnn \muskip_compare_shrink:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_mutoglue:D \etex_muexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_mutoglue:D \etex_muexpr:D #3 ;
      #2
      \etex_glueshrinkorder:D
      \etex_glueshrink:D
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\muskip_compare:nNn}
%   This function uses the same auxiliaries as \cs{skip_compare:nNn},
%   first converting the mu units to points.
%    \begin{macrocode}
\prg_new_conditional:Npnn \muskip_compare:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_aux:wwN
      \skip_use:N \etex_mutoglue:D \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_mutoglue:D \etex_glueexpr:D #3 ;
      #2
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{\pkg{l3basics}}
%
% \begin{macro}{\group_after_set:NNn}
% A bad name that allows local variables to `escape' out of the current group.
% (Without being global.)
%    \begin{macrocode}
\cs_new:Nn \group_after_set:NNn
{
%    \end{macrocode}
% Set the variable locally for use inside the group:
%    \begin{macrocode}
  #1 #2 {#3}
%    \end{macrocode}
% 
%    \begin{macrocode}
  \cs_if_exist:cF { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
    {
      \tl_new:c { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
    }
%    \end{macrocode}
% For the first time the function is executed inside the group,
% set up |\group_insert_after:N| to insert a token list which
% is initialised to clear itself (being clear used as a flag).
%    \begin{macrocode}
  \tl_if_empty:vT { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
    {
      \group_insert_after:c
        { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }

      \tl_gset:cx { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
        {
          \tl_gclear:c { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
        }
    }
%    \end{macrocode}
% Finally append the new material to the token list being inserted:
%    \begin{macrocode}
  \tl_gput_right:cx
    { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
    {
      \exp_not:n { #1 #2 } { \exp_not:V #2 }
    }
}
%    \end{macrocode}
% 
%    \begin{macrocode}
\cs_generate_variant:Nn \group_insert_after:N {c}
%    \end{macrocode}
% \end{macro}
%
% \subsection{\pkg{l3int}}
%
% \begin{macro}{\int_mul_truncate:nn}
% Analogous to and more useful than "\int_div_truncate:nn".
% Uses the integer representation of lengths in "sp" for the calculation.
% Since we cannot have fractional amounts of an "sp", we must define "#1" to be the integer expression to be multiplied, and "#2" to be the (real) scaling factor.
%    \begin{macrocode}
\cs_set:Npn \int_mul_truncate:nn #1 #2
  {
    \int_use:N \int_eval:w
      \dim_eval:w
        #2 \dim_eval:w \int_eval:w #1 \int_eval_end: sp \dim_eval_end:
      \dim_eval_end:
    \int_eval_end:
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex