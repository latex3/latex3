% \iffalse
%
%% File l3kernel-extras.dtx (C) Copyright 2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental add ons to l3file}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3kernel-extras} package\\ Add ons to \pkg{l3file}^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{\pkg{l3kernel-extras} documentation}
%
% \subsection{Expandable warnings}
%
% \begin{function}[int, EXP]
%   {
%     \__msg_kernel_expandable_warning:nnnnnn,
%     \__msg_kernel_expandable_warning:nnnnn,
%     \__msg_kernel_expandable_warning:nnnn,
%     \__msg_kernel_expandable_warning:nnn,
%     \__msg_kernel_expandable_warning:nn
%   }
%   \begin{syntax}
%     \cs{__msg_kernel_expandable_warning:nnnnnn} \Arg{module} \Arg{message} \Arg{arg one} \Arg{arg two} \Arg{arg three} \Arg{arg four}
%   \end{syntax}
%   Issues a warning, passing \meta{arg one} to \meta{arg four}
%   to the text-creating functions. The resulting string must
%   be shorter than a line, otherwise it will be cropped.
% \end{function}
%
% \begin{function}[int, EXP]{\__msg_expandable_warning:n}
%   \begin{syntax}
%     \cs{__msg_expandable_warning:n} \Arg{warning message}
%   \end{syntax}
%   Issues an \enquote{end of file when \tn{if} is incomplete} warning
%   from \eTeX{} itself, and prints the \meta{warning message}. The
%   \meta{warning message} must be short: it is cropped at the end of
%   one line.
% \end{function}
%
% \subsection{Support for detecting deprecated functions}
%
% \begin{function}[int]{\__cs_protected_deprecated:N}
%   \begin{syntax}
%     \cs{__cs_protected_deprecated:N} \meta{control sequence}
%   \end{syntax}
%   Triggers a warning or error with the name of the \meta{control
%     sequence} which is deprecated.
% \end{function}
%
% \begin{function}[int, EXP]{\__cs_deprecated:N}
%   \begin{syntax}
%     \cs{__cs_deprecated:N} \meta{control sequence}
%   \end{syntax}
%   Triggers an expandable warning or error with the name of the
%   \meta{control sequence} which is deprecated.
% \end{function}
%
% \subsection{\pkg{l3basics}}
%
% \begin{function}{\group_insert_after:n, \group_insert_after:x}
%   \begin{syntax}
%     \cs{group_insert_after:n} \Arg{tokens}
%   \end{syntax}
%   Places the \meta{tokens} in the input stream once the current group
%   ends.  If this function is called multiple times, the \meta{tokens}
%   will be inserted in the same order.  Note that a construction such as
%   \begin{verbatim}
%     \tl_set:Nn \l_example_tl { outside }
%     \group_begin:
%       \tl_set:Nn \l_example_tl { inside }
%       \group_insert_after:n { \tl_use:N \l_example_tl }
%     \group_end:
%   \end{verbatim}
%   will use the value of \cs{l_example_tl} when \cs{tl_use:N}, which is
%   outside the group.  Using \cs{group_insert_after:x} would instead
%   use \enquote{\texttt{inside}}.
% \end{function}
%
% \begin{function}{\group_insert_after:N}
%   This function (currently a copy of \tn{aftergroup}, should be
%   redefined to be a copy of \cs{group_insert_after:n} (see
%   implementation section for reasons).
% \end{function}
%
% \begin{function}{\group_after_set:NNn}
%   \begin{syntax}
%     \cs{group_after_set:NNn} <`set' function> <variable> \Arg{value}
%   \end{syntax}
%   Locally sets the <variable> to some <value> using the specified
%   <`set' function>.  The variable is set up to be locally defined in
%   the group one level higher.  Used as:
%   \begin{verbatim}
%     \group_begin:
%       \group_begin:
%         \group_after_set:NNn \int_set:Nn \y {3}
%         % \y == 3
%       \group_end:
%       % \y == 3
%     \group_end:
%     \y == undefined
%   \end{verbatim}
%   Only variables can be set in this way (e.g., \texttt{tl},
%   \texttt{clist}, \texttt{int}, etc.).  There is not yet an analogous
%   method for functions set with the \cs{cs_set:Npn} family of commands.
% \end{function}
%
% \subsection{\pkg{l3int}}
%
% \begin{function}[EXP]{\int_mul_truncate:nn}
%   \begin{syntax}
%     \cs{int_mult_truncate:Nn} \Arg{intexpr} \Arg{value}
%   \end{syntax}
%   Multiples the <integer expression> by <value>, which may be any real
%   value.  The result is truncated and left in the input stream as an
%   \meta{integer denotation} after two expansions.
% \end{function}
%
% \subsection{\pkg{l3token}}
%
% \begin{function}[EXP]{\char_category_name:N, \char_category_name:n}
%   \begin{syntax}
%     \cs{char_category_name:N} \meta{char}
%     \cs{char_category_name:N} |\|\meta{char}
%     \cs{char_category_name:n} \Arg{intexpr}
%   \end{syntax}
%   Expands to the category name, one of |escape|, |group_begin|,
%   |group_end|, |math_toggle|, |alignment|, |end_line|, |parameter|,
%   |superscript|, |subscript|, |ignore|, |space|, |letter|, |other|,
%   |active|, |comment|, |invalid|.
% \end{function}
%
% \begin{function}{\char_show:N, \char_show:n}
%   \begin{syntax}
%     \cs{char_show:N} \meta{char}
%     \cs{char_show:N} |\|\meta{char}
%     \cs{char_show:n} \Arg{intexpr}
%   \end{syntax}
%   Shows information about the character, given either as an explicit
%   character token, as a one-character control sequence, or as its
%   character code \meta{intexpr}.
% \end{function}
%
% \subsection{\pkg{l3skip}}
%
% \begin{function}[EXP]{\skip_abs:n}
%   \begin{syntax}
%     \cs{skip_abs:n} \Arg{skipexpr}
%   \end{syntax}
%   Converts each component (main, shrink, stretch) of the
%   \meta{skipexpr} to its absolute value, leaving the result in the
%   input stream as an \meta{skip denotation}.
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {
%     \skip_compare_main:nNn,
%     \skip_compare_stretch:nNn,
%     \skip_compare_shrink:nNn,
%   }
%   \begin{syntax}
%     \cs{skip_compare_main_p:nNn} \Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2} \\
%     \cs{skip_compare_main:nNnTF}
%     ~~\Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions} as
%   described for \cs{skip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {\skip_compare_main:n, \skip_compare_stretch:n, \skip_compare_shrink:n}
%   \begin{syntax}
%     \cs{skip_compare_main_p:n} \{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \} \\
%     \cs{skip_compare_main:nTF}
%     ~~\{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions} as
%   described for \cs{skip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\skip_compare:nNn}
%   \begin{syntax}
%     \cs{skip_compare_p:nNn} \Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2} \\
%     \cs{skip_compare:nNnTF}
%     ~~\Arg{skipexpr_1} \meta{relation} \Arg{skipexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions}
%   as described for \cs{skip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\skip_compare:n}
%   \begin{syntax}
%     \cs{skip_compare_p:n} \{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \} \\
%     \cs{skip_compare:nTF}
%     ~~\{ \meta{skipexpr1} \meta{relation} \meta{skipexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{skip expressions}
%   as described for \cs{skip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP]{\muskip_abs:n}
%   \begin{syntax}
%     \cs{muskip_abs:n} \Arg{muexpr}
%   \end{syntax}
%   Converts each component (main, shrink, stretch) of the
%   \meta{muexpr} to its absolute value, leaving the result in the
%   input stream as an \meta{muskip denotation}.
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {
%     \muskip_compare_main:nNn,
%     \muskip_compare_stretch:nNn,
%     \muskip_compare_shrink:nNn,
%   }
%   \begin{syntax}
%     \cs{muskip_compare_main_p:nNn} \Arg{muexpr_1} \meta{relation} \Arg{muexpr_2} \\
%     \cs{muskip_compare_main:nNnTF}
%     ~~\Arg{muexpr_1} \meta{relation} \Arg{muexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions} as
%   described for \cs{muskip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {\muskip_compare_main:n, \muskip_compare_stretch:n, \muskip_compare_shrink:n}
%   \begin{syntax}
%     \cs{muskip_compare_main_p:n} \{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \} \\
%     \cs{muskip_compare_main:nTF}
%     ~~\{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions} as
%   described for \cs{muskip_eval:n}. The appropriate components (main,
%   stretch or shrink) of the two results are then compared using the
%   \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\muskip_compare:nNn}
%   \begin{syntax}
%     \cs{muskip_compare_p:nNn} \Arg{muexpr_1} \meta{relation} \Arg{muexpr_2} \\
%     \cs{muskip_compare:nNnTF}
%     ~~\Arg{muexpr_1} \meta{relation} \Arg{muexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions}
%   as described for \cs{muskip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\muskip_compare:n}
%   \begin{syntax}
%     \cs{muskip_compare_p:n} \{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \} \\
%     \cs{muskip_compare:nTF}
%     ~~\{ \meta{muexpr1} \meta{relation} \meta{muexpr2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{muskip expressions}
%   as described for \cs{muskip_eval:n}. The two results are then
%   compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \subsubsection{Miscellaneous proposals}
%
% [Old thoughts; I'm not sorting those, so we may have already added
% some of the functions mentionned here.]
%
% Change the first argument of the conditional-defining commands to be
% of \texttt{n}-type, such that
% \begin{quote}
%   \cs{prg_new_conditional:npnn} |{ cs_if_exist:N } #1 { TF }| \Arg{code}
% \end{quote}
% defines \cs{cs_if_exist:NTF}.
%
% Introduce \cs{prg_new_conditionals:Npn} which defines all $4$
% conditionals (\texttt{TF}, \texttt{T}, \texttt{F}, and \texttt{p}),
% and \cs{prg_new_protected_conditionals:Npn}, which defines the first
% $3$ only (since predicates can't be protected).  With the proposal
% above, the \texttt{N} argument would be \texttt{n}, but the two
% proposals are orthogonal.
%
% Check that packages are loaded at $\tn{currentgrouplevel}=0$, for
% example by adding
% \begin{verbatim}
%   \int_compare:nNnF \etex_currentgrouplevel:D = \c_zero
%     {
%       \__msg_kernel_error:nnnnnn
%         { kernel } { package-in-group } {#1} {#2} {#3} {#4}
%       \tex_endinput:D
%     }
% \end{verbatim}
% to the definition of \cs{ProvidesExplPackage} and
% \cs{ProvidesExplClass}.  Well, really, this \enquote{error} should be
% \enquote{critical} (which includes the \tn{endinput}), but since for
% some reason we don't provide a kernel critical error, let it be.
%
% We could add
% \begin{itemize}
% \item \cs{tl_item:NnF}, \cs{tl_item:cnF}, \cs{tl_item:nnF}, where the
%   last argument is used when the token list doesn't have such an item;
% \item \cs{seq_item:NnF}, \cs{seq_item:cnF};
% \item \cs{seq_head:N}, \cs{seq_head:NF};
% \item \cs{seq_get_head:NN};
% \item \cs{seq_get_left:NN}, \cs{seq_get_left:NNTF};
% \item \cs{seq_get_right:NN}, \cs{seq_get_right:NNTF};
% \item \cs{seq_get_item:NnN}, \cs{seq_get_item:NnNTF};
% \item \cs{seq_replace_all:Nnn} \meta{seq} \Arg{old item} \Arg{new
%     item} (and the \texttt{once} version);
% \item \cs{seq_put:Nnn} \meta{seq} \Arg{position} \meta{replacement item}
% \item \cs{seq_insert:Nnn} \meta{seq} \Arg{position} \meta{inserted
%     item}, makes the sequence one item longer;
% \item \cs{seq_pop_item:NnN} \meta{seq} \Arg{position} \meta{tl}
%   removes the item at \meta{position} from the sequence, and stores it
%   in the \meta{tl}.
% \end{itemize}
% Potentially some of the \pkg{l3seq} function could be added to
% \pkg{l3clist} too.
%
% For \pkg{l3prop},
% \begin{itemize}
% \item \cs{prop_value:Nn}, \cs{prop_value:NnF}
% \item \cs{prop_get_value:NnN}, \cs{prop_get_value:NnNTF}.
% \end{itemize}
%
% Add \texttt{const} for all datatypes:
% \begin{itemize}
%   \item \cs{seq_const:Nn}, \cs{prop_const:Nn}, what should the
%     \texttt{n} argument contain?
%   \item \cs{bool_const:Nn} may be somewhat useless.
%   \item \cs{hbox_const:Nn}, \cs{vbox_const:Nn}
%   \item \cs{hcoffin_const:Nn}, \cs{vcoffin_const:Nn}
%   \item \cs{ior_const:Nn}, \cs{iow_const:Nn} probably bad since we
%     have very few streams available.
%   \item \cs{cctab_const:Nn}
%   \item \cs{token_const:Nn} odd one, note that the current
%     \cs{token_new:Nn} is used purely as \cs{token_const:Nn} in
%     \pkg{l3kernel}.
% \end{itemize}
%
% Add \texttt{concat} or similar for all datatypes where it might
% potentially make sense:
% \begin{itemize}
%   \item \cs{hbox_concat:NNN}, \cs{vbox_concat:NNN}
%   \item \cs{hcoffin_concat:NNN}, \cs{vcoffin_concat:NNN}
%   \item \cs{prop_join:NNN} (or concat? but here duplicate keys must be
%     resolved)
%   \item \cs{file_concat:nnn}.
% \end{itemize}
%
% Add \cs{DeclareDocumentShortHand} (or simply \cs{DeclareShortHand}) as
% a synonym for \cs{tl_set:Nn}.  Perhaps \texttt{Shorthand} rather than
% \texttt{ShortHand}?
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3kernel-extras} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%    \end{macrocode}
%
% \subsection{Expandable warnings}
%
% We already know how to get expandable errors (see
% \cs{__msg_expandable_error:n}).  It turns out that \eTeX{}'s
% \cs{tracingnesting} can be abused to produce custom warnings
% expandably.
%
%    \begin{macrocode}
\int_gset:Nn \etex_tracingnesting:D { 2 }
%    \end{macrocode}
%
% \begin{macro}[EXP]{\__msg_expandable_warning:n}
% \begin{macro}[aux, EXP]
%   {\__msg_expandable_warning_aux:nn, \__msg_expandable_warning_loop:n}
%   The idea is to use the warnings that \eTeX{} produces when a
%   conditional is ended in a different file than where it was started.
%   Build a file using \cs{etex_scantokens:D}, with essentially
%   \tn{inputlineno} empty lines, followed by a line with the string
%   \texttt{LaTeX3 warning:} followed by the warning message.  This
%   \cs{etex_scantokens:D} is expanded before the previous \cs{if:w},
%   hence the \cs{if:w} starts within the new file, but does not have a
%   line number (since it was not input in that file): those properties
%   make the \eTeX{} warning shorter.
%
%   We need to get rid of the contents of the file.  A simple
%   \cs{use_none_delimit_by_q_recursion_stop:w} would fail since there
%   is an end-of-file marker at the end of the \cs{etex_scantokens:D}
%   file.  Instead, we read the contents as for a token list mapping,
%   with an additional \cs{exp_not:N}, inserted there to prevent the
%   end-of-file marker from making \cs{etex_scantokens:D} choke.  The
%   warning is in fact produced when \cs{exp_not:N} goes beyond the
%   end-of-file marker (hence acting on the following quark).
%    \begin{macrocode}
\cs_new_nopar:Npn \__msg_expandable_warning:n
  {
    \exp_args:Nf \__msg_expandable_warning_aux:nn
      {
        \exp_args:Nno \prg_replicate:nn
          { \int_max:nn { \c_zero } { \tex_inputlineno:D - \c_two } }
          { \iow_newline: }
      }
  }
\cs_new:Npn \__msg_expandable_warning_aux:nn #1#2
  {
    \exp_after:wN \if:w
    \exp_after:wN ?
    \exp_after:wN ?
    \exp_after:wN \__msg_expandable_warning_loop:n
    \etex_scantokens:D { #1 LaTeX3 ~ warning: ~ #2 }
      \q_recursion_tail \q_recursion_stop
    \fi:
  }
\cs_new:Npn \__msg_expandable_warning_loop:n #1
  {
    \quark_if_recursion_tail_stop:n {#1}
    \exp_after:wN \__msg_expandable_warning_loop:n \exp_not:N
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {
%     \__msg_kernel_expandable_warning:nnnnnn,
%     \__msg_kernel_expandable_warning:nnnnn,
%     \__msg_kernel_expandable_warning:nnnn,
%     \__msg_kernel_expandable_warning:nnn,
%     \__msg_kernel_expandable_warning:nn
%   }
%   The command built from the csname
%   |\c__msg_text_prefix_tl LaTeX / #1 / #2|
%   takes four arguments and builds the warning text, which is fed to
%   \cs{__msg_expandable_warning:n}.
%    \begin{macrocode}
\cs_new:Npn \__msg_kernel_expandable_warning:nnnnnn #1#2#3#4#5#6
  {
    \exp_args:Nf \__msg_expandable_warning:n
      {
        \exp_args:NNc \exp_after:wN \exp_stop_f:
          { \c__msg_text_prefix_tl LaTeX / #1 / #2 }
          {#3} {#4} {#5} {#6}
      }
  }
\cs_new:Npn \__msg_kernel_expandable_warning:nnnnn #1#2#3#4#5
  {
    \__msg_kernel_expandable_warning:nnnnnn
      {#1} {#2} {#3} {#4} {#5} { }
  }
\cs_new:Npn \__msg_kernel_expandable_warning:nnnn #1#2#3#4
  {
    \__msg_kernel_expandable_warning:nnnnnn
      {#1} {#2} {#3} {#4} { } { }
  }
\cs_new:Npn \__msg_kernel_expandable_warning:nnn #1#2#3
  {
    \__msg_kernel_expandable_warning:nnnnnn
      {#1} {#2} {#3} { } { } { }
  }
\cs_new:Npn \__msg_kernel_expandable_warning:nn #1#2
  {
    \__msg_kernel_expandable_warning:nnnnnn
      {#1} {#2} { } { } { } { }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{For deprecated commands}
%
% \begin{variable}{\l__expl_deprecated_error_bool}
%   Boolean variable which controls if deprecated functions trigger an
%   error or simply a warning.  We should add an option to \pkg{expl3}
%   to control that boolean.  By default, warnings.
%    \begin{macrocode}
\bool_new:N \l__expl_deprecated_error_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\__cs_protected_deprecated:N}
%   In format mode, deprecated functions produce a warning.  In package
%   mode, it can be a warning or an error.
%    \begin{macrocode}
\cs_new_protected:Npn \__cs_protected_deprecated:N #1
  {
%<*package>
    \bool_if:NTF \l__expl_deprecated_error_bool
      \__msg_kernel_error:nnn
%</package>
      \__msg_kernel_warning:nnn
        { kernel } { deprecated-function } { \token_to_str:N #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\__cs_deprecated:N}
%   The same for expandable functions.
%    \begin{macrocode}
\cs_new:Npn \__cs_deprecated:N #1
  {
%<*package>
    \bool_if:NTF \l__expl_deprecated_error_bool
      \__msg_kernel_expandable_error:nnn
%</package>
      \__msg_kernel_expandable_warning:nnn
        { kernel } { expandable-deprecated-function } {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% Two messages (probably requires improvements).
%    \begin{macrocode}
\__msg_kernel_new:nnn { kernel } { deprecated-function }
  { The~function~#1~is~deprecated. }
\__msg_kernel_new:nnn { kernel } { expandable-deprecated-function }
  { #1 deprecated. }
%    \end{macrocode}
%
% Redefine a bunch of deprecated commands from \pkg{l3kernel} to make
% use of \cs{__cs_deprecated:N} and \cs{__cs_protected_deprecated:N}.
%    \begin{macrocode}
\tl_map_inline:nn
  { \tl_length:n \l_tmpc_int \msg_term:x }
  {
    \cs_new_eq:cN { __cs_deprecated_ \cs_to_str:N #1 } #1
    \bool_if:nTF
      {
        \token_if_protected_macro_p:N #1
        || \token_if_protected_long_macro_p:N #1
      }
      {
        \cs_gset_protected_nopar:Npx #1
          {
            \exp_not:N \__cs_protected_deprecated:N \exp_not:N #1
            \exp_not:c { __cs_deprecated_ \cs_to_str:N #1 }
          }
      }
      {
        \cs_gset_nopar:Npx #1
          {
            \exp_not:N \__cs_deprecated:N \exp_not:N #1
            \exp_not:c { __cs_deprecated_ \cs_to_str:N #1 }
          }
      }
  }
%    \end{macrocode}
%
% \subsection{\pkg{l3basics}}
%
% \begin{macro}{\group_insert_after:n, \group_insert_after:x}
% \begin{macro}[EXP]{\__group_insert_after:NNn}
%   The material to insert at the end of a given group is stored in a
%   global variable, whose name is built from the
%   \tn{currentgrouplevel}.  We build the variable's name once, then
%   feed it to an auxiliary.  First make sure the variable exists by
%   defining it if needed.  If it is empty, this is the first time
%   \cs{group_insert_after:n} is called in this group.  Use the \TeX{}
%   primitive \tn{aftergroup} to insert that token list, which is
%   initialized to clear itself (emptyness is used as a flag).  Finally
%   append the new material to the token list being inserted.
%    \begin{macrocode}
\cs_new_protected:Npn \group_insert_after:n
  {
    \exp_args:NNc \__group_insert_after:NNn \tl_gput_right:Nn
      { g_group_after_ \int_use:N \etex_currentgrouplevel:D _tl }
  }
\cs_new_protected:Npn \group_insert_after:x
  {
    \exp_args:NNc \__group_insert_after:NNn \tl_gput_right:Nx
      { g_group_after_ \int_use:N \etex_currentgrouplevel:D _tl }
  }
\cs_new_protected:Npn \__group_insert_after:NNn #1#2#3
  {
    \tl_if_exist:NF #2 { \tl_new:N #2 }
    \tl_if_empty:NT #2
      {
        \tex_aftergroup:D #2
        \tl_gset:Nn #2 { \tl_gclear:N #2 }
      }
    #1 #2 {#3}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\group_insert_after:N, \group_insert_after:c}
%   We cannot define \cs{group_insert_after:N} directly as the \TeX{}
%   primitive \tn{aftergroup}, because the order would not be preserved
%   between tokens inserted with the \texttt{n}-type variant and the
%   \texttt{N}-type variant.  Instead, we simply copy the definition of
%   the \texttt{n}-type function.
%    \begin{macrocode}
\cs_gset_eq:NN \group_insert_after:N \group_insert_after:n
\cs_generate_variant:Nn \group_insert_after:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\group_after_set:NNn}
%   A bad name that allows local variables to \enquote{escape} out of
%   the current group.  (Without being global.)  Set the variable
%   locally for use inside the group, then after the group place the
%   assignment and the value of the variable.  We don't use |#3| as a
%   value, because this may involve functions or variables which are
%   only defined in the group.
%    \begin{macrocode}
\cs_new_protected:Npn \group_after_set:NNn #1#2#3
  {
    #1 #2 {#3}
    \group_insert_after:x { \exp_not:n { #1 #2 } { \exp_not:V #2 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{\pkg{l3int}}
%
% \begin{macro}{\int_mul_truncate:nn}
%   Analogous to and more useful than \cs{int_div_truncate:nn}.  Uses
%   the integer representation of lengths in \texttt{sp} for the
%   calculation.  Since we cannot have fractional amounts of an
%   \texttt{sp}, we must define |#1| to be the integer expression to be
%   multiplied, and |#2| to be the (real) scaling factor.
%    \begin{macrocode}
\cs_new:Npn \int_mul_truncate:nn #1 #2
  {
    \__int_value:w
      \__dim_eval:w
        #2 \__dim_eval:w \__int_eval:w #1 \__int_eval_end: sp \__dim_eval_end:
      \__dim_eval_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{\pkg{l3token}}
%
% \begin{macro}[EXP]{\char_category_name:N, \char_category_name:n}
%   Use \cs{int_case:nnn} to expand to the correct character category
%   name.
%    \begin{macrocode}
\cs_new:Npn \char_category_name:N #1
  { \char_category_name:n { `#1 } }
\cs_new:Npn \char_category_name:n #1
  {
    \int_case:nnn { \char_value_catcode:n {#1} }
      {
        {  0 } { escape }
        {  1 } { group_begin }
        {  2 } { group_end }
        {  3 } { math_toggle }
        {  4 } { alignment }
        {  5 } { end_line }
        {  6 } { parameter }
        {  7 } { math_superscript }
        {  8 } { math_subscript }
        {  9 } { ignore }
        { 10 } { space }
        { 11 } { letter }
        { 12 } { other }
        { 13 } { active }
        { 14 } { comment }
        { 15 } { invalid }
      }
      { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\char_show:N, \char_show:n}
% \begin{macro}[aux]{\__char_show:N}
% \begin{macro}[aux, EXP]
%   {\__char_show_code:n, \__char_show_p:n, \__char_if_in_font:nNTF}
%    \begin{macrocode}
\int_new:N \l__char_code_int
\tl_new:N \l__char_lowercase_tl
\tl_new:N \l__char_uppercase_tl
\cs_new_protected:Npn \char_show:N #1 { \char_show:n { `#1 } }
\group_begin:
  \char_set_catcode_other:n { 0 }
  \cs_new_protected:Npn \char_show:n #1
    {
      \int_set:Nn \l__char_code_int {#1}
      \group_begin:
      \tex_lccode:D \c_zero = \l__char_code_int
      \tl_to_lowercase:n
        {
          \group_end:
          \__char_show:N ^^@
        }
    }
\group_end:
\cs_new_protected:Npn \__char_show:N #1
  {
    \group_begin:
      \cs_set_eq:NN \ \c_space_tl
      \cs_set:Npn \\ { \iow_newline: > ~ }
      \tl_to_lowercase:n { \tl_set:Nn \l__char_lowercase_tl {#1} }
      \tl_to_uppercase:n { \tl_set:Nn \l__char_uppercase_tl {#1} }
      \tl_set:Nx \l__char_internal_tl
        {
          \\ category \
          \char_category_name:n { \l__char_code_int } \
          ( \char_value_catcode:n { \l__char_code_int } )
        }
      \tl_put_right:Nx \l__char_internal_tl
        {
          \\ lowercase \
          \l__char_lowercase_tl \
          ( \char_value_lccode:n { \l__char_code_int } )
        }
      \tl_put_right:Nx \l__char_internal_tl
        {
          \\ uppercase \
          \l__char_uppercase_tl \
          ( \char_value_uccode:n { \l__char_code_int } )
        }
      \tl_put_right:Nx \l__char_internal_tl
        {
          \\ space ~ factor \
          \char_value_sfcode:n { \l__char_code_int }
        }
      \tl_put_right:Nx \l__char_internal_tl
        {
          \\ math ~ code \
          " \int_to_hexadecimal:n { \tex_mathcode:D \l__char_code_int }
          \int_compare:nT { \tex_mathcode:D \l__char_code_int = "8000 }
            { ~ ( math ~ active ) }
        }
      \tl_put_right:Nx \l__char_internal_tl
        {
          \int_compare:nTF { \tex_delcode:D \l__char_code_int = -1 }
            { \\ not ~ a ~ delimiter }
            {
              \\ delimiter ~ code \
              " \int_to_hexadecimal:n { \tex_delcode:D \l__char_code_int }
            }
        }
      \__char_if_in_font:nNTF \l__char_code_int \tex_font:D
        {
          \tl_put_right:Nx \l__char_internal_tl
            {
              \\ size ~ in ~ current ~ font:
              \iow_newline: \ \ \ \
              ht~\tex_the:D \etex_fontcharht:D \tex_font:D \l__char_code_int , \
              wd~\tex_the:D \etex_fontcharwd:D \tex_font:D \l__char_code_int , \
              dp~\tex_the:D \etex_fontchardp:D \tex_font:D \l__char_code_int , \
              ic~\tex_the:D \etex_fontcharic:D \tex_font:D \l__char_code_int
            }
        }
        {
          \tl_put_right:Nx \l__char_internal_tl
            { \\ not ~ in ~ current ~ font }
        }
      \int_compare:nF { \__char_show_code:n { ef } = \c_zero }
        {
          \tl_put_right:Nx \l__char_internal_tl
            {
              \\ expansion ~ factor \
              \__char_show_code:n { ef }
            }
        }
      \bool_if:nF { \__char_show_p:n { lp } && \__char_show_p:n { rp } }
        {
          \tl_put_right:Nx \l__char_internal_tl
            {
              \\ protrusion: \
              left ~ margin ~ \__char_show_code:n { lp } , \
              right ~ margin ~ \__char_show_code:n { rp }
            }
        }
      \bool_if:nF
        {
          \__char_show_p:n { knbs }
          && \__char_show_p:n { stbs }
          && \__char_show_p:n { shbs }
        }
        {
          \tl_put_right:Nx \l__char_internal_tl
            {
              \\ bscodes: \
              \__char_show_code:n { knbs } \
              plus ~ \__char_show_code:n { stbs } \
              minus ~ \__char_show_code:n { shbs }
            }
        }
      \bool_if:nF { \__char_show_p:n { knbc } && \__char_show_p:n { knac } }
        {
          \tl_put_right:Nx \l__char_internal_tl
            {
              \\ knccodes: \
              before ~ \__char_show_code:n { knbc } , \
              after ~ \__char_show_code:n { knac }
            }
        }
      \tl_put_right:Nx \l__char_internal_tl
        { \\ tagcode ~ \__char_show_code:n { tag } }
      \__msg_term:nnn { LaTeX / kernel } { show-char } {#1}
      \__msg_show_variable:x { \l__char_internal_tl }
    \group_end:
  }
\cs_new:Npn \__char_show_p:n #1
  { \int_compare_p:n { \__char_show_code:n {#1} = \c_zero } }
\cs_new:Npn \__char_show_code:n #1
  {
    \tex_the:D
      \cs_if_exist_use:cF { pdftex_#1code:D }
        { \cs_if_exist_use:cF { #1 code } { \c_zero \use_none:nn } }
      \tex_font:D \l__char_code_int
  }
\prg_new_conditional:Npnn \__char_if_in_font:nN #1#2 { TF }
  {
    \etex_iffontchar:D #2 \__int_eval:w #1 \__int_eval_end:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\__msg_kernel_new:nnn { kernel } { show-char }
  {
    The ~ character ~ '#1' ~ has ~ character ~ code ~
    \int_use:N \l__char_code_int , ~ and ~ properties
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Additions to \pkg{l3skip}}
%
% \begin{macro}[EXP]{\skip_abs:n}
% \begin{macro}[EXP,aux]{\skip_abs_aux:wwN}
%   Evaluate the \meta{skipexpr}, then remove all |-|.  Namely,
%   \cs{skip_abs_aux:wwN} receives a \meta{skip} followed by some
%   trailing material.  If the \meta{skip} contains a |-| sign, then
%   |#3| is \cs{skip_abs_aux:wwN} itself, and that step of expansion
%   simply removes the |-|, leaving everything else unchanged.  Once
%   there are no more |-| in the \meta{skip}, |#2| and |#3| become
%   empty, and |#1| is our result, followed by \cs{use_none:nn}
%   \cs{scan_stop:} \cs{skip_abs_aux:wwN}. This disappears, and the
%   overall \meta{skipexpr} is closed by \cs{scan_stop:} inserted by our
%   auxiliary.
%    \begin{macrocode}
\cs_new:Npn \skip_abs:n #1
  {
    \skip_use:N \etex_glueexpr:D
      \exp_after:wN \skip_abs_aux:wwN
      \skip_use:N \etex_glueexpr:D #1 \scan_stop:
      \use_none:nn \scan_stop: \skip_abs_aux:wwN
      - \scan_stop: { }
  }
\cs_new:Npn \skip_abs_aux:wwN #1 - #2 \scan_stop: #3
  { #3 #1 #2 \scan_stop: #3 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]
%   {
%     \skip_compare_main:nNn,
%     \skip_compare_stretch:nNn,
%     \skip_compare_shrink:nNn,
%   }
% \begin{macro}[EXP, aux]{\skip_compare_component_aux:wwNNN}
%   Similar to \cs{dim_compare:nNnTF}.  For the main component,
%   \cs{if_dim:w} automatically casts the \meta{skip} to a
%   \meta{dimension}.  For the other components, first we evaluate the
%   glue expressions, then compare the appropriate glue components.
%   Infinite glues complicate the picture: if one of the operands has a
%   higher order infinity than the other, replace the negligible glue by
%   zero.  The use of \cs{etex_glueexpr:D} and \cs{scan_stop:} ensures
%   that the arguments of \cs{if_dim:w} are entirely found before the
%   expansion hits \cs{prg_return_true:}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \skip_compare_main:nNn #1#2#3 { p , T , F , TF }
  {
    \if_dim:w \etex_glueexpr:D #1 #2 \etex_glueexpr:D #3 \scan_stop:
      \prg_return_true: \else: \prg_return_false: \fi:
  }
\prg_new_conditional:Npnn \skip_compare_stretch:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_glueexpr:D #3 ;
      #2
      \etex_gluestretchorder:D
      \etex_gluestretch:D
  }
\prg_new_conditional:Npnn \skip_compare_shrink:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_glueexpr:D #3 ;
      #2
      \etex_glueshrinkorder:D
      \etex_glueshrink:D
  }
\cs_new:Npn \skip_compare_component_aux:wwNNN #1;#2;#3#4#5
  {
    \if_dim:w
        \if_int_compare:w #4#1<#4#2
          \c_zero_dim
        \else:
          #5 \etex_glueexpr:D #1 \scan_stop:
        \fi:
        #3
        \if_int_compare:w #4#1>#4#2
          \c_zero_dim
        \else:
          #5 \etex_glueexpr:D #2 \scan_stop:
        \fi:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\skip_compare:nNn}
% \begin{macro}[EXP, aux]{\__skip_compare:wwN, \__skip_compare_ii:wwN}
%   Goal: compare $a\ \mathtt{plus}\ b\ \mathtt{minus}\ c$ with $a'\
%   \mathtt{plus}\ b'\ \mathtt{minus}\ c'$.  Those are equal if and only
%   if $a=a'$, $b=b'$ and $c=c'$.  The first is less than the second if
%   and only if $a<a'$, $|b|<|b'|$, and $|c'|<|c|$.
%    \begin{macrocode}
\prg_new_conditional:Npnn \skip_compare:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \__skip_compare:wwN
      \skip_use:N \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_glueexpr:D #3 ;
      #2
  }
\cs_new:Npn \__skip_compare:wwN #1; #2; #3
  {
    \if_charcode:w = #3
      \__str_if_eq_x_return:nn {#1} {#2}
    \else:
      \if_dim:w \etex_glueexpr:D #1 #3 \etex_glueexpr:D #2 \scan_stop:
        \exp_after:wN \__skip_compare_ii:wwN
          \skip_use:N \etex_glueexpr:D \skip_abs:n {#1} \exp_after:wN ;
          \skip_use:N \etex_glueexpr:D \skip_abs:n {#2} ;
          #3
      \else:
        \prg_return_false:
      \fi:
    \fi:
  }
\cs_new:Npn \__skip_compare_ii:wwN #1;#2;#3
  {
    \skip_compare_stretch:nNnTF {#2} #3 {#1}
      { \prg_return_false: }
      {
        \skip_compare_shrink:nNnTF {#1} #3 {#2}
          { \prg_return_false: }
          { \prg_return_true: }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\muskip_abs:n}
%   This relies on the same auxiliary as \cs{skip_abs:n}.  See this
%   function for an explanation of the code.
%    \begin{macrocode}
\cs_new:Npn \muskip_abs:n #1
  {
    \muskip_use:N \etex_muexpr:D
      \exp_after:wN \skip_abs_aux:wwN
      \muskip_use:N \etex_muexpr:D #1 \scan_stop:
      \use_none:nn \scan_stop: \skip_abs_aux:wwN
      - \scan_stop: { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,pTF]
%   {
%     \muskip_compare_main:nNn,
%     \muskip_compare_stretch:nNn,
%     \muskip_compare_shrink:nNn,
%   }
%   Those functions are based on the same auxiliaries as their
%   \texttt{skip} counterparts, but mu expressions must be converted to
%   glue using the \eTeX{} primitive \tn{mutoglue}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \muskip_compare_main:nNn #1#2#3 { p , T , F , TF }
  {
    \if_dim:w \etex_mutoglue:D \etex_muexpr:D #1
           #2 \etex_mutoglue:D \etex_muexpr:D #3 \scan_stop:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\prg_new_conditional:Npnn \muskip_compare_stretch:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_mutoglue:D \etex_muexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_mutoglue:D #3 ;
      #2
      \etex_gluestretchorder:D
      \etex_gluestretch:D
  }
\prg_new_conditional:Npnn \muskip_compare_shrink:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \skip_compare_component_aux:wwNNN
      \skip_use:N \etex_mutoglue:D \etex_muexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_mutoglue:D \etex_muexpr:D #3 ;
      #2
      \etex_glueshrinkorder:D
      \etex_glueshrink:D
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\muskip_compare:nNn}
%   This function uses the same auxiliaries as \cs{skip_compare:nNn},
%   first converting the mu units to points.
%    \begin{macrocode}
\prg_new_conditional:Npnn \muskip_compare:nNn #1#2#3 { p , T , F , TF }
  {
    \exp_after:wN \__skip_compare:wwN
      \skip_use:N \etex_mutoglue:D \etex_glueexpr:D #1 \exp_after:wN ;
      \skip_use:N \etex_mutoglue:D \etex_glueexpr:D #3 ;
      #2
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Optimizations for \pkg{l3seq} }
%
% The idea here is that most modules could gain a factor of $2$ in
% speed, but at the price of having obfuscated code.  So those
% optimizations shall wait until we have a better idea of what are the
% bottlenecks in a \LaTeX3 format.
%
% \begin{macro}{\seq_pop_left:NN, \seq_pop_left:cN}
% \UnitTested
% \begin{macro}{\seq_gpop_left:NN, \seq_gpop_left:cN}
% \UnitTested
% \begin{macro}[aux]{\seq_pop_left_aux:NNN}
% \begin{macro}[aux]{\seq_pop_left_aux:NNNn}
%    \begin{macrocode}
\cs_gset_protected_nopar:Npn \seq_pop_left:NN
  { \seq_pop_left_aux:NNN \tex_edef:D }
\cs_gset_protected_nopar:Npn \seq_gpop_left:NN
  { \seq_pop_left_aux:NNN \tex_xdef:D }
\cs_gset_protected:Npn \seq_pop_left_aux:NNN #1#2#3
  {
    \tex_edef:D #3
      {
        \if_meaning:w #2 \c_empty_tl
          \exp_not:N \q_no_value
        \else:
          \if_false: { \fi:
            \exp_after:wN \seq_pop_left_aux:NNNn
            \exp_after:wN #1
            \exp_after:wN #2
            #2
          }
        \fi:
      }
  }
\cs_gset:Npn \seq_pop_left_aux:NNNn #1#2 \__seq_item:n #3
  {
    \exp_not:n {#3} \if_false: { \fi: }
    #1 #2 { \etex_unexpanded:D \exp_after:wN { \if_false: } } \fi:
  }
\cs_generate_variant:Nn \seq_pop_left:NN  { c }
\cs_generate_variant:Nn \seq_gpop_left:NN { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex