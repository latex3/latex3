% \iffalse meta-comment
%
%% File: l3fp-parse.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{l3fp-new}
\GetIdInfo$Id$
  {L3 Experimental floating-point expression parsing}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\usepackage{l3fp-new}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-parse} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Floating point expression parsing}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released \filedate}
%
% \maketitle
% \tableofcontents
%
%^^A To typeset the examples of expansion control, I'm using a hand-made
%^^A environment.
% \newcommand{\fpOperation}[1]
%   {\textcolor[rgb]{.6,.2,.2}{\ttfamily#1}}
% \newcommand{\fpPrecedence}[1]
%   {\textcolor[rgb]{.2,.2,.6}{\ttfamily#1}}
% \newcommand{\fpExpand}[2]
%   {\underline{\textcolor{red}{#1{#2}}}}
% \newenvironment{l3fp-code-example}
%   {\begin{quote}^^A
%       \edef\^{\string^}^^A
%       \let\*\fpExpand
%       \let\o\fpOperation
%       \let\p\fpPrecedence
%       \def\!{\begingroup\def\!{\endgroup\par}\color[gray]{0.5}}^^A
%       \ttfamily\frenchspacing
%   }{\end{quote}}
%
% \begin{documentation}
%
% \section{Evaluating an expression}
%
% \begin{function}[EXP]{\fp_parse:n}
%   \begin{syntax}
%     \cs{fp_parse:n} \Arg{floating point expression}
%   \end{syntax}
%   This \texttt{f}-expands to the internal floating point number
%   obtained by evaluating the \meta{floating point expression}.  During
%   this evaluation, each token is fully \texttt{f}-expanded.
%   \begin{texnote}
%     Registers (integers, toks, etc.) are automatically unpacked,
%     without requiring a function such as \cs{int_use:N}. Invalid
%     tokens remaining after \texttt{f}-expansion will lead to
%     unrecoverable low-level TeX errors.\footnote{Bruno: describe what
%       happens in cases like $2\cs{c_three} = 6$. (In fact, not yet.)}
%   \end{texnote}
% \end{function}
%
% \section{Work plan}\label{subsec:fp-parse-workplan}
%
% The task at hand is non-trivial, and some previous failed attempts have
% shown me that the code ends up giving unreadable logs, so we'd better get
% it (almost) right the first time. Let us thus first discuss precisely
% the design before starting to write the code. To simplify matters,
% we first consider expressions with integers only.
%
% \subsection{Storing results}
%
% The main issue in parsing expressions expandably is: \enquote{where
%   in the input stream should the result be put?}
%
% One option is to place the result at the end of the expression,
% but this has several drawbacks:
% \begin{itemize}
% \item firstly it means that for long expressions we would be reaching
%   all the way to the end of the expression at every step of the
%   calculation, which can be rather expensive;
% \item secondly, when parsing parenthesized sub-expressions, we would
%   naturally place the result after the corresponding closing parenthesis.
%   But since \cs{fp_parse:n} does not assume that its argument is expanded,
%   this closing parenthesis may be hidden in a macro, and not present yet,
%   causing havoc.
% \end{itemize}
%
% The other natural option is to store the result at the start of the
% expression, and carry it as an argument of each macro. This does not
% really work either: in order to expand what follows on the input stream,
% we need to skip at each step over all the tokens in the result using
% \cs{exp_after:wN}. But this requires adding many \cs{exp_after:wN} to
% the result at each step, also an expensive process.
%
% Hence, we need to go for some fine expansion control: the result is
% stored \emph{before} the start\ldots{} A toy model that illustrates this
% idea is to try and add some positive integers which may be hidden
% within macros, or registers. Assume that one number has already been
% found, and that we want to parse the next number. The current status
% of the code may look as follows.
% \begin{quote}\ttfamily
%   \cs{exp_after:wN} \cs{add:ww}
%   \cs{int_value:w} 12345 \cs{exp_after:wN} ; \newline
%   \cs{tex_romannumeral:D} -`0 \cs{clean:w} \meta{stuff}
% \end{quote}
% Hitting this construction by one step of expansion expands
% \cs{exp_after:wN}, which triggers the primitive \cs{int_value:w},
% which reads an integer, \texttt{12345}. This integer is unfinished,
% causing the second \cs{exp_after:wN} to expand, and trigger
% the construction \cs{tex_romannumeral:D} |-`0|, which f-expands
% \cs{clean:w} (see \pkg{l3expan.dtx} for an explanation). Assume
% then that \cs{clean:w} is such that it expands \meta{stuff} to
% \emph{e.g.}, |333444;|. Once \cs{clean:w} is done expanding, we
% will obtain essentially
% \begin{quote}\ttfamily
%   \cs{exp_after:wN} \cs{add:ww} \cs{int_value:w} 12345 ; 333444 ;
% \end{quote}
% where in fact \cs{exp_after:wN} has already been expanded, and
% \cs{int_value:w} has already seen \texttt{12345}. Now,
% \cs{int_value:w} sees the \texttt{;}, and stops expanding, and
% we are left with
% \begin{quote}\ttfamily
%   \cs{add:ww} 12345 ; 333444 ;
% \end{quote}
% which can safely perform the addition by grabbing two arguments
% delimited by \texttt{;}.
%
% On this toy example, we could note that if we were to continue
% parsing the expression, then the following number should also
% be cleaned up before the next use of a binary operation such as
% \cs{add:ww}. Just like \cs{int_value:w} \texttt{12345}
% \cs{exp_after:wN} \texttt{;} expanded what follows once, we need
% \cs{add:ww} to do the calculation, and in the process to expand
% the following once. This is also true in our real application:
% all the functions of the form \cs{fp_...:ww} expand the what
% follows once. This comes at the cost of leaving tokens in the
% input stack, and we will need to be careful to waste as little
% as possible of this precious memory.
%
%
% \subsection{Precedence}
%
% A major point to keep in mind when parsing expressions is that
% different operators have different precedence. The true analog
% of our toy \cs{clean:w} macro must thus take care of that. For
% definiteness, let us assume that the operation which prompted
% \cs{clean:w} was a multiplication. Then \cs{clean:w} (expand
% and) read digits until the number is ended by some operation.
% If this is \texttt{+} or~\texttt{-}, then the multiplication
% should be calculated next, so \cs{clean:w} can simply decide
% that its job is done. However, if the operator we find is |^|,
% then this operation must be performed before returning control
% to the multiplication. This means that we need to \cs{clean:w}
% the number following |^|, and perform the calculation, then just
% end our job.
%
% Hence, each time a number is cleaned, the precedence of the
% following operation must be compared to that of the previous
% operation. The process of course has to happen recursively.
% For instance, |1+2^3*4| would involve the following steps.
% \begin{itemize}
% \item |1| is cleaned up.
% \item |2| is cleaned up.
% \item The precedences of |+| and |^| are compared. Since the
%   latter is higher, the second operand of |^| should be cleaned.
% \item |3| is cleaned up.
% \item The precedences of |^| and |*| are compared. Since the
%   former is higher, the cleaning step stops.
% \item Compute |2^3 = 8|.
% \item We now have |1+8*4|, and the operation |+| is still
%   looking for a second operand. Clean |8|.
% \item The precedences of |+| and |*| are compared. Since the
%   latter is higher, the second operand of |*| should be cleaned.
% \item |4| is cleaned up, and the end of the expression is reached.
% \item Compute |8*4 = 32|.
% \item We now have |1+8*4|, and the operation |+| is still
%   looking for a second operand. Clean |32|, and reach the end
%   of the expression.
% \item Compute |1+32 = 33|.
% \end{itemize}
% Here, there is some (expensive) redundant work: the results of
% computations should not need to be cleaned again. Thus the true definition
% is slightly more elaborate.
%
% The precedence of |(| and |)| are defined to be equal, and smaller than
% the precedence of |+| and |-|, itself smaller than |*| and |/|, smaller,
% finally, then the power operator |**| (or |^|).
%
%
% \subsection{Infix operators}
%
% The implementation that was chosen is slightly wasteful: it causes
% more nesting than necessary. ^^A todo: clarify.
% However, it is simpler to implement and to explain than a slightly
% optimized variant. ^^A todo: implement optimized version; compare.
%
% The cornerstone of that method is a pair of functions,
% \cs{until} and \cs{one}, which both take as their first
% argument the precedence (an integer) of the last operation.
% The f-expansion of
% \begin{quote}
%   \cs{until} \meta{prec} \cs{one} \meta{prec} \meta{stuff}
% \end{quote}
% is the internal floating point obtained by \enquote{cleaning}
% numbers which follow in the input stream, and performing
% computations until reaching an operation with a precedence
% less than or equal to \meta{prec}. This is followed by a control
% sequence of the form \cs{infix_?}, namely,
% \begin{quote}
%   \meta{floating point} \cs{infix_?}
% \end{quote}
% where |?| is the operation following that number in the input
% stream (we thus know that this operation has at most the
% precedence \meta{prec}, otherwise it would have been performed
% already).
%
% How is that expansion achieved? First, \cs{one} \meta{prec}
% reads one \meta{floating point} number, and converts it to an
% internal form, then the following operation, say |*|, is
% packed in the form \cs{infix_*}, which is fed the \meta{prec}.
% This function (one per infix operator) compares \meta{prec}
% with the precedence of the operator we just read (here |*|).
% If \meta{prec} is higher, our job is finished, and \cs{one}
% leaves \cs{c_true_bool} so that \cs{until} knows to stop.
% Otherwise, \cs{infix_*} triggers a new pair
% \cs{until} \meta{prec(*)} \cs{one} \meta{prec(*)},
% which produces the second operand \meta{floating point 2}
% for the multiplication:
% \begin{quote}
%   \cs{until} \meta{prec} \meta{floating point} \newline
%   \texttt{...} \meta{floating point 2} |;| \cs{infix_?}
% \end{quote}
% The dots are \cs{c_false_bool} \cs{fp_mul:ww}. The boolean
% tells \cs{until} that it is not done, and it expands
% (essentially) to
% \begin{quote}
%   \cs{until} \meta{prec}
%   \cs{fp_mul:ww} \meta{floating point} \meta{floating point 2}
%   \cs{tex_romannumeral:D} \texttt{-`0} \cs{infix_?} \meta{prec}
% \end{quote}
% making \TeX{} expand \cs{fp_mul:ww} before \cs{until}.
% As implemented in \pkg{l3fp-basics}, this operation expands
% what follows exactly once. This triggers \cs{tex_romannumeral:D},
% which fully expands \cs{infix_?} \meta{prec}. This compares
% the precedence of the next operation, |?|, and \meta{prec},
% and leaves a boolean (and possibly more things), which is then
% checked by \cs{until} \meta{prec} to know if the result
% of the multiplication is the end of the story, or if |?|
% should be computed as well before \cs{until} \meta{prec} ends.
%
% This should be easier to see on an example. To each infix
% operator, for instance, |*|, is associated the following data:
% \begin{itemize}
% \item a test function, \cs{infix_*}, which conditionally continues
%   the calculation or waits to be hit again by expansion;
% \item a function \fpOperation{*} (notation for \cs{fp_mul:ww})
%   which performs the actual calculation;
% \item an integer, \fpPrecedence{*}, which encodes the precedence of
%   the operator (typically, \cs{c_zero}, \cs{c_one}, or \cs{c_two}).
% \end{itemize}
% The token that is currently being expanded is underlined,
% and in red. Tokens that have not yet been read (and could
% still be hidden in macros) are in gray.
%
% In a first reading, the disinction between the \meta{precedence}
% \fpPrecedence{+}, the operation \fpOperation{+}, and the character
% token |+| should not matter. It is only required to accomodate for
% multi-token infix operators such as |**|: indeed, when controlling
% expansion, we need to skip over those tokens using \cs{exp_after:wN},
% and this only skips one token. Thus |**| needs to be replaced by a
% single token (either its precedence or its calculating function,
% depending on the place).
%
% To end the computation cleanly, we add a trailing right
% parenthesis, and give |(| and |)| the lowest precedence,
% so that \cs{until}\fpPrecedence{(} \cs{one}\fpPrecedence{(}
% reads numbers and performs operations until meeting a right
% parenthesis. This is discussed more precisely in the next section.
%
% \begin{l3fp-code-example}
%   \cs{until}\p(    \*\cs{one}\p( \! 11 + 2**3 * 5 - 9 )\!
%   \cs{until}\p( 1  \*\cs{one}\p( \! 1  + 2**3 * 5 - 9 )\!
%   \cs{until}\p( 11 \*\cs{one}\p( \!    + 2**3 * 5 - 9 )\!
%   \cs{until}\p( 11; \*\cs{infix_+}\p( \! 2**3 * 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ \*\cs{one}\p+ \! 2**3 * 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 2 \*\cs{one}\p+ \!  **3 * 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 2; \*\cs{infix_**}\p+ \! 3 * 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 2;
%       F \o{**} \cs{until}\p{**} \*\cs{one}\p{**} \! 3 * 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 2;
%       F \o{**} \cs{until}\p{**} 3 \*\cs{one}\p{**} \! * 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 2;
%       F \o{**} \cs{until}\p{**} 3; \*\cs{infix_*}\p{**} \! 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 2;
%       F \o{**} \*\cs{until}\p{**} 3; T \cs{infix_*} \! 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \*\cs{until}\p+ 2;
%       F \o{**} 3; \cs{infix_*} \! 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ \*\o{**} 2; 3;
%       \cs{infix_*}\p+ \! 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 8; \*\cs{infix_*}\p+ \! 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 8;
%       F \o* \cs{until}\p* \*\cs{one}\p* \! 5 - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 8;
%       F \o* \cs{until}\p* 5 \*\cs{one}\p* \! - 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 8;
%       F \o* \cs{until}\p* 5; \*\cs{infix_-}\p* \! 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 8;
%       F \o* \*\cs{until}\p* 5; T \cs{infix_-} \! 9 )\!
%   \cs{until}\p( 11; F \o+ \*\cs{until}\p+ 8; F \o* 5; \cs{infix_-} \! 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ \*\o{*} 8; 5; \cs{infix_-}\p+ \! 9 )\!
%   \cs{until}\p( 11; F \o+ \cs{until}\p+ 40; \*\cs{infix_-}\p+ \! 9 )\!
%   \cs{until}\p( 11; F \o+ \*\cs{until}\p+ 40; T \cs{infix_-} \! 9 )\!
%   \*\cs{until}\p( 11; F \o+ 40; \cs{infix_-} \! 9 )\!
%   \cs{until}\p( \*\o{+} 11; 40; \cs{infix_-}\p( \! 9 )\!
%   \cs{until}\p( 51; \*\cs{infix_-}\p( \! 9 )\!
%   \cs{until}\p( 51; F \o- \cs{until}\p- \*\cs{one}\p- \! 9 )\!
%   \cs{until}\p( 51; F \o- \cs{until}\p- 9 \*\cs{one}\p- \! )\!
%   \cs{until}\p( 51; F \o- \cs{until}\p- 9; \*\cs{infix_)}\p- \!\!
%   \cs{until}\p( 51; F \o- \*\cs{until}\p- 9; T \cs{infix_)} \!\!
%   \*\cs{until}\p( 51; F \o- 9; \cs{infix_)} \!\!
%   \cs{until}\p( \*\o{-} 51; 9; \cs{infix_)}\p( \!\!
%   \cs{until}\p( 42; \*\cs{infix_)}\p( \!\!
%   \*\cs{until}\p( 42; T \cs{infix_)} \!\!
%   42; \cs{infix_)} \!\!
% \end{l3fp-code-example}
%
% The only missing step is to clean the output by removing \cs{infix_)},
% and possibly checking that nothing else remains.
%
% \subsection{Prefix operators, parentheses, and functions}
%
% Prefix operators (typically the unary |-|) and parentheses are
% taken care of by the same mechanism, and functions (\texttt{sin},
% \texttt{exp}, etc.) as well. Finding the argument of the unary
% |-|, for instance, is very similar to grabbing the second operand
% of a binary infix operator, with a small subtelty on precedence
% explained below. Once that argument is found, its sign can be
% flipped. A left parenthesis is just a prefix operator which
% removes the closing parenthesis (with some extra checks).
%
% Detecting prefix operators is done by \cs{one}. Before looking
% for a number, it tests the first character. If it is a digit, a
% dot, or a register, then we have a number. Otherwise, it is put
% in a function, \cs{prefix_?} (where |?| is roughly that first
% character), which is expanded. For instance, with a left
% parenthesis we would have the following.
% \begin{l3fp-code-example}
%   \*\cs{one}\p* \! ( 2 + 3 ) \!
%   \*\cs{prefix_(}\p* \! 2 + 3 ) \!
%   \o(\p* \cs{until}\p( \*\cs{one}\p( \! 2 + 3 ) \!
%   ... \!\!
%   \o(\p* 5; \cs{infix_)} \! \!
% \end{l3fp-code-example}
% As usual, the \cs{until}--\cs{one} pair reads and compute
% until reaching an operator of precedence at most \fpPrecedence{(}.
% Then \fpOperation{(} removes \cs{infix_)} and looks ahead for
% the next operation, comparing its precedence with the precedence
% \fpPrecedence{*} of the previous operation (in fact, this comparison
% is done by the relevant \cs{infix_?} built from the next operation).
%
% To support multi-character function (and constant) names, we
% may need to put more than one character in the \cs{prefix_?}
% construction. See implementation for details.
%
% Note that contrarily to \cs{infix_?} functions, the \cs{prefix_?}
% functions perform no test on their argument (which is once more
% the previous precedence), since we know that we need a number,
% and must never stop there.
%
% Functions are implemented as prefix operators with infinitely high
% precedence, so that their argument is the first number that can
% possibly be built. For instance, something like the following could
% happen in a computation
% \begin{l3fp-code-example}
%   \*\cs{one}\p* \! sqrt 4 + 3 ) \!
%   \*\cs{prefix_sqrt}\p* \! 4 + 3 ) \!
%   \o{sqrt}\p* \cs{until}\p{$\infty$} \*\cs{one}\p{$\infty$} \! 4 + 3 ) \!
%   ... \!\!
%   \o{sqrt}\p* 4; \cs{infix_+} \! 3 ) \!
%   2; \*\cs{infix_+}\p* \! 3 ) \!
% \end{l3fp-code-example}
%
% Lonely example, to be put somewhere: |2+sin 1 * 3| is $2+(\sin(1)\times 3)$.
%
% A further complication arises in the case of the unary |-| sign:
% |-3**2| should be $-(3^2)=-9$, and not $(-3)^2=9$. Easy, just give
% |-| a lower precedence, equal to that of the infix |+| and |-|.
% Unfortunately, this fails in subtle cases such as |3**-2*4|,
% yielding $3^{-2\times 4}$ instead of the correct $3^{-2}\times 4$.
% In fact, a unary |-| should only perform operations whose precedence
% is greater than that of the last operation, as well as
% |-|.\footnote{Taking into account the precedence of \texttt{-} itself
%   only matters when it follows a left parenthesis:
%   \texttt{(-2*4+3)} should give \texttt{((-8)+3)}, not \texttt{(-(8+3))}.}
% Thus, \cs{prefix_-} \meta{prec} expands to something like
% \begin{l3fp-code-example}
%   \o- \meta{prec} \cs{until}\p? \*\cs{one} \p?
% \end{l3fp-code-example}
% where \fpPrecedence{?} is the maximum of \meta{prec} and the
% precedence of |-|. Once the argument of |-| is found, \fpOperation{-}
% gets its opposite, and leaves it for the previous operation to use.
%
% An example with parentheses.
%
% \begin{l3fp-code-example}
%   \cs{until}\p(    \*\cs{one}\p( \! 11 * ( 2 + 3 ) - 9 )\!
%   \cs{until}\p( 1  \*\cs{one}\p( \! 1  * ( 2 + 3 ) - 9 )\!
%   \cs{until}\p( 11 \*\cs{one}\p( \!    * ( 2 + 3 ) - 9 )\!
%   \cs{until}\p( 11; \*\cs{infix_*}\p( \!   ( 2 + 3 ) - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \*\cs{one}\p* \! ( 2 + 3 ) - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \*\cs{prefix_(}\p* \! 2 + 3 ) - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \cs{until}\p( \*\cs{one}\p( \! 2 + 3 ) - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \cs{until}\p( 2 \*\cs{one}\p( \! + 3 ) - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \cs{until}\p( 2; \*\cs{infix_+}\p( \! 3 ) - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \cs{until}\p( 2; F \o+ \cs{until}\p+ \*\cs{one}\p+ \! 3)-9)\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \cs{until}\p( 2; F \o+ \cs{until}\p+ 3 \*\cs{one}\p+ \! )-9)\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \cs{until}\p( 2; F \o+ \cs{until}\p+ 3; \*\cs{infix_)}\p+ \! -9)\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \cs{until}\p( 2; F \o+ \*\cs{until}\p+ 3; T \cs{infix_)} \! -9)\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \*\cs{until}\p( 2; F \o+ 3; \cs{infix_)} \! - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \cs{until}\p( \*\o+ 2; 3; \cs{infix_)}\p( \! - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \cs{until}\p( 5; \*\cs{infix_)}\p( \! - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \o(\p* \*\cs{until}\p( 5; T \cs{infix_)} \! - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* \*\o(\p* 5; \cs{infix_)} \! - 9 )\!
%   \cs{until}\p( 11; F \o* \cs{until}\p* 5; \*\cs{infix_-}\p* \! 9 )\!
%   \cs{until}\p( 11; F \o* \*\cs{until}\p* 5; T \cs{infix_-} \! 9 )\!
%   \*\cs{until}\p( 11; F \o* 5; \cs{infix_-} \! 9 )\!
%   \cs{until}\p( \*\o* 11; 5; \cs{infix_-}\p( \! 9 )\!
%   \cs{until}\p( 55; \* \cs{infix_-}\p( \! 9 )\!
%   \cs{until}\p( 55; F \o- \cs{until}\p- \*\cs{one}\p- \! 9 )\!
%   \cs{until}\p( 55; F \o- \cs{until}\p- 9 \*\cs{one}\p- \! )\!
%   \cs{until}\p( 55; F \o- \cs{until}\p- 9; \*\cs{infix_)}\p- \!\!
%   \cs{until}\p( 55; F \o- \*\cs{until}\p- 9; T \cs{infix_)} \!\!
%   \*\cs{until}\p( 55; F \o- 9; \cs{infix_)} \!\!
%   \cs{until}\p( \*\o- 55; 9; \cs{infix_)}\p( \!\!
%   \cs{until}\p( 47; \*\cs{infix_)}\p( \!\!
%   \*\cs{until}\p( 47; T \cs{infix_)} \!\!
%   47; \cs{infix_)} \!\!
% \end{l3fp-code-example}
%
% The end of this (sub)section was not revised yet
%
% \begin{itemize}
% \item If it is a sign (|-| or |+|), then any following sign will be
%   combined with this initial sign, forming \cs{prefix_+} or \cs{prefix_-}.
% \item If it is a letter, then any following letter is grabbed, forming
%   for instance \cs{prefix_sin} or \cs{prefix_sinh}.
% \item Otherwise, only one token\footnote{Some support for multi-character
%     prefix operator may be added in the future, but right now, I don't
%     see a use for it. Perhaps, for including comments inside
%     the computation itself??} is grabbed, for instance \cs{prefix_(}.
% \end{itemize}
%
% Functions may take several arguments, possibly an unknown
% number\footnote{Keyword argument support may be added later.},
% for instance \texttt{round(1.23456,2)}.
% \begin{itemize}
% \item \texttt{round} is made into \cs{prefix_round}, which tries to
%   grab one number using \cs{one}.
% \item This builds \cs{prefix_(}, which uses \cs{one} to grab one
%   number, calculating as necessary. The comma is given the same
%   precedence as parentheses, and thus ends the calculation of the
%   argument of \texttt{round}.
% \item \texttt{round} now has its first argument. It can check whether
%   the argument was closed by |,| or |)|, and branch accordingly.
% \item If it was a comma, then the first argument is skipped over,
%   through an expensive set of \cs{exp_after:wN}, and the second
%   argument can be grabbed. Here it is simply an integer, easier
%   to parse by building upon \cs{etex_numexpr:D}.
% \item The closing parenthesis (or another comma) is seen, and the
%   control is given back to \cs{prefix_round}.
% \end{itemize}
%
% \subsection{Type detection}
%
% The type of data should be detected by reading the first few tokens,
% before calling the type-specific function of \file{l3fp-clean}. Or
% should the type be obtained after the semicolon which indicates the
% end of the thing? And placed there?
%
% Also to grab exponent correctly, build \cs{fp_<abc>:w} when seeing
% some non-numeric |abc| while still looking to complete a number (or
% other data). Then, if \cs{fp_postfix_<type>_<abc>:w} exists, use it.^^A...?
%
% The internal representation of floating point numbers is quite
% untypable, and we provide here the tools to convert from a more
% user-friendly representation to internal floating point numbers,
% and for various other conversions. Every floating point operation
% calls those functions to normalize the input, so they must be
% optimized.
%
% \section{Internal representation}
%
% Internally, a floating point number \meta{X} is a
% token list containing
% \begin{quote}
%   \cs{s_fp} \cs{fp_use:w} \meta{case} \meta{sign} \meta{body} |;|
% \end{quote}
% Let us explain each piece separately.
%
% Internal floating point numbers will be used in expressions,
% and in this context will be subject to f-expansion. They must
% leave a recognizable mark after f-expansion, to prevent the
% floating point number from being re-parsed. Thus, \cs{s_fp}
% is simply another name for \cs{tex_relax:D}.
%
% Since floating point numbers are always accessed by the various
% operations using f-expansion, we can safely let them be protected:
% x-expansion will then leave them untouched. However, when typeset,
% \cs{s_fp} will do nothing, and \cs{fp_use:w} will take care of
% typesetting the number, with whichever typesetting setting is
% currently active.
%
% The (decimal part of the) IEEE-754-2008 standard requires the
% format to be able to represent special floating point numbers
% besides the usual positive and negative cases. The various
% possibilities will be distinguished by their \meta{case}, which
% is a single digit:\footnote{Bruno: I need to implement subnormal
%   numbers. Also, quiet and signalling NaN must be better
%   distinguished.}
% \begin{itemize}
% \item[0] zeros: |+0| and |-0|,
% \item[1] \enquote{normal} numbers (positive and negative),
% \item[2] infinities: |+inf| and |-inf|,
% \item[3] quiet and signalling |NaN|.
% \end{itemize}
% The \meta{sign} is |0| (positive) or |2| (negative),
% except in the case of |NaN|, which have $\meta{sign} = 1$.
% This ensures that changing the \meta{sign} digit to $2-\meta{sign}$
% is exactly equivalent to changing the sign of the number.
%
% Special floating point numbers have the form
% \begin{quote}
%   \cs{s_fp} \cs{fp_use:w} \meta{case} \meta{sign} \cs{fp_info:...} |;|
% \end{quote}
% where \cs{fp_info:...} is a control sequence let to
% \cs{tex_relax:D}, carrying an information string
% \enquote{\texttt{...}} which describes where the
% number was formed (useful for debugging).
%
% Normal floating point numbers ($\meta{case} = 1$) have the form
% \begin{quote}
%   \cs{s_fp} \cs{fp_use:w} 1 \meta{sign} \Arg{exponent}
%   \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4} |;|
% \end{quote}
% Here, the \meta{exponent} is an integer in the range
% [\cs{c_fp_min_exponent_int},\cs{c_fp_max_exponent_int}].
% The body consists in four blocks of exactly $4$ digits,
% $ 0000 \leq \meta{X$\sb{i}$} \leq 9999 $, such that
% \[
% \meta{X}
% = (-1)^{\meta{sign}} 10^{-\meta{exponent}}
% \sum_{i=1}^{4} \meta{X$\sb{i}$} 10^{-4i}
% \]
% and such that the \meta{exponent} is minimal. This implies
% $ 1000 \leq \meta{X1} \leq 9999 $.
%
% \begin{table}\centering
%   \caption{Internal representation of floating point numbers.}
%   \label{tab:fp-convert-special}
%   \begin{tabular}{ll}
%     \toprule
%     \multicolumn{1}{c}{Representation} & Meaning \\
%     \midrule
%     0 0 \cs{fp_info:...}  \texttt{;} & Positive zero.      \\
%     0 2 \cs{fp_info:...}  \texttt{;} & Negative zero.      \\
%     1 0 \Arg{exponent} \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4} \texttt{;}
%                                      & Positive floating point. \\
%     1 2 \Arg{exponent} \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4} \texttt{;}
%                                      & Negative floating point. \\
%     2 0 \cs{fp_info:...}  \texttt{;} & Positive infinity.  \\
%     2 2 \cs{fp_info:...}  \texttt{;} & Negative infinity.  \\
%     3 1 \cs{fp_info:q...} \texttt{;} & Quiet |NaN|.        \\
%     3 1 \cs{fp_info:s...} \texttt{;} & Signalling |NaN|.   \\
%     \bottomrule
%   \end{tabular}
% \end{table}
%
%
% \end{documentation}
%
% \begin{implementation}
% ^^A todo: add error detection that there is nothing left to parse at the end.
%
% \section{Implementation}
%
%
%    We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\package_check_loaded_expl:
%</package>
%<*initex|package>
%    \end{macrocode}
%
%
% \subsection{Parse one floating point}
%
% In this section, we write some code to convert user input to
% an internal floating point. The following forms are accepted:
% \begin{itemize}
% \item \meta{signs} \meta{floating point}
% \item \meta{signs} \meta{integer} |.| \meta{decimal} |e| \meta{exponent}
% \end{itemize}
% In both cases, \meta{signs} is a (possibly empty) string of
% |+| and |-| (with any category code\footnote{Bruno: except
%   1, 2, 4, 10, 13, and those which cannot be tokens (0, 5, 9),
%   so really, just 3, 6, 7, 8, 11, 12.}).\footnote{Bruno:
%   test (and implement) non-other digits.}
%
% In the second form, the \meta{integer} is a sequence of digits,
% whose length is not limited by constraints \TeX{}'s integer
% registers. It stops at the first non-digit character. The
% \meta{decimal} part is formed by all digits from the dot
% (if it exists) until the first non-digit character. The
% \meta{exponent} part has the form \meta{exponent sign}
% \meta{exponent body}, where \meta{exponent sign} is any string
% of |+| or |-|, and \meta{exponent body} is a string of digits,
% stopping, as usual, at the first non-digit.
%
% The code attempts to match the longest possible string. If some
% tokens remain, no error is raised.\footnote{Bruno: this \emph{must}
%   be fixed, and \texttt{sNaN} be returned!}
%
% Any missing part will take the appropriate default value.
% \begin{itemize}
% \item A missing \meta{exponent} is considered to be zero.
% \item A number with no dot has zero decimal part.
% \item An empty \meta{integer} part or decimal part is zero.
% \end{itemize}
%
% Border cases:
% \begin{itemize}
% \item \texttt{e1} is considered as invalid input, and gives
%   \texttt{qNaN}.\footnote{Bruno: now just gives an error.}
%   This will be important once parsing expressions is
%   implemented, since \texttt{e-1} would be ambiguous otherwise.
% \item \texttt{.e3} and \texttt{.} are zero.
% \end{itemize}
%
% Bruno: expansion, not yet. Only f-expansion at the start, and
% unpacking of registers after signs.
%
%
% Work-plan.
% \begin{itemize}
% \item Remove any leading sign and build the \meta{sign} as we go.
%   If the next character is a letter, go to the \enquote{special}
%   branch, discussed later.
% \item Drop leading zeros.
% \item If the next character is a dot, drop some more zeros,
%   keeping track of how many were dropped after the dot.
%   Counting those gives $\meta{exp1}<0$. Then read the decimal part
%   with the \cs{fp_from_str_small} functions.
% \item Otherwise, $\meta{exp1}=0$, and first read the integer part,
%   then the decimal part. This is implemented through the more
%   elaborate \cs{fp_from_str_large} functions.
% \item Continuing in the same line of expansion, read the exponent
%   \meta{exp2}.
% \item Finally check that nothing is left.\footnote{Bruno: not done yet.}
% \end{itemize}
%
% \subsubsection{Trimming leading zeros}
%
% \begin{macro}{\fp_cfs_trim_loop:N,\fp_cfs_trim_end:w}
%
%   In this branch, we expect a number with a non-empty mantissa
%   (between the sign part and the exponent part), starting with
%   a digit (those starting with a dot are handled by
%   \cs{fp_cfs_strim_loop:N}. The goal here is to trim zeros from
%   the beginning of the number, reaching the most significant
%   digit before starting to really read the number (this is required
%   to round properly).
%
%   There are two cases. If we find a non-zero digit before any dot
%   or exponent part, the mantissa is \enquote{large} ($\geq 1$).
%   If we find no non-zero digit before a dot, we need to continue
%   removing zeros afterwards (through the \cs{fp_cfs_strim} functions,
%   resulting in a \enquote{small} mantissa ($<1$). In the latter case,
%   we have to keep track of the shift $\meta{exp1}<0$ as we remove
%   zeros after the dot. This exponent is \cs{c_zero} for large
%   mantissas.
%
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_trim_loop:N #1
  {
      \if:w 0 #1
        \exp_after:wN \fp_cfs_trim_loop:N
        \tex_romannumeral:D
      \else:
        \if:w . #1
          \exp_after:wN \fp_cfs_strim_loop:N
          \tex_romannumeral:D
        \else:
          \fp_cfs_trim_end:w #1
        \fi:
      \fi:
      \fp_aux_expand:w
  }
\cs_new:Npn \fp_cfs_trim_end:w #1 \fi: \fi: \fp_aux_expand:w
  {
        \fi:
      \fi:
      \if_num:w 9 < 1#1 \exp_stop_f:
        \exp_after:wN ; \exp_after:wN \fp_cfs_large:NwN
      \else:
        \exp_after:wN ; \exp_after:wN \fp_cfs_zero:Nw
      \fi:
      #1
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fp_cfs_strim_loop:N,\fp_cfs_strim_end:w}
%   If we have removed all digits until a period (or if the body
%   started with a period), then enter the
%   \enquote{\texttt{small\_trim}} loop which outputs $-1$ for each
%   removed $0$.
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_strim_loop:N #1
  {
      \if:w 0 #1
        - \c_one
        \exp_after:wN \fp_cfs_strim_loop:N
        \tex_romannumeral:D
      \else:
        \fp_cfs_strim_end:w #1
      \fi:
      \fp_aux_expand:w
  }
%    \end{macrocode}
%
%   As we cannot round properly before the sign is known,
%   we need to take a rest when reaching a non-zero, stop the
%   \cs{int_eval:w} which is computing the \meta{exp1},
%   and simply leave instructions after the semicolon on what to
%   do next.
%
%
% %   and the best we can do at this stage is to read up to $16$
% %   digits, and use any remaining digit to produce the correct
% %   \meta{rounding} digit, as described for \cs{fp_aux_round:NNN}.
% %   This can be done at most $9$ digits at a time, so we need two
% %   steps.
% %
% %   If the number of digits in front of us is less than $16$,
% %   simply fill with more zeros. If there are more digits, start
% %   a loop to remove them, doing almost nothing (taking care of
% %   the \meta{rounding}).
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_strim_end:w #1 \fi: \fp_aux_expand:w
  {
      \fi:
      \if_num:w 9 < 1#1 \exp_stop_f:
        \exp_after:wN ; \exp_after:wN \fp_cfs_small:NwN
      \else:
        \exp_after:wN ; \exp_after:wN \fp_cfs_zero:Nw
      \fi:
      #1
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Special cases}
%
% \begin{macro}{\fp_cfs_lead_relax:N}
%   The argument is a token equal to \cs{tex_relax:D}.  This can be
%   \cs{s_fp}, \cs{s_fp_mark}, or a badly initialized register.
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_lead_relax:N #1
  {
    \exp_after:wN \fp_cfs_lead_relax_aux:NN
      \cs:w fp_cfs_lead_type_ \cs_to_str:N #1 :w \cs_end:
      #1
  }
\cs_new:Npn \fp_cfs_lead_relax_aux:NN #1#2
  {
    \if_meaning:w \tex_relax:D #1
      %^^A todo: cleanup and add info to snan.
      \msg_expandable_error:n { Erroneous~variable~#2~used! }
      \exp_after:wN \exp_after:wN \exp_after:wN \fp_cfs_internal:w
      \exp_after:wN \c_empty_snan_fp
    \else:
      \exp_after:wN #1
    \fi:
  }
\cs_new:Npn \fp_cfs_lead_type_s_fp:w { \fp_cfs_internal:w \s_fp }
\cs_new:Npn \fp_cfs_lead_type_s_fp_mark:w
  { \c_one E 0 ; \fp_cfs_premature_end:w \s_fp_mark }
%    \end{macrocode}
%
%   In the case of an internal floating point number, |#1| is
%   \cs{s_fp}, and what follows looks as follows.
%   We terminate the \cs{int_eval:w} for the sign, and
%   put the tokens in the right place.
%   \begin{syntax}
%     \cs{fp_cfs_internal:w} \cs{s_fp} \cs{fp_use:w}
%     ~~\meta{case} \meta{sign} \meta{body} |;|
%     ~~\meta{remaining input}
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_internal:w \s_fp \fp_use:w #1 #2 #3 ;
  { \int_eval:w 1 - #2 E #3 ; { \s_fp \fp_use:w #1 } }
%    \end{macrocode}
%
%   All other \cs{tex_relax:D} are invalid input, and we
%   produce a signalling \texttt{NaN}, whose \meta{info}
%   field is the remaining part of the input.
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_premature_end:w #1 0;
  {
    \msg_expandable_error:n { Premature~end~in~fp~expression. }
    \c_empty_snan_fp
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_cfs_zero:Nw}
%   \begin{syntax}
%     \cs{fp_cfs_zero:Nw} \meta{sign} \meta{exp1} ; \meta{non-digit}
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_zero:Nw #1 #2 ;
  {
    \exp_after:wN \fp_cfs_zero_aux:Nw
    \exp_after:wN #1
    \int_value:w \fp_cfs_exponent_test:N
  }
\cs_new:Npn \fp_cfs_zero_aux:Nw #1 #2 ; { \fp_aux_zero_fp:N #1 }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Small mantissa}
%
% \begin{macro}{\fp_cfs_small:NwN}
%   \begin{syntax}
%     \cs{fp_cfs_small:NwN} \meta{sign} \meta{exp1} |;| \meta{non-zero digit}
%   \end{syntax}
%   The goal here is to grab up to $16$ digits. But we can't do
%   that all at once, because \cs{int_value:w} (which allows us
%   to collect digits and continue expanding) can only go up to
%   $9$ digits. We do it in two steps of (almost) $8$ digits.
%   Using $8$ rather than $9$ helps us repack more easily. In fact,
%   we've already read one digit, and there is no need to re-read it,
%   hence the use of \cs{fp_aux_grab_digits_vii:N}. As usual,
%   brace-removing f-expansion of the following. The goal is
%   \begin{syntax}
%     \cs{fp_cfs_sanitize:Nw} \meta{sign} \meta{exp} |;|
%     ~~\Arg{4 digits} \Arg{4 digits} \Arg{4 digits} \Arg{4 digits} |;|
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_small:NwN #1 #2 ; #3
  {
    \exp_after:wN \fp_cfs_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \int_eval:w #2
      \exp_after:wN \fp_cfs_i_after:NNNNNww
      \int_use:N \int_eval:w 1
        \exp_after:wN \fp_cfs_small_i:NwwNN
        \exp_after:wN #1
        \int_value:w 1 #3
          \exp_after:wN \fp_aux_grab_digits_vii:N
          \tex_romannumeral:D \fp_aux_expand:w
  }
%    \end{macrocode}
%
%   The next function appears within the \cs{int_eval:w}
%   for the final exponent.
%   \begin{syntax}
%     \cs{fp_cfs_small_i:NwwNN} \meta{sign}
%     ~~|1| \meta{digits} |,| \meta{zeros} |;| \meta{number~of~zeros}
%   \end{syntax}
%   Here, \meta{digits}\meta{zeros} is a string of $8$ digits,
%   and \meta{number~of~zeros} counts how many zeros we had to
%   add to complete the digits that we had already found.
%
%   Note that the next token, |#5|, is already f-expanded in all
%   cases (by the \cs{fp_aux_grab_digits} functions which looked
%   for a digit). If that next token is a digit, then we need to
%   grab more digits, until the $15$th digit (the digit number
%   $16$ plays a special role in rounding). Otherwise, we check
%   for an exponent (\cs{fp_cfs_exponent_test:N/w} is used in
%   all \enquote{normal} branches), and end.
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_small_i:NwwNN #1 1 #2, #3; #4 #5
  {
        #2 #3
        \if_num:w 9 < 1 #5 \exp_stop_f:
          \exp_after:wN \fp_cfs_small_ii:NwwNN
          \exp_after:wN #1
          \int_value:w 1 #5
            \exp_after:wN \fp_aux_grab_digits_vi:N
            \tex_romannumeral:D
        \else:
          \exp_after:wN \fp_cfs_small_i_end:
          \int_value:w
            \fp_cfs_exponent_test:w #5
        \fi:
        \fp_aux_expand:w
  }
%    \end{macrocode}
%   Ending involves filling up with zeros, and bringing the exponent
%   back in the input stream, for \cs{fp_cfs_i_after:NNNNNww}.
%   Since \cs{fp_cfs_i_after:NNNNNww} is common to both the case
%   where there are few digits, and the cases with many digits, there
%   is a check for the carry which may arise from rounding up.
%   This carry can only arise to give a power of ten (and |#1| is |0000|).
%   \footnote{Bruno: explain by going down through the expansion, and
%     then up.}
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_small_i_end: #1 ; { ; #1 ; {0000} {0000} ; }
\cs_new:Npn \fp_cfs_ii_after:NNNNNNww #1 #2 #3#4#5#6 #7; #8 ;
  {
    \if:w 2 #2
      + 1
    \fi:
    ; #8 + #1 ; {#3#4#5#6}{#7};
  }
\cs_new:Npn \fp_cfs_i_after:NNNNNww
    #1 #2#3#4#5 #6; #7 ;
  {
    + #7
    \if:w 2 #1
      + 1 \exp_after:wN \fp_cfs_small_carry:w
    \fi:
    ; {#2#3#4#5} {#6}
  }
\cs_new:Npn \fp_cfs_small_carry:w ; #1 { ; {1000} }
%    \end{macrocode}
%
%   \begin{syntax}
%     \cs{fp_cfs_small_ii:NwwNN} \meta{sign}
%     ~~|1| \meta{digits} |,| \meta{zeros} |;| \meta{number~of~zeros}
%     ~~\meta{next~token}
%   \end{syntax}
%   Let's get ready for more digits. The \meta{next~token} is
%   f-expanded. If it is a digit, it is the $16$th digit.
%   \cs{fp_cfs_small_ii:NwwNN} builds a number $1$\meta{8 digits},
%   rounded properly, and feeds that to
%   \cs{fp_cfs_large_ii_after:NNNNNNww}.
%
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_small_ii:NwwNN #1 1 #2, #3; #4 #5
  {
        \exp_after:wN \fp_cfs_ii_after:NNNNNNww
        \exp_after:wN \c_zero
        \int_use:N \int_eval:w 1 #2 #3
          \if_num:w 9 < 1 #5 \exp_stop_f:
            #5
            +
            \exp_after:wN \fp_cfs_small_round:NNNw
            \exp_after:wN #1
            \exp_after:wN #5
            \tex_romannumeral:D
          \else:
            0
            \exp_after:wN ;
            \int_value:w
              \fp_cfs_exponent_test:w #5
          \fi:
          \fp_aux_expand:w
  }
%    \end{macrocode}
%   Just as \cs{fp_cfs_i_after:NNNNNww}, pack digits in blocks
%   of $4$, check for a carry, and increase the \cs{int_eval:w}
%   above if needed. No surprise there.
%    \begin{macrocode}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Finding the exponent}
%
%
% \begin{macro}{\fp_cfs_exponent_test:N}
%   \begin{syntax}
%     \cs{int_value:w} \cs{fp_cfs_exponent_test:N}
%   \end{syntax}
%   Can also be invoked from within \cs{int_eval:w}, since
%   the exponent gets terminated by a semicolon.
%
%   Expansion is a little bit tricky here. When implementing
%   expression parsing, later, we may want to accept input where
%   multiplication is implicit.
% \begin{verbatim}
% \fp_parse:n { 3.2 erf(0.1) }
% \fp_parse:n { 3.2 e\l_my_int }
% \fp_parse:n { 3.2 \c_pi_fp }
% \end{verbatim}
%   The first case indicates that just looking one character ahead
%   for an \enquote{\texttt{e}} is not enough, since we would mistake
%   the function \texttt{erf} for an exponent of \enquote{\texttt{rf}}.
%   An alternative would be to look two tokens ahead and check if what
%   follows is a sign or a digit, considering in that case that we must
%   be finding an exponent. But taking care of the second case requires
%   that we unpack registers after \texttt{e}. However, blindly expanding
%   the two tokens ahead completely (plus unpacking) would break
%   the third example. Indeed, in the course of reading $3.2$,
%   \cs{c_pi_fp} is expanded to \cs{s_fp} \cs{fp_use:w} |1| |0| |{-1}|
%   |{3141}| $\cdots$ |;| and \cs{s_fp} stops the expansion. Expanding
%   two tokens ahead would then force the expansion of \cs{fp_use:w}
%   (despite it being protected), and that function typesets the floating
%   point number.
%
%   What can we do? Really, the reason why this last case breaks is that
%   just as \TeX{} does, we should read ahead as little as possible.
%   Here, the only case where there may be an exponent is if the first
%   token ahead is |e|.\footnote{The commented code below allows
%     both \texttt{e} and \texttt{E}, but seems ugly.} Then we expand
%   (and possibly unpack) the second token --- and hopefully that is safe.
%
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_exponent_test:w
    #1 \fi: \fp_aux_expand:w
  {
    \fi:
    \fp_cfs_exponent_test:N #1
  }
\cs_new:Npn \fp_cfs_exponent_test:N #1
  {
    % \if_num:w \tex_uccode:D `e
    %     = \tex_uccode:D \exp_after:wN ` \token_to_str:N #1 \exp_stop_f:
    \if:w e #1
      \exp_after:wN \fp_cfs_exponent_test_aux:NN
      \exp_after:wN #1
      \tex_romannumeral:D \exp_after:wN \fp_aux_unpack:w
    \else:
      \exp_after:wN 0
      \exp_after:wN \fp_cfs_exponent_end:
      \exp_after:wN #1
    \fi:
  }
%    \end{macrocode}
%   The interested reader is invited to
%   check that |#2=-| gives the case |0|, |#2=+| gives |2|,
%   |#2=|digit gives the \cs{else:} branch, and all other case,
%   including |*| and |/|, and also |(| and |)| (which stop the
%   \cs{int_eval:w}) go to case |1|.
%
%   Anyways, that test should be rewritten. Now that I've put
%   the expansion, it is ugly. Note that after the signs we
%   unpack registers, whereas between digits we don't.
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_exponent_test_aux:NN #1 #2
  {
    \if_case:w \int_eval:w 1 #2 1 \int_eval_end:
      - \exp_after:wN \fp_cfs_exponent_sign:N
      \tex_romannumeral:D \exp_after:wN \fp_aux_unpack:w
    \or:
      \exp_after:wN 0
      \exp_after:wN \fp_cfs_exponent_end:
      \exp_after:wN #1
      \exp_after:wN #2
    \or:
      \exp_after:wN \fp_cfs_exponent_sign:N
      \tex_romannumeral:D \exp_after:wN \fp_aux_unpack:w
    \else:
      #2
      \exp_after:wN \fp_cfs_exponent_body:N
      \tex_romannumeral:D \exp_after:wN \fp_aux_expand:w
    \fi:
  }
\cs_new:Npn \fp_cfs_exponent_sign:N #1
  {
    \if:w + \if:w - #1 + \fi: #1
      \exp_after:wN \fp_cfs_exponent_sign:N
      \tex_romannumeral:D \exp_after:wN \fp_aux_unpack:w
    \else:
      \exp_after:wN \fp_cfs_exponent_body:N
      \exp_after:wN #1
    \fi:
  }
\cs_new:Npn \fp_cfs_exponent_body:N #1
  {
    \if_num:w 9 < 1 #1 \exp_stop_f:
      #1
      \exp_after:wN \fp_cfs_exponent_body:N
      \tex_romannumeral:D \exp_after:wN \fp_aux_expand:w
    \else:
      \exp_after:wN \fp_cfs_exponent_end: \exp_after:wN #1
    \fi:
  }
\cs_new:Npn \fp_cfs_exponent_end: { ; }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsubsection{Large mantissa}
%
% \begin{macro}{\fp_cfs_large:NwN}
%   \begin{syntax}
%     \cs{fp_cfs_large:NwN} \meta{sign} \meta{exp1} |;| \meta{non-zero digit}
%   \end{syntax}
%   This function and subsequent \cs{fp_cfs_large_...} functions are
%   the most convoluted of this submodule. It is called after trimming
%   leading zeros, if this does not reach a dot yet. Because we are
%   reading the integer part of the number, digits must be counted.
%   But at the same time, digits must be stored, and expansion must
%   continue. We only have one place to store both digits and the
%   corresponding exponent: upstream. Hence, quite a lot of reshuffling.
%
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_large:NwN #1 #2 ; #3
  {
    \exp_after:wN \fp_cfs_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \int_eval:w #2
      \exp_after:wN \fp_cfs_large_i:NwwNN
      \exp_after:wN #1
      \int_value:w 1 #3
        \exp_after:wN \fp_aux_grab_digits_vii:N
        \tex_romannumeral:D \fp_aux_expand:w
  }
%    \end{macrocode}
%   Beyond |#3|, which is the first non-zero digit of the (large)
%   mantissa (already expanded), we grab seven additional digits.
%   Afterwards, we add to the exponent the shift corresponding to
%   how many digits were grabbed, and test whether |#5| is a digit
%   (the $9$th digit), a dot, or something else.
%
%   Then, if |#5| is a digit, it is the $9$th digit of the mantissa,
%   and we grab six more digits to reach a total of $15$, calling
%   \cs{fp_cfs_large_ii:NwwNN}.
%
%   Otherwise, |#5| may be a dot, in which case we switch to the
%   functions we used in the \enquote{small} case. Finally, |#5|
%   may be something else, in which case we just look for an exponent.
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_large_i:NwwNN #1 1 #2, #3; #4 #5
  {
      + 8 - #4
      \exp_after:wN \fp_cfs_i_after:NNNNNww
      \int_use:N \int_eval:w 1 #2
        \if_num:w 9 < 1 #5 \exp_stop_f:
          \exp_after:wN \fp_cfs_large_ii:NwwNN
          \exp_after:wN #1
          \int_value:w 1 #5
            \exp_after:wN \fp_aux_grab_digits_vi:N
            \tex_romannumeral:D
        \else:
          \if:w . #5
            \exp_after:wN \fp_cfs_small_i:NwwNN
            \exp_after:wN #1
            \int_value:w 1
              \cs:w
                fp_aux_grab_digits_
                \tex_romannumeral:D #4
                :N \exp_after:wN
              \cs_end:
              \tex_romannumeral:D
          \else:
            #3
            \exp_after:wN \fp_cfs_small_i_end:
            \int_value:w
              \exp_after:wN \fp_cfs_exponent_test:w
              \exp_after:wN #5
          \fi:
        \fi:
        \fp_aux_expand:w
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_large_ii:NwwNN #1 1 #2, #3; #4 #5
  {
      \if_num:w 9 < 1 #5 \exp_stop_f:
        \exp_after:wN \fp_cfs_ii_after:NNNNNNww
        \exp_after:wN \c_eight
        \int_use:N \int_eval:w 1 #2 #5
          + \exp_after:wN \fp_cfs_large_round:NNNw
            \exp_after:wN #1
            \exp_after:wN #5
            \tex_romannumeral:D
      \else:
        \exp_after:wN \fp_cfs_ii_after:NNNNNNww
        \int_use:N \int_eval:w 7 - #4 \exp_after:wN \int_eval_end:
        \int_use:N \int_eval:w 1 #2
          \if:w . #5
            \exp_after:wN \fp_cfs_large_iii:NwwNN
            \exp_after:wN #1
            \int_value:w 1
              \cs:w
                fp_aux_grab_digits_
                \tex_romannumeral:D #4
                :N \exp_after:wN
              \cs_end:
              \tex_romannumeral:D
          \else:
            #3 0 \exp_after:wN ;
            \int_value:w
              \exp_after:wN \fp_cfs_exponent_test:w
              \exp_after:wN #5
          \fi:
      \fi:
      \fp_aux_expand:w
  }
\cs_new:Npn \fp_cfs_large_iii:NwwNN #1 1 #2, #3; #4 #5
  {
          #2 #3
          \if_num:w 9 < 1 #5 \exp_stop_f:
            #5
            +
            \exp_after:wN \fp_cfs_small_round:NNNw
            \exp_after:wN #1
            \exp_after:wN #5
            \tex_romannumeral:D
          \else:
            0
            \exp_after:wN ;
            \int_value:w
              \fp_cfs_exponent_test:w #5
          \fi:
          \fp_aux_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Beyond 16 digits: rounding}
%
% \begin{macro}{\fp_cfs_round_loop:N}
%   Used both for \cs{fp_cfs_small_round:NNNw} and
%   \cs{fp_cfs_large_round:NNNw}.
%   Should appear after a \cs{int_eval:w} |0|. Reads digits one by one,
%   until reaching a non-digit. Adds |+1| for each digit. If all digits
%   found are |0|, ends the \cs{int_eval:w} by |;\c_zero|, otherwise
%   by |;\c_one|. This is done by switching the loop to |round_up|
%   at the first non-zero digit.
%
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_round_loop:N #1
  {
    \if_num:w 9 < 1 #1 \exp_stop_f:
      + \c_one
      \if:w 0 #1
        \exp_after:wN \fp_cfs_round_loop:N
        \tex_romannumeral:D
      \else:
        \exp_after:wN \fp_cfs_round_up:N
        \tex_romannumeral:D
      \fi:
    \else:
      \fp_aux_swap_fisuf:w ; \c_zero #1
    \fi:
    \fp_aux_expand:w
  }
\cs_new:Npn \fp_cfs_round_up:N #1
  {
    \if_num:w 9 < 1 #1 \exp_stop_f:
      + 1
      \exp_after:wN \fp_cfs_round_up:N
      \tex_romannumeral:D
    \else:
      \fp_aux_swap_fisuf:w ; \c_one #1
    \fi:
    \fp_aux_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fp_cfs_large_round:NNNw}
%   \begin{syntax}
%     \cs{fp_cfs_large_round:NNNw} \meta{sign} \meta{digit} \meta{stuff}
%   \end{syntax}
%   \meta{digit} is the digit that we are currently rounding (we only
%   care whether it is even or odd).
%
%   The goal is to get \cs{c_zero} or \cs{c_one}, check for an exponent
%   afterwards, and combine it to the number of digits before the decimal
%   point (which we thus need to keep track of).
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_large_round:NNNw #1 #2 #3
  {
    \if_num:w 9 < 1 #3 \exp_stop_f:
      \exp_after:wN \fp_aux_round_s:NNNw
      \exp_after:wN #1
      \exp_after:wN #2
      \exp_after:wN #3
      \int_use:N \int_eval:w
        \exp_after:wN \fp_cfs_large_round_after:wNN
        \int_use:N \int_eval:w 1
          \exp_after:wN \fp_cfs_round_loop:N
    \else: %^^A could be dot, or e, or other
      \exp_after:wN \fp_cfs_large_round_dot_test:NNNw
      \exp_after:wN #1
      \exp_after:wN #2
      \exp_after:wN #3
    \fi:
  }
\cs_new:Npn \fp_cfs_large_round_dot_test:NNNw #1 #2 #3
  {
    \if:w . #3
      \exp_after:wN \fp_cfs_small_round:NNNw
      \exp_after:wN #1
      \exp_after:wN #2
      \tex_romannumeral:D
    \else:
      \exp_after:wN \c_zero \exp_after:wN ;
      \int_value:w
        \fp_cfs_exponent_test:w #3
    \fi:
    \fp_aux_expand:w
  }
%    \end{macrocode}
%   \begin{syntax}
%     \cs{fp_cfs_large_round_after:wNN} \meta{exp} |;|
%     ~~\meta{0 or 1} \meta{next~token}
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_large_round_after:wNN #1 ; #2 #3
  {
    \if:w . #3
      \exp_after:wN \fp_cfs_large_round_after_ii:wN
      \int_use:N \int_eval:w #1 +
        \c_zero * \int_eval:w
          \exp_after:wN \fp_cfs_round_loop:N
          \tex_romannumeral:D
    \else:
      + #2
      \exp_after:wN ;
      \int_use:N \int_eval:w #1 +
        \fp_cfs_exponent_test:w #3
    \fi:
    \fp_aux_expand:w
  }
\cs_new:Npn \fp_cfs_large_round_after_ii:wN #1 ; #2
  {
    + #2
    \exp_after:wN ;
    \int_use:N \int_eval:w #1 +
      \fp_cfs_exponent_test:N
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fp_cfs_small_round:NNNw}
%   \begin{syntax}
%     \cs{fp_cfs_small_round:NNNw} \meta{sign} \meta{digit} \meta{stuff}
%   \end{syntax}
%   \meta{digit} is the digit that we are currently rounding (we only
%   care whether it is even or odd).
%
%   The goal is to get \cs{c_zero} or \cs{c_one}
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_small_round:NNNw #1 #2 #3
  {
    \if_num:w 9 < 1 #3 \exp_stop_f:
      \exp_after:wN \fp_aux_round_s:NNNw
      \exp_after:wN #1
      \exp_after:wN #2
      \exp_after:wN #3
      \int_use:N \int_eval:w
        \exp_after:wN \fp_cfs_small_round_after:wN
        \int_use:N \int_eval:w 0
          \exp_after:wN \fp_cfs_round_loop:N
          \tex_romannumeral:D
    \else:
      0 \exp_after:wN ;
      \int_value:w
        \fp_cfs_exponent_test:w #3
    \fi:
    \fp_aux_expand:w
  }
\cs_new:Npn \fp_cfs_small_round_after:wN #1; #2
  {
    + #2 \exp_after:wN ;
    \int_value:w \fp_cfs_exponent_test:N
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Just a final check}
%
% \begin{macro}{\fp_cfs_sanitize:Nw}
%   \begin{syntax}
%     \cs{fp_cfs_sanitize:Nw} \meta{sign} \meta{exp} |;|
%     ~~\Arg{4~digits} \Arg{4~digits} \Arg{4~digits} \Arg{4~digits} |;|
%   \end{syntax}
%   check overflow
%    \begin{macrocode}
\cs_new:Npn \fp_cfs_sanitize:Nw #1 #2 ;
  {
    \if_num:w #2 > \c_fp_max_exponent_int
      \exp_after:wN \fp_aux_overflow:w
    \else:
      \if_num:w #2 < \c_fp_min_exponent_int
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_aux_underflow:w
      \fi:
    \fi:
    \s_fp \fp_use:w 1 #1 {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Main functions}
%
% \begin{macro}{\fp_parse:n}
%   Thanks to \cs{tex_romannumeral:D}, this expands to an
%   internal floating point number after two expansion steps,
%   just like \cs{int_eval:n} and others.
%    \begin{macrocode}
\cs_new:Npn \fp_parse:n #1
  { \tex_romannumeral:D \fp_parse:w #1 \s_fp_mark \s_fp_stop }
\cs_new:Npn \fp_parse:w
  {
    \exp_after:wN \fp_parse_after:ww
    \tex_romannumeral:D -`0
    \fp_parse_uo:Nw \c_fp_parse_min_precedence_int
    \fp_aux_expand:w
  }
\cs_new:Npn \fp_parse_after:ww #1; #2 \s_fp_stop
  {
    %^^A todo: check that #2 is \fp_parse_infix_end:N
    \c_zero
    #1;
  }
\int_const:Nn \c_fp_parse_min_precedence_int { 0 }
\int_const:Nn \c_fp_parse_max_precedence_int { 100 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_parse_uo:Nw}
%   This is just a shorthand which sets up both \cs{fp_parse_until}
%   and \cs{fp_parse_one} with the same precedence. Note the
%   trailing \cs{tex_romannumeral:D}. This function should be
%   used with much care.
%    \begin{macrocode}
\cs_new:Npn \fp_parse_uo:Nw #1
  {
    \exp_after:wN \fp_parse_until:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0
    \exp_after:wN \fp_parse_one:Nw
    \exp_after:wN #1
    \tex_romannumeral:D
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_parse_until:NwN}
%   \begin{syntax}
%     \cs{fp_parse_until:NwN} \meta{prec} \meta{fp} \meta{bool}
%   \end{syntax}
%   If \meta{bool} is true, then \meta{fp} is the floating
%   point number that we are looking for (it ends with |;|),
%   and this expands to \meta{fp}. If \meta{bool} is false,
%   then the input stream actually looks like
%   \begin{quote}
%     \cs{fp_parse_until:NwN} \meta{prec} \meta{fp 1} \meta{false}
%     \meta{oper} \meta{fp 2} \cs{infix_?}
%   \end{quote}
%   and we must feed \meta{prec} to \cs{infix_?}, and perform
%   \meta{oper} on \meta{fp 1} and \meta{fp 2}: this
%   triggers the expansion of \cs{infix_?} \meta{prec}, continuing
%   the computation (or stopping). In that case, the function \cs{until}
%   yields
%   \begin{quote}
%     \cs{fp_parse_until:NwN} \meta{prec}
%     \meta{oper} \meta{fp 1} \meta{fp 2}
%     \cs{tex_romannumeral:D} |-`0| \cs{infix_?} \meta{prec}
%   \end{quote}
%   expanding \meta{oper} next.
%    \begin{macrocode}
\cs_new:Npn \fp_parse_until:NwN #1 #2; #3
  {
    \if_meaning:w \c_true_bool #3
      \exp_after:wN \use_none:nn
    \fi:
    \fp_parse_until_aux:NwNwN #1 #2;
  }
\cs_new:Npn \fp_parse_until_aux:NwNwN #1 #2; #3 #4; #5
  {
    \exp_after:wN \fp_parse_until:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0
    #3 #2; #4;
    \tex_romannumeral:D -`0 #5 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Parsing one number}
%
% \begin{macro}{\fp_parse_one:Nw}
%   Function called \cs{one} at other places. It grabs one
%   fp number, and packs what follows in an \cs{infix_} function.
%
%   |#1| is the previous \meta{prec}. Since we fully expanded,
%   and only registers and characters are allowed in expressions,
%   |#2| can be
%   \begin{itemize}
%   \item \cs{tex_relax:D} in some form. That can be an internal floating
%     point, a premature end, or an unitialized register. In an
%     \cs{int_eval:n}, we would get \enquote{missing number, treated as $0$}.
%   \item A register. To be unpacked. But note that \cs{c_minus_one} is
%     not equivalent to $-\cs{c_one}$.\footnote{Bruno: elaborate.}
%   \item A digit, or a dot. That's the start of a number.
%   \item A letter, which starts a \enquote{prefix} word, either
%     constant or function (possibly unknown).
%   \item A sign: in that case we grab all following signs, and turn
%     them into a single \cs{prefix_+} or \cs{prefix_-} for efficiency.
%   \item A left parenthesis.
%   \item Any other character is an error.\footnote{Bruno: rephrase that,
%       since really, it could be extended.}
%   \end{itemize}
%   The two first cases are separated out by an \cs{if_catcode:w} check,
%   digits are also singled out, and then we use the \cs{grab_letters}
%   facility.
%    \begin{macrocode}
\cs_new:Npn \fp_parse_one:Nw #1 #2
  {
    \if_catcode:w \tex_relax:D #2
      \if_meaning:w \tex_relax:D #2
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_parse_one_relax:NN
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_parse_one_register:NN
      \fi:
    \else:
      \if_num:w 9<1#2 \exp_stop_f:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_parse_one_digit:NN
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_parse_one_other:NN
      \fi:
    \fi:
    #1 #2
  }
\cs_new:Npn \fp_parse_one_relax:NN #1
  {
    \exp_after:wN \fp_parse_sign_after:NNwn
    \exp_after:wN #1
    \int_use:N \int_eval:w 1 - \fp_cfs_lead_relax:N
  }
\cs_new:Npn \fp_parse_one_register:NN #1
  { \exp_after:wN \fp_parse_one:Nw \exp_after:wN #1 \tex_the:D }
\cs_new:Npn \fp_parse_one_digit:NN #1
  {
    \exp_after:wN \fp_parse_sign_after:NNwn
    \exp_after:wN #1
    \exp_after:wN 0
    \exp_after:wN E
      \int_use:N \int_eval:w \c_zero \fp_cfs_trim_loop:N
  }
\group_begin:
  \char_set_catcode_letter:N \*
  \cs_new:Npn \fp_parse_one_after:NwN #1 #2; #3
    {
      \fp_aux_exp_after_fp:wN #2;
      \tex_romannumeral:D -`0
      \if_catcode:w \tex_relax:D #3
        \if_meaning:w \tex_relax:D #3
          \exp_after:wN \exp_after:wN \exp_after:wN \fp_parse_infix_end:N
          \exp_after:wN \exp_after:wN \exp_after:wN #1
        \else:
          \exp_after:wN \exp_after:wN \exp_after:wN \fp_parse_infix_*:N
          \exp_after:wN \exp_after:wN \exp_after:wN #1
          \exp_after:wN \exp_after:wN \exp_after:wN #3
        \fi:
      \else:
        \exp_after:wN \fp_parse_one_after_check:NNN
        \exp_after:wN #3
        \cs:w fp_parse_infix_#3:N \exp_after:wN \cs_end:
        \exp_after:wN #1
      \fi:
    }
  \cs_new:Npn \fp_parse_one_after_check:NNN #1#2#3
    {
      \if_meaning:w \tex_relax:D #2
        \msg_expandable_error:n { Missing~*~inserted. }
        \exp_after:wN \fp_parse_infix_*:N
        \exp_after:wN #3
        \exp_after:wN #1
      \else:
        \exp_after:wN #2
        \exp_after:wN #3
      \fi:
    }
\group_end:
\cs_new:Npn \fp_parse_infix_end:N #1
  { \c_true_bool \fp_parse_infix_end:N }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,aux]{\fp_parse_one_after_unary:NNwN}
%   Here, |#2| is \emph{e.g.}, \cs{fp_neg:w}, and expands once
%   after the calculation.\footnote{Bruno: explain.}
%    \begin{macrocode}
\cs_new:Npn \fp_parse_one_after_unary:NNwN #1 #2 #3; #4
  { #2 #3; \tex_romannumeral:D -`0 #4 #1 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_parse_one_other:NN}
%   The interesting bit is \cs{fp_parse_one_other:NN}. It separates
%   letters from non-letters and builds the appropriate \cs{prefix}
%   function. If it is not defined (is \cs{tex_relax:D}), make it
%   a signalling \texttt{nan}. We don't look for an argument, as the
%   unknown \enquote{prefix} can also be a (mistyped) constant such
%   as \texttt{Inf}.
%    \begin{macrocode}
\cs_new:Npn \fp_parse_one_other:NN #1 #2
  {
    \if_num:w \int_eval:w \tex_uccode:D `#2 / \c_twenty_six = \c_three
      \exp_after:wN \fp_parse_one_other_word_aux:NN
      \exp_after:wN #1
      \cs:w fp_parse_word_ #2
        \exp_after:wN \fp_aux_grab_letters:N \tex_romannumeral:D
    \else:
      \exp_after:wN \fp_parse_one_other_prefix_aux:NNN
      \exp_after:wN #1
      \exp_after:wN #2
      \cs:w fp_parse_prefix_#2:Nw \exp_after:wN \cs_end:
      \tex_romannumeral:D
    \fi:
    \fp_aux_expand:w
  }
\cs_new:Npn \fp_parse_one_other_word_aux:NN #1 #2
  {
    \if_meaning:w \tex_relax:D #2
      \fp_aux_error:N #2
      \exp_after:wN \fp_parse_one_other_nan:NN
    \fi:
    #2 #1
  }
\cs_new:Npn \fp_parse_one_other_prefix_aux:NNN #1#2#3
  {
    \if_meaning:w \tex_relax:D #3
      \cs_if_exist:cTF { fp_parse_infix_#2:N }
        {
          \exp_after:wN \fp_parse_one_other_nan:NN
          \exp_after:wN #3
          \exp_after:wN #1
          \tex_romannumeral:D \exp_after:wN #2 % "Missing number" error
        }
        {
          \msg_expandable_error:n { Unknown~symbol~#2~ignored. }
          \exp_after:wN \fp_parse_one:Nw
          \exp_after:wN #1
        }
    \else:
      \exp_after:wN #3
      \exp_after:wN #1
    \fi:
  }
\cs_new:Npn \fp_parse_one_other_nan:NN #1 #2
  { \fp_parse_one_after:NwN #2 \s_fp \fp_use:w 3 1 #1 ; }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Signs}
%
% \begin{macro}{\fp_parse_sign_after:NNwn}
%   \begin{syntax}
%     \cs{fp_parse_sign_after:NNwn} \meta{prec} \meta{sign} E \meta{exp1} |;| \meta{function}
%   \end{syntax}
%   Puts \meta{function} back in front. This function will be
%   \begin{itemize}
%   \item \cs{fp_cfs_premature_end:w} when the sign is
%     immediately followed by the end of the number (gives a sNaN).
%   \item \cs{fp_cfs_internal:w} when parsing an internal floating point,
%   \item \cs{fp_cfs_zero:Nw} when parsing a zero,
%   \item \cs{fp_cfs_small:NwN} when the mantissa is less than $1$,
%   \item \cs{fp_cfs_large:NwN} when the mantissa is greater than $1$.
%   \end{itemize}
%   Sometimes it is a brace group, not a function.
%   \footnote{Bruno: the \texttt{E} is useless here.}
%    \begin{macrocode}
\cs_new:Npn \fp_parse_sign_after:NNwn #1#2 E #3 ; #4
  {
    \exp_after:wN \fp_parse_one_after:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0 #4 #2 #3 ;
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Prefix operators: variables and functions}
%
% \begin{macro}{\fp_parse_word_inf:N}
% \begin{macro}{\fp_parse_word_nan:N}
%   This ought to give the infinite floating point.
%    \begin{macrocode}
\cs_new:cpn {fp_parse_word_inf:N} #1
  {
    \exp_after:wN \fp_parse_one_after:NwN
    \exp_after:wN #1 \c_inf_fp
  }
\cs_new_eq:cc {fp_parse_word_infty:N} {fp_parse_word_inf:N}
\cs_new_eq:cc {fp_parse_word_infinity:N} {fp_parse_word_inf:N}
\cs_new:cpn {fp_parse_word_nan:N} #1
  {
    \exp_after:wN \fp_parse_one_after:NwN
    \exp_after:wN #1
    \c_empty_qnan_fp
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_parse_prefix_+:Nw, \fp_parse_prefix_-:Nw}
%   A unary |+| is trivial. Unary |-| is harder. As an optimization,
%   if the next character is also a |-|, we do like a unary |+|.
%    \begin{macrocode}
\cs_new_eq:cN {fp_parse_prefix_+:Nw} \fp_parse_one:Nw
\cs_new:cpn {fp_parse_prefix_-:Nw} #1 #2
  {
    \if:w - #2
      \fp_parse_prefix_double_minus:Nw #1
    \else:
      \exp_after:wN \fp_parse_one_after_unary:NNwN
      \exp_after:wN #1
      \exp_after:wN \fp_neg:w
      \tex_romannumeral:D -`0
      \if_num:w \c_five < #1
        \fp_parse_uo:Nw #1
      \else:
        \fp_parse_uo:Nw \c_five
      \fi:
    \fi:
    \fp_aux_expand:w
    #2
  }
\cs_new:Npn \fp_parse_prefix_double_minus:Nw
    #1 #2 \fi: \fp_aux_expand:w #3
  {
    \fi:
    \exp_after:wN \fp_parse_one:Nw
    \exp_after:wN #1
    \tex_romannumeral:D \fp_aux_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_parse_prefix_(:Nw}
%   This really ought to have a correct argument spec,
%   but it is technically complicated.
%    \begin{macrocode}
\cs_new:cpn {fp_parse_prefix_(:Nw} #1
  {
    \exp_after:wN \fp_parse_lparen_after:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0
    \fp_parse_uo:Nw \c_fp_parse_min_precedence_int
    \fp_aux_expand:w
  }
\cs_new:Npx \fp_parse_lparen_after:NwN #1 #2; #3
  {
    \exp_not:N \if_meaning:w \exp_not:c { fp_parse_infix_):N } #3
    \exp_not:n
      {
          \exp_after:wN \use_i:nn
        \else:
          \tex_romannumeral:D \int_eval:w ( 0 \int_eval_end: %^^A trigger error
          \exp_after:wN \use:nn
        \fi:
      }
    { \exp_not:N \fp_parse_one_after:NwN #1 #2; }
    \s_fp_mark %^^A todo: this fp_mark is wrong!
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_parse_prefix_.:Nw}
%   This function is called when a number starts with a dot.
%    \begin{macrocode}
\cs_new:cpn {fp_parse_prefix_.:Nw} #1
  {
    \exp_after:wN \fp_parse_sign_after:NNwn
    \exp_after:wN #1
    \exp_after:wN 0
    \exp_after:wN E
      \int_use:N \int_eval:w \c_zero
      \fp_cfs_strim_loop:N
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_parse_word_ln:N}
%    \begin{macrocode}
\cs_new:cpn {fp_parse_word_ln:N} #1
  {
    \exp_after:wN \fp_parse_one_after_unary:NNwN
    \exp_after:wN #1
    \exp_after:wN \fp_ln:w
    \tex_romannumeral:D -`0
    \fp_parse_uo:Nw \c_fp_parse_max_precedence_int
    \fp_aux_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_parse_word_abs:N}
%    \begin{macrocode}
\cs_new:cpn {fp_parse_word_abs:N} #1
  {
    \exp_after:wN \fp_parse_one_after_unary:NNwN
    \exp_after:wN #1
    \exp_after:wN \fp_abs:w
    \tex_romannumeral:D -`0
    \fp_parse_uo:Nw \c_fp_parse_max_precedence_int
    \fp_aux_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Infix operators}
%
% \begin{macro}[aux]{\fp_parse_def_infix:NNN,\fp_parse_def_infix:cNN}
%   As described in the \enquote{work plan}, each infix operator has an
%   associated \cs{infix} function, a computing function, and
%   precedence, given as arguments to \cs{fp_parse_def_infix:NNN}.  The
%   latter two are only needed when defining the \cs{infix} function.
%    \begin{macrocode}
\cs_new:Npn \fp_parse_def_infix:NNN #1#2#3
  {
    \cs_new:Npn #1 ##1
      {
        \if_num:w ##1 < #3
          \exp_after:wN \c_false_bool
          \exp_after:wN #2
          \tex_romannumeral:D -`0
          \fp_parse_uo:Nw #3
          \exp_after:wN \fp_aux_expand:w
        \else:
          \exp_after:wN \c_true_bool
          \exp_after:wN #1
        \fi:
      }
  }
\cs_generate_variant:Nn \fp_parse_def_infix:NNN { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]
%   {
%     \fp_parse_infix_+:N, \fp_parse_infix_-:N,
%     \fp_parse_infix_*:N, \fp_parse_infix_/:N
%   }
%   Using the general mechanism for arithmetic operations.
%    \begin{macrocode}
\fp_parse_def_infix:cNN { fp_parse_infix_+:N } \fp_add:ww \c_five
\fp_parse_def_infix:cNN { fp_parse_infix_-:N } \fp_sub:ww \c_five
\fp_parse_def_infix:cNN { fp_parse_infix_*:N } \fp_mul:ww \c_ten
\fp_parse_def_infix:cNN { fp_parse_infix_/:N } \fp_div:ww \c_ten
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]
%   {
%     \fp_parse_infix_<:N, \fp_parse_infix_=:N,
%     \fp_parse_infix_>:N, \fp_parse_infix_!:N
%   }
% \begin{macro}[aux, EXP]
%   {
%     \fp_parse_infix_excl_aux:NN,
%     \fp_parse_infix_excl_error:,
%     \fp_infix_compare:N,
%     \fp_parse_compare:NNNNNw,
%     \fp_parse_compare_expand:NNNNNw,
%     \fp_parse_compare_end:NNNN,
%     \fp_compare:wNNNNw,
%   }
%    \begin{macrocode}
\cs_new:cpn { fp_parse_infix_<:N } #1
  {
    \fp_infix_compare:N #1 \c_one_fp
      \c_zero_fp  \c_zero_fp \c_zero_fp \c_zero_fp <
  }
\cs_new:cpn { fp_parse_infix_=:N } #1
  {
    \fp_infix_compare:N #1 \c_one_fp
      \c_zero_fp \c_zero_fp \c_zero_fp \c_zero_fp =
  }
\cs_new:cpn { fp_parse_infix_>:N } #1
  {
    \fp_infix_compare:N #1 \c_one_fp
      \c_zero_fp \c_zero_fp \c_zero_fp \c_zero_fp >
  }
\cs_new:cpn { fp_parse_infix_!:N } #1
  {
    \exp_after:wN \fp_parse_infix_excl_aux:NN
    \exp_after:wN #1 \tex_romannumeral:D \fp_aux_expand:w
  }
\cs_new:Npn \fp_parse_infix_excl_aux:NN #1#2
  {
    \if_catcode:w \tex_relax:D #2
      \fp_parse_infix_excl_error:
    \else:
      \if_num:w `#2 > `? \exp_stop_f:
        \fp_parse_infix_excl_error:
      \else:
        \if_num:w `#2 < `< \exp_stop_f:
          \fp_parse_infix_excl_error:
        \fi:
      \fi:
    \fi:
    \fp_infix_compare:N #1 \c_zero_fp
      \c_one_fp \c_one_fp \c_one_fp \c_one_fp #2
  }
\cs_new:Npn \fp_parse_infix_excl_error:
  { \msg_expandable_error:n { Missing~relation~symbol~after~'!'. } }
\cs_new:Npn \fp_infix_compare:N #1
  {
    \if_num:w #1 < \c_two
      \exp_after:wN \fp_parse_compare:NNNNNw
    \else:
      \exp_after:wN \c_true_bool
      \exp_after:wN \fp_infix_compare:N
    \fi:
  }
\cs_new:Npn \fp_parse_compare:NNNNNw #1#2#3#4#5#6
  {
    \if_case:w
          \if_catcode:w \tex_relax:D #6
            \c_minus_one
          \else:
            \int_eval:w `#6 - `< \int_eval_end:
          \fi:
         \fp_parse_compare_expand:NNNNNw #1#1#3#4#5
    \or: \fp_parse_compare_expand:NNNNNw #1#2#1#4#5
    \or: \fp_parse_compare_expand:NNNNNw #1#2#3#1#5
    \or: \fp_parse_compare_expand:NNNNNw #1#2#3#4#1
    \else: \fp_parse_compare_end:NNNN #2#3#4#5#6
    \fi:
  }
\cs_new:Npn \fp_parse_compare_expand:NNNNNw #1#2#3#4#5
  {
    \exp_after:wN \fp_parse_compare:NNNNNw
    \exp_after:wN #1
    \exp_after:wN #2
    \exp_after:wN #3
    \exp_after:wN #4
    \exp_after:wN #5
    \tex_romannumeral:D \exp_after:wN \fp_aux_expand:w
  }
\cs_new:Npn \fp_parse_compare_end:NNNN #1#2#3#4#5 \fi:
  {
    \fi:
    \exp_after:wN \c_false_bool
    \exp_after:wN \fp_compare:wNNNNw
    \exp_after:wN #1
    \exp_after:wN #2
    \exp_after:wN #3
    \exp_after:wN #4
    \tex_romannumeral:D -`0
    \fp_parse_uo:Nw \c_two \fp_aux_expand:w #5
  }
\cs_new:Npn \fp_compare:wNNNNw #1; #2#3#4#5 #6;
  {
    \exp_after:wN \exp_after:wN
    \exp_after:wN \exp_after:wN
    \exp_after:wN \exp_after:wN
    \if_case:w \fp_compare:ww #1; #6; \exp_stop_f:
           #3
    \or:   #4
    \or:   #5
    \else: #2
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, EXP]+\fp_parse_infix_):N+
%   This one is a little bit odd: force every previous operator to end,
%   regardless of the precedence.  This is very similar to
%   \cs{fp_parse_infix_end:N}.
%    \begin{macrocode}
\cs_new:cpx { fp_parse_infix_):N } #1
  { \c_true_bool \exp_not:c { fp_parse_infix_):N } }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex