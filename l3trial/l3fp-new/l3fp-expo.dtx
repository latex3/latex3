% \iffalse meta-comment
%
%% File: l3fp-expo.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{l3fp-new}
\GetIdInfo$Id$
  {L3 Experimental floating-point arithmetic}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\usepackage{l3fp-expo}
\begin{document}
  \tableofcontents
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-expo} package\thanks{This file
%         has version number \ExplFileVersion, last
%         revised \ExplFileDate.}\\
% Floating point exponential related functions}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \begin{function}[EXP]{\fp_exp:N,\fp_ln:N}
%   \begin{syntax}
%     \cs{fp_exp:N} \meta{fp~var}
%   \end{syntax}
%   These functions f-expand to the exponential and the logarithm
%   (in base $e$) of the \meta{floating point variable}.
% \end{function}
%
% \begin{function}[EXP]{\fp_pow:NN}
%   \begin{syntax}
%     \cs{fp_pow:NN} \meta{fp~var~1} \meta{fp~var~2}
%   \end{syntax}
%   This function f-expands to $\meta{fp~var~1}^{\meta{fp~var~2}}$.
% \end{function}
% \end{documentation}
%
% \begin{implementation}
%
% \section{Implementation}
%
%   We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%<*initex|package>
%    \end{macrocode}
%
% \subsection{User commands}
%
% \begin{macro}[EXP]{\fp_exp:N,\fp_ln:N}
%    \begin{macrocode}
\cs_new:Npn \fp_exp:N #1 { \exp_after:wN \fp_exp:w #1 \fp_aux_do_nothing: }
\cs_new:Npn \fp_ln:N #1 { \exp_after:wN \fp_ln:w #1 \fp_aux_do_nothing: }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Some constants}
%
% \begin{variable}
%   {
%     \c_fp_ln_1_fixed_tl ,
%     \c_fp_ln_2_fixed_tl ,
%     \c_fp_ln_3_fixed_tl ,
%     \c_fp_ln_4_fixed_tl ,
%     \c_fp_ln_6_fixed_tl ,
%     \c_fp_ln_7_fixed_tl ,
%     \c_fp_ln_8_fixed_tl ,
%     \c_fp_ln_9_fixed_tl ,
%     \c_fp_ln_10_fixed_tl,
%   }
%   A few values of the logarithm which are needed in the implementation.
%    \begin{macrocode}
\tl_const:cn { c_fp_ln_1_fixed_tl } { {0000}{0000}{0000}{0000}{0000}{0000} }%?
\tl_const:cn { c_fp_ln_2_fixed_tl } { {6931}{4718}{0559}{9453}{0941}{7232} }
\tl_const:cn { c_fp_ln_3_fixed_tl } {{10986}{1228}{8668}{1096}{9139}{5245} }
\tl_const:cn { c_fp_ln_4_fixed_tl } {{13862}{9436}{1119}{8906}{1883}{4464} }
 % \tl_const:cn { c_fp_ln_5_fixed_tl } {{16094}{3791}{2434}{1003}{7460}{0759} }
\tl_const:cn { c_fp_ln_6_fixed_tl } {{17917}{5946}{9228}{0550}{0081}{2477} }
\tl_const:cn { c_fp_ln_7_fixed_tl } {{19459}{1014}{9055}{3133}{0510}{5353} }
\tl_const:cn { c_fp_ln_8_fixed_tl } {{20794}{4154}{1679}{8359}{2825}{1696} }
\tl_const:cn { c_fp_ln_9_fixed_tl } {{21972}{2457}{7336}{2193}{8279}{0490} }
\tl_const:cn { c_fp_ln_10_fixed_tl} {{23025}{8509}{2994}{0456}{8401}{7991} }
%    \end{macrocode}
% \end{variable}
%
% \subsection{Logarithm}
%
% \subsubsection{Sign, exponent, and special numbers}
%
% \begin{macro}[EXP]{\fp_ln:w}
%   \begin{syntax}
%     \cs{fp_ln:w} \cs{s_fp} \cs{fp_use:w} \meta{case} \meta{sign} \meta{body} |;|
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npx \fp_ln:w \s_fp \fp_use:w #1 #2
  {
    \exp_not:N \if_case:w #2 \exp_stop_f:
    \exp_not:N   \exp_after:wN
    \exp_not:N   \fp_ln_cases:N
    \exp_not:N   \exp_after:wN
                 #1
    \exp_not:N \or:
    \exp_not:N   \exp_after:wN
    \exp_not:N   \fp_ln_nan:w
    \exp_not:N \or:
    \exp_not:N   \fp_aux_case_return:nw
                   {
    \exp_not:N       \exp_after:wN
    \exp_not:N       \fp_aux_snan_fp:N
    \exp_not:N       \exp_after:wN
    \exp_not:c       { fp_info: ~ ln(negative); }
                   }
    \exp_not:N \fi:
  }
\cs_new:Npn \fp_ln_nan:w #1 ;
  {
    \exp_after:wN \fp_aux_qnan_fp:N
    \exp_after:wN #1
  }
\cs_new:Npn \fp_ln_cases:N #1
  {
    \if_case:w #1 \exp_stop_f:
         \fp_aux_case_return:nw { \exp_after:wN \c_minus_inf_fp }
    \or: \exp_after:wN \fp_ln_npos:nw
    \or: \fp_aux_case_return:nw { \exp_after:wN \c_inf_fp }
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Absolute ln}
%
% In this subsection we are given a positive normal number,
% of the form $ a \cdot 10^{b} $ with $0.1\leq a < 1$. To compute
% its logarithm, we find a small integer $1\leq c < 10$ such that
% $ a c \sim 1 $, and use the relation
% \[
% \ln (a \cdot 10^b) = b \cdot \ln (10) - \ln (c) + \ln (a c).
% \]
% The logarithms $\ln(10)$ and $\ln(c)$ can be looked up in a table,
% while the last term is computed using an enhanced version of the
% naive Taylor series of $\ln$ near $1$. We leave the various pieces
% on the right on the input stream, to be added at the end.
%
% Two reasons for multiplying by $c$ instead of dividing by a
% corresponding appropriate number. Efficiency: multiplying by a
% single number digit is among the fastest operations. Accuracy: we
% can multiply by a single digit with no rounding at this stage, and
% at least it makes the analysis of the total rounding errors simpler.
%
% \begin{macro}{\fp_ln_npos:nw}
%   \begin{syntax}
%     \cs{fp_ln_npos:nw} \Arg{exponent} \meta{mantissa} |;|
%   \end{syntax}
%   We catch the case of a mantissa very close to $0.1$ or to $1$.
%   In all other cases, the final result is at least $10^{-4}$, and
%   that an error of $0.5\cdot 10^{-20}$ is acceptable.\footnote{Bruno:
%     special cases not implemented yet.}
%    \begin{macrocode}
\cs_new:Npn \fp_ln_npos:nw #1 #2#3;
  {
    \exp_after:wN \fp_ln_return:Nww
    \int_value:w % for the overall sign
      \if_num:w #1 < \c_one
        2
      \else:
        0
      \fi:
      \exp_after:wN \exp_stop_f:
      \int_use:N \int_eval:w % for the exponent
        \fp_ln_mantissa:NNNNnnnN #2#3
        \fp_ln_exponent:ww #1;
        \fp_fixed_to_float:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, rEXP]{\fp_ln_mantissa:NNNNnnnN}
%   \begin{syntax}
%     \cs{fp_ln_mantissa:NNNNnnnN} \meta{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4} \meta{continuation}
%   \end{syntax}
%   This function is always called within an \cs{int_eval:w} for the
%   overall exponent, \emph{which is currently empty}.
%    \begin{macrocode}
\cs_new:Npn \fp_ln_mantissa:NNNNnnnN #1#2#3#4
  {
    \exp_after:wN \fp_ln_x_ii:wnnnn
    \int_value:w
      \if_case:w #1 \exp_stop_f:
      \or:
        \if_num:w #2 < \c_four
          \int_eval:w \c_ten - #2
        \else:
          6
        \fi:
      \or: 4
      \or: 3
      \or: 2
      \or: 2
      \or: 2
      \else: 1
      \fi:
    ; { #1 #2 #3 #4 }
  }
%    \end{macrocode}
%   We have thus found $c$. It is chosen such that $0.7\leq ac < 1.4$
%   in all cases. Compute $ 1 + x = 1 + ac \in [1.7,2.4)$.
%    \begin{macrocode}
\cs_new:Npn \fp_ln_x_ii:wnnnn #1; #2#3#4#5
  {
    \exp_after:wN \fp_ln_div_after:Nw
    \cs:w c_fp_ln_ #1 _fixed_tl \exp_after:wN \cs_end:
    \int_value:w
      \exp_after:wN \fp_ln_x_iv:nnnnnnnn
      \tex_romannumeral:D -`0
        \exp_after:wN \fp_ln_x_iii_var:NNNNNw
        \int_use:N \int_eval:w 9999 9999 + #1*#2#3 +
          \exp_after:wN \fp_ln_x_iii:NNNNNw
          \int_use:N \int_eval:w 1 0000 0000 + #1*#4#5 ;
    {20000} {0000} {0000} {0000}
  } %^^A todo: reoptimize (a generalization attempt failed).
\cs_new:Npn \fp_ln_x_iii:NNNNNw #1 #2#3#4#5 #6; { #1; {#2#3#4#5} {#6} }
\cs_new:Npn \fp_ln_x_iii_var:NNNNNw #1 #2#3#4#5 #6; { {#1#2#3#4#5} {#6} }
%    \end{macrocode}
%   The Taylor series will be expressed in terms of
%   $t = (x-1)/(x+1) = 1 - 2/(x+1)$. We now compute the
%   quotient with extended precision, reusing some code
%   from \cs{fp_div:ww}. Note that $1+x$ is known exactly.
%
%   To reuse notations from \pkg{l3fp-basics}, we want to
%   compute $ A / Z $ with $ A = 2 $ and $ Z = x + 1 $.
%   In \pkg{l3fp-basics}, we considered the case where
%   both $A$ and $Z$ are arbitrary, in the range $[0.1,1)$,
%   and we had to monitor the growth of the sequence of
%   remainders $A$, $B$, $C$, etc. to ensure that no overflow
%   occured during the computation of the next quotient.
%   The main source of risk was our choice to define the
%   quotient as roughly $10^9 \cdot A / 10^5 \cdot Z$: then
%   $A$ was bound to be below $2.147\cdots$, and this limit
%   was never far.
%
%   In our case, we can simply work with $10^8 \cdot A$ and
%   $10^4 \cdot Z$, because our reason to work with higher
%   powers has gone: we needed the integer $y \simeq 10^5 \cdot Z$
%   to be at least $10^4$, and now, the definition
%   $y \simeq 10^4 \cdot Z$ suffices.
%
%   Let us thus define $y = \left\lfloor 10^4 \cdot Z \right\rfloor + 1
%   \in ( 1.7 \cdot 10^4, 2.4 \cdot 10^4 ] $, and
%   \[
%   Q\sb{1}
%   =
%   \left\lfloor
%     \frac {\left\lfloor 10^8 \cdot A\right\rfloor} {y} - \frac{1}{2}
%   \right\rfloor.
%   \]
%   (The $1/2$ comes from how e\TeX{} rounds.) As for division, it is
%   easy to see that $Q\sb{1} \leq 10^4 A / Z$, \emph{i.e.}, $Q\sb{1}$
%   is an underestimate.
%
%   Exactly as we did for division, we set $B = 10^4 A - Q\sb{1}Z$. Then
%   \begin{align*}
%     10^4 B
%     \leq
%     A\sb{1}A\sb{2}.A\sb{3}A\sb{4}
%     - \left( \frac{A\sb{1}A\sb{2}}{y} - \frac{3}{2} \right) 10^4 Z
%     \leq
%     A\sb{1}A\sb{2} \left( 1 - \frac{10^4 Z}{y} \right) + 1 + \frac{3}{2} y
%     \leq
%     10^8 \frac{A}{y} + 1 + \frac{3}{2} y
%   \end{align*}
%   In the same way, and using $1.7\cdot 10^4\leq y\leq 2.4\cdot 10^4$,
%   and convexity, we get
%   \begin{align*}
%     10^4 A &= 2\cdot 10^4 \\
%     10^4 B &\leq 10^8 \frac{A}{y} + 1.6 y \leq 4.7\cdot 10^4\\
%     10^4 C &\leq 10^8 \frac{B}{y} + 1.6 y \leq 5.8\cdot 10^4\\
%     10^4 D &\leq 10^8 \frac{C}{y} + 1.6 y \leq 6.3\cdot 10^4\\
%     10^4 E &\leq 10^8 \frac{D}{y} + 1.6 y \leq 6.5\cdot 10^4\\
%     10^4 F &\leq 10^8 \frac{E}{y} + 1.6 y \leq 6.6\cdot 10^4\\
%   \end{align*}
%   Note that we compute more steps than for division: since $t$ is
%   not the end result, we need to know it with more accuracy
%   (on the other hand, the ending is much simpler, as we don't
%   need an exact rounding for transcendental functions, but just
%   a faithful rounding).\footnote{Bruno: to be completed.}
%
%   \begin{quote}
%     \cs{fp_ln_x_iv:NNNNNwnn}
%     \meta{1 or 2} \meta{8d} |;| \Arg{4d} \Arg{4d} \meta{fixed-tl}
%   \end{quote}
%   The number is $x$. Compute $y$ by adding 1 to the five first digits.
%    \begin{macrocode}
\cs_new:Npn \fp_ln_x_iv:nnnnnnnn #1#2#3#4 #5#6#7#8
  {
    \exp_after:wN \fp_ln_div_i:w
    \int_use:N \int_eval:w #1 + \c_one ;
    #5 #6 ; {#7} {#8}
    {#1} {#2} {#3} {#4}
  }
\cs_new:Npn \fp_ln_div_i:w #1;
  {
    \exp_after:wN \fp_ln_div_ii:www
    \int_value:w #1 \exp_after:wN ;
    \int_value:w
      \exp_after:wN \fp_basics_div_mantissa_calc:Nwwnnnnnn
      \int_use:N \int_eval:w 999999 + 2 0000 0000 / #1 ; % Q1
  }
\cs_set_protected:Npn \fp_tmp:w #1#2
  {
    \cs_new:Npn #1 ##1; ##2; ##3; % y; Q1; B1B2; <- for k=1
      {
        \exp_after:wN \fp_basics_div_mantissa_pack:NNN
        \int_use:N \int_eval:w ##2
          \exp_after:wN #2
          \int_value:w ##1 \exp_after:wN ;
          \int_value:w
            \exp_after:wN \fp_basics_div_mantissa_calc:Nwwnnnnnn
            \int_use:N \int_eval:w 999999 + ##3 / ##1 ; % Q2
            ##3 ;
      }
  }
\fp_tmp:w \fp_ln_div_ii:www \fp_ln_div_iii:www
\fp_tmp:w \fp_ln_div_iii:www \fp_ln_div_iv:www
\fp_tmp:w \fp_ln_div_iv:www \fp_ln_div_v:www
\fp_tmp:w \fp_ln_div_v:www \fp_ln_div_vi:www
\cs_new:Npn \fp_ln_div_vi:www #1; #2; #3;#4#5 #6#7#8#9 %y;Q5;F1F2;F3F4x1x2x3x4
  {
    \exp_after:wN \fp_basics_div_mantissa_pack:NNN
    \int_use:N \int_eval:w #2
      \exp_after:wN \fp_basics_div_mantissa_pack:NNN
      \int_use:N \int_eval:w 1000000 + #3 / #1 ; % Q6
  }
%    \end{macrocode}
%   We now have essentially\footnote{Bruno: add a mention that
%     the error on $Q\sb{6}$ is bounded by $10$ (probably $6.7$),
%     and thus corresponds to an error of $10^{-23}$ on the final
%     result, small enough in all cases.}
%   \begin{quote}
%     \cs{fp_ln_div_after:Nw} \meta{fixed tl}
%     \cs{fp_basics_div_mantissa_pack:NNN} $10^6 + Q\sb{1}$
%     \cs{fp_basics_div_mantissa_pack:NNN} $10^6 + Q\sb{2}$
%     \cs{fp_basics_div_mantissa_pack:NNN} $10^6 + Q\sb{3}$
%     \cs{fp_basics_div_mantissa_pack:NNN} $10^6 + Q\sb{4}$
%     \cs{fp_basics_div_mantissa_pack:NNN} $10^6 + Q\sb{5}$
%     \cs{fp_basics_div_mantissa_pack:NNN} $10^6 + Q\sb{6}$ |;|
%     \meta{exponent} |;| \meta{continuation}
%   \end{quote}
%   where \meta{fixed tl} holds the logarithm of a number
%   in $[1,10]$, and \meta{exponent} is
%   the exponent. Also, the expansion is done backwards. Then
%   \cs{fp_basics_div_mantissa_pack:NNN} puts things in the
%   correct order to add the $Q\sb{i}$ together and put semicolons
%   between each piece. Once those have been expanded, we get
%   \begin{quote}
%     \cs{fp_ln_div_after:Nw} \meta{fixed-tl} \meta{1d} |;| \meta{4d} |;| \meta{4d} |;| \meta{4d} |;| \meta{4d} |;| \meta{4d} |;| \meta{4d} |;| \meta{exponent} |;|
%   \end{quote}
%   ^^A todo: redoc.
%   Just as with division, we know that the first two digits
%   are |1| and |0| because of bounds on the final result of
%   the division $2/(x+1)$, which is between roughly $0.8$ and $1.2$.
%   We then compute $1-2/(x+1)$, after testing whether $2/(x+1)$ is
%   greater than or smaller than $1$.
%    \begin{macrocode}
\cs_new:Npn \fp_ln_div_after:Nw #1#2;
  {
    \if_meaning:w 0 #2
      \exp_after:wN \fp_ln_t_small:Nw
    \else:
      \exp_after:wN \fp_ln_t_large:NNw
      \exp_after:wN -
    \fi:
    #1
  }
\cs_new:Npn \fp_ln_t_small:Nw #1 #2; #3; #4; #5; #6; #7;
  {
    \exp_after:wN \fp_ln_t_large:NNw
    \exp_after:wN + % <sign>
    \exp_after:wN #1
    \int_use:N \int_eval:w 9999 - #2 \exp_after:wN ;
    \int_use:N \int_eval:w 9999 - #3 \exp_after:wN ;
    \int_use:N \int_eval:w 9999 - #4 \exp_after:wN ;
    \int_use:N \int_eval:w 9999 - #5 \exp_after:wN ;
    \int_use:N \int_eval:w 9999 - #6 \exp_after:wN ;
    \int_use:N \int_eval:w 1 0000 - #7 ;
  }
%    \end{macrocode}
%
%   \begin{quote}
%     \cs{fp_ln_t_large:NNw} \meta{sign}\meta{fixed tl}  \meta{t1}|;| \meta{t2} |;| \meta{t3}|;| \meta{t4}|;| \meta{t5} |;| \meta{t6}|;| \meta{exponent} |;| \meta{continuation}
%   \end{quote}
%   Compute the square $|t|^2$, and keep $|t|$ at the end with its
%   sign. We know that $|t|<0.1765$, so every piece has at most $4$
%   digits. However, since we were not careful in \cs{fp_ln_t_small:w},
%   they can have less than $4$ digits.
%    \begin{macrocode}
\cs_new:Npn \fp_ln_t_large:NNw #1 #2 #3; #4; #5; #6; #7; #8;
  {
    \exp_after:wN \fp_ln_square_t_after:w
    \int_use:N \int_eval:w 9999 0000 + #3*#3
      \exp_after:wN \fp_ln_square_t_pack:NNNNNw
      \int_use:N \int_eval:w 9999 0000 + 2*#3*#4
        \exp_after:wN \fp_ln_square_t_pack:NNNNNw
        \int_use:N \int_eval:w 9999 0000 + 2*#3*#5 + #4*#4
          \exp_after:wN \fp_ln_square_t_pack:NNNNNw
          \int_use:N \int_eval:w 9999 0000 + 2*#3*#6 + 2*#4*#5
            \exp_after:wN \fp_ln_square_t_pack:NNNNNw
            \int_use:N \int_eval:w 1 0000 0000 + 2*#3*#7 + 2*#4*#6 + #5*#5
              + (2*#3*#8 + 2*#4*#7 + 2*#5*#6) / 1 0000
              % ; ; ;
    \exp_after:wN \fp_ln_twice_t_after:w
    \int_use:N \int_eval:w -1 + 2*#3
      \exp_after:wN \fp_ln_twice_t_pack:Nw
      \int_use:N \int_eval:w 9999 + 2*#4
        \exp_after:wN \fp_ln_twice_t_pack:Nw
        \int_use:N \int_eval:w 9999 + 2*#5
          \exp_after:wN \fp_ln_twice_t_pack:Nw
          \int_use:N \int_eval:w 9999 + 2*#6
            \exp_after:wN \fp_ln_twice_t_pack:Nw
            \int_use:N \int_eval:w 9999 + 2*#7
              \exp_after:wN \fp_ln_twice_t_pack:Nw
              \int_use:N \int_eval:w 10000 + 2*#8 ; ;
    { \fp_ln_c:NwNw #1 }
    #2
  }
\cs_new:Npn \fp_ln_twice_t_pack:Nw #1 #2; { + #1 ; {#2} }
\cs_new:Npn \fp_ln_twice_t_after:w #1; { ;;; {#1} }
\cs_new:Npn \fp_ln_square_t_pack:NNNNNw #1 #2#3#4#5 #6;
  { + #1#2#3#4#5 ; {#6} }
\cs_new:Npn \fp_ln_square_t_after:w 1 0 #1#2#3 #4;
  { \fp_ln_Taylor:wwNw {0#1#2#3} {#4} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_ln_Taylor:wwNw}
%   Denoting $T=t^2$, we get
%   \begin{quote}
%     \cs{fp_ln_Taylor:wwNw}
%     \Arg{T_1} \Arg{T_2} \Arg{T_3} \Arg{T_4} \Arg{T_5} \Arg{T_6} |;| |;|
%     \Arg{2t1} \Arg{2t2} \Arg{2t3} \Arg{2t4} \Arg{2t5} \Arg{2t6} |;|
%     |{| \cs{fp_ln_c:NwNn} \meta{sign} |}|
%     \meta{fixed tl} \meta{exponent} |;| \meta{continuation}
%   \end{quote}
%   And we want to compute
%   \[
%   \ln\left(\frac{1+t}{1-t}\right)
%   = 2t\left(1 + T \left(\frac{1}{3} + T \left(\frac{1}{5}
%         + T \left(\frac{1}{7} + T \left( \frac{1}{9} + \cdots
%           \right)\right)\right)\right)\right)
%   \]
%   The process looks as follows
%   \begin{verbatim}
%     \loop 5; A;
%     \div_int 5; 1.0; \add A; \mul T; {\loop \eval 5-2;}
%     \add 0.2; A; \mul T; {\loop \eval 5-2;}
%     \mul B; T; {\loop 3;}
%     \loop 3; C;
%   \end{verbatim}
%   \footnote{Bruno: add explanations.}
%
%   This uses the routine for dividing a number by a small integer
%   (${}<10^4$).
%    \begin{macrocode}
\cs_new:Npn \fp_ln_Taylor:wwNw
  { \fp_ln_Taylor_loop:www 21 ; {0000}{0000}{0000}{0000}{0000}{0000} ; }
\cs_new:Npn \fp_ln_Taylor_loop:www #1; #2; #3;
  {
    \if_num:w #1 = \c_one
      \fp_ln_Taylor_break:w
    \fi:
    \exp_after:wN \fp_fixed_div_int:wwN \c_fp_one_fixed_tl ; #1;
    \fp_fixed_add:wwN #2;
    \fp_fixed_mul:wwn #3;
    {
      \exp_after:wN \fp_ln_Taylor_loop:www
      \int_use:N \int_eval:w #1 - \c_two ;
    }
    #3;
  }
\cs_new:Npn \fp_ln_Taylor_break:w \fi: #1 \fp_fixed_add:wwN #2#3; #4 ;;
  {
    \fi:
    \exp_after:wN \fp_fixed_mul:wwn
    \exp_after:wN { \int_use:N \int_eval:w 10000 + #2 } #3;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_ln_c:NwNw}
%   \begin{quote}
%     \cs{fp_ln_c:NwNw} \meta{sign}
%     \Arg{r_1} \Arg{r_2} \Arg{r_3} \Arg{r_4} \Arg{r_5} \Arg{r_6} |;|
%     \meta{fixed tl} \meta{exponent} |;| \meta{continuation}
%   \end{quote}
%   We are now reduced to finding $\ln c$ and $\meta{exponent}\ln 10$
%   in a table, and adding it to the mixture. The first step is to
%   get $\ln c - \ln x = - \ln a$, then we get $|b|\ln 10$ and add
%   or subtract.
%
%   For now, $\ln x$ is given as $\cdot 10^0$. Unless both the exponent
%   is $1$ and $c=1$, we shift to working in units of $\cdot 10^4$,
%   since the final result will be at least $\ln 10/7 \simeq
%   0.35$.\footnote{Bruno: that was wrong at some point, I must check.}
%    \begin{macrocode}
\cs_new:Npn \fp_ln_c:NwNw #1 #2; #3
  {
    \if_meaning:w + #1
      \exp_after:wN \exp_after:wN \exp_after:wN \fp_fixed_sub:wwN
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \fp_fixed_add:wwN
    \fi:
    #3 ; #2 ;
  }
%    \end{macrocode}
% \footnote{Bruno: this \emph{\textbf{must}} be updated with correct values!}
% \end{macro}
%
% \begin{macro}{\fp_ln_exponent:ww}
%   \begin{quote}
%     \cs{fp_ln_exponent:ww}
%     \Arg{s_1} \Arg{s_2} \Arg{s_3} \Arg{s_4} \Arg{s_5} \Arg{s_6} |;|
%     \meta{exponent} |;|
%   \end{quote}
%   Compute \meta{exponent} times $\ln 10$. Apart from the cases where
%   \meta{exponent} is $0$ or $1$, the result will necessarily be at
%   least $\ln 10 \simeq 2.3$ in magnitude. We can thus drop the least
%   significant $4$ digits. In the case of a very large (positive or
%   negative) exponent, we can (and we need to) drop $4$ additional
%   digits, since the result is of order $10^4$. Naively, one would
%   think that in both cases we can drop $4$ more digits than we do,
%   but that would be slightly too tight for rounding to happen correctly.
%   Besides, we already have addition and subtraction for $24$ digits
%   fixed point numbers.
%    \begin{macrocode}
\cs_new:Npn \fp_ln_exponent:ww #1; #2;
  {
    \if_case:w #2 \exp_stop_f:
      \c_zero \fp_aux_case_return:nw \fp_fixed_continue:wn
    \or:
      \exp_after:wN \fp_ln_exponent_one:ww  \int_value:w
    \else:
      \if_num:w #2 > \c_zero
        \exp_after:wN \fp_ln_exponent_small:Nww
        \exp_after:wN \fp_fixed_sub:wwN \int_value:w
      \else:
        \exp_after:wN \fp_ln_exponent_small:Nww
        \exp_after:wN \fp_fixed_add:wwN \int_value:w -
      \fi:
    \fi:
    #2; #1;
  }
%    \end{macrocode}
%   Now we painfully write all the cases.\footnote{Bruno: do rounding.}
%   No overflow nor underflow can happen, except when computing \texttt{ln(1)}.
%    \begin{macrocode}
\cs_new:Npn \fp_ln_return:Nww #1 #2;
  {
    \if_num:w #2 < - \c_fp_max_exponent_int
      \exp_after:wN \fp_aux_exact_zero:w
    \fi:
    \s_fp \fp_use:w 1 #1 {#2}
  }
\cs_new:Npx \fp_ln_exponent_one:ww 1; #1;
  {
    \c_zero
    \exp_not:N \fp_fixed_sub:wwN
      \exp_not:v { c_fp_ln_10_fixed_tl } ;
      #1;
  }
%    \end{macrocode}
%   For small exponents, we just drop one block of digits, and set the
%   exponent of the log to $4$ (minus any shift coming from leading zeros
%   in the conversion from fixed point to floating point). Note that here
%   the exponent has been made positive.
%    \begin{macrocode}
\cs_new:Npx \fp_ln_exponent_small:Nww #1 #2; #3#4#5#6#7#8;
  {
    \c_four
    \exp_not:N \fp_fixed_mul:wwn
      \exp_not:v { c_fp_ln_10_fixed_tl } ;
      {#2}{0000}{0000}{0000}{0000}{0000} ;
    #1
      {0000}{#3}{#4}{#5}{#6}{#7};
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Exponential}
%
% \subsubsection{Sign, exponent, and special numbers}
%
% \begin{macro}[int, EXP]{\fp_exp:w}
% \begin{macro}[aux, EXP]{\fp_exp_inf:Nw, \fp_exp_normal:Nw}
%    \begin{macrocode}
\cs_new:Npn \fp_exp:w \s_fp \fp_use:w #1
  {
    \if_case:w #1 \exp_stop_f:
         \fp_aux_case_return:nw { \exp_after:wN \c_one_fp }
    \or: \exp_after:wN \fp_exp_normal:Nw
    \or: \exp_after:wN \fp_exp_inf:Nw
    \or:
      \fp_aux_case_return:nw
        { \exp_after:wN \fp_aux_qnan_fp:N \exp_after:wN #1 }
    \fi:
  }
\cs_new:Npn \fp_exp_inf:Nw #1#2;
  {
    \exp_after:wN \s_fp
    \exp_after:wN \fp_use:w
    \int_value:w \if_meaning:w 0 #1 2 \else: 0 \fi:
    \exp_after:wN \exp_stop_f:
    \exp_after:wN 0
    \exp_after:wN #2
    \exp_after:wN ;
  }
\cs_new:Npn \fp_exp_normal:Nw #1
  {
    \if_meaning:w 0 #1
      \exp_after:wN \fp_exp_pos:nw
    \else:
      \exp_after:wN \fp_exp_neg:nw
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\fp_exp_neg:nw}
% ^^A TODO: \fp_exp_neg:nw is BAD!
%   \begin{macrocode}
\cs_new:Npn \fp_exp_neg:nw
  {
    \exp_after:wN \exp_after:wN
    \exp_after:wN \fp_div:ww
    \exp_after:wN \c_one_fp
    \tex_romannumeral:D -`0
    \fp_exp_pos:nw
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\fp_exp_pos:nw}
%    \begin{macrocode}
\cs_new:Npn \fp_exp_pos:nw #1#2;
  {
    \if_int_compare:w #1 < \c_zero
      \if_int_compare:w #1 < - \c_eight
        \fp_basics_add_npos:Nnwnw 0
          {1} {1000} {0000} {0000} {0000} ;
          {#1} #2;
        \tex_romannumeral:D
      \else:
        \exp_after:wN \fp_exp_sanitize:w
        \int_use:N \int_eval:w \c_zero
          \fp_aux_decimate:nNnnnn
            { - #1 }
            \fp_exp_Taylor:Nnnw
            #2
          \fp_fixed_to_float:w
        \tex_romannumeral:D
      \fi:
    \else:
      \if_int_compare:w #1 > \c_five % cf \c_fp_max_exponent_int
        \exp_after:wN \c_inf_fp
        \tex_romannumeral:D
      \else:
        \exp_after:wN \fp_exp_sanitize:w
        \int_use:N \int_eval:w \c_zero
          \fp_aux_decimate:nNnnnn
            { \c_sixteen - #1 }
            \fp_exp_pos_large:NnnNwn
            #2
            {#1}
        \tex_romannumeral:D
      \fi:
    \fi:
    \exp_after:wN \c_zero
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\fp_exp_sanitize:w}
%   After the computation, check that the result does not overflow.
%    \begin{macrocode}
\cs_new:Npn \fp_exp_sanitize:w #1;
  {
    \if_num:w #1 > \c_fp_max_exponent_int
      \exp_after:wN \fp_aux_overflow:w
    \fi:
    \s_fp \fp_use:w 1 0 {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\fp_exp_Taylor:Nnnw}
% \begin{macro}[aux, EXP]{\fp_exp_Taylor_loop:www, \fp_exp_Taylor_break:Nww}
%   This function is called for numbers in the range $[10^{-9},
%   10^{-1})$.  Our only task is to compute the Taylor series.  The
%   first argument is irrelevant (rounding digit used by some other
%   functions).  The next three arguments, at least $16$ digits,
%   delimited by a semicolon, form a fixed point number, so we pack it
%   in blocks of $4$ digits.
%    \begin{macrocode}
\cs_new:Npn \fp_exp_Taylor:Nnnw #1#2#3 #4;
  {
    \fp_aux_pack_twice_four:wNNNNNNNN
    \fp_aux_pack_twice_four:wNNNNNNNN
    \fp_aux_pack_twice_four:wNNNNNNNN
    \fp_exp_Taylor_ii:ww
    ; #2#3#4 0000 0000 ;
  }
\cs_new:Npn \fp_exp_Taylor_ii:ww #1; #2;
  { \fp_exp_Taylor_loop:www 10 ; #1 ; #1 ; \s_stop }
\cs_new:Npn \fp_exp_Taylor_loop:www #1; #2; #3;
  {
    \if_int_compare:w #1 = \c_one
      \exp_after:wN \fp_exp_Taylor_break:Nww
    \fi:
    \fp_fixed_div_int:wwN #3 ; #1 ;
    \fp_fixed_add_one:wN
    \fp_fixed_mul:wwn #2 ;
    {
      \exp_after:wN \fp_exp_Taylor_loop:www
      \int_use:N \int_eval:w #1 - 1 ;
      #2 ;
    }
  }
\cs_new:Npn \fp_exp_Taylor_break:Nww #1 #2; #3 \s_stop
  { \fp_fixed_add_one:wN #2 ; }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]
%   {
%     \fp_exp_pos_large:NnnNwn ,
%     \fp_exp_large_after:wN ,
%     \fp_exp_large:w ,
%     \fp_exp_large_v:wN,
%     \fp_exp_large_iv:wN,
%     \fp_exp_large_iii:wN,
%     \fp_exp_large_ii:wN,
%     \fp_exp_large_i:wN,
%     \fp_exp_large_:wN,
%   }
%   The first two arguments are irrelevant (a rounding digit, and a
%   brace group with $8$ zeros).  The third argument is the integer part
%   of our number, then we have the decimal part delimited by a
%   semicolon, and finally the exponent, in the range $[0,5]$.  Remove
%   leading zeros from the integer part: putting |#4| in there too
%   ensures that an integer part of $0$ is also removed.  Then read
%   digits one by one, looking up $\exp(\meta{digit}\cdot
%   10^{\meta{exponent}})$ in a table, and multiplying that to the
%   current total.  The loop is done by having the auxiliary for one
%   exponent call the auxiliary for the next exponent.  The current
%   total is expressed by leaving the exponent behind in the input
%   stream (we are currently within an \cs{int_eval:w}), and keeping
%   track of a fixed point number, |#1| for the numbered auxiliaries.
%   Our usage of \cs{if_case:w} is somewhat dirty for optimization:
%   \TeX{} jumps to the appropriate case, but we then lose the
%   \cs{if_case:w} \enquote{by hand}, using \cs{or:} and \cs{fi:} as
%   delimiters.
%    \begin{macrocode}
\cs_new:Npn \fp_exp_pos_large:NnnNwn #1#2#3 #4#5; #6
  {
    \exp_after:wN \exp_after:wN
    \cs:w fp_exp_large_\tex_romannumeral:D #6:wN \exp_after:wN \cs_end:
    \exp_after:wN \c_fp_one_fixed_tl
    \exp_after:wN ;
    \int_value:w #3 #4 \exp_stop_f:
    #5 00000 ;
  }
\cs_new:Npn \fp_exp_large_after:wN #1; #2;
  {
    \fp_exp_Taylor:Nnnw ? { } { } 0 #2;
    \fp_fixed_mul:wwn #1;
    \fp_fixed_to_float:w
  }
\cs_new:Npn \fp_exp_large:w #1 \or: #2 \fi:
  { \fi: \fp_fixed_mul:wwn #1; }
\cs_new:Npn \fp_exp_large_v:wN #1; #2
  {
    \if_case:w #2 ~           \exp_after:wN \fp_fixed_continue:wn  \or:
      +  4343 \fp_exp_large:w {8806}{8182}{2566}{2921}{5872}{6150} \or:
      +  8686 \fp_exp_large:w {7756}{0047}{2598}{6861}{0458}{3204} \or:
      + 13029 \fp_exp_large:w {6830}{5723}{7791}{4884}{1932}{7351} \or:
      + 17372 \fp_exp_large:w {6015}{5609}{3095}{3052}{3494}{7574} \or:
      + 21715 \fp_exp_large:w {5297}{7951}{6443}{0315}{3251}{3576} \or:
      + 26058 \fp_exp_large:w {4665}{6719}{0099}{3379}{5527}{2929} \or:
      + 30401 \fp_exp_large:w {4108}{9724}{3326}{3186}{5271}{5665} \or:
      + 34744 \fp_exp_large:w {3618}{6973}{3140}{0875}{3856}{4102} \or:
      + 39087 \fp_exp_large:w {3186}{9209}{6113}{3900}{6705}{9685} \or:
    \fi:
    #1;
    \fp_exp_large_iv:wN
  }
\cs_new:Npn \fp_exp_large_iv:wN #1; #2
  {
    \if_case:w #2 ~          \exp_after:wN \fp_fixed_continue:wn  \or:
      +  435 \fp_exp_large:w {1970}{0711}{1401}{7046}{9938}{8888} \or:
      +  869 \fp_exp_large:w {3881}{1801}{9428}{4368}{5764}{8232} \or:
      + 1303 \fp_exp_large:w {7646}{2009}{8905}{4704}{8893}{1073} \or:
      + 1738 \fp_exp_large:w {1506}{3559}{7005}{0524}{9009}{7592} \or:
      + 2172 \fp_exp_large:w {2967}{6283}{8402}{3667}{0689}{6630} \or:
      + 2606 \fp_exp_large:w {5846}{4389}{5650}{2114}{7278}{5046} \or:
      + 3041 \fp_exp_large:w {1151}{7900}{5080}{6878}{2914}{4154} \or:
      + 3475 \fp_exp_large:w {2269}{1083}{0850}{6857}{8724}{4002} \or:
      + 3909 \fp_exp_large:w {4470}{3047}{3316}{5442}{6408}{6591} \or:
    \fi:
    #1;
    \fp_exp_large_iii:wN
  }
\cs_new:Npn \fp_exp_large_iii:wN #1; #2
  {
    \if_case:w #2 ~         \exp_after:wN \fp_fixed_continue:wn  \or:
      +  44 \fp_exp_large:w {2688}{1171}{4181}{6135}{4484}{1263} \or:
      +  87 \fp_exp_large:w {7225}{9737}{6812}{5749}{2581}{7748} \or:
      + 131 \fp_exp_large:w {1942}{4263}{9524}{1255}{9365}{8421} \or:
      + 174 \fp_exp_large:w {5221}{4696}{8976}{4143}{9505}{8876} \or:
      + 218 \fp_exp_large:w {1403}{5922}{1785}{2837}{4107}{3977} \or:
      + 261 \fp_exp_large:w {3773}{0203}{0092}{9939}{8234}{0143} \or:
      + 305 \fp_exp_large:w {1014}{2320}{5473}{5004}{5094}{5533} \or:
      + 348 \fp_exp_large:w {2726}{3745}{7211}{2566}{5673}{6478} \or:
      + 391 \fp_exp_large:w {7328}{8142}{2230}{7421}{7051}{8866} \or:
    \fi:
    #1;
    \fp_exp_large_ii:wN
  }
\cs_new:Npn \fp_exp_large_ii:wN #1; #2
  {
    \if_case:w #2 ~        \exp_after:wN \fp_fixed_continue:wn  \or:
      +  5 \fp_exp_large:w {2202}{6465}{7948}{0671}{6516}{9579} \or:
      +  9 \fp_exp_large:w {4851}{6519}{5409}{7902}{7796}{9107} \or:
      + 14 \fp_exp_large:w {1068}{6474}{5815}{2446}{2146}{9905} \or:
      + 18 \fp_exp_large:w {2353}{8526}{6837}{0199}{8540}{7900} \or:
      + 22 \fp_exp_large:w {5184}{7055}{2858}{7072}{4640}{8745} \or:
      + 27 \fp_exp_large:w {1142}{0073}{8981}{5684}{2836}{6296} \or:
      + 31 \fp_exp_large:w {2515}{4386}{7091}{9167}{0062}{6578} \or:
      + 35 \fp_exp_large:w {5540}{6223}{8439}{3510}{0525}{7117} \or:
      + 40 \fp_exp_large:w {1220}{4032}{9431}{7840}{8020}{0271} \or:
    \fi:
    #1;
    \fp_exp_large_i:wN
  }
\cs_new:Npn \fp_exp_large_i:wN #1; #2
  {
    \if_case:w #2 ~       \exp_after:wN \fp_fixed_continue:wn  \or:
      + 1 \fp_exp_large:w {2718}{2818}{2845}{9045}{2353}{6029} \or:
      + 1 \fp_exp_large:w {7389}{0560}{9893}{0650}{2272}{3043} \or:
      + 2 \fp_exp_large:w {2008}{5536}{9231}{8766}{7740}{9285} \or:
      + 2 \fp_exp_large:w {5459}{8150}{0331}{4423}{9078}{1103} \or:
      + 3 \fp_exp_large:w {1484}{1315}{9102}{5766}{0342}{1116} \or:
      + 3 \fp_exp_large:w {4034}{2879}{3492}{7351}{2260}{8387} \or:
      + 4 \fp_exp_large:w {1096}{6331}{5842}{8458}{5992}{6372} \or:
      + 4 \fp_exp_large:w {2980}{9579}{8704}{1728}{2747}{4359} \or:
      + 4 \fp_exp_large:w {8103}{0839}{2757}{5384}{0077}{1000} \or:
    \fi:
    #1;
    \fp_exp_large_:wN
  }
\cs_new:Npn \fp_exp_large_:wN #1; #2
  {
    \if_case:w #2 ~       \exp_after:wN \fp_fixed_continue:wn  \or:
      + 1 \fp_exp_large:w {1105}{1709}{1807}{5647}{6248}{1171} \or:
      + 1 \fp_exp_large:w {1221}{4027}{5816}{0169}{8339}{2107} \or:
      + 1 \fp_exp_large:w {1349}{8588}{0757}{6003}{1039}{8374} \or:
      + 1 \fp_exp_large:w {1491}{8246}{9764}{1270}{3178}{2485} \or:
      + 1 \fp_exp_large:w {1648}{7212}{7070}{0128}{1468}{4865} \or:
      + 1 \fp_exp_large:w {1822}{1188}{0039}{0508}{9748}{7537} \or:
      + 1 \fp_exp_large:w {2013}{7527}{0747}{0476}{5216}{2455} \or:
      + 1 \fp_exp_large:w {2225}{5409}{2849}{2467}{6045}{7954} \or:
      + 1 \fp_exp_large:w {2459}{6031}{1115}{6949}{6638}{0013} \or:
    \fi:
    #1;
    \fp_exp_large_after:wN
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Power}
%
% Raising a negative number to some power is only allowed for integer
% exponents and the sign depends on parity.
%
% \begin{macro}[int, EXP]{\fp_pow:ww}
%   ^^A Slight coupling with \pkg{l3fp-convert} for \texttt{nan}.
%   ^^A todo: move ~\fp_pow_nan:w to l3fp-aux.
%   ^^A todo: explain this tabular
%^^A   \begin{tabular}{cccc}
%^^A     00^31 = nan  & 02^31 = nan  & 20^31 = nan  & 22^31 = nan  \\
%^^A     00^20 = 0    & 02^20 = 0    & 20^20 = inf  & 22^20 = nan  \\
%^^A     00^22 = inf  & 02^22 = inf  & 20^22 = 0    & 22^22 = nan  \\
%^^A     00^10 = 0    & 02^10 = ?0   & 20^10 = inf  & 22^10 = ?inf \\
%^^A     00^12 = inf  & 02^12 = ?inf & 20^12 = 0    & 22^12 = ?0   \\
%^^A     00^00 = nan  & 02^00 = nan  & 20^00 = nan  & 22^00 = nan  \\
%^^A     00^02 = nan  & 02^02 = nan  & 20^02 = nan  & 22^02 = nan  \\
%^^A   \end{tabular}
%    \begin{macrocode}
\cs_new:Npn \fp_pow:ww \s_fp \fp_use:w #1#2#3; \s_fp \fp_use:w #4#5#6;
  {
    \if_meaning:w 2 #2
      \exp_after:wN \fp_pow_neg:Nw
      \int_value:w \fp_pow_parity:w #4 #5 #6
    \fi:
    \if_case:w #1 \exp_stop_f:
         \exp_after:wN \fp_pow_nonf:NNww
    \or: \exp_after:wN \fp_pow_pos:NNww
    \or: \exp_after:wN \fp_pow_nonf:NNww
    \else: \exp_after:wN \fp_aux_return_qnan:Nww \exp_after:wN ^
    \fi:
    #4#5
    \s_fp \fp_use:w #1  0 #3;
    \s_fp \fp_use:w #4 #5 #6;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\fp_pow_nonf:NNww, \fp_pow_nonf_aux:Nww}
%   Called in the case where $x=0\text{ or }\infty$.  Followed by
%   \meta{type(y)}, \meta{sign(y)}, \meta{x}, \meta{y}.  When raised to
%   the power $0$, error.  When raised to the power \texttt{nan}, simply
%   keep the \texttt{nan} (currently wrong).  Otherwise, the result is
%   that $\infty^{\text{negative}} = 0^{\text{positive}} = 0$, and
%   $\infty^{\text{positive}} = 0^{\text{negative}} = \infty$.
%    \begin{macrocode}
\cs_new:Npn \fp_pow_nonf:NNww #1
  {
    \if_case:w #1 \exp_stop_f:
         \exp_after:wN \fp_aux_return_snan:Nww \exp_after:wN ^
    \or: \exp_after:wN \fp_pow_nonf_aux:Nww
    \or: \exp_after:wN \fp_pow_nonf_aux:Nww
    \else: \exp_after:wN \fp_aux_return_qnan:Nww \exp_after:wN ^
    \fi:
  }
\cs_new:Npn \fp_pow_nonf_aux:Nww #1 \s_fp \fp_use:w #2
  {
    \if_meaning:w #1#2
      \exp_after:wN \fp_aux_return_zero:ww
    \else:
      \exp_after:wN \fp_aux_return_inf:ww
    \fi:
    \s_fp \fp_use:w #2
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\fp_pow_pos:NNww}
%   We have in front of us \meta{type(y)}, \meta{sign(y)}, $x$, and $y$,
%   and $x$ is a positive normal number.
%    \begin{macrocode}
\cs_new:Npn \fp_pow_pos:NNww #1#2 \s_fp \fp_use:w 1 0 #3 #4;
  {
    \if_case:w \int_eval:w
                 \if_num:w
                     \pdftex_strcmp:D
                       { #3 #4 } { 1 {1000}{0000}{0000}{0000} }
                     = \c_zero
                   \c_five - #1
                 \else:
                   #1 - \c_one
                 \fi:
               \int_eval_end:
      \exp_after:wN \fp_pow_pos_normal:Nww \exp_after:wN #2
    \or:
      \if:w #2 \if_int_compare:w #3 > \c_zero 0 \else: 2 \fi:
        \exp_after:wN \exp_after:wN \exp_after:wN \fp_aux_return_zero:ww
      \else:
        \exp_after:wN \exp_after:wN \exp_after:wN \fp_aux_return_inf:ww
      \fi:
    \or:   \exp_after:wN \fp_aux_return_qnan:Nww \exp_after:wN ^
    \or:   \exp_after:wN \fp_aux_return_snan:Nww \exp_after:wN ^
    \else: \exp_after:wN \fp_aux_return_one:ww
    \fi:
    \s_fp \fp_use:w 1 0 {#3} #4;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\fp_pow_pos_normal:Nww}
%   Now we have filtered out all the nasty special cases and are left
%   with positive normal numbers only (and $x\neq 1$).  We are thus
%   computing $|x|^{|y|} = (a \cdot 10^{n})^{b\cdot 10^{p}} =
%   \exp((\log(a) + n \log(10))\cdot b \cdot 10^{p})$.  To compute the
%   exponential accurately, we need to know the digits of the
%   intermediate result up to the $16$-th position.  Since the
%   exponential of $10^7$ is infinite, we only need at most $23$ digits,
%   hence the fixed point result of \cs{fp_ln:w} is precise enough.
%    \begin{macrocode}
\cs_new:Npn \fp_pow_pos_normal:Nww
    #1 \s_fp \fp_use:w 1#2 #3 #4#5; \s_fp \fp_use:w 1#6 #7 #8#9;
  {
    \if:w #1 \if_num:w #3 < \c_one 0 \else: 2 \fi:
      \exp_after:wN \exp_after:wN
      \exp_after:wN \fp_div:ww
      \exp_after:wN \c_one_fp
      \tex_romannumeral:D -`0
    \fi:
    \fp_ln_mantissa:NNNNnnnN #4#5
    \fp_pow_exponent:wn {#3}
    {#7} {#8} #9;
  }
\cs_new:Npn \fp_pow_exponent:wn #1#2#3#4#5#6; #7 #8#9;
  {
    \if_num:w #7 > \c_zero
      \exp_after:wN \fp_pow_exponent:Nw
      \exp_after:wN \fp_fixed_sub:wwN
    \else:
      \exp_after:wN \fp_pow_exponent:Nw
      \exp_after:wN \fp_fixed_add:wwN \int_value:w -
    \fi:
    #7; {0000}{#1}{#2}{#3}{#4}{#5};
    \fp_fixed_mul:wwn #9 {0000}{0000} ;
    \fp_pow_B:ww #8;
  }
\cs_new:Npn \fp_pow_exponent:Nw #1#2;
  {
    \exp_after:wN \fp_fixed_mul_after:wwn
    \int_use:N \int_eval:w -5 0000
      \exp_after:wN \fp_fixed_mul_pack:NNNNNw
      \int_use:N \int_eval:w 4 9995 0000 + #2*23025
        \exp_after:wN \fp_fixed_mul_pack:NNNNNw
        \int_use:N \int_eval:w 4 9995 0000 + #2*8509
          \exp_after:wN \fp_fixed_mul_pack:NNNNNw
          \int_use:N \int_eval:w 4 9995 0000 + #2*2994
            \exp_after:wN \fp_fixed_mul_pack:NNNNNw
            \int_use:N \int_eval:w 4 9995 0000 + #2*0456
              \exp_after:wN \fp_fixed_mul_pack:NNNNNw
              \int_use:N \int_eval:w 5 0000 0000
                + #2*8401 + ( #2*7991 )/10000 ; ;
    #1
  } %^^A todo: use that in ln. %^^A todo: too much precision?
\cs_new:Npn \fp_pow_B:ww #1#2#3#4#5#6; #7;
  {
    \if_int_compare:w #7 < \c_zero
      \exp_after:wN \fp_pow_C_neg:w \int_value:w -
    \else:
      \if_int_compare:w #7 < \c_twenty_six
        \exp_after:wN \fp_pow_C_pos:w \int_value:w
      \else:
        \exp_after:wN \fp_pow_C_huge:w \int_value:w
      \fi:
    \fi:
    #7 \exp_after:wN ;
    \int_use:N \int_eval:w 10 0000 + #1 \int_eval_end:
    #2#3#4#5#6 0000 0000 0000 0000 0000 0000 ; %^^A todo: how many 0?
  }
\cs_new:Npn \fp_pow_C_huge:w #1; 1 #2 0000 0000 0000 0000 0000 0000 ;
  {
    \if:w 0 \pdftex_strcmp:D {#2} { 0 0000 0000 0000 0000 0000 0000 }
    \else: \exp_after:wN \fp_aux_overflow:w \tex_romannumeral:D -`0
    \fi:
    \exp_after:wN \c_one_fp
  }
\cs_new:Npn \fp_pow_C_neg:w #1 ; 1
  {
    \exp_after:wN \exp_after:wN \exp_after:wN \fp_pow_C_pack:w
    \prg_replicate:nn {#1} {0}
  }
\cs_new:Npn \fp_pow_C_pos:w #1; 1
  { \fp_pow_C_pos_loop:wN #1; }
\cs_new:Npn \fp_pow_C_pos_loop:wN #1; #2
  {
    \if_meaning:w 0 #1
      \exp_after:wN \fp_pow_C_pack:w
      \exp_after:wN #2
    \else:
      \if_meaning:w 0 #2
        \exp_after:wN \fp_pow_C_pos_loop:wN \int_value:w
      \else:
        \exp_after:wN \fp_pow_C_overflow:w \int_value:w
      \fi:
      \int_eval:w #1 - \c_one \exp_after:wN ;
    \fi:
  }
\cs_new:Npn \fp_pow_C_overflow:w #1; #2;
  {
    \exp_after:wN \exp_after:wN \exp_after:wN \fp_aux_overflow:w
    \exp_after:wN \c_inf_fp %^^A fake number.
  }
\cs_new:Npn \fp_pow_C_pack:w
  {
    \exp_after:wN \fp_exp_sanitize:w
    \int_use:N \int_eval:w \c_zero
      \exp_after:wN \fp_exp_large_v:wN \c_fp_one_fixed_tl ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\fp_pow_neg:Nww, \fp_pow_neg_nan:w}
%   If the exponent is an integer (|#1| is its sign, $0$ or $2$), then
%   return the result of the previous step with a changed sign.
%   ^^A todo: improve error detection.
%    \begin{macrocode}
\cs_new:Npn \fp_pow_neg:Nw #1 \s_fp \fp_use:w #2#3
  {
    \if_meaning:w 1 #1
      \if_meaning:w 1 #2 \fp_pow_neg_nan:w \fi:
      \if_meaning:w 2 #2 \fp_pow_neg_nan:w \fi:
    \fi:
    \exp_after:wN \s_fp
    \exp_after:wN \fp_use:w
    \exp_after:wN #2
    \int_value:w \if_meaning:w 1 #3 1 \else: #1 \fi: \exp_stop_f:
  }
\cs_new:Npx \fp_pow_neg_nan:w \fi: #1 \fi: #2;
  {
    \exp_not:n { \fi: \fi: }
    \exp_not:N \fp_aux_snan_fp:N
    \exp_not:c { fp_info: ~ negative ^ non-integer ; }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\fp_pow_parity:w}
% \begin{macro}[aux, EXP]
%   {\fp_pow_parity_aux:nnnnn, \fp_pow_parity_aux:NNNNNNNNw}
%^^A todo: redoc
%   This function must be preceeded by \cs{int_value:w}. It then expands
%   to $0$ for even integers, $2$ for odd integers, and $1$ for
%   non-integers, and continues expanding, looking for more digits: in
%   practice, this is stopped by a \cs{s_fp} from \cs{fp_pow:ww}.  Zeros
%   are even.  The sign of normal numbers is irrelevant.  If the
%   exponent is greater than sixteen, then the number is even.  If the
%   exponent is non-positive, the number cannot be an integer.  We
%   separate the ranges of exponent $[1,8]$ and $[9,16]$.  In the former
%   case, check that the last $8$ digits are zero (otherwise we don't
%   have an integer).  In both cases, consider the appropriate $8$
%   digits, either |#4#5| or |#2#3|, remove the first few: we are then
%   left with \meta{digit} \meta{digits} |;| which would be the digits
%   surrounding the decimal period.
%    \begin{macrocode}
\cs_new:Npn \fp_pow_parity:w #1#2
  {
    \if_case:w #1 \exp_stop_f:
           0 \exp_after:wN \use_none:n
    \or:     \exp_after:wN \fp_pow_parity_aux:nnnnn
    \else: 1 \exp_after:wN \use_none:n
    \fi:
  }
\cs_new:Npn \fp_pow_parity_aux:nnnnn #1#2#3#4#5
  {
    \if_num:w #1 > \c_eight
      \if_num:w #1 > \c_sixteen
        0
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_pow_parity_aux:NNNNNNNNw
        \prg_replicate:nn { \c_sixteen - #1 } { 0 } #4#5 ;
      \fi:
    \else:
      \if_num:w #1 > \c_zero
        \if_num:w #4#5 = \c_zero
          \exp_after:wN \exp_after:wN
          \exp_after:wN \fp_pow_parity_aux:NNNNNNNNw
          \prg_replicate:nn { \c_eight - #1 } { 0 } #2#3 ;
        \else:
          1
        \fi:
      \else:
        1
      \fi:
    \fi:
  }
\cs_new:Npn \fp_pow_parity_aux:NNNNNNNNw #1#2#3#4#5#6#7#8#9;
  {
    \if_int_compare:w 0 #9 = \c_zero
      \if_int_odd:w #8 \exp_stop_f:
        2
      \else:
        0
      \fi:
    \else:
      1
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex