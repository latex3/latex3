% \iffalse meta-comment
%
%% File: l3fp-convert.dtx Copyright(C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{l3fp-new}
\GetIdInfo$Id$
  {L3 Experimental floating point conversion}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\usepackage{l3fp-new}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{l3fp-convert} package\\ Floating point conversion^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\texttt{l3fp-convert} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
% \subsection{Floating point to various outputs}
%
% \subsubsection{Decimal}
%
% \begin{macro}[EXP]
%   {\fp_to_decimal:N, \fp_to_decimal:c, \fp_to_decimal:n}
%   All three variants are based on the same \cs{fp_to_decimal:w} after
%   evaluating their argument to an internal floating point.
%    \begin{macrocode}
\cs_new:Npn \fp_to_decimal:N #1 { \exp_after:wN \fp_to_decimal:w #1 }
\cs_generate_variant:Nn \fp_to_decimal:N { c }
\cs_new_nopar:Npn \fp_to_decimal:n
  {
    \exp_after:wN \fp_to_decimal:w
    \tex_romannumeral:D -`0 \fp_parse:n
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,aux]
%   {
%     \fp_to_decimal:w,
%     \fp_to_decimal_normal:nnnnn,
%     \fp_to_decimal_large:Nnnw,
%     \fp_to_decimal_huge:wnnnn,
%   }
%   In the case of a \texttt{nan}, we trigger the \enquote{Missing
%     number, treated as $0$.} error.
%    \begin{macrocode}
\cs_new:Npn \fp_to_decimal:w \s_fp \fp_use:w #1#2
  {
    \if_meaning:w 2 #2 \exp_after:wN - \tex_romannumeral:D -`0 \fi:
    \if_case:w #1 \exp_stop_f:
         \fp_aux_case_return:nw { 0.000 0000 0000 0000 }
    \or: \exp_after:wN \fp_to_decimal_normal:nnnnn
    \or: \fp_aux_case_return:nw { 9999 9999 9999 9999 }
    \else:
      \fp_aux_case_return:nw
        {
          \exp_after:wN \use_none:n \tex_romannumeral:D ;
          0.000 0000 0000 0000
        }
    \fi:
  }
\cs_new:Npn \fp_to_decimal_normal:nnnnn #1 #2#3#4#5;
  {
    \int_compare:nNnTF {#1} > \c_zero
      {
        \int_compare:nNnTF {#1} < \c_sixteen
          {
            \fp_aux_decimate:nNnnnn { \c_sixteen - #1 }
              \fp_to_decimal_large:Nnnw
          }
          {
            \exp_after:wN \exp_after:wN
            \exp_after:wN \fp_to_decimal_huge:wnnnn
            \prg_replicate:nn { #1 - \c_sixteen } { 0 }
          }
        {#2} {#3} {#4} {#5}
      }
      {
        \exp_after:wN 0 \exp_after:wN .
        \prg_replicate:nn { - #1 } { 0 }
        #2#3#4#5
      }
  }
\cs_new:Npn \fp_to_decimal_large:Nnnw #1#2#3#4;
  {
    \int_value:w % remove leading zeros.
      \if_int_compare:w #2 > \c_zero
        #2 \exp_after:wN \exp_stop_f:
      \fi:
    #3.#4
  }
\cs_new:Npn \fp_to_decimal_huge:wnnnn #1; #2#3#4#5 { #2#3#4#5 #1 }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Dimension}
%  ^^A todo: correct the rounding.
% \begin{macro}[EXP]{\fp_to_dim:N, \fp_to_dim:c, \fp_to_dim:n}
%   The three functions evaluate their argument, then pass it to
%   \cs{fp_to_dim:w}.
%    \begin{macrocode}
\cs_new:Npn \fp_to_dim:N #1 { \exp_after:wN \fp_to_dim:w #1 }
\cs_generate_variant:Nn \fp_to_dim:N { c }
\cs_new_nopar:Npn \fp_to_dim:n
  {
    \exp_after:wN \fp_to_dim:w
    \tex_romannumeral:D -`0 \fp_parse:n
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {
%     \fp_to_dim:w , \fp_to_dim_normal:nnnnn , \fp_to_dim_small:n ,
%     \fp_to_dim_large:n , \fp_to_dim_large_pack:NNNNNw
%   }
%   Our goal is to convert a floating point to a dimension in
%   \texttt{pt}.  The first step is to evaluate the floating point
%   expression.  Then start a \cs{dim_eval:n} ending with \texttt{pt} to
%   avoid any worry, and insert a minus sign if appropriate.  Zero
%   floating point numbers are mapped to \cs{c_zero_dim}, infinite
%   floating point numbers to \texttt{99999pt}, causing an overflow, and
%   \texttt{nan} is mapped to \texttt{pt}, triggering the appropriate
%   \TeX{} error: \enquote{Missing number, treated as 0}.  Finally, for
%   normal numbers, check the exponent: if it is too large, output
%   \texttt{99999pt} as for infinities; if it is very small, output
%   \cs{c_zero_dim}, and in between, either produce
%   \texttt{.000\ldots{}00} followed by the actual digits, or grab the
%   first few digits and add a dot afterwards.
%    \begin{macrocode}
\cs_new:Npn \fp_to_dim:w \s_fp \fp_use:w #1#2#3;
  {
    \dim_eval:n
      {
        \if_meaning:w 2 #2 - \fi:
        \if_case:w #1 \exp_stop_f:
             \c_zero
        \or: \fp_to_dim_normal:nnnnn #3
        \or: 99999
        \fi:
        pt
      }
  }
\cs_new:Npn \fp_to_dim_normal:nnnnn #1#2#3#4#5
  {
    \if_num:w #1 > \c_five
      99999
    \else:
      \if_num:w #1 < - \c_five
        \c_zero
      \else:
        \if_num:w #1 > \c_zero
          \exp_after:wN \fp_to_dim_large:n
        \else:
          \exp_after:wN \fp_to_dim_small:n
        \fi:
        {#1} #2#3#4#5
      \fi:
    \fi:
  }
\cs_new:Npn \fp_to_dim_small:n #1
  { . \prg_replicate:nn {-#1} {0} }
\cs_new:Npn \fp_to_dim_large:n #1
  {
    \exp_after:wN \exp_after:wN
    \exp_after:wN \fp_to_dim_large_pack:NNNNNw
      \prg_replicate:nn { \c_five - #1 } {0}
  }
\cs_new:Npn \fp_to_dim_large_pack:NNNNNw #1#2#3#4#5 { #1#2#3#4#5 . }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Integer}
%
% \begin{macro}[EXP]{\fp_to_int:N, \fp_to_int:c, \fp_to_int:n}
%   The three functions evaluate their argument, then pass it to
%   \cs{fp_to_int:w}.
%    \begin{macrocode}
\cs_new:Npn \fp_to_int:N #1 { \exp_after:wN \fp_to_int:w #1 }
\cs_generate_variant:Nn \fp_to_int:N { c }
\cs_new_nopar:Npn \fp_to_int:n
  {
    \exp_after:wN \fp_to_int:w
    \tex_romannumeral:D -`0 \fp_parse:n
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {
%     \fp_to_int:w,
%     \fp_to_int_normal:Nnnnnn,
%     \fp_to_int_large_aux:NNNNNNNNN,
%     \fp_to_int_large_aux:NNNNNNwN
%   }
%   ^^A inconsistency on whether overflow causes error.
%   Our goal is to convert a floating point to an integer, rounding
%   correctly.  The first step is to evaluate the floating point
%   expression.  Then find the sign, which will affect an integer
%   expression.  Zero is mapped to $0$, infinite floating points are
%   silently mapped to the largest available integer, and \texttt{nan}
%   triggers a \enquote{Missing number, treated as 0} error.  Finally,
%   for normal numbers, detect underflow (non-positive exponent), and
%   overflow (more elaborate tests using $2^{31}-1 = 2147483647$).  In
%   the most normal case, we can grab $10$ digits after adding the
%   appropriate number of $0$ to the front, then do the rounding.
%    \begin{macrocode}
\cs_new:Npn \fp_to_int:w \s_fp \fp_use:w #1#2#3;
  {
    \int_value:w \if_meaning:w 2 #2 - \fi:
      \int_eval:w
        \if_case:w #1 \exp_stop_f:
             \c_zero
        \or: \fp_to_int_normal:Nnnnnn #2 #3
        \or: \c_max_int
        \fi:
      \int_eval_end:
  }
\cs_new:Npn \fp_to_int_normal:Nnnnnn #1#2#3#4#5#6
  {
    \if_case:w
        \if_num:w #2 < \c_zero      \c_two \fi:
        \if_num:w #2 > \c_ten       \c_one \fi:
        \if_num:w #2 = \c_ten
          \if_num:w #3#4 > 21474836 \c_one \fi:
          \if_num:w #3#4 = 21474836 \exp_stop_f:
            \if_num:w #5 > 4699     \c_one \fi:
          \fi:
        \fi:
        \c_zero
      \exp_after:wN \exp_after:wN
      \exp_after:wN \fp_to_int_large_aux:NNNNNNNNN
      \prg_replicate:nn { \c_ten - #2 } {0}
      #3#4#5#6 ; #1
    \or:
      \c_max_int
    \else:
      \c_zero
    \fi:
  }
\cs_new:Npn \fp_to_int_large_aux:NNNNNNNNN #1#2#3#4#5#6#7#8#9
  { #1#2#3#4#5#6#7#8#9 \fp_to_int_large_aux:NNNNNNwN }
\cs_new:Npn \fp_to_int_large_aux:NNNNNNwN #1#2 #3#4#5#6#7; #8
  { #1 + \fp_aux_round:NNNN #8 #1 #2 { \int_eval:w #3#4#5#6 + #7 } }
  % ^^A wrong arg spec for round:.
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Scientific notation}
%
% Expressing an internal floating point number in scientific notation is
% quite easy: no rounding, and the format is very well defined. We
% simply have to filter out the various special cases.
%
% \begin{macro}
%   {\fp_to_scientific:N, \fp_to_scientific:c, \fp_to_scientific:n}
%   The three functions evaluate their argument, then pass it to
%   \cs{fp_to_scientific:w}.
%    \begin{macrocode}
\cs_new:Npn \fp_to_scientific:N #1 { \exp_after:wN \fp_to_scientific:w #1 }
\cs_generate_variant:Nn \fp_to_scientific:N { c }
\cs_new:Npn \fp_to_scientific:n #1
  {
    \exp_after:wN \fp_to_scientific:w
    \tex_romannumeral:D -`0 \fp_parse:n {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux,EXP]
%   {
%     \fp_to_scientific:w,
%     \fp_to_scientific_normal:nnnnn,
%     \fp_to_scientific_normal:wNw
%   }
%   First cater for the sign: we need to insert |-| if |#2=2|.  Then
%   filter the special cases.  In the normal case, decrement the
%   exponent and unbrace the $4$ brace groups, then in a second step
%   grab the first digit (previously hidden in braces) and order the
%   various parts correctly.
%    \begin{macrocode}
\cs_new:Npn \fp_to_scientific:w \s_fp \fp_use:w #1 #2
  {
    \if_meaning:w 2 #2
      \exp_after:wN -
      \tex_romannumeral:D -`0
    \fi:
    \if_case:w #1 \exp_stop_f:
         \fp_aux_case_return:nw { 0.000000000000000e0 }
    \or: \exp_after:wN \fp_to_scientific_normal:nnnnn
    \or: \fp_aux_case_return:nw { inf }
    \or: \fp_aux_case_return:nw { nan }
    \fi:
  }
\cs_new:Npn \fp_to_scientific_normal:nnnnn #1 #2#3#4#5 ;
  {
    \exp_after:wN \fp_to_scientific_normal:wNw
      \int_use:N \int_eval:w #1 - \c_one ; #2 #3 #4 #5 ;
  }
\cs_new:Npn \fp_to_scientific_normal:wNw #1 ; #2#3; { #2.#3 e #1 }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Token list (pocket calculator)}
%
% \begin{macro}[EXP]{\fp_to_tl:N, \fp_to_tl:c, \fp_to_tl:n}
%   The three functions evaluate their argument, then pass it to
%   \cs{fp_to_tl:w}.
%    \begin{macrocode}
\cs_new:Npn \fp_to_tl:N #1 { \exp_after:wN \fp_to_tl:w #1 }
\cs_generate_variant:Nn \fp_to_tl:N { c }
\cs_new_nopar:Npn \fp_to_tl:n
  {
    \exp_after:wN \fp_to_tl:w
    \tex_romannumeral:D -`0 \fp_parse:n
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, aux]
%   {
%     \fp_to_tl:w,
%     \fp_to_tl_aux:nw,
%     \fp_to_tl_normal:nnnnn,
%     \fp_to_tl_large:w,
%     \fp_to_tl_large_aux:wN,
%     \fp_to_tl_small:w,
%     \fp_to_tl_scientific:wNw,
%     \fp_to_tl_zeros:w,
%     \fp_to_tl_zeros_aux:w,
%     \fp_to_tl_zeros_dot:w,
%     \fp_to_tl_zeros_end:w,
%   }
%    \begin{macrocode}
\cs_new:Npn \fp_to_tl:w \s_fp \fp_use:w #1#2
  {
    \if_meaning:w 2 #2 \exp_after:wN - \tex_romannumeral:D -`0 \fi:
    \if_case:w #1 \exp_stop_f:
           \fp_aux_case_return:nw { 0 }
    \or:   \exp_after:wN \fp_to_tl_normal:nnnnn
    \or:   \fp_aux_case_return:nw { inf }
    \else: \fp_aux_case_return:nw { nan }
    \fi:
  }
\cs_new:Npn \fp_to_tl_normal:nnnnn #1 #2#3#4#5;
  {
    \if_int_compare:w #1 > \c_zero
      \if_int_compare:w #1 > \c_sixteen
        \exp_after:wN \fp_to_tl_scientific:wNw \exp_after:wN e
        \int_use:N \int_eval:w \c_minus_one +
      \else:
        \exp_after:wN \fp_to_tl_large:w \int_value:w
      \fi:
    \else:
      \if_int_compare:w #1 < - \c_two
        \exp_after:wN \fp_to_tl_scientific:wNw \exp_after:wN e
        \int_use:N \int_eval:w \c_minus_one +
      \else:
        \exp_after:wN \fp_to_tl_small:w \int_value:w
      \fi:
    \fi:
    #1 ; #2 #3 #4 #5 ;
  }
\cs_new:Npn \fp_to_tl_large:w #1;
  { \prg_replicate:nn {#1} { \fp_to_tl_large_aux:wN } \fp_to_tl_zeros:w . }
\cs_new:Npn \fp_to_tl_large_aux:wN #1 . #2 { #1 #2 . }
\cs_new:Npn \fp_to_tl_small:w #1;
  {
    \exp_after:wN \fp_to_tl_scientific:wNw \exp_after:wN ;
      \tex_romannumeral:D -`0 \prg_replicate:nn {-#1} {0} 0
  }
\cs_new:Npn \fp_to_tl_scientific:wNw #1; #2#3;
  { \fp_to_tl_zeros:w #2.#3 ; #1 }
\cs_new:Npn \fp_to_tl_zeros:w #1 ;
  {
    \fp_to_tl_zeros_aux:w #1
      ; \fp_to_tl_zeros_aux:w 0; \fp_to_tl_zeros_dot:w .; \s_stop
  }
\cs_new:Npn \fp_to_tl_zeros_aux:w #1 0; #2 { #2 #1 ; #2 }
\cs_new:Npn \fp_to_tl_zeros_dot:w #1 .; { \fp_to_tl_zeros_end:w #1 ; }
\cs_new:Npn \fp_to_tl_zeros_end:w #1 ; #2 \s_stop { #1 }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Misc}
%
% \subsubsection{Rounding}
%
% \begin{macro}[EXP]{\fp_round_figures:nn, \fp_round_places:nn}
% \begin{macro}[EXP,aux]
%   {
%     \fp_round_aux:Nww, \fp_round_normal:NwNnw, \fp_round_normal:wwN,
%     \fp_round_normal:w, \fp_round_normal:NnnwN,
%     \fp_round_normal_round:NNNNNNNNN, \fp_round_normal_pack:NNNNNw,
%     \fp_round_normal_end:NNNNNw
%   }
%    \begin{macrocode}
\cs_new:Npn \fp_round_figures:nn #1#2
  {
    \exp_after:wN \fp_round_aux:Nww \exp_after:wN 0
    \int_use:N \int_eval:w #2 \exp_after:wN ;
    \tex_romannumeral:D -`0 \fp_parse:n {#1}
  }
\cs_new:Npn \fp_round_places:nn #1#2
  {
    \exp_after:wN \fp_round_aux:Nww \exp_after:wN 1
    \int_use:N \int_eval:w #2 \exp_after:wN ;
    \tex_romannumeral:D -`0 \fp_parse:n {#1}
  }
\cs_new:Npn \fp_round_aux:Nww #1#2; \s_fp \fp_use:w #3
  {
    \if_meaning:w 1 #3
      \exp_after:wN \fp_round_normal:NwNnw
      \exp_after:wN #1
      \int_value:w #2
    \fi:
    \s_fp \fp_use:w #3
  }
\cs_new:Npn \fp_round_normal:NwNnw #1#2 \s_fp \fp_use:w 1 #3#4#5;
  {
    \exp_after:wN \fp_round_normal:wwN
    \int_use:N \int_eval:w #4 +
      \exp_after:wN \fp_round_normal:w
      \int_use:N \int_eval:w
        \c_sixteen - #2
        \if_meaning:w 1 #1 - #4 \fi:
      ;
    \fp_round_normal:NnnwN
    #5
    #3
  }
\cs_new:Npn \fp_round_normal:w #1;
  {
    \if_num:w #1 < \c_fifteen
      \if_num:w #1 > \c_zero
        #1
      \else:
        \c_zero
      \fi:
    \else:
      \c_fifteen
    \fi:
    \fp_aux_decimate:nNnnnn
      { \if_num:w #1 < \c_fifteen #1 \else: \c_fifteen \fi: }
  }
\cs_new:Npn \fp_round_normal:wwN #1; #2; #3
  { \s_fp \fp_use:w 1 #3 {#1} #2; }
\cs_new:Npn \fp_round_normal:NnnwN #1#2#3#4; #5
  {
    \exp_after:wN \fp_round_normal_end:NNNNNw
    \int_use:N \int_eval:w 9999 9999 + #2 +
      \exp_after:wN \fp_round_normal_pack:NNNNNw
      \int_use:N \int_eval:w 1 0000 0000 + #3 +
        \fp_round_normal_round:NNNNNNNNN #3 #5 #1 ;
    {0000} {0000} ;
    #5
  }
\cs_new:Npn \fp_round_normal_round:NNNNNNNNN #1#2#3#4#5#6#7#8#9
  { \fp_aux_round:NNN #9 #8 }
\cs_new:Npn \fp_round_normal_pack:NNNNNw #1#2#3#4#5 #6;
  { #1 ; {#2#3#4#5} {#6} }
\cs_new:Npn \fp_round_normal_end:NNNNNw #1#2#3#4#5 #6;
  { \fp_fixed_to_float:w {#2#3#4#5} {#6} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Dimension}
%
%^^A todo: "0pt" should give "-0" when rounding to -infty.
%
% \begin{macro}[EXP]{\dim_to_fp:n}
% \begin{macro}[aux, EXP]
%   {
%     \dim_to_fp_test:N,
%     \dim_to_fp_ii:Nw,
%     \dim_to_fp_iii:NNNNNNNN,
%     \dim_to_fp_iii:nNNNNNNN,
%     \dim_to_fp_iv:nnnnnnwN,
%     \dim_to_fp_aux:w,
%     \dim_to_fp_zero:w
%   }
%   The dimension expression (which can in fact be a glue expression)
%   is evaluated, converted to a number (\emph{i.e.}, expressed in
%   scaled points), then multiplied by $2^{-16} = 0.0000152587890625$
%   to give a value expressed in points.
%
%   We use the auxiliary function
%   \begin{quote}
%     \cs{fp_basics_mul_npos:Nnwnw} \meta{sign} \newline
%     ~~\Arg{exp_1}  \meta{body1} |;| \Arg{exp_2} \meta{body2} |;|
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \dim_to_fp:n #1
  {
    \exp_after:wN \dim_to_fp_test:N
    \int_value:w \etex_glueexpr:D #1 ;
    {-4} {1525} {8789} {0625} {0000} ;
  }
\cs_new:Npn \dim_to_fp_test:N #1
  {
    \if_num:w \c_ten < 1 #1 \exp_stop_f:
      \exp_after:wN \dim_to_fp_aux:w
      \tex_romannumeral:D -`0
      \exp_after:wN \dim_to_fp_ii:Nw
      \exp_after:wN 0
      \exp_after:wN #1
    \else:
      \if_meaning:w 0 #1
        \exp_after:wN \exp_after:wN
        \exp_after:wN \dim_to_fp_zero:w
      \else:
        \exp_after:wN \dim_to_fp_aux:w
        \tex_romannumeral:D -`0
        \exp_after:wN \exp_after:wN
        \exp_after:wN \dim_to_fp_ii:Nw
        \exp_after:wN \exp_after:wN
        \exp_after:wN 2
      \fi:
    \fi:
  }
\cs_new:Npn \dim_to_fp_ii:Nw #1 #2;
  { \dim_to_fp_iii:NNNNNNNN #2 000 0000 00{10}987654321; #1 }
\cs_new:Npn \dim_to_fp_iii:NNNNNNNN #1#2#3#4 #5#6#7#8
  { \dim_to_fp_iii:nNNNNNNN { {#1#2#3#4} {#5#6#7#8} } }
\cs_new:Npn \dim_to_fp_iii:nNNNNNNN #1 #2#3 #4#5#6#7#8
  { \dim_to_fp_iv:nnnnnnwN { #1 {#2#300} {0000} } }
\cs_new:Npn \dim_to_fp_iv:nnnnnnwN #1 #2#3#4#5 #6 #7; #8
  { \s_fp \fp_use:w 1 #8 {#6} #1 ; }
\cs_new:Npn \dim_to_fp_aux:w \s_fp \fp_use:w #1
  { \fp_basics_mul_npos:Nnwnw }
\cs_new:Npn \dim_to_fp_zero:w ; #1; { \c_zero_fp }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Use and eval}
%
% \begin{macro}[EXP]{\fp_use:N, \fp_use:c, \fp_eval:n}
%   The meaning of those functions might vary.  For now, they convert to
%   a real number appropriate as a factor in front of dimensions.
%    \begin{macrocode}
\cs_new_eq:NN \fp_use:N  \fp_to_decimal:N
\cs_generate_variant:Nn \fp_use:N { c }
\cs_new_eq:NN \fp_eval:n \fp_to_decimal:n
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex