% \iffalse meta-comment
%
%% File: l3fp-convert.dtx Copyright(C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{l3fp-new}
\GetIdInfo$Id$
  {L3 Experimental floating point conversion}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\usepackage{l3fp-new}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{l3fp-convert} package\\ Floating point conversion^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{Internal functions}
%
% \begin{function}[EXP]{\fp_to_ofp:n,\fp_to_ofp:N,\fp_to_ofp:w}
%   \begin{syntax}
%     \cs{fp_to_ofp:n} \Arg{token list}
%     \cs{fp_to_ofp:N} \meta{fp var}
%     \cs{fp_to_ofp:w} \meta{floating point}
%   \end{syntax}
%   These functions convert an internal floating point number to the old
%   format (\meta{sign}\meta{digit}.\meta{9~digits}e\meta{exponent}).
%   Note that since the new internal floating point number format includes
%   a trailing semicolon, it is not needed for \cs{fp_to_ofp:w}.
%
%   This should probably be made into some generic rounding procedure.
% \end{function}
%
% \begin{function}[EXP]{\ofp_to_fp:N,\ofp_to_fp:w}
%   \begin{syntax}
%     \cs{ofp_to_fp:N} \meta{old fp var}
%     \cs{ofp_to_fp:w} \meta{old floating point} |;|
%   \end{syntax}
%   Converts the \meta{old fp var} to the new floating
%   point format. Leaves the result in the input stream.
%   These functions are f-expandable. Note the trailing
%   semicolon (with catcode other) in the |w| case.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\texttt{l3fp-convert} implementation}
%
% We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%<*initex|package>
%    \end{macrocode}
%
% \subsection{Scientific notation}
%
% Expressing an internal floating point number in scientific notation is
% quite easy: no rounding, and the format is very well defined. We
% simply have to filter out the various special cases.
%
% \begin{macro}{\fp_use:N,\fp_eval:n}
% \begin{macro}[aux,EXP]
%   {
%     \fp_to_scientific:w,
%     \fp_to_scientific_normal:nnnnn,
%     \fp_to_scientific_normal:wNw
%   }
%   First cater for the sign: we need to insert |-| if |#2=2|.  Then
%   filter the special cases.  In the normal case, decrement the
%   exponent and unbrace the $4$ brace groups, then in a second step
%   grab the first digit (previously hidden in braces) and order the
%   various parts correctly.
%    \begin{macrocode}
\cs_new:Npn \fp_use:N #1 { \exp_after:wN \fp_to_scientific:w #1 }
\cs_new:Npn \fp_eval:n #1
  {
    \exp_after:wN \fp_to_scientific:w
    \tex_romannumeral:D -`0 \fp_parse:n {#1}
  }
\cs_new:Npn \fp_to_scientific:w \s_fp \fp_use:w #1 #2
  {
    \if_meaning:w 2 #2
      \exp_after:wN -
      \tex_romannumeral:D -`0
    \fi:
    \if_case:w #1 \exp_stop_f:
         \fp_aux_case_return:nw { 0.000000000000000e0 }
    \or: \exp_after:wN \fp_to_scientific_normal:nnnnn
    \or: \fp_aux_case_return:nw { inf }
    \or: \fp_aux_case_return:nw { nan }
    \fi:
  }
\cs_new:Npn \fp_to_scientific_normal:nnnnn #1 #2#3#4#5 ;
  {
    \exp_after:wN \fp_to_scientific_normal:wNw
      \int_use:N \int_eval:w #1 - \c_one ; #2 #3 #4 #5 ;
  }
\cs_new:Npn \fp_to_scientific_normal:wNw #1 ; #2#3; { #2.#3 e #1 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Conversion to tl}
%
% \begin{macro}[EXP]{\fp_to_tl:N, \fp_to_tl:c, \fp_to_tl:n}
% \begin{macro}[EXP, aux]
%   {
%     \fp_to_tl:w,
%     \fp_to_tl_aux:nw,
%     \fp_to_tl_normal:nnnnn,
%     \fp_to_tl_large:w,
%     \fp_to_tl_large_aux:wN,
%     \fp_to_tl_small:w,
%     \fp_to_tl_scientific:wNw,
%     \fp_to_tl_zeros:w,
%     \fp_to_tl_zeros_aux:w,
%     \fp_to_tl_zeros_dot:w,
%     \fp_to_tl_zeros_end:w,
%   }
%    \begin{macrocode}
\cs_new:Npn \fp_to_tl:N #1 { \exp_after:wN \fp_to_tl:w #1 }
\cs_generate_variant:Nn \fp_to_tl:N { c }
\cs_new_nopar:Npn \fp_to_tl:n
  {
    \exp_after:wN \fp_to_tl:w
    \tex_romannumeral:D -`0 \fp_parse:n
  }
\cs_new:Npn \fp_to_tl:w \s_fp \fp_use:w #1#2
  {
    \if_meaning:w 2 #2 \exp_after:wN - \tex_romannumeral:D -`0 \fi:
    \if_case:w #1 \exp_stop_f:
           \fp_aux_case_return:nw { 0 }
    \or:   \exp_after:wN \fp_to_tl_normal:nnnnn
    \or:   \fp_aux_case_return:nw { inf }
    \else: \fp_aux_case_return:nw { nan }
    \fi:
  }
\cs_new:Npn \fp_to_tl_normal:nnnnn #1 #2#3#4#5;
  {
    \if_int_compare:w #1 > \c_zero
      \if_int_compare:w #1 > \c_sixteen
        \exp_after:wN \fp_to_tl_scientific:wNw \exp_after:wN e
        \int_use:N \int_eval:w \c_minus_one +
      \else:
        \exp_after:wN \fp_to_tl_large:w \int_value:w
      \fi:
    \else:
      \if_int_compare:w #1 < - \c_two
        \exp_after:wN \fp_to_tl_scientific:wNw \exp_after:wN e
        \int_use:N \int_eval:w \c_minus_one +
      \else:
        \exp_after:wN \fp_to_tl_small:w \int_value:w
      \fi:
    \fi:
    #1 ; #2 #3 #4 #5 ;
  }
\cs_new:Npn \fp_to_tl_large:w #1;
  { \prg_replicate:nn {#1} { \fp_to_tl_large_aux:wN } \fp_to_tl_zeros:w . }
\cs_new:Npn \fp_to_tl_large_aux:wN #1 . #2 { #1 #2 . }
\cs_new:Npn \fp_to_tl_small:w #1;
  {
    \exp_after:wN \fp_to_tl_scientific:wNw \exp_after:wN ;
      \tex_romannumeral:D -`0 \prg_replicate:nn {-#1} {0} 0
  }
\cs_new:Npn \fp_to_tl_scientific:wNw #1; #2#3;
  { \fp_to_tl_zeros:w #2.#3 ; #1 }
\cs_new:Npn \fp_to_tl_zeros:w #1 ;
  {
    \fp_to_tl_zeros_aux:w #1
      ; \fp_to_tl_zeros_aux:w 0; \fp_to_tl_zeros_dot:w .; \s_stop
  }
\cs_new:Npn \fp_to_tl_zeros_aux:w #1 0; #2 { #2 #1 ; #2 }
\cs_new:Npn \fp_to_tl_zeros_dot:w #1 .; { \fp_to_tl_zeros_end:w #1 ; }
\cs_new:Npn \fp_to_tl_zeros_end:w #1 ; #2 \s_stop { #1 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Int}
%
% \begin{macro}[EXP]{\fp_to_int:N, \fp_to_int:c, \fp_to_int:n}
% \begin{macro}[aux, EXP]
%   {
%     \fp_to_int:w, \fp_to_int_normal:Nnnnnn,
%     \fp_to_int_large_aux:NNNNNNNNN,
%     \fp_to_int_large_aux:NNNNNNwN
%   }
%   ^^A inconsistency on whether overflow causes error.
%   Our goal is to convert a floating point to an integer, rounding
%   correctly.  The first step is to evaluate the floating point
%   expression.  Then find the sign, which will affect an integer
%   expression.  Zero is mapped to $0$, infinite floating points are
%   silently mapped to the largest available integer, and \texttt{nan}
%   triggers a \enquote{Missing number, treated as 0} error.  Finally,
%   for normal numbers, detect underflow (non-positive exponent), and
%   overflow (more elaborate tests using $2^{31}-1 = 2147483647$).  In
%   the most normal case, we can grab $10$ digits after adding the
%   appropriate number of $0$ to the front, then do the rounding.
%    \begin{macrocode}
\cs_new:Npn \fp_to_int:N #1 { \exp_after:wN \fp_to_int:w #1 }
\cs_generate_variant:Nn \fp_to_int:N { c }
\cs_new_nopar:Npn \fp_to_int:n
  {
    \exp_after:wN \fp_to_int:w
    \tex_romannumeral:D -`0 \fp_parse:n
  }
\cs_new:Npn \fp_to_int:w \s_fp \fp_use:w #1#2#3;
  {
    \int_value:w \if_meaning:w 2 #2 - \fi:
      \int_eval:w
        \if_case:w #1 \exp_stop_f:
             \c_zero
        \or: \fp_to_int_normal:Nnnnnn #2 #3
        \or: \c_max_int
        \fi:
      \int_eval_end:
  }
\cs_new:Npn \fp_to_int_normal:Nnnnnn #1#2#3#4#5#6
  {
    \if_case:w
        \if_num:w #2 < \c_one       \c_two \fi:
        \if_num:w #2 > \c_ten       \c_one \fi:
        \if_num:w #2 = \c_ten
          \if_num:w #3#4 > 21474836 \c_one \fi:
          \if_num:w #3#4 = 21474836 \exp_stop_f:
            \if_num:w #5 > 4699     \c_one \fi:
          \fi:
        \fi:
        \c_zero
      \exp_after:wN \exp_after:wN
      \exp_after:wN \fp_to_int_large_aux:NNNNNNNNN
      \prg_replicate:nn { \c_ten - #2 } {0}
      #3#4#5#6 ; #1
    \or:
      \c_max_int
    \else:
      \c_zero
    \fi:
  }
\cs_new:Npn \fp_to_int_large_aux:NNNNNNNNN #1#2#3#4#5#6#7#8#9
  { #1#2#3#4#5#6#7#8#9 \fp_to_int_large_aux:NNNNNNwN }
\cs_new:Npn \fp_to_int_large_aux:NNNNNNwN #1#2 #3#4#5#6#7; #8
  { #1 + \fp_aux_round:NNNN #8 #1 #2 { \int_eval:w #3#4#5#6 + #7 } }
  % ^^A wrong arg spec for round:.
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Dimensions}
%
%
% \begin{macro}[EXP]{\fp_to_dim:N, \fp_to_dim:c, \fp_to_dim:n}
% \begin{macro}[aux, EXP]
%   {
%     \fp_to_dim:w , \fp_to_dim_normal:nnnnn , \fp_to_dim_small:n ,
%     \fp_to_dim_large:n , \fp_to_dim_large_pack:NNNNNw
%   }
%   Our goal is to convert a floating point to a dimension in
%   \texttt{pt}.  The first step is to evaluate the floating point
%   expression.  Then start a \cs{dim_eval:n} ending with \texttt{pt} to
%   avoid any worry, and insert a minus sign if appropriate.  Zero
%   floating point numbers are mapped to \cs{c_zero_dim}, infinite
%   floating point numbers to \texttt{99999pt}, causing an overflow, and
%   \texttt{nan} is mapped to \texttt{pt}, triggering the appropriate
%   \TeX{} error: \enquote{Missing number, treated as 0}.  Finally, for
%   normal numbers, check the exponent: if it is too large, output
%   \texttt{99999pt} as for infinities; if it is very small, output
%   \cs{c_zero_dim}, and in between, either produce
%   \texttt{.000\ldots{}00} followed by the actual digits, or grab the
%   first few digits and add a dot afterwards.
%    \begin{macrocode}
\cs_new:Npn \fp_to_dim:N #1 { \exp_after:wN \fp_to_dim:w #1 }
\cs_generate_variant:Nn \fp_to_dim:N { c }
\cs_new_nopar:Npn \fp_to_dim:n
  {
    \exp_after:wN \fp_to_dim:w
    \tex_romannumeral:D -`0 \fp_parse:n
  }
\cs_new:Npn \fp_to_dim:w \s_fp \fp_use:w #1#2#3;
  {
    \dim_eval:n
      {
        \if_meaning:w 2 #2 - \fi:
        \if_case:w #1 \exp_stop_f:
             \c_zero
        \or: \fp_to_dim_normal:nnnnn #3
        \or: 99999
        \fi:
        pt
      }
  }
\cs_new:Npn \fp_to_dim_normal:nnnnn #1#2#3#4#5
  {
    \if_num:w #1 > \c_five
      99999
    \else:
      \if_num:w #1 < - \c_five
        \c_zero
      \else:
        \if_num:w #1 > \c_zero
          \exp_after:wN \fp_to_dim_large:n
        \else:
          \exp_after:wN \fp_to_dim_small:n
        \fi:
        {#1} #2#3#4#5
      \fi:
    \fi:
  }
\cs_new:Npn \fp_to_dim_small:n #1
  { . \prg_replicate:nn {-#1} {0} }
\cs_new:Npn \fp_to_dim_large:n #1
  {
    \exp_after:wN \exp_after:wN
    \exp_after:wN \fp_to_dim_large_pack:NNNNNw
      \prg_replicate:nn { \c_five - #1 } {0}
  }
\cs_new:Npn \fp_to_dim_large_pack:NNNNNw #1#2#3#4#5 { #1#2#3#4#5 . }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{From dimension to floating point}
%
%^^A todo: "0pt" should give "-0" when rounding to -infty.
%
% \begin{macro}{\dim_to_fp:n}
%   \begin{syntax}
%     \cs{dim_to_fp:n} \Arg{dimension expression}
%   \end{syntax}
%   The dimension expression (which can in fact be a glue expression)
%   is evaluated, converted to a number (\emph{i.e.}, expressed in
%   scaled points), then multiplied by $2^{-16} = 0.0000152587890625$
%   to give a value expressed in points.
%
%   We use the auxiliary function
%   \begin{quote}
%     \cs{fp_basics_mul_npos:Nnwnw} \meta{sign} \newline
%     ~~\Arg{exp_1}  \meta{body1} |;| \Arg{exp_2} \meta{body2} |;|
%   \end{quote}
%
%    \begin{macrocode}
\cs_new:Npn \dim_to_fp:n #1
  {
    \exp_after:wN \dim_to_fp_test:N
    \int_value:w \etex_glueexpr:D #1 ;
    {-4} {1525} {8789} {0625} {0000} ;
  }
\cs_new:Npn \dim_to_fp_test:N #1
  {
    \if_num:w \c_ten < 1 #1 \exp_stop_f:
      \exp_after:wN \dim_to_fp_aux:w
      \tex_romannumeral:D -`0
      \exp_after:wN \dim_to_fp_ii:Nw
      \exp_after:wN 0
      \exp_after:wN #1
    \else:
      \if_meaning:w 0 #1
        \exp_after:wN \exp_after:wN
        \exp_after:wN \dim_to_fp_zero:w
      \else:
        \exp_after:wN \dim_to_fp_aux:w
        \tex_romannumeral:D -`0
        \exp_after:wN \exp_after:wN
        \exp_after:wN \dim_to_fp_ii:Nw
        \exp_after:wN \exp_after:wN
        \exp_after:wN 2
      \fi:
    \fi:
  }
\cs_new:Npn \dim_to_fp_ii:Nw #1 #2;
  { \dim_to_fp_iii:NNNNNNNN #2 000 0000 00{10}987654321; #1 }
\cs_new:Npn \dim_to_fp_iii:NNNNNNNN #1#2#3#4 #5#6#7#8
  { \dim_to_fp_iii:nNNNNNNN { {#1#2#3#4} {#5#6#7#8} } }
\cs_new:Npn \dim_to_fp_iii:nNNNNNNN #1 #2#3 #4#5#6#7#8
  { \dim_to_fp_iv:nnnnnnwN { #1 {#2#300} {0000} } }
\cs_new:Npn \dim_to_fp_iv:nnnnnnwN #1 #2#3#4#5 #6 #7; #8
  { \s_fp \fp_use:w 1 #8 {#6} #1 ; }
\cs_new:Npn \dim_to_fp_aux:w \s_fp \fp_use:w #1
  { \fp_basics_mul_npos:Nnwnw }
\cs_new:Npn \dim_to_fp_zero:w ; #1; { \c_zero_fp }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Conversion from old floating points}
%
% To ease the transition, we provide a conversion from the old
% floating point implementation to the new one. The input is a token
% list of the form \meta{sign} \meta{1~digit}|.|\meta{9~digits}
% |e|\meta{exponent}.
%
% \begin{macro}[EXP]
%   {
%     \ofp_to_fp:N,
%     \ofp_to_fp:w
%   }
% \begin{macro}[EXP,aux]
%   {
%     \ofp_to_fp_special:Nw,
%     \ofp_to_fp_normal:NnNNNNww,
%     \ofp_to_fp_sign:N
%   }
%
%   The old module only has one special case, \cs{c_undefined_fp},
%   distinguished by its sign. It is converted to an \enquote{empty}
%   \texttt{qNaN}. All other numbers are converted with no
%   precision loss, just by adding zero at the end. The exponent
%   is shifted by $1$ (because the mantissa of new floating point
%   numbers starts with $0.\cdots$). For instance,
%   \texttt{+1.234512345e7} is stored as \cs{s_fp} \cs{fp_use:w}
%   |10{8}{1234}{5123}{4500}{0000};|.
%
%   \begin{macrocode}
\cs_new_nopar:Npn \ofp_to_fp:N #1
  { \exp_after:wN \ofp_to_fp:w #1 ; }
\cs_new_nopar:Npn \ofp_to_fp:w #1 #2.#3#4#5
  {
    \if_meaning:w 0 #2
      \exp_after:wN \ofp_to_fp_special:Nw
    \else:
      \exp_after:wN \ofp_to_fp_normal:NnNNNNww
    \fi:
    #1 {#2#3#4#5}
  }
\cs_new_nopar:Npn \ofp_to_fp_special:Nw #1 #2 ;
  {
    \if:w X #1
      \exp_after:wN \c_empty_qnan_fp
    \else:
      \exp_after:wN \c_zero_fp
    \fi:
  }
\cs_new_nopar:Npn \ofp_to_fp_normal:NnNNNNww
    #1 #2 #3#4#5#6 #7 e #8 ;
  {
    \ofp_to_fp_sign:N #1
    { \int_use:N \int_eval:w #8 + 1 }
    {#2} {#3#4#5#6} {#700} {0000} ;
  }
\cs_new_nopar:Npn \ofp_to_fp_sign:N #1
  {
    \exp_after:wN \s_fp
    \exp_after:wN \fp_use:w
    \int_value:w 1 \if_meaning:w + #1 0 \else: 2 \fi: \exp_after:wN
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsection{Conversion to old floating points}
%
% Converting from the internal representation to the old format for fp
% is slightly harder, as it involves rounding.
%
% \begin{macro}[EXP]{\fp_to_ofp:n, \fp_to_ofp:N, \fp_to_ofp:w}
% \begin{macro}[aux, EXP]
%   {
%     \fp_to_ofp_normal:Nnnn,
%     \fp_to_ofp_aux_i:NNN,
%     \fp_to_ofp_aux_ii:N,
%     \fp_to_ofp_aux_iii:NN,
%     \fp_to_ofp_carry:w
%     \fp_to_ofp_sanitize:NNw,
%   }
%   The conversion then starts by examining the \meta{case}, and
%   branching accordingly. Infinities and NaN are treated identically.
%
%   In the case of normal numbers ($\meta{case}=1$), we do the
%   rounding within some \cs{int_eval:w}. Afterwards,
%   check for a carry. This only ever happens to yield $1.0\cdots0$
%   as a result, so \cs{fp_to_ofp_carry:w} knows
%   precisely what follows.
%
%   The whole thing is wrapped in a calculation of the exponent.
%   This will be ended by $-1$ (unless there is a carry). At the end,
%   \emph{i.e.}, after the carry, \cs{fp_to_ofp_sanitize:NNw}
%   tests for overflow or underflow, and reorders the various pieces.
%
%   If (the absolute value of) the exponent is less than $100$,
%   then the number fits in the \enquote{old} range of exponents:
%   simply set the sign correctly. Underflow gives \cs{c_zero_ofp}
%   and  overflow gives \cs{c_undefined_ofp}.
%    \begin{macrocode}
\cs_new:Npn \fp_to_ofp:n
  {
    \exp_after:wN \fp_to_ofp:w
    \tex_romannumeral:D -`0 \fp_parse:n
  }
\cs_new:Npn \fp_to_ofp:N { \exp_after:wN \fp_to_ofp:w }
\cs_new:Npn \fp_to_ofp:w \s_fp \fp_use:w #1
  {
    \if_case:w #1 \exp_stop_f:
         \fp_aux_case_return:nw { \c_zero_ofp }
    \or: \exp_after:wN \fp_to_ofp_normal:Nnnn
    \or: \fp_aux_case_return:nw { \c_undefined_ofp }
    \or: \fp_aux_case_return:nw { \c_undefined_ofp }
    \fi:
  }
\cs_new:Npn \fp_to_ofp_normal:Nnnn #1 #2 #3#4
  {
    \exp_after:wN \fp_to_ofp_sanitize:NNw
    \exp_after:wN #1
    \int_use:N \int_eval:w #2
      \exp_after:wN \fp_to_ofp_aux_iii:NN
      \int_use:N \int_eval:w 1#3
        \exp_after:wN \fp_to_ofp_aux_ii:N
        \int_use:N \int_eval:w
          1 #4 \fp_to_ofp_aux_i:NNN #1
  }
\cs_new:Npn \fp_to_ofp_aux_i:NNN #1 #2#3
  { % <sign> <X9> <X10> <X11-X16> ;
    #2 #3
    + \fp_aux_round_s:NNNw #1#3
  }
\cs_new:Npn \fp_to_ofp_aux_ii:N #1
  { % <1 or 2> <X'6-10> ;
    \if_meaning:w 2 #1 + 1 \fi: \int_eval_end:
  }
\cs_new:Npn \fp_to_ofp_aux_iii:NN #1 #2
  { % <1 or 2> <X'1>
    \if_meaning:w 2 #1
      \exp_after:wN \fp_to_ofp_carry:w
    \fi:
    - 1 ;
    #2.
  }
\cs_new:Npn \fp_to_ofp_carry:w - 1 ; 0.000000000 ;
  { ; 1.000000000 ; }
\cs_new:Npn \fp_to_ofp_sanitize:NNw #1 #2#3 ;
  { % <sign digit> <exponent> ; <body> ;
    \if_num:w \if:w - #2 - \fi: #2#3 < \c_one_hundred
      \exp_after:wN \fp_to_ofp_sane:Nww
    \else:
      \exp_after:wN \fp_to_ofp_unsane:NNww
    \fi:
    #1 #2#3 ;
  }
\cs_new:Npn \fp_to_ofp_sane:Nww #1 #2; #3;
  { \if:w 0 #1 \exp_after:wN + \else: \exp_after:wN - \fi: #3 e #2 }
\cs_new:Npn \fp_to_ofp_unsane:NNww #1 #2#3; #4;
  {
    \if:w - #2
      \exp_after:wN \c_zero_ofp
    \else:
      \exp_after:wN \c_undefined_ofp
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex