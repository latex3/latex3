% \iffalse meta-comment
%
%% File: l3fp-basics.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{l3fp-new}
\GetIdInfo$Id$
  {L3 Experimental floating-point arithmetic}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\usepackage{l3fp-new}
\begin{document}
  \tableofcontents
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-basics} package\thanks{This file
%         has version number \ExplFileVersion, last
%         revised \ExplFileDate.}\\
% Floating point expressions}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{Internal storage of floating points numbers}
%
% The internal structure of floating point numbers is described in
% \file{l3fp-convert.dtx}. A floating point number \meta{X} is stored as
% \begin{quote}
%   \cs{s_fp} \cs{fp_use:w} \meta{case} \meta{sign} \meta{body} |;|
% \end{quote}
% Here, \meta{case} is 0 for $\pm 0$, 1 for normal numbers,
% 2 for $\pm \infty$, and 3 for \texttt{nan}, and \meta{sign} is
% $0$ for positive numbers, $1$ for \texttt{nan}s, and $2$ for
% negative numbers. The \meta{body} of normal numbers is
% \Arg{exponent} \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4}, with
% \[
% \meta{X}
% = (-1)^{\meta{sign}} 10^{-\meta{exponent}}
% \sum_i \meta{X$\sb{i}$} 10^{-4i}.
% \]
% Calculations are done in base $10000$, \emph{i.e.} one myriad.
% The \meta{exponent} lies in the range $[\cs{c_fp_min_exponent_int},
% \cs{c_fp_max_exponent_int}]$, currently $ \ExplSyntaxOn [ \int_use:N
% \c_fp_min_exponent_int, \int_use:N \c_fp_max_exponent_int ] $
% but this may change a bit: the main constraint is to be a valid
% \TeX{} integer.
%
% Additionally, positive and negative floating point numbers may only
% be stored with $1000\leq\meta{X1}<10000$. This requirement is necessary
% in order to preserve accuracy and speed. Not abiding by it will lead
% to all sorts of trouble.
%
% \section{Operations with exact rounding}
%
% The operations with argument specification \texttt{:nn} previously
% described in this section are superseeded by \cs{fp_parse:n}. For
% instance, \cs{fp_add:nn} \Arg{token list 1} \Arg{token list 2} is
% now \cs{fp_parse:n} |{| \meta{token list 1} |+| \meta{token list 2} |}|.
%
% The operations described in this section yield the outcome of
% rounding the infinitely precise result of the operation to the
% nearest representable number.
%
% \begin{function}[EXP]{\fp_add:NN,\fp_sub:NN,\fp_mul:NN,\fp_div:NN}
%   \begin{syntax}
%     \cs{fp_add:NN} \meta{fp~var} \meta{fp~var}
%   \end{syntax}
%   These functions f-expand to the sum, the difference, the product, and
%   the quotient of the two floating point variables, respectively.
% \end{function}
%
% \section{Temporary function for testing}
%
% \begin{function}[EXP]{\fp_rem:nn}
%   \begin{syntax}
%     \cs{fp_rem:nn} \Arg{fp~expr} \Arg{fp~expr}
%   \end{syntax}
%   This computes the remainder of the division of the first argument
%   by the second.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{Implementation}
%
%   We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%<*initex|package>
%    \end{macrocode}
%
% Some algorithms used below end up being quite similar to
% some described in \enquote{What Every Computer Scientist
%   Should Know About Floating Point Arithmetic}, by
% David Goldberg, which can be found at
% \texttt{http://cr.yp.to/2005-590/goldberg.pdf}. I need to
% compare them very carefully.
%
% \subsection{Temporary function for testing}
%
% \begin{macro}[EXP]{\fp_rem:nn}
%   \begin{macrocode}
\cs_new:Npn \fp_rem:nn #1 #2
  { \exp_args:Nff \fp_rem_aux:nn { \fp_parse:n {#1} } { \fp_parse:n {#2} } }
\cs_new:Npn \fp_rem_aux:nn #1 #2 { \fp_rem:ww #1 #2 }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Common to several operations}
%
% \begin{macro}[EXP]{\fp_basics_aux_pack_low:NNNNNw,
%     \fp_basics_aux_pack_high:NNNNNw,
%     \fp_basics_aux_pack_high_carry:w}
%   Addition and multiplication of mantissas are done in two steps:
%   first compute a (more or less) exact result,
%   then round and pack digits in the final (braced) form.
%   These functions take care of the packing, with special attention
%   given to the case where rounding has caused a carry.
%   In \cs{fp_basics_aux_pack_high_carry:w}, |#1| should
%   always be $0000$.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_aux_pack_low:NNNNNw #1 #2#3#4#5 #6;
  {
    \if:w 2 #1
      + \c_one
    \fi:
    ; {#2#3#4#5} {#6} ;
  }
\cs_new:Npn \fp_basics_aux_pack_high:NNNNNw #1 #2#3#4#5 #6;
  {
    \if:w 2 #1
      \fp_basics_aux_pack_high_carry:w
    \fi:
    ; {#2#3#4#5} {#6}
  }
\cs_new:Npn \fp_basics_pack_high_carry:w \fi: ; #1
  { + \c_one ; {1000} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_return_nan_nan:NNww,
%     \fp_basics_return_zero:NNww,
%     \fp_basics_return_inf:NNww,
%     \fp_basics_return_i:NNNNww,
%     \fp_basics_return_ii:NNNNww,
%     \fp_basics_return_nan:NNNNww}
%   \begin{syntax}
%     \cs{fp_basics_return_...:NNww}
%     ~~\meta{sign1} \meta{sign2} \meta{body1} |;| \meta{body2} |;|
%   \end{syntax}
%   Used for binary operations, to return a value for some special
%   cases (common to several operations). All functions expand once
%   after their arguments.
%
%   The \texttt{nan_nan} function combines the \texttt{info} fields
%   of the two \texttt{nan}.\footnote{Bruno: check that messages are
%     kept.}
%   The \texttt{zero} and \texttt{inf} functions return $\pm 0$ or
%   $\pm\infty$ with a sign equal to the product of the two signs:
%   three \cs{exp_after:wN} are needed to escape out of the
%   conditional, and expand once after.
%   The \texttt{i} and \texttt{ii} functions return one of their
%   operands and expand after using \cs{fp_aux_exp_after_fp:wN}.
%   In some cases, this could be optimized, since we know in advance
%   what case of number we have. However, it seems better to keep the
%   number of control sequences low: these functions are called only
%   in special cases anyways, so performance is not an issue.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_return_nan_nan:NNww #1#2 #3; #4;
  {
    \exp_after:wN \fp_aux_qnan_fp:N
    \cs:w
      fp_info: ~ %
        \fp_aux_extract_info:N #3
        \fp_aux_extract_info:N #4
      \exp_after:wN
    \cs_end:
  }
\cs_new:Npn \fp_basics_return_zero:NNww #1#2 #3; #4;
  {
    \if_meaning:w #1 #2
      \exp_after:wN \exp_after:wN \exp_after:wN \c_zero_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_minus_zero_fp
    \fi:
  }
\cs_new:Npn \fp_basics_return_inf:NNww #1#2 #3; #4;
  {
    \if_meaning:w #1 #2
      \exp_after:wN \exp_after:wN \exp_after:wN \c_inf_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_minus_inf_fp
    \fi:
  }
\cs_new:Npn \fp_basics_return_i:NNNNww #1#2 #3#4 #5; #6;
  { \fp_aux_exp_after_fp:wN \s_fp \fp_use:w #1 #3 #5; }
\cs_new:Npn \fp_basics_return_ii:NNNNww #1#2 #3#4 #5; #6;
  { \fp_aux_exp_after_fp:wN \s_fp \fp_use:w #2 #4 #6; }
\cs_new:Npn \fp_basics_return_nan:NNNNww #1#2
  {
    \if_meaning:w #1 #2
      \exp_after:wN \fp_basics_return_nan_nan:NNww
    \else:
      \if_num:w #1 = \c_three
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_basics_return_i:NNNNww
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_basics_return_ii:NNNNww
      \fi:
      \exp_after:wN #1
      \exp_after:wN #2
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{User commands}
%
% Only a few commands are meant for external use (although none
% of them by end-users). The trailing \cs{fp_aux_do_nothing:} in some
% commands catches the extra expansion that is done by design at
% the end of every calculation. This extra expansion will be
% critical when parsing expressions.
%
% \begin{macro}[EXP]{\fp_basics_shuffle:NNN,\fp_basics_shuffle:Nww}
%   \begin{syntax}
%     \cs{fp_basics_shuffle:NNN} \meta{function} \meta{fp1} \meta{fp2}
%     \cs{fp_basics_shuffle:Nww} \meta{function}
%     ~~\meta{floating point 1} \meta{floating point 2}
%   \end{syntax}
%   Feed the floating points to \meta{function} in the same form
%   as produced by \cs{fp_basics_shuffle:Nnn}. However, the
%   \texttt{Nww} function expands once after the computation,
%   and does not swap the numbers, while the \texttt{NNN} does not
%   expand, but swaps the numbers.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_basics_shuffle:NNN #1 #2 #3
  {
    \exp_after:wN \exp_after:wN \exp_after:wN \fp_basics_shuffle:Nww
    \exp_after:wN \exp_after:wN \exp_after:wN #1
    \exp_after:wN #3 #2
    \fp_aux_do_nothing:
  }
\cs_new:Npn \fp_basics_shuffle:Nww
    #1 \s_fp \fp_use:w #2 #3 #4 ; \s_fp \fp_use:w #5 #6
  { #1 #2 #5 #3 #6 #4 ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_add:NN,\fp_add:ww}
% \begin{macro}[EXP]{\fp_mul:NN,\fp_mul:ww}
%   For addition and multiplication, everything is easy.
%    \begin{macrocode}
\cs_new:Npn \fp_add:NN { \fp_basics_shuffle:NNN \fp_basics_add_cases:NN }
\cs_new:Npn \fp_add:ww { \fp_basics_shuffle:Nww \fp_basics_add_cases:NN }
\cs_new:Npn \fp_mul:NN { \fp_basics_shuffle:NNN \fp_basics_mul_cases:NN }
\cs_new:Npn \fp_mul:ww { \fp_basics_shuffle:Nww \fp_basics_mul_cases:NN }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_sub:NN,\fp_sub:ww}
%   For subtraction, the sign and the order are a little
%   bit problematic, so we need two \enquote{\texttt{cases}}
%   functions with opposite signs.
%    \begin{macrocode}
\cs_new:Npn \fp_sub:NN { \fp_basics_shuffle:NNN \fp_basics_sub_back_cases:NN }
\cs_new:Npn \fp_sub:ww { \fp_basics_shuffle:Nww \fp_basics_sub_cases:NN }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_div:NN,\fp_div:ww}
%   For division, the problem is slightly worse than for
%   subtraction, since swapping the arguments has much
%   stronger consequences than just changing the sign.
%   Hence, we code \cs{fp_div:ww} by hand so that it
%   swaps its arguments.
%    \begin{macrocode}
\cs_new:Npn \fp_div:NN { \fp_basics_shuffle:NNN \fp_basics_div_back_cases:NN }
\cs_new:Npn \fp_div:ww \s_fp \fp_use:w #1 #2 #3 ; \s_fp \fp_use:w #4 #5 #6 ;
  { \fp_basics_div_back_cases:NN #4 #1 #5 #2 #6 ; #3 ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_rem:NN, \fp_rem:ww}
%   See \cs{fp_div:NN} and \cs{fp_div:ww}.
%    \begin{macrocode}
\cs_new:Npn \fp_rem:NN { \fp_basics_shuffle:NNN \fp_basics_rem_back_cases:NN }
\cs_new:Npn \fp_rem:ww \s_fp \fp_use:w #1 #2 #3 ; \s_fp \fp_use:w #4 #5 #6 ;
  { \fp_basics_rem_back_cases:NN #4 #1 #5 #2 #6 ; #3 ; }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Addition and subtraction}
%
% \subsubsection{Sign, exponent, and special numbers}
%
% \begin{macro}[EXP,aux]{\fp_basics_sub_back_cases:NN}
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_basics_sub_back_cases:NN #1 #2 #3
  {
    \exp_after:wN \fp_basics_add_cases:NN
    \exp_after:wN #1
    \exp_after:wN #2
    \int_use:N \int_eval:w \c_two - #3 \int_eval_end:
  }
\cs_new_nopar:Npn \fp_basics_sub_cases:NN #1 #2 #3 #4
  {
    \exp_after:wN \fp_basics_add_cases:NN
    \exp_after:wN #1
    \exp_after:wN #2
    \exp_after:wN #3
    \int_use:N \int_eval:w \c_two - #4 \int_eval_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,aux]{\fp_basics_add_cases:NN}
%   \begin{syntax}
%     \cs{fp_basics_add_cases:NN} \meta{case1} \meta{case2}
%     ~~\meta{sign1} \meta{sign2} \meta{body1} |;| \meta{body2} |;|
%   \end{syntax}
%   This performs the addition. it also expands the following tokens
%   on the input stream once.
%
%   Whenever \meta{case1} is different from \meta{case2}, the result
%   is simply the floating point number with the highest \meta{case}.
%   For instance, adding a normal number to a zero gives the normal
%   number, and adding a \texttt{nan} to any non-\texttt{nan} gives
%   that \texttt{nan}. Optimizing for addition of normal numbers,
%   we test for equality and then separate the \enquote{greater than}
%   and \enquote{less than} branches.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_cases:NN #1 #2
  {
    \if_num:w #1 = #2 \exp_stop_f:
      \exp_after:wN \fp_basics_add_cases_eq:N
    \else:
      \if_num:w #1 < #2 \exp_stop_f:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_basics_return_ii:NNNNww
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_basics_return_i:NNNNww
      \fi:
      \exp_after:wN #1
    \fi:
    #2
  }
%    \end{macrocode}
%   If the first \meta{case} is larger, then the first number remains
%   untouched, while the second number is ignored. On the other hand,
%   if the second \meta{case} is larger, the opposite happens: we retain
%   the second number. In both cases, there needs to be one step of
%   expansion after.
%    \begin{macrocode}
%    \end{macrocode}
%   We are then ready for the equality case: we split according
%   to the \meta{case}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_cases_eq:N #1
  {
    \if_case:w #1 \exp_stop_f:
         \exp_after:wN \fp_basics_add_zeros:NNww
    \or: \exp_after:wN \fp_basics_add_normal:NNww
    \or: \exp_after:wN \fp_basics_add_inf:NNww
    \or: \exp_after:wN \fp_basics_return_nan_nan:NNww
    \fi:
  }
%    \end{macrocode}
%   Adding two zeros yields \cs{c_zero_fp}, except if both
%   zeros were $-0$.\footnote{Bruno: this should depend on the
%     rounding mode.}
%   Three \cs{exp_after:wN} are needed to get out of the conditional,
%   and add an extra step of expansion.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_zeros:NNww #1#2 #3; #4;
  {
    \if_num:w #1 #2 = 22 \exp_stop_f:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_minus_zero_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_zero_fp
    \fi:
  }
%    \end{macrocode}
%   If both infinities have the same sign, just return that infinity,
%   otherwise, it is not a number.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_inf:NNww #1#2 #3; #4;
  {
    \if_meaning:w #1 #2
      \exp_after:wN \exp_after:wN \exp_after:wN \fp_aux_inf_fp:N
      \exp_after:wN \exp_after:wN \exp_after:wN #1
    \else:
      \exp_after:wN \fp_snan_inf_minus_inf:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_normal:NNww}
%   \begin{syntax}
%     \cs{fp_basics_add_normal:NNww} \meta{sign1} \meta{sign2}
%     ~~\Arg{exp_1}  \meta{body1} |;| \Arg{exp_2} \meta{body2} |;|
%   \end{syntax}
%   We now have two normal numbers to add, and we have to check signs
%   and exponents more carefully before performing the addition.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_normal:NNww #1#2
  {
    \if_meaning:w #1#2
      \exp_after:wN \fp_basics_add_npos:Nnwnw
    \else:
      \exp_after:wN \fp_basics_sub_npos:Nnwnw
    \fi:
    #1
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Absolute addition}
%
% In this subsection, we perform the addition
% of two positive normal numbers.
%
% \begin{macro}[EXP]{\fp_basics_add_npos:Nnwnw}
%   \begin{syntax}
%     \cs{fp_basics_add_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp_1}  \meta{body1} |;| \Arg{exp_2} \meta{body2} |;|
%   \end{syntax}
%   Since we are doing an addition, \meta{sign} will be the final sign.
%   The only special case which may arise is the case of an overflow.
%   This will be checked by \cs{fp_basics_add_sanitize:wN} at the end of
%   the calculation. We start an \cs{int_eval:w}, responsible for
%   computing the exponent, which may receive a contribution of |+1|
%   in case of carry. The exponent should be stopped by |;| followed by
%   the overall \meta{sign} for the sanitizing to work properly.
%
%   Grab and compare the exponents. The smaller number is decimated until
%   its exponent reaches that of the bigger number. We need to bring the
%   final sign down in the midst of the calculation to do the rounding
%   correctly.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_npos:Nnwnw #1 #2#3; #4
  {
    \exp_after:wN \fp_basics_add_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \int_eval:w
      \if_num:w #2 > #4 \exp_stop_f:
        #2
        \exp_after:wN \fp_basics_add_big_i:wNww \int_value:w -
      \else:
        #4
        \exp_after:wN \fp_basics_add_big_ii:wNww \int_value:w
      \fi:
      \int_eval:w #4 - #2 ; #1 #3;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_sanitize:Nw}
%   \begin{syntax}
%     \cs{fp_basics_add_sanitize:Nw} \meta{sign} \meta{exp} |;| \Arg{body} |;|
%   \end{syntax}
%   We only need to check for overflow. This code is done after
%   the computation, and we don't need to perform the post-expansion.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_sanitize:Nw #1 #2 ;
  {
    \if_num:w #2 > \c_fp_max_exponent_int
      \exp_after:wN \fp_aux_overflow:w
    \fi:
    \s_fp \fp_use:w 1 #1 {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_big_i:wNww,
%     \fp_basics_add_big_ii:wNww}
%   \begin{syntax}
%     \cs{fp_basics_add_big_i:wNww} \meta{shift} |;| \meta{sign}
%     ~~\meta{body1} |;| \meta{body2} |;|
%   \end{syntax}
%   Shift the mantissa of the small number, and then add with
%   \cs{fp_basics_add_mantissa:NnnwnnnnN}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_big_i:wNww #1; #2 #3; #4;
  {
    \fp_aux_decimate:nNnnnn {#1}
      \fp_basics_add_mantissa:NnnwnnnnN
      #4
    #3
    #2
  }
\cs_new:Npn \fp_basics_add_big_ii:wNww #1; #2 #3; #4;
  {
    \fp_aux_decimate:nNnnnn {#1}
      \fp_basics_add_mantissa:NnnwnnnnN
      #3
    #4
    #2
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_mantissa:NnnwnnnnN}
%   \begin{syntax}
%     \cs{fp_basics_add_mantissa:NnnwnnnnN}
%     ~~\meta{rounding}
%     ~~\Arg{Y'1} \Arg{Y'2} \meta{extra-digits} |;|
%     ~~\Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4}
%     ~~\meta{final sign}
%   \end{syntax}
%   To round properly, we must know at which digit the rounding
%   should occur. This requires to know whether the addition
%   produces an overall carry or not. Thus, we do the computation
%   now and check for a carry, then go back and do the rounding.
%   The rounding may cause a carry in very rare cases such as
%   $0.99\cdots 95 \to 1.00\cdots 0$, but this situation always
%   give an exact power of $10$, for which it is easy to correct
%   the result at the end.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa:NnnwnnnnN #1 #2#3 #4; #5#6#7#8
  {
    \exp_after:wN \fp_basics_add_mantissa_test:N
    \int_use:N \int_eval:w 1#5#6 + #2
      \exp_after:wN \fp_basics_add_mantissa_pack:NNNNNNN
      \int_use:N \int_eval:w 1#7#8 + #3 ; #1
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa_pack:NNNNNNN #1 #2#3#4#5#6#7
  {
    \if:w 2 #1
      + \c_one
    \fi:
    ; #2 #3 #4 #5 #6 #7 ;
  }
\cs_new:Npn \fp_basics_add_mantissa_test:N #1
  {
    \if:w 2 #1
      \exp_after:wN \fp_basics_add_mantissa_carry:wwNNNN
    \else:
      \exp_after:wN \fp_basics_add_mantissa_no_carry:wwNNNN
    \fi:
  }
%    \end{macrocode}
%
%   \begin{quote}
%     \cs{fp_basics_add_mantissa_no_carry:wwNNNN}
%     ~~\meta{8d} |;| \meta{6d} |;| \meta{2d} |;|
%     ~~\meta{rounding} \meta{sign}
%   \end{quote}
%   If there's no carry, grab all the digits again, and just
%   set the rounding correctly.\footnote{Bruno: an optimization
%     would be to compute whether we need rounding or not,
%     and only grab digits if there is rounding.}
%
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa_no_carry:wwNNNN
    #1; #2; #3#4 ; #5#6
  {
    \exp_after:wN \fp_basics_aux_pack_high:NNNNNw
    \int_use:N \int_eval:w 1 #1
      \exp_after:wN \fp_basics_aux_pack_low:NNNNNw
      \int_use:N \int_eval:w 1 #2 #3#4
        + \fp_aux_round:NNN #6 #4 #5
        \exp_after:wN ;
  }
%    \end{macrocode}
%
%   The case where there is a carry is very similar: rounding can even
%   raise the first digit from $1$ to $2$ (but we don't need to check that).
%   \begin{quote}
%     \cs{fp_basics_add_mantissa_carry:wwNNNN}
%     ~~\meta{8d} |;| \meta{6d} |;| \meta{2d} |;|
%     ~~\meta{rounding} \meta{sign}
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa_carry:wwNNNN
    #1; #2; #3#4; #5#6
  {
    + \c_one
    \exp_after:wN \fp_basics_add_mantissa_carry_pack:NNNNNNNNw
    \int_use:N \int_eval:w 1 #1
      \exp_after:wN \fp_basics_add_mantissa_carry_pack_ii:NNNNw
      \int_use:N \int_eval:w 1 #2#3
        + \fp_aux_round:NNNN #6 #3 #4 #5
        \exp_after:wN ;
  }
\cs_new:Npn \fp_basics_add_mantissa_carry_pack_ii:NNNNw #1 #2#3#4 #5;
  {
    \if:w 2 #1
      + \c_one
    \fi:
    \int_eval_end:
    #2#3#4; {#5} ;
  }
\cs_new:Npn \fp_basics_add_mantissa_carry_pack:NNNNNNNNw
    #1#2#3#4 #5#6#7#8 #9; { ; {#1#2#3#4} {#5#6#7#8} {#9} }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Absolute subtraction}
%
% \begin{macro}[EXP]{\fp_basics_sub_npos:Nnwnw}
%   \begin{syntax}
%     \cs{fp_basics_sub_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp_1}  \meta{body1} |;| \Arg{exp_2} \meta{body2} |;|
%   \end{syntax}
%   Rounding properly in some modes requires to know what the sign
%   of the result will be. For addition, this was easy. Here, besides
%   comparing the exponents to know how to decimate, we need to
%   check carefully which number is bigger when they have the same
%   exponent.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_npos:Nnwnw #1 #2#3; #4 #5;
  {
    \exp_after:wN \fp_basics_sub_sanitize:wN
    \int_use:N \int_eval:w
      \if_num:w #2 > #4 \exp_stop_f:
        #2
        \exp_after:wN \fp_basics_sub_big_i:wNww \int_value:w -
      \else:
        #4
        \if_num:w #2 = #4 \exp_stop_f:
          \fp_basics_sub_exponent_eq:nnnnnnnn #3 #5
        \else:
          \exp_after:wN \fp_basics_sub_big_ii:wNww \int_value:w
        \fi:
      \fi:
      \int_eval:w #4 - #2 ; #1 #3; #5;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_sanitize:wN}
%   \begin{syntax}
%     \cs{fp_basics_sub_sanitize:wN} \meta{exp} |;| \meta{sign} \Arg{body} |;|
%   \end{syntax}
%   \footnote{Bruno: the fact that half of the sanitizing functions
%     expect the sign before the exponent, and the other half expect
%     it the other way around is a pain.}
%   We need to check for overflow, for underflow, and for exact zero
%   (which is characterized by setting the sign to $1$).
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_sanitize:wN #1 ; #2
  {
    \if_case:w \if_num:w #1 > \c_fp_max_exponent_int \c_one \else:
               \if_num:w #1 < \c_fp_min_exponent_int \c_two \else:
               \if:w 1 #2 \c_three \else: \c_zero \fi: \fi: \fi:
    \or: \exp_after:wN \fp_aux_overflow:w
    \or: \exp_after:wN \fp_aux_underflow:w
    \or: \exp_after:wN \fp_aux_exact_zero:w
    \fi:
    \s_fp \fp_use:w 1 #2 {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_exponent_eq:nnnnnnnn}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_exponent_eq:nnnnnnnn #1#2#3#4 #5#6#7#8
  {
    \if_num:w #1#2 > #5#6 \exp_stop_f:
      \exp_after:wN \fp_basics_sub_big_i:wNww \int_value:w
    \else:
      \if_num:w #1#2 < #5#6 \exp_stop_f:
        \exp_after:wN \fp_basics_sub_big_ii:wNww \int_value:w
      \else:
        \if_num:w #3#4 > #7#8 \exp_stop_f:
          \exp_after:wN \fp_basics_sub_big_i:wNww \int_value:w
        \else:
          \if_num:w #3#4 < #7#8 \exp_stop_f:
            \exp_after:wN \fp_basics_sub_big_ii:wNww \int_value:w
          \else:
            \exp_after:wN \fp_basics_sub_eq:wNww \int_value:w
          \fi:
        \fi:
      \fi:
    \fi:
  }
\cs_new:Npn \fp_basics_sub_eq:wNww #1; #2 #3; #4; { ; 1 ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_big_i:wNww,\fp_basics_sub_big_ii:wNww}
%   \begin{syntax}
%     \cs{fp_basics_sub_big_i:wNww} \meta{shift} |;| \meta{sign}
%     ~~\meta{body1} |;| \meta{body2} |;|
%   \end{syntax}
%   Shift the mantissa of the small number, and then subtract with
%   \cs{fp_basics_sub_back_mantissa:NnnwNnnnn}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_big_i:wNww #1; #2 #3; #4;
  {
    \fp_aux_decimate:nNnnnn {#1}
      \fp_basics_sub_back_mantissa:NnnwNnnnn
      #4
    #2
    #3
  }
\cs_new:Npn \fp_basics_sub_big_ii:wNww #1; #2 #3; #4;
  {
    \exp_after:wN \fp_basics_sub_big_i:wNww
    \int_value:w #1 \exp_after:wN ;
    \int_use:N \int_eval:w 2 - #2 \int_eval_end:
    #4; #3;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_back_mantissa:NnnwNnnnn}
%   \begin{syntax}
%     \cs{fp_basics_sub_back_mantissa:NnnwNnnnn}
%     ~~\meta{rounding} \Arg{Y'1} \Arg{Y'2} \meta{extra-digits}
%     ~~\meta{final sign}
%     ~~\Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4}
%   \end{syntax}
%   At this stage, we know that \meta{Y} is less than \meta{X},
%   and we know the final sign.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_mantissa:NnnwNnnnn #1 #2#3 #4; #5 #6#7#8#9
  {
    \exp_after:wN \fp_basics_sub_back_mantissa_aux:NNwNNNNwN
    \exp_after:wN #1
    \exp_after:wN #5
    \int_use:N \int_eval:w 2#6#7 - #2 - \c_two +
      \exp_after:wN \fp_basics_sub_back_mantissa_round:wNN
      \int_use:N \int_eval:w 2#8#9 - #3 ; #1 #5
  }
%    \end{macrocode}
% After the computation, we need to check whether the first digit of
% the result is zero. This can only happen if the two numbers had the
% same exponent, or exponents differing by $1$. In the latter case,
% the \meta{rounding} digit is not quite enough to let us retrieve
% the exact result (consider $\cdots25$ and $\cdots15$, both rounded
% to $\cdots2$ in the usual mode), so we also move the result of
% \cs{fp_aux_round_neg:NNN} upstream as the digit $0$ or $1$.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_mantissa_round:wNN #1; #2 #3
  {
    \exp_after:wN \fp_basics_sub_back_mantissa_aux_iii:N
    \int_value:w
        \exp_after:wN \fp_aux_round_neg:NNN
        \exp_after:wN #3
        \use_none:nnnnnnnn #1 #2
      + #1
    \exp_after:wN ;
  }
\cs_new:Npn \fp_basics_sub_back_mantissa_aux_iii:N #1
  {
    \exp_after:wN \fp_basics_sub_back_mantissa_aux_ii:NNNNNNw
    \exp_after:wN #1
    \int_use:N \int_eval:w
      - #1
  }
\cs_new:Npn \fp_basics_sub_back_mantissa_aux_ii:NNNNNNw #1 #2 #3#4#5#6 #7;
  { #2 ; #1 {#3#4#5#6} {#7} ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_back_mantissa_aux:NNwNNNNwN}
%   Here, |#3| should always be $2$, but we have to take is
%   as a normal undelimited argument since that would break
%   if |#2| is $2$.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_mantissa_aux:NNwNNNNwN #1#2 #3 #4#5#6#7 #8; #9
  {
    \if:w 0 #4
      \exp_after:wN \fp_basics_sub_back_carry:NNwNnnnn
      \exp_after:wN #1
      \exp_after:wN #9
    \fi:
    ; #2
    {#4#5#6#7} {#8}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_back_carry:NNwNnnnn}
%   \begin{syntax}
%     \cs{fp_basics_sub_back_carry:NNwNnnnn}
%     ~~\meta{rounding} \meta{0 or 1} |;| \meta{final sign}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} |;|
%   \end{syntax}
%   This function is called when $\meta{Z1}\leq 999$. We revert
%   the carry, which is given by \meta{0 or 1}, and subtract the
%   \meta{rounding} digit as appropriate, then feed the result,
%   of the form \meta{$\leq$ 7d} |;| \meta{9d} |;| to
%   \cs{fp_basics_sub_back_carry_aux:wwN}. The result is always exact.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry:NNwNnnnn #1#2 ; #3 #4#5#6#7 ;
  {
    \exp_after:wN \fp_basics_sub_back_carry_aux:wwN
    \int_use:N \int_eval:w #4 #5 - 1 + \exp_after:wN \fp_aux_i_s:N
    \int_use:N \int_eval:w 1 #6 #7 0 + #2 0 - #1 ; #3
  }
%    \end{macrocode}
%   Unless the first block is zero, check how many digits is has,
%   and shift the exponent down by the corresponding amount. Then
%   pack digits into blocks of $4$ (there are between $10$ and $16$
%   digits in front of \cs{fp_basics_sub_back_carry_large:NNNNNNNNw}).
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry_aux:wwN #1 ;
  {
    \if:w 0 #1
      - 8
      \exp_after:wN \fp_basics_sub_back_carry_small:wN \int_value:w
    \else:
      - \fp_basics_sub_back_carry_aux_ii:NNNNNNNNw #1 1234567;
      \exp_after:wN \fp_basics_sub_back_carry_large:NNNNNNNNw
    \fi:
    #1
  }
%    \end{macrocode}
%   The case where the number is non-zero is slightly easier.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry_aux_ii:NNNNNNNNw #1#2#3#4#5#6#7#8#9; {#8}
\cs_new:Npn \fp_basics_sub_back_carry_large:NNNNNNNNw #1#2#3#4 #5#6#7#8 #9;
  {
    \fp_basics_sub_back_carry_large_ii:NNNNNNNNw
    #9 000000 ; {#1#2#3#4} {#5#6#7#8}
  }
\cs_new:Npn \fp_basics_sub_back_carry_large_ii:NNNNNNNNw #1#2#3#4 #5#6#7#8 #9;
  { \fp_basics_sub_back_carry_large_iii:nnnnN {#1#2#3#4} {#5#6#7#8} }
\cs_new:Npn \fp_basics_sub_back_carry_large_iii:nnnnN #1#2 #3#4 #5
  { ; #5 {#3}{#4} {#1}{#2} ; }
%    \end{macrocode}
%   In the case of a \enquote{small} result, what comes after
%   \cs{fp_basics_sub_back_carry_small:wN} has between $1$
%   and $9$ digits, and is not zero.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry_small:wN #1;
  {
    - \exp_after:wN \fp_aux_use_i_until_s:nw
      \use_none:nnnnnnnnn #1 012345678;
    \fp_basics_sub_back_carry_small_ii:NNNNNNNN #1 00000000 ;
  }
\cs_new:Npn \fp_basics_sub_back_carry_small_ii:NNNNNNNN #1#2#3#4 #5#6#7#8
  { \fp_basics_sub_back_carry_small_iii:nnNwN {#1#2#3#4} {#5#6#7#8} }
\cs_new:Npn \fp_basics_sub_back_carry_small_iii:nnNwN #1 #2 #3 #4; #5
  { ; #5 {#1} {#2} {#3000} {0000} ; }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Multiplication}
%
% The functions \cs{fp_mul:NN}, and \cs{fp_mul:ww}
% have been defined earlier through the \cs{fp_basics_shuffle} functions.
%
% \subsubsection{Signs, and special numbers}
%
% \begin{macro}[EXP,aux]{\fp_basics_mul_cases:NN}
%   \begin{syntax}
%     \cs{fp_basics_mul_cases:NN} \meta{case1} \meta{case2}
%     ~~\meta{sign1} \meta{sign2} \meta{body1} |;| \meta{body2} |;|
%   \end{syntax}
%   Expands the following tokens on the input stream once.
%   The special cases are coded at the start of this module,
%   and identical to the ones for division.\footnote{Bruno: \texttt{nan}
%     are not treated properly: $\infty\times 0$ should signal.}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_cases:NN #1 #2
  {
    \if_case:w \int_eval:w \c_one +
            \if_num:w #1 = \c_one          #2 \int_eval_end: \fi:
            \if_num:w #2 = \c_one          #1 \int_eval_end: \fi:
            \if_num:w #1 = #2 \exp_stop_f: #1 \int_eval_end: \fi:
            \c_three \int_eval_end:
    \or: \exp_after:wN \fp_basics_return_zero:NNww
    \or: \exp_after:wN \fp_basics_mul_normal:NNww
    \or: \exp_after:wN \fp_basics_return_inf:NNww
    \or: \exp_after:wN \fp_basics_return_nan_nan:NNww
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_normal:NNww}
%   \begin{syntax}
%     \cs{fp_basics_mul_normal:NNww} \meta{sign1} \meta{sign2}
%     ~~\Arg{exp_1}  \meta{body1} |;| \Arg{exp_2} \meta{body2} |;|
%   \end{syntax}
%   We now have two normal numbers to multiply. Combine the signs.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_normal:NNww #1#2
  {
    \if:w #1#2
      \exp_after:wN \fp_basics_mul_npos:Nnwnw
      \exp_after:wN 0
    \else:
      \exp_after:wN \fp_basics_mul_npos:Nnwnw
      \exp_after:wN 2
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute multiplication}
%
% In this subsection, we perform the multiplication
% of two positive normal numbers.
%
% \begin{macro}[EXP]{\fp_basics_mul_npos:Nnwnw}
%   \begin{syntax}
%     \cs{fp_basics_mul_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp_1}  \meta{body1} |;| \Arg{exp_2} \meta{body2} |;|
%   \end{syntax}
%   As for addition, \meta{sign} is the final sign. After the computation,
%   \cs{fp_basics_mul_sanitize:Nw} checks for overflow or underflow.
%   As before, \cs{int_eval:w} computes the exponent, catching any
%   shift coming from the computation in the mantissa. Again, the
%   \meta{sign} is needed for rounding to be done properly, so we move
%   it around with us. We setup the post-expansion here, triggered by
%   \cs{fp_basics_mul_mantissa:nnnnNnnnn}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_npos:Nnwnw #1 #2#3; #4 #5;
  {
    \exp_after:wN \fp_basics_mul_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \int_eval:w
      #2 + #4
      \fp_basics_mul_mantissa:nnnnNnnnn #3 #1 #5
    \exp_after:wN ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_sanitize:Nw}
%   \begin{syntax}
%     \cs{fp_basics_mul_sanitize:Nw} \meta{sign} \meta{exp} |;| \Arg{body} |;|
%   \end{syntax}
%   Over- and underflow check, optimized for the usual case
%   (neither under nor overflow).
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_sanitize:Nw #1 #2 ;
  {
    \if_num:w #2 > \c_fp_max_exponent_int
      \exp_after:wN \fp_aux_overflow:w
    \else:
      \if_num:w #2 < \c_fp_min_exponent_int
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_aux_underflow:w
      \fi:
    \fi:
    \s_fp \fp_use:w 1 #1 {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_mantissa:nnnnNnnnn}
%   \begin{syntax}
%     \cs{fp_basics_mul_mantissa:nnnnNnnnn}
%     ~~\Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4} \meta{sign}
%     ~~\Arg{Y_1} \Arg{Y_2} \Arg{Y_3} \Arg{Y_4} \meta{;}
%   \end{syntax}
%   After one expansion, the token following \meta{Y4} must be a semicolon
%   (represented by \meta{;}).
%
%   The product of two $16$ digit integers has $31$ or $32$ digits,
%   but it is impossible to know which one before computing. The place
%   where we round depends on that number of digits, and may depend
%   on all digits until the last in some rare cases. The approach is
%   thus to compute the $5$ first blocks of $4$ digits (the first one
%   is between $100$ and $9999$ inclusive), and a compact version of
%   the remaining $3$ blocks. Afterwards, the number of digits is
%   known, and we can do the rounding within yet another set of
%   \cs{int_eval:w}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_mantissa:nnnnNnnnn #1#2#3#4 #5 #6#7#8#9
  {
    \exp_after:wN \fp_basics_mul_mantissa_after:NNN
    \exp_after:wN #5
    \int_use:N \int_eval:w 99990000 + #1*#6 +
      \exp_after:wN \fp_basics_mul_mantissa_keep:NNNNNw
      \int_use:N \int_eval:w 99990000 + #1*#7 + #2*#6 +
        \exp_after:wN \fp_basics_mul_mantissa_keep:NNNNNw
        \int_use:N \int_eval:w 99990000 + #1*#8 + #2*#7 + #3*#6 +
          \exp_after:wN \fp_basics_mul_mantissa_drop:NNNNNw
          \int_use:N \int_eval:w  99990000 + #1*#9 + #2*#8 + #3*#7 + #4*#6 +
            \exp_after:wN \fp_basics_mul_mantissa_drop:NNNNNw
            \int_use:N \int_eval:w  99990000 + #2*#9 + #3*#8 + #4*#7 +
              \exp_after:wN \fp_basics_mul_mantissa_drop:NNNNNw
              \int_use:N \int_eval:w  99990000 + #3*#9 + #4*#8 +
                \exp_after:wN \fp_basics_mul_mantissa_drop:NNNNNw
                \int_use:N \int_eval:w 100000000 + #4*#9 \exp_after:wN ;
  }
\cs_new:Npn \fp_basics_mul_mantissa_drop:NNNNNw #1#2#3#4#5 #6;
  { #1#2#3#4#5 ; + #6 }
\cs_new:Npn \fp_basics_mul_mantissa_keep:NNNNNw #1#2#3#4#5 #6;
  { #1#2#3#4#5 ; #6 ; }
%    \end{macrocode}
%   Once the first \cs{int_use:N} \cs{int_eval:w}, and all the
%   \cs{fp_basics_mul_mantissa_...:NNNNNw} have been expanded,
%   we get
%   \begin{quote}
%     \cs{fp_basics_mul_mantissa_after:NNN} \meta{sign} |1|
%     ~~\meta{digits 1--8} |;| \meta{digits 9--12} |;| \meta{digits 13--16} |;|
%     ~~|+| \meta{digits 17--20} |+| \meta{digits 21--24}
%     ~~|+| \meta{digits 25--28} |+| \meta{digits 29--32} |;|
%   \end{quote}
%   If the \meta{digit 1} is non-zero, then for rounding we only care
%   about the digits $16$ and $17$, and whether all other digits are zero
%   or not (check for exact ties). On the other hand, if \meta{digit 1}
%   is zero, we care about digits $17$ and $18$, and whether all others are
%   zero.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_mantissa_after:NNN #1 #2 #3
  {
    \if:w 0 #3
      \exp_after:wN \fp_basics_mul_mantissa_small:NNwwwN
    \else:
      \exp_after:wN \fp_basics_mul_mantissa_large:NwwNNNN
    \fi:
    #1 #3
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_mantissa_large:NwwNNNN}
%   In this branch, \meta{digit 1} is non-zero. The result is thus
%   \meta{digits 1--16}, plus some rounding which depends on the digits
%   $16$, $17$, and whether all subsequent digits are zero or not.
%   Here, \cs{fp_aux_round_s:NNNw} takes the \meta{sign}, followed by
%   digits $16$, $17$, and an integer expression which is zero if and
%   only if all further digits are zero.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_mantissa_large:NwwNNNN #1 #2; #3; #4#5#6#7; +
  {
    \exp_after:wN \fp_basics_aux_pack_high:NNNNNw
    \int_use:N \int_eval:w 1#2
      \exp_after:wN \fp_basics_aux_pack_low:NNNNNw
      \int_use:N \int_eval:w 1#3#4#5#6#7 + \fp_aux_round_s:NNNw #1 #7
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_mantissa_small:NNwwwN}
%   In this branch, \meta{digit 1} is zero. Our result will thus be
%   \meta{digits 2--17}, plus some rounding which depends on the digits
%   $17$, $18$, and whether all subsequent digits are zero or not.
%   The $8$ digits |1#3| are followed, after expansion of the
%   \texttt{small_pack} auxiliary, by the next digit, to form a $9$
%   digit number. Also, rounding may have caused a carry, which is
%   then converted to \cs{c_ten} rather than the usual \cs{c_one},
%   because of the shift.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_mantissa_small:NNwwwN #1 #2#3; #4; #5; + #6
  {
    - \c_one
    \exp_after:wN \fp_basics_aux_pack_high:NNNNNw
    \int_use:N \int_eval:w 1#3
      \exp_after:wN \fp_basics_mul_mantissa_small_pack:NNNNNNw
      \int_use:N \int_eval:w 1#4#5#6 + \fp_aux_round_s:NNNw #1 #6
  }
\cs_new:Npn \fp_basics_mul_mantissa_small_pack:NNNNNNw #1#2 #3#4#5#6 #7;
  {
    #2
    \if:w 2 #1
      + \c_ten
    \fi:
    ; {#3#4#5#6} {#7} ;
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Division}
%
% Time is now ripe to tackle the hardest of the four elementary
% operations: division. The functions \cs{fp_div:NN},
% and \cs{fp_div:ww} have been defined earlier.
%
% \subsubsection{Signs, and special numbers}
%
% In the case of division, the order of the operands matters,
% and it turns out to be slightly simpler if we internally
% compute the \enquote{backwards} division.
%
% \begin{macro}[EXP,aux]{\fp_basics_div_back_cases:NN}
%   \begin{syntax}
%     \cs{fp_basics_div_back_cases:NN} \meta{case2} \meta{case1}
%     ~~\meta{sign2} \meta{sign1} \meta{body2} |;| \meta{body1} |;|
%   \end{syntax}
%   Expands the following tokens on the input stream once.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_back_cases:NN #1 #2
  {
    \if_case:w \if_num:w #1 = #2 \exp_stop_f:
                 #1 \exp_stop_f:
               \else:
                 \if_num:w #1 < #2 \exp_stop_f:
                   \if:w 3 #2 \c_four \else: \c_five \fi:
                 \else:
                   \if:w 3 #1 \c_six \else: \c_seven \fi:
                 \fi:
               \fi:
         \exp_after:wN \fp_basics_div_back_zero_zero:NNww
    \or: \exp_after:wN \fp_basics_div_back_normal:NNww
    \or: \exp_after:wN \fp_basics_div_back_inf_inf:NNww
    \or: \exp_after:wN \fp_basics_return_nan_nan:NNww
    \or:
      \exp_after:wN \fp_basics_return_ii:NNNNww
      \exp_after:wN #1
      \exp_after:wN #2
    \or: \exp_after:wN \fp_basics_return_inf:NNww
    \or:
      \exp_after:wN \fp_basics_return_i:NNNNww
      \exp_after:wN #1
      \exp_after:wN #2
    \or: \exp_after:wN \fp_basics_return_zero:NNww
    \fi:
  }
%    \end{macrocode}
%   Most of the special cases are common with some
%   previous operations. We only need to write the cases of
%   $0/0$ and $\infty/\infty$. To make the error message as
%   informative as possible, we keep the signs (remember that
%   the arguments are swapped).\footnote{Bruno: everywhere,
%     optimize some tests by replacing \cs{if:w} by \cs{if_meaning:w}.}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_back_zero_zero:NNww #1#2 #3; #4;
  {
    \exp_after:wN \fp_aux_snan_fp:N
    \cs:w fp_info: ~ %
      \if_meaning:w 0 #2 + \else: - \fi: 0 /
      \if_meaning:w 0 #1 + \else: - \fi: 0 ;
      \exp_after:wN
    \cs_end:
  }
\cs_new:Npn \fp_basics_div_back_inf_inf:NNww #1#2 #3; #4;
  {
    \exp_after:wN \fp_aux_snan_fp:N
    \cs:w fp_info: ~ %
      \if_meaning:w 0 #2 + \else: - \fi: inf /
      \if_meaning:w 0 #1 + \else: - \fi: inf ;
      \exp_after:wN
    \cs_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_div_back_normal:NNww}
%   \begin{syntax}
%     \cs{fp_basics_div_back_normal:NNww} \meta{sign1} \meta{sign2}
%     ~~\Arg{exp_1}  \meta{body1} |;| \Arg{exp_2} \meta{body2} |;|
%   \end{syntax}
%   We now have two normal numbers to divide. Combine the signs.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_back_normal:NNww #1#2
  {
    \if:w #1#2
      \exp_after:wN \fp_basics_div_back_npos:Nnwnw
      \exp_after:wN 0
    \else:
      \exp_after:wN \fp_basics_div_back_npos:Nnwnw
      \exp_after:wN 2
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute (backwards) division}
%
% In this subsection, we perform the division
% of two positive normal numbers.
%
% \begin{macro}[EXP]{\fp_basics_div_back_npos:Nnwnw}
%   \begin{syntax}
%     \cs{fp_basics_div_back_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp Z} \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} |;|
%     ~~\Arg{exp A} \Arg{A_1} \Arg{A_2} \Arg{A_3} \Arg{A_4} |;|
%   \end{syntax}
%   We want to compute $A/Z$. As for addition and multiplication,
%   \meta{sign} is the final sign. Checking for underflow and
%   overflow is done using the same auxiliary as for multiplication.
%   As explained just below, we first compute $y$, which is
%   the $5$ first digits of $Z$, plus $1$, and then compute pieces
%   of the quotient roughly $4$ digits at a time. Here, |#1| is
%   a single digit, |#2| and |#7| are the exponents (integers),
%   |#8| is three brace groups, and all others are each $4$ digits.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_back_npos:Nnwnw #1 #2 #3#4#5#6; #7 #8;
  {
    \exp_after:wN \fp_basics_mul_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \int_eval:w
      #7 - #2
      \fp_basics_div_mantissa_i:wNwnn #3; #4;
      #8 {#3}{#4}{#5}{#6} #1
  }
%    \end{macrocode}
% \end{macro}
%
%   We are given two numbers, $A=0.A\sb{1}A\sb{2}A\sb{3}A\sb{4}$
%   and $Z=0.Z\sb{1}Z\sb{2}Z\sb{3}Z\sb{4}$, in blocks of $4$ digits,
%   and we know that the first digits of $A\sb{1}$ and of $Z\sb{1}$
%   are non-zero. To compute $A/Z$, we proceed as follows.
%   \begin{itemize}
%   \item Find an integer $Q\sb{1} \simeq 10^4 A / Z$.
%   \item Replace $A$ by $B = 10^4 A - Q\sb{1} Z$.
%   \item Find an integer $Q\sb{2} \simeq 10^4 B / Z$.
%   \item Replace $B$ by $C = 10^4 B - Q\sb{2} Z$.
%   \item Find an integer $Q\sb{3} \simeq 10^4 C / Z$.
%   \item Replace $C$ by $D = 10^4 C - Q\sb{3} Z$.
%   \item Find an integer $Q\sb{4} \simeq 10^4 D / Z$.
%   \item Consider $E = 10^4 D - Q\sb{4} Z$, and ensure
%     correct rounding.
%   \end{itemize}
%   The calculations of $B$, $C$, $D$, and $E$ can be done
%   exactly with only $16$ (or $17$) digits.
%
%   Unfortunately, things are not as easy as they seem.
%   Firstly, we make sure that all intermediate steps are positive,
%   since negative results would require extra calculations at the end.
%   This requires that $Q\sb{1} \leq 10^4 A / Z$ etc. A reasonable
%   attempt would be to define $Q\sb{1}$ as
%   \[
%   \cs{int_eval:n} \left\{
%     \frac{ A\sb{1} A\sb{2} }{ Z\sb{1} + 1 } - 1 \right\}.
%   \]
%   Subtracting $1$ at the end takes care of the fact that e\TeX{}'s
%   \cs{int_eval:w} rounds instead of truncating. We add $1$ to $Z\sb{1}$
%   because $ Z\sb{1} \leq 10^4 Z < Z\sb{1}+1$ and we need $Q\sb{1}$
%   to be an underestimate. However, we are now underestimating
%   $Q\sb{1}$ too much: it can be wrong by up to $100$, for instance
%   when $Z = 0.1$ and $A \simeq 1$. Then $B$ could take values up to
%   $10$ (maybe more), and a few steps down the line, we would run into
%   arithmetic overflow, since \TeX{} can only handle integers less than
%   roughly $2\cdot 10^9$.
%
%   A better formula is to take
%   \[
%   Q\sb{1} = \cs{int_eval:n} \left\{
%     \frac{ 10 \cdot A\sb{1} A\sb{2} }
%       { \left\lfloor 10^{-3} \cdot Z\sb{1} Z\sb{2} \right\rfloor + 1 }
%     - 1 \right\}.
%   \]
%   This is always less than $10^9 A / (10^5 Z)$, as we wanted.
%   In words, we take the $5$ first digits of $Z$ into account,
%   and the $8$ first digits of $A$, using $0$ as a $9$-th digit
%   rather than the true digit for efficiency reasons. We shall
%   prove that using this formula to define all the $Q\sb{i}$
%   leads to no overflow. For convenience, let us denote
%   \[
%   y = \left\lfloor 10^{-3} \cdot Z\sb{1} Z\sb{2} \right\rfloor + 1,
%   \]
%   so that, taking into account the fact that e\TeX{} rounds ties
%   away from zero,
%   \[
%   Q\sb{1} = \left\lfloor A\sb{1}A\sb{2}0/y - 1/2 \right\rfloor.
%   \]
%   Note that $10^4<y\leq 10^5$, and $999 \leq Q\sb{1} \leq 99989$.
%   Also note that this formula does not cause an overflow as long as
%   $A<2.147\cdots$, since the numerator involves an integer slightly
%   smaller than $10^9A$.
%
%   Let us bound $B$:
%   \begin{align*}
%   10^5 B
%   &=
%   A\sb{1}A\sb{2}0 + 10 \cdot 0.A\sb{3}A\sb{4}
%   - 10 \cdot Z\sb{1}.Z\sb{2}Z\sb{3}Z\sb{4}
%   \cdot \left\lfloor A\sb{1}A\sb{2}0/y - 1/2 \right\rfloor
%   \\
%   &<
%   A\sb{1}A\sb{2}0
%   \cdot \left( 1 - 10 \frac{Z\sb{1}.Z\sb{2}Z\sb{3}Z\sb{4}}{y} \right)
%   + \frac{3}{2} \cdot 10 \cdot Z\sb{1}.Z\sb{2}Z\sb{3}Z\sb{4} + 10
%   \\
%   &\leq
%   \frac{A\sb{1}A\sb{2}0 \cdot (y - 10 Z\sb{1}.Z\sb{2}Z\sb{3}Z\sb{4})}{y}
%   + \frac{3}{2} y + 10
%   \\
%   &\leq
%   \frac{A\sb{1}A\sb{2}0}{y} + \frac{3}{2} y + 10
%   \leq
%   \frac{10^9 A}{y} + 1.6 y
%   \end{align*}
%   At the last step, we hide $10$ into the second term
%   for later convenience. The same reasoning yields\footnote{Bruno:
%     I need to find much better notations. These are not great.}
%   \begin{align*}
%     10^5 B &< 10^9 A/y + 1.6 y, \\
%     10^5 C &< 10^9 B/y + 1.6 y, \\
%     10^5 D &< 10^9 C/y + 1.6 y, \\
%     10^5 E &< 10^9 D/y + 1.6 y. \\
%   \end{align*}
%   The goal is now to prove that none of $B$, $C$, $D$, and $E$
%   can go beyond $2.147\cdots$. Simply bounding each term on the
%   right-hand side separately will not be tight enough: for instance,
%   we would get $10^5 B < 10^5 + 1.6\cdot 10^5 = 2.6 \cdot 10^5$,
%   which is too large.
%
%   Combining the various inequalities together with $A<1$, we get
%   \begin{align*}
%     10^5 B &< 10^9/y + 1.6 y, \\
%     10^5 C &< 10^{13}/y^2 + 1.6 (y + 10^4), \\
%     10^5 D &< 10^{17}/y^3 + 1.6 (y + 10^4 + 10^8/y), \\
%     10^5 E &< 10^{21}/y^4 + 1.6 (y + 10^4 + 10^8/y + 10^{12}/y^2). \\
%   \end{align*}
%   All of those bounds are convex functions of $y$ (since every power
%   of $y$ involved is convex, and hte coefficients are positive), and
%   thus maximal at one of the end-points of the allowed range
%   $10^4<y\leq 10^5$. Thus,
%   \begin{align*}
%     10^5 B &< \mathrm{max} ( 1.16\cdot 10^5, 1.7 \cdot 10^5), \\
%     10^5 C &< \mathrm{max} ( 1.32\cdot 10^5, 1.77 \cdot 10^5), \\
%     10^5 D &< \mathrm{max} ( 1.48\cdot 10^5, 1.777 \cdot 10^5), \\
%     10^5 E &< \mathrm{max} ( 1.64\cdot 10^5, 1.7777 \cdot 10^5). \\
%   \end{align*}
%   All of those bounds are less than $2.147\cdot 10^5$, and
%   we are thus within \TeX{}'s bounds in all cases!\footnote{Bruno:
%     but I need to check this very carefully again.}
%
%   We will later need to have a bound on the $Q\sb{i}$. Their
%   definitions imply that $Q\sb{1} < 10^9 A/y - 1/2 < 10^5 A$ and
%   similarly for the other $Q\sb{i}$. Thus each of them is at most
%   $177770$.
%
%   The last step is to ensure correct rounding. We have
%   \[
%   A/Z = \sum_{i=1}^4 \left(10^{-4i} Q\sb{i}\right) + 10^{-16} E/Z
%   \]
%   exactly. Furthermore, we know that the result will be between
%   $0.1$ (inclusive) and $10$, so we only need to know the integer
%   part of $E/Z$, and a \enquote{rounding} digit encoding the rest
%   (see maybe addition for an explanation of why). Equivalently,
%   we need to find the integer part of $2E/Z$, and determine whether
%   it was an exact integer or not (this serves to detect ties). Since
%   \[
%   \frac{2E}{Z} = 2\frac{10^5 E}{10^5 Z}
%   \leq 2\frac{10^5 E}{10^4} < 36,
%   \]
%   this integer part is between $0$ and $35$ inclusive. We let
%   e\TeX{} round
%   \[
%   P = \cs{int_eval:n} \left\{
%     2 \frac{E\sb{1}E\sb{2}}{Z\sb{1}Z\sb{2}} \right\},
%   \]
%   which differs from $2E/Z$ by at most
%   \[
%   \frac{1}{2}
%   + 2 \left\lvert \frac{E}{Z} - \frac{E}{10^{-8} Z\sb{1}Z\sb{2}}\right\rvert
%   + 2 \left\lvert \frac{10^8 E - E\sb{1}E\sb{2}}{Z\sb{1}Z\sb{2}}\right\rvert
%   < 1,
%   \]
%   ($1/2$ comes from e\TeX{}'s rounding) because each absolute value
%   is less than $10^{-7}$. Thus $P$ is either the correct integer part,
%   or an overestimate by $1$ (impossible if $2E/Z$ is an integer). It
%   then suffices to compare $PZ$ with $2E$ to get the integer part of
%   $2E/Z$ and the information of whether it was an exact quotient or not.
%
% \begin{macro}[EXP]{\fp_basics_div_mantissa_i:wNwnn}
%   \begin{syntax}
%     \cs{fp_basics_div_mantissa_i:wNwnn}
%     ~~\meta{Z1} |;| \meta{Z2} |;|
%     ~~\Arg{A_1} \Arg{A_2} \Arg{A_3} \Arg{A_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{syntax}
%   First compute $y$ from the first $5$ digits of $Z$, and
%   unbrace \meta{A1} and \meta{A2}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_i:wNwnn #1; #2 #3; #4 #5
  {
    \exp_after:wN \fp_basics_div_mantissa_ii:ww
    \int_use:N \int_eval:w #1#2 + \c_one ;
    #4 #5 ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_ii:ww}
%     ~~\meta{y} |;| \meta{A1} \meta{A2} |;| \Arg{A_3} \Arg{A_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   Compute $Q\sb{1}$ by evaluating $\meta{A1}\meta{A2}0/y - 1$.
%   The result will be output to the left, in an \cs{int_eval:w}
%   which we start now.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_ii:ww #1; #2;
  {
    \exp_after:wN \fp_basics_div_mantissa_iii:www
    \int_value:w #1 \exp_after:wN ;
    \int_value:w
      \exp_after:wN \fp_basics_div_mantissa_calc:Nwwnnnnnn
      \int_use:N \int_eval:w #20/#1 + 999999 ; #2 ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_calc:Nwwnnnnnn} \meta{$10^6+{}$Q1} |;|
%     ~~\meta{A1} \meta{A2} |;| \Arg{A_3} \Arg{A_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   The goal here is to expand to
%   \begin{quote}
%     \meta{$10^6+{}$Q1} |;| \meta{B1} \meta{B2} |;| \Arg{B_3} \Arg{B_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   where $B = 10^4 A - Q\sb{1} \cdot Z$. More generally, this function
%   is used with $A\to B$, $B\to C$ and $Q\sb{1} \to Q\sb{2}$, etc.
%
%   Computing the product $Q\sb{1} \cdot Z$ is almost simple, since
%   $Q\sb{1}$ is rather small, but not quite:
%   the product of $Q\sb{1}$ with each block of four digits $Z\sb{i}$
%   is within \TeX{}'s bounds, but we wouldn't be able to use the
%   usual trick of adding a large power of $10$ to ensure that the
%   number of digits is fixed (see other operations for many examples
%   of this). Instead, we split off the digit of $10^5$ in $Q\sb{1}$
%   (and more generally $Q\sb{i}$), and do something similar to the
%   case of the full multiplication.
%
%   We know that $0<Q\sb{i}<1.8\cdot 10^5$, so $10^6+Q\sb{i}$ starts
%   with the digit $1$, followed by $\#1 = 1$ or $0$, then |#2|, which
%   is $5$ more digits. It would be somewhat simpler if we got |#1|
%   to be two digits, and |#2| four, but we are constrained by the $9$
%   arguments limit.
%
%   The result we want is then (the overall power of $10$ is arbitrary):
%   \begin{align*}
%   &10^{-4} ( \#3 - \#2 \cdot \#6 - 10 \cdot \#1 \cdot \#6\#7 )
%   + 10^{-8} ( \#4 - \#2 \cdot \#7 - 10 \cdot \#1 \cdot \#8 ) \\
%   &+ 10^{-12}( \#5 - \#2 \cdot \#8 - 10 \cdot \#1 \cdot \#9 )
%   + 10^{-16}(     - \#2 \cdot \#9 ).
%   \end{align*}
%   The factors of $10$ come from the fact that
%   $Q\sb{i} = 10\cdot 10^4 \cdot \#1 + \#2$. As usual, to combine
%   all the terms, we need to choose some shifts which must ensure
%   that the number of digits of the second, third, and fourth terms
%   are each fixed. Here, a good choice is $2\cdot 10^9$.
%   We are flirting with \TeX{}'s limits once more.
%
%   If $\#1=0$, then each term in parentheses (omitting the first)
%   is in the open interval $(-10^9, 10^4)$. Thus, adding
%   $2\cdot 10^9$ to it gives a $10$ digits number.\footnote{Bruno:
%     check that the carry from below does not screw that up. This
%   requires slightly tighter bounds.}
%
%   If $\#1=1$, then $\#2 < 7.8 \cdot 10^4$, and each term
%   in parentheses (omitting the first) is in the interval
%   $(-8\cdot 10^8, 10^4)$, and we are even safer.
%
%   We add the terms containing $\#1$ in a slightly tricky way
%   for efficiency reasons: if $\#1=0$, no need to do any computation,
%   while if $\#1=1$ we want $10$ times some number, simply obtained
%   by appending a $0$ digit.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_calc:Nwwnnnnnn 1#1#2; #3;#4#5 #6#7#8#9
  {
    1 #1 #2 \exp_after:wN ;
    \int_use:N \int_eval:w
      - 200000 + #3 - #2 * #6
      \if_meaning:w 1 #1
        - #6#70
      \fi:
      +
      \exp_after:wN \fp_basics_div_mantissa_calc_last:NNNNNN
      \int_use:N \int_eval:w
        1999800000 + #4 - #2*#7
        \if_meaning:w 1 #1
          - #80
        \fi:
        +
        \exp_after:wN \fp_basics_div_mantissa_calc_pack:NNNNNNw
        \int_use:N \int_eval:w
          1999800000 + #5 - #2*#8
          \if_meaning:w 1 #1
            - #90
          \fi:
          +
          \exp_after:wN \fp_basics_div_mantissa_calc_pack:NNNNNNw
          \int_use:N \int_eval:w 2000000000 - #2*#9 ;
    {#6}{#7}{#8}{#9}
  }
\cs_new:Npn \fp_basics_div_mantissa_calc_pack:NNNNNNw #1#2#3#4#5#6 #7;
  { #1#2#3#4#5#6 ; {#7} }
\cs_new:Npn \fp_basics_div_mantissa_calc_last:NNNNNN #1#2#3#4#5#6
  { #1#2#3#4#5#6 \int_eval_end: }
%    \end{macrocode}
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_iii:www} \meta{y} |;| \meta{$10^6+{}$Q1} |;|
%     ~~\meta{B1} \meta{B2} |;| \Arg{B_3} \Arg{B_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_iii:www #1; #2; #3;
  {
    \exp_after:wN \fp_basics_div_mantissa_iii_after:w
    \int_use:N \int_eval:w #2
      \exp_after:wN \fp_basics_div_mantissa_iv:www
      \int_value:w #1 \exp_after:wN ;
      \int_value:w
        \exp_after:wN \fp_basics_div_mantissa_calc:Nwwnnnnnn
        \int_use:N \int_eval:w #30/#1 + 999999 ;
        #3 ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_iv:www} \meta{y} |;| \meta{$10^6+{}$Q2} |;|
%     ~~\meta{C1} \meta{C2} |;| \Arg{C_3} \Arg{C_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_iv:www #1; #2; #3;
  {
    \exp_after:wN \fp_basics_div_mantissa_pack:NNNw
    \int_use:N \int_eval:w #2
      \exp_after:wN \fp_basics_div_mantissa_v:www
      \int_value:w #1 \exp_after:wN ;
      \int_value:w
        \exp_after:wN \fp_basics_div_mantissa_calc:Nwwnnnnnn
        \int_use:N \int_eval:w #30/#1 + 999999 ;
        #3 ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_v:www} \meta{y} |;| \meta{$10^6+{}$Q3} |;|
%     ~~\meta{D1} \meta{D2} |;| \Arg{D_3} \Arg{D_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_v:www #1; #2; #3;
  {
    \exp_after:wN \fp_basics_div_mantissa_pack:NNNw
    \int_use:N \int_eval:w #2
      \exp_after:wN \fp_basics_div_mantissa_vi:wwnnnn
      \int_value:w
        \exp_after:wN \fp_basics_div_mantissa_calc:Nwwnnnnnn
        \int_use:N \int_eval:w #30/#1 + 999999 ;
        #3 ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_vi:wwnnnn} \meta{$10^6+{}$Q4} |;|
%     ~~\meta{E1} \meta{E2} |;| \Arg{E_3} \Arg{E_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   We compute $P$ by rounding $2 E\sb{1} E\sb{2}/Z\sb{1}Z\sb{2}$.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_vi:wwnnnn #1; #2;#3#4 #5#6
  {
    \exp_after:wN \fp_basics_div_mantissa_pack:NNNw
    \int_use:N \int_eval:w #10
      \exp_after:wN \fp_basics_div_mantissa_vii:wwnnnnnn
      \int_use:N \int_eval:w (\c_two*#2)/#5#6 ; % <- P
      #2;{#3}{#4}
      {#5}{#6}
  }
%    \end{macrocode}
%   Note that we used |#10| instead of |#2| which we had previously.
%   Two reasons: firstly, since we dropped $y$, the argument which
%   holds $Q\sb{i}$ has changed, and secondly, we will want the
%   fourth piece of the result to have $5$ digits, including the
%   \meta{rounding} digit, which we shall compute now from $P$.
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_vii:wwnnnnnn} \meta{P} |;|
%     ~~\meta{E1} \meta{E2} |;| \Arg{E_3} \Arg{E_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   Then compute $2E-PZ$. Once more, we need to be careful and show
%   that the calculation $\#1\cdot\#5\#6$ below does not cause an
%   overflow: naively, $P$ can be up to $35$, and $\#5\#6$ up to
%   $10^8$, but both cannot happen simultaneously. To show that things
%   are fine, we split in two (non-disjoint) cases.
%   \begin{itemize}
%   \item For small $P$, say, $P< 10$, the product obeys
%     $P\cdot\#5\#6 < 10^8 \cdot P < 10^9 $.
%   \item For large $P$, say, $P\geq 3$, the rounding error on $P$,
%     which is at most $1$, is less than a factor of $2$, hence
%     $P\leq 4E/Z$, and $P\cdot \#5\#6 \leq 4E\cdot 10^8 < 10^9$.
%   \end{itemize}
%   Both inequalities could be made tighter if needed.
%
%   Note however that $P\cdot \#7\#8$ may overflow,
%   since the two factors are now independent, and the result may reach
%   $3.5\cdot 10^9$.
%
%   Also, we add $10\cdot P/2$ to the \enquote{fourth piece} of the result
%   as a first estimate of $10$ times $E/Z$. The goal is that the last digit
%   (for now $0$ or $5$) should be the \meta{rounding} digit. More precisely,
%   it will be corrected later by adding or subtracting $1$ depending on
%   whether $F$ was the correct integer part, or an overestimate (and nothing
%   is added when the quotient was exact). This does not give the
%   \enquote{correct} \meta{rounding} digit, but it always gives a digit
%   in the right \enquote{class} ($0$, $[1,4]$, $5$, or $[6-9]$), enough
%   for rounding purposes.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_vii:wwnnnnnn #1; #2;#3#4 #5#6#7#8
  {
    + \c_five * #1
    \exp_after:wN \fp_basics_div_mantissa_ix:Nww
    \int_use:N \int_eval:w -20 + 2*#2 - #1*#5#6 +
      \exp_after:wN \fp_basics_div_mantissa_viii:NNw
      \int_use:N \int_eval:w 199980 + 2*#3 - #1*#7 +
        \exp_after:wN \fp_basics_div_mantissa_viii:NNw
        \int_use:N \int_eval:w 200000 + 2*#4 - #1*#8 ; ;
  }
\cs_new:Npn \fp_basics_div_mantissa_viii:NNw #1#2#3; { #1#2 ; + #3 }
%    \end{macrocode}
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_ix:Nww}
%     ~~\meta{F1} \meta{F2} |;| |+| \meta{F3} |+| \meta{F4} |;| \meta{sign}
%   \end{quote}
%   where $F=2E-PZ$. We only need to know whether it is positive,
%   negative, or exactly zero.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_ix:Nww #1#2;#3;
  {
    \if_meaning:w 0 #1
      \exp_after:wN \fp_basics_div_mantissa_x:w
      \int_use:N \int_eval:w #3
    \else:
      \if_meaning:w - #1
        -
      \else:
        +
      \fi:
      \c_one
    \fi:
    ;
  }
\cs_new:Npn \fp_basics_div_mantissa_x:w #1;
  {
    \if_num:w #1 > \c_zero
      + \c_one
    \fi:
    ;
  }
%    \end{macrocode}
%   We now obtain the following code, where \TeX{} is in the process
%   of expanding each of the integer expressions, and thus expands
%   the function at the bottom before the ones above it.
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_iii_after:w}  $10^6 + Q\sb{1}$
%     \cs{fp_basics_div_mantissa_pack:NNNw} $10^6 + Q\sb{2}$
%     \cs{fp_basics_div_mantissa_pack:NNNw} $10^6 + Q\sb{3}$
%     \cs{fp_basics_div_mantissa_pack:NNNw}
%     $10^7 + 10\cdot Q\sb{4} + 5 \cdot P + \varepsilon$ |;| \meta{sign}
%   \end{quote}
%   Here, $\varepsilon$ is $0$ in case $2E=PZ$ (\emph{i.e.}, $F=0$),
%   $1$ in case $2E>PZ$, which means that $P$ was the correct value,
%   but not with an exact quotient, and $-1$ if $2E<PZ$, \emph{i.e.},
%   $P$ was an overestimate.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_pack:NNNw 1 #1 #2 #3;
  { + #1 #2 ; #3 ; }
%    \end{macrocode}
%   Once those have been expanded, we get
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_iii_after:w} |1| |0| \meta{5d} |;|
%     ~~\meta{4d} |;| \meta{4d} |;| \meta{5d} |;| \meta{sign}
%   \end{quote}
%   The reason we know that the first two digits are |1| and |0|
%   is that the final result is known to be between $0.1$ (inclusive)
%   and $10$, hence $\widetilde{Q\sb{1}}$ (the tilde denoting the
%   contribution from the other $Q\sb{i}$) is at most $99999$,
%   and $10^6+\widetilde{Q\sb{1}} = 10\cdots$.
%
%   It is now time to round. This depends on how many digits
%   the final result will have.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_iii_after:w 10 #1
  {
    \if_meaning:w 0 #1
      \exp_after:wN \fp_basics_div_mantissa_small:wwwNNNNwN
    \else:
      \exp_after:wN \fp_basics_div_mantissa_large:wwwNNNNwN
    \fi:
    #1
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_small:wwwNNNNwN} |0| \meta{4d} |;|
%     ~~\meta{4d} |;| \meta{4d} |;| \meta{5d} |;| \meta{sign}
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_small:wwwNNNNwN
    0 #1; #2; #3; #4#5#6#7#8; #9
  {
    \exp_after:wN \fp_basics_aux_pack_high:NNNNNw
    \int_use:N \int_eval:w 1 #1#2
      \exp_after:wN \fp_basics_aux_pack_low:NNNNNw
      \int_use:N \int_eval:w 1 #3#4#5#6#7
        + \fp_aux_round:NNN #9 #7 #8
        \exp_after:wN ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{fp_basics_div_mantissa_large:wwwNNNNwN} \meta{5d} |;|
%     ~~\meta{4d} |;| \meta{4d} |;| \meta{5d} |;| \meta{sign}
%   \end{quote}
%   \footnote{Bruno: rename the \enquote{add mantissa carry pack} function.}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_div_mantissa_large:wwwNNNNwN
    #1; #2; #3; #4#5#6#7#8; #9
  {
    + \c_one
    \exp_after:wN \fp_basics_div_mantissa_large_pack:NNNNNNNNw
    \int_use:N \int_eval:w 1 #1 #2 %<- 1+9d
      \exp_after:wN \fp_basics_add_mantissa_carry_pack_ii:NNNNw
      \int_use:N \int_eval:w 1 #3 #4 #5 #6
        + \fp_aux_round:NNNN #9 #6 #7 #8
        \exp_after:wN ;
  }
\cs_new:Npn \fp_basics_div_mantissa_large_pack:NNNNNNNNw
    1 #1#2#3#4 #5#6#7#8 #9; { ; {#1#2#3#4} {#5#6#7#8} {#9} }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Remainder}
%
% This is an exact operation. It is based on the same ideas as division,
% with some extra exponent check. Also, we need to add some more testing
% here and there to avoid overflow: contrarily to division, there is no
% limit on how many divide-and-subtract steps there can be.
%
% \subsubsection{Signs, and special numbers}
%
% The operands are given to us backwards. In the following we compute
% \meta{A} \texttt{REM} \meta{Z}, remainder of \meta{A} when divided
% by \meta{Z}. The result must be exact, and is not affected by the
% rounding mode.
%
% \begin{macro}[EXP,aux]{\fp_basics_rem_back_cases:NN}
%   \begin{syntax}
%     \cs{fp_basics_rem_back_cases:NN} \meta{case Z} \meta{case A}
%     ~~\meta{sign Z} \meta{sign A} \meta{body Z} |;| \meta{body A} |;|
%   \end{syntax}
%   \meta{case Z} and \meta{case A} can each be $0$ (for zeroes),
%   $1$ (for normal numbers), $2$ (for infinities) or $3$ (for nans).
%   The complicated \cs{int_eval:w} ends before \cs{c_minus_one} in
%   almost all cases, because this immediately follows another integer.
%   The only exception is when both numbers are normal, in which case
%   neither internal \cs{if_case:w} statements gives anything, and
%   \cs{c_minus_one} is added, yielding an \enquote{outer} case of $0$.
%   The rest of the table is simply an addition.
%   \begin{center}
%     \begin{tabular}{c|cccc}
%       Z\textbackslash A
%         & 0 & 1 & 2 & 3  \\ \hline
%       0 & 2 & 2 & 3 & 5 \\
%       1 & 1 & * & 2 & 4 \\
%       2 & 1 & 1 & 2 & 4 \\
%       3 & 4 & 4 & 5 & 7
%     \end{tabular}
%   \end{center}
%   This allows us to distinguish between (0) normal numbers,
%   (1) a zero result, (2--3) invalid: \meta{A} is infinity
%   or \meta{Z} is zero, (\textgreater 3) one of the operands is nan.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_rem_back_cases:NN #1 #2
  {
    \if_case:w \int_eval:w
                 \c_one
                 +
                 \if_case:w #1 \exp_stop_f:
                      \c_one
                 \or:
                 \or: \c_zero
                 \or: \c_three
                 \fi:
                 \if_case:w #2 \exp_stop_f:
                      + \c_zero
                 \or:
                 \or: + \c_one
                 \or: + \c_three
                 \fi:
                 \c_minus_one
               \int_eval_end:
         \exp_after:wN \fp_basics_rem_back_normal:wNNnwnw
    \or: \exp_after:wN \fp_basics_rem_return_zero:NNNNww
    \or: \exp_after:wN \fp_basics_rem_snan:NNNNww
    \or: \exp_after:wN \fp_basics_rem_snan:NNNNww
    \else:
      \exp_after:wN \fp_basics_return_nan:NNNNww
    \fi:
    #1 #2
  }
\cs_new:Npn \fp_basics_rem_return_zero:NNNNww #1#2 #3#4 #5; #6;
  { \exp_after:wN \fp_aux_zero_fp:N \exp_after:wN #4 }
\cs_new:Npn \fp_basics_rem_snan:NNNNww #1#2 #3#4 #5; #6;
  {
    \exp_after:wN \fp_aux_snan_fp:N
    \cs:w fp_info: ~ %
      rem ( \fp_to_tl:w \s_fp \fp_use:w #2#4#6; , ~ %
            \fp_to_tl:w \s_fp \fp_use:w #1#3#5; ) ;
      \exp_after:wN
    \cs_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Normal (backwards) remainder}
%
% In this subsection, we perform the remainder operation.
% Given \meta{Z} and \meta{A}, find the remainder
% of $\meta{A}/\meta{Z}$.
%
% \begin{macro}{\fp_basics_rem_back_normal:wNNnwnw}
%   \begin{syntax}
%     \cs{fp_basics_rem_back_normal:wNNnwnw}
%     ~~\texttt{1} \texttt{1} \meta{sign Z} \meta{sign A}
%     ~~\Arg{exp Z} \meta{body Z} |;|
%     ~~\Arg{exp A} \meta{body A} |;|
%   \end{syntax}
%   The sign of \meta{Z} is ignored. Since there is no rounding,
%   we only need to keep the sign of \meta{A} and multiply at the
%   end (no need to know in advance the sign of the final result).
%   If \meta{A} is much smaller than \meta{Z}, nothing has to be done.
%   If \meta{A} is much bigger than \meta{Z}, however, we need to calculate.
%   And the calculations are messier than for division: since there can
%   be arbitrary many divide-and-subtract steps, the bounds that we
%   could prove for division do not hold anymore, and we cannot shift
%   by $4$ at each step. Rather, we shift by $2$, but still work with
%   blocks of $4$ most of the time.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_rem_back_normal:wNNnwnw 1 1 #1#2 #3 #4; #5
  {
    \if_num:w #3 > #5 \exp_stop_f:
      \exp_after:wN \fp_basics_rem_back_big_i:Nnwnw
    \else:
      \exp_after:wN \fp_basics_rem_back_sanitize:wN
      \int_use:N \int_eval:w #3
        \exp_after:wN \fp_basics_rem_back_big_ii:wNnwnw
        \int_use:N \int_eval:w #5 - #3 + \c_one \exp_after:wN ;
    \fi:
    #2 {#3} #4; {#5}
  }
\cs_new:Npn \fp_basics_rem_back_big_i:Nnwnw #1 #2;
  { \fp_aux_exp_after_fp:wN \s_fp \fp_use:w 1 #1 }
%    \end{macrocode}
% Initially, shift \meta{A} by $1$ if the difference |#1| in exponents
% is odd. The trailing zero after |#9| is discarded later or not.
% We revisite the good ol' \cs{romannumeral} $\meta{integer}\times 1000$
% method to get a number of characters equal to \emph{half} of the
% difference in exponents. Note that the representation of $2500$
% for instance in roman numerals is \texttt{mmd}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_rem_back_big_ii:wNnwnw #1; #2 #3 #4; #5 #6#7#8#9;
  {
        \exp_after:wN \fp_basics_rem_back_pre_pack:www
        \int_value:w 1
          \if_int_odd:w \int_eval:w #1 \int_eval_end:
            0
          \fi:
          #6
          \exp_after:wN \fp_aux_use_none_stop_f:N
          \int_value:w 1 #7 #8
            \exp_after:wN \fp_aux_use_none_stop_f:N
            \int_value:w 1 #9 0
              \exp_after:wN \fp_aux_use_none_semicolon:N
              \int_to_roman:w \int_eval:w #1*500 \int_eval_end:
              { \fi: \fp_basics_rem_back_break:w } #2 ;
        #4 ;
  }
\cs_new:Npn \fp_aux_use_none_stop_f:N    #1 { ~ }
\cs_new:Npn \fp_aux_use_none_semicolon:N #1 { ; }
%    \end{macrocode}
%   We'll (roughly) divide the
%   first block of \meta{A} by the first block of \meta{Z} to get a
%   piece \meta{Q1} of the quotient. Then subtract
%   $\meta{Q1}\times\meta{Z}$ from \meta{A}. This should yield a
%   result roughly $100$ times smaller (\emph{i.e.}, shifted by
%   $2$ positions) for use as \meta{A}, and we can continue.
%   End when reaching the weird construction \cs{fi:}
%   \cs{fp_basics_rem_back_break:w}.
% \end{macro}
%
% \begin{macro}[EXP]{\fp_basics_rem_back_pre_pack:www}
%   \begin{syntax}
%     \cs{fp_basics_rem_back_pre_pack:www} \texttt{1}
%     ~~\meta{shifted A} \texttt{;}
%     ~~\texttt{m\ldots d} \Arg{break code} \meta{sign A} \texttt{;}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \texttt{;}
%   \end{syntax}
%   Here \meta{shifted A} has $17$ or $18$ digits, the last one $0$,
%   and they should be stored in blocks of $4$ digits, except the first
%   one, which should be $5$ digits. This time, we'll separate blocks
%   of \meta{shifted A} with blank spaces, but \meta{Z} is
%   still stored as four braced groups.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_rem_back_pre_pack:www 1 #1#2#3#4#5 #6#7#8#9
  { \fp_basics_rem_back_pre_pack_ii:nNNNNNNNN { #1#2#3#4#5 ~ #6#7#8#9 } }
\cs_new:Npn \fp_basics_rem_back_pre_pack_ii:nNNNNNNNN #1 #2#3#4#5 #6#7#8#9
  { \fp_basics_rem_back_pre_pack_iii:nwww { #1 ~ #2#3#4#5 ~ #6#7#8#9} }
\cs_new:Npn \fp_basics_rem_back_pre_pack_iii:nwww #1 #2; #3; #4;
  { \fp_basics_rem_mantissa_loop:wwn #1 ; #4 ; #3 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_basics_rem_mantissa_loop:wwn}
%   \begin{syntax}
%     \cs{fp_basics_rem_mantissa_loop:wwn}
%     ~~\meta{A'1} \verb*+ + \meta{A'2} \verb*+ + \meta{A'3} \verb*+ + \meta{A'4} \texttt{;}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \texttt{;}
%     ~~\texttt{m\ldots} \Arg{break code} \meta{sign A}
%   \end{syntax}
%   Initially, $-10^5<\meta{A'1}<10^5$, while the other blocks are exactly
%   $4$ digits. Below, we remove the space between \meta{A'2} and \meta{A'3}
%   so that \cs{fp_basics_rem_mantissa_loop_ii:wwwwnnnnN} only has $9$
%   arguments.
%   Compute the quotient of \meta{A'1} by $\meta{Z1}$\footnote{Bruno: $+1/2$?},
%   and subtract that many times \meta{Z} from \meta{A'},
%   then shift by two digits.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_rem_mantissa_loop:wwn #1 ~ #2 ~ #3; #4
  {
    \exp_after:wN \fp_basics_rem_mantissa_loop_ii:wwwwnnnnN
    \int_use:N \int_eval:w #1 / #4 ;
    #1 ~ #2#3 ;
    {#4}
  }
\cs_new:Npn \fp_basics_rem_mantissa_loop_ii:wwwwnnnnN
    #1; #2 ~ #3 ~ #4; #5#6#7#8; #9
  {
    \if_false: #9 #1 \fi: % to end the loop.
    \exp_after:wN \fp_basics_rem_mantissa_loop:wwn
    \int_use:N \int_eval:w
      (- 2 0000 + #2 - #1*#5)*100 +
      \exp_after:wN \fp_basics_rem_mantissa_pack_last:NNNNNNNw
      \int_use:N \int_eval:w
        1 9998 0000 - #1*#6 +
        \exp_after:wN \fp_basics_rem_mantissa_pack:NNNNNNNw
        \int_use:N \int_eval:w
          1 9998 0000 + #3 - #1*#7 +
          \exp_after:wN \fp_basics_rem_mantissa_pack:NNNNNNNw
          \int_use:N \int_eval:w
            2 0000 0000 + #4 - #1*#8
          \int_eval_end:
          00 ;;
    {#5}{#6}{#7}{#8};
  } % <9d>;{<4d>}{<4d>}{<4d>};;{<4d>}{<4d>}{<4d>}{<4d>};
\cs_new:Npn \fp_basics_rem_mantissa_pack:NNNNNNNw #1#2#3 #4#5#6#7 #8;
  {
    % \fp_trace_assert:nn {#8} {\d\d\d\d}
    #1#2#3 #4#5 \int_eval_end: #6#7 ; ~ #8
  }
\cs_new:Npx \fp_basics_rem_mantissa_pack_last:NNNNNNNw #1#2#3 #4#5#6#7 #8;
  { #1#2#3 #4#5#6#7 \int_eval_end: \c_space_tl #8 }
 % \cs_new:Npn \fp_basics_rem_mantissa_loop_half:NNNNNNNwn #1#2#3#4#5#6#7 #8;; #9
 %   { % 7*<1d> (<2d>;{<4d>}{<4d>}{<4d>};;) (<4d>)
 %     \exp_after:wN \fp_basics_rem_mantissa_loop_half_ii:wwnnwnnnn
 %     \int_use:N \int_eval:w
 %       ( - 5 0000 00 + #1#2#3#4#5#6#7 ) / #9
 %       \exp_after:wN ;
 %       \int_use:N \int_eval:w - 5 0000 0000 +
 %         #1 #2#3#4#5 #6#7 #8 ; %^^A #8 is horrible!
 %     {#9}
 %   } % <quot>;<~8d>;{<4d>}{<4d>}{<4d>};{<4d>}{<4d>}{<4d>}{<4d>};
 % \cs_new:Npn \fp_basics_rem_mantissa_loop_half_ii:wwnnwnnnn
 %     #1; #2; #3#4#5; #6#7#8#9;
 %   {
 %     \exp_after:wN \fp_basics_rem_mantissa_loop:wnnwn
 %     \int_use:N \int_eval:w - 20 0000
 %       + #2 - #1*#6 + \exp_after:wN \fp_basics_rem_mantissa_pack:NNNNNNw
 %       \int_use:N \int_eval:w 19 9980 0000
 %         + #3 - #1*#7 + \exp_after:wN \fp_basics_rem_mantissa_pack:NNNNNNw
 %         \int_use:N \int_eval:w 19 9980 0000
 %           + #4 - #1*#8 + \exp_after:wN \fp_basics_rem_mantissa_pack:NNNNNNw
 %           \int_use:N \int_eval:w 20 0000 0000
 %             + #5 - #1*#9 ; ;
 %     {#6}{#7}{#8}{#9};
 %   }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fp_basics_rem_back_break:w}
%   \begin{syntax}
%     \cs{fp_basics_rem_back_break:w} \meta{last quotient} \cs{fi:}
%     ~~\cs{exp_after:wN} \cs{fp_basics_rem_mantissa_loop:wnnwn}
%     ~~\meta{calculation} |;| \Arg{junk} |;|
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} |;| \meta{sign A}
%   \end{syntax}
%   Get rid of the first three tokens, and perform the calculation.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_rem_back_break:w
    #1 \fi: \exp_after:wN \fp_basics_rem_mantissa_loop:wwn
  {
    \exp_after:wN \fp_basics_rem_back_result_sign:Nwnnw
  }
%    \end{macrocode}
%   After expanding the computation, we get
%   \begin{syntax}
%     \cs{fp_basics_rem_back_result_sign:w}
%     ~~\meta{A'1} \texttt{;} \Arg{A'2} \Arg{A'3} \Arg{junk} \texttt{;}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} |;| \meta{sign A}
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_rem_back_result_sign:N #1
  {
    \if_meaning:w - #1
      \exp_after:wN \fp_basics_rem_back_result_neg:w
      \int_use:N \int_eval:w -
    \else:
      \exp_after:wN \fp_basics_rem_back_result_pos:w
      \int_use:N \int_eval:w
    \fi:
    100000000 + #1
  }
% \cs_new:Npn \fp_basics_rem_back_result_pos:w 1 #1#2#3#4 #5#6#7#8;
%   { \fp_basics_rem_back_result_pos_ii:nnnnw {#1#2#3#4} {#5#6#7#8} }
% % \cs_new:Npn \fp_basics_rem_back_result_pos_ii:nnnnw #1#2#3#4 #5; #6#7#8#9;
% %   {

%  % \cs_new:Npn \fp_basics_rem_back_result_neg:w -1 #1#2#3#4 #5#6#7#8;
%  %   {
%  %     \int_use:N \int_eval:w
%  %       100000000 +
%  %       #1#2;
%  %       #3#4;
%  %   }
% \cs_new:Npn \fp_basics_rem_back_result_pos:w 1#1#2#3#4#5#6#7#8;
% \cs_new:Npn \fp_basics_rem_back_result_neg:w - #1;
%   {
% %   of the form \meta{$\leq$ 7d} |;| \meta{9d} |;| to
% %   \cs{fp_basics_sub_back_carry_aux:wwN}. The result is always exact.

%     \if_num:w #1 < \c_zero
%       \fp_basics_rem_back
%     ;
%     %; {#1}{#2}{#3} ;
%   }
%    \end{macrocode}
% ^^A here
% in blocks of 4, placing
%   them \emph{after} the semicolon.
%   We want to compute the remainder of $A/Z$. Checking for underflow and
%   overflow is done using the same auxiliary as for multiplication.
%   As explained just below, we first compute $y$, which is
%   the $5$ first digits of $Z$, plus $1$, and then compute pieces
%   of the quotient roughly $4$ digits at a time. Here, |#1| is
%   a single digit, |#2| and |#7| are the exponents (integers),
%   |#8| is three brace groups, and all others are each $4$ digits.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_rem_back_npos:Nnwnw #1 #2 #3#4#5#6; #7 #8;
  {
    \exp_after:wN \fp_basics_mul_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \int_eval:w
      #7 - #2
      \fp_basics_rem_mantissa_i:wNwnn #3; #4;
      #8 {#3}{#4}{#5}{#6} #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Unary operations}
%
% \begin{macro}{\fp_neg:w}
%   This function flips the sign of the \meta{floating point}
%   and expands after it in the input stream, just like
%   \cs{fp_add:ww} etc.
%    \begin{macrocode}
\cs_new:Npn \fp_neg:w \s_fp \fp_use:w #1 #2
  {
    \exp_after:wN \fp_aux_exp_after_fp:wN
    \exp_after:wN \s_fp
    \exp_after:wN \fp_use:w
    \exp_after:wN #1
    \int_use:N \int_eval:w \c_two - #2 \int_eval_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_abs:w}
%   This function sets the sign of the \meta{floating point} to be
%   positive, and expands after itself in the input stream, just like
%   \cs{fp_neg:ww}.
%    \begin{macrocode}
\cs_new:Npn \fp_abs:w \s_fp \fp_use:w #1 #2
  { \fp_aux_exp_after_fp:wN \s_fp \fp_use:w #1 0 }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex