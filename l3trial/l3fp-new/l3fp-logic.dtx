% \iffalse meta-comment
%
%% File: l3fp-logic.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{l3fp-new}
\GetIdInfo$Id: l3fp-logic.dtx 3504 2012-03-06 06:38:45Z bruno $
  {L3 Experimental floating-point arithmetic}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\usepackage{l3fp-new}
\begin{document}
  \tableofcontents
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-logic} package\thanks{This file
%         has version number \ExplFileVersion, last
%         revised \ExplFileDate.}\\
% Floating point expressions}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{Implementation}
%
%   We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%<*initex|package>
%    \end{macrocode}
%
% \subsection{Comparison}
%
% \begin{macro}[int, EXP]{\fp_compare:ww}
% \begin{macro}[aux, EXP]
%   {
%     \fp_compare_nan:w, \fp_compare_mantissa:ww,
%     \fp_compare_mantissa:nnnnnnnn
%   }
%   \begin{syntax}
%     \cs{fp_compare:ww} \meta{X} |;| \meta{Y} |;|
%   \end{syntax}
%   Expands (in the same way as \cs{int_eval:n}) to $-1$ if $x<y$, $0$
%   if $x=y$, $1$ if $x>y$, and $2$ otherwise (denoted as $x?y$).  A
%   trick that will later be useful is that the character codes of |<|,
%   |=|, |>| and |?| are contiguous, and in the same order as the return
%   codes of \cs{fp_compare:ww}.
%    \begin{macrocode}
\cs_new:Npn \fp_compare:ww \s_fp \fp_use:w #1#2#3; \s_fp \fp_use:w #4#5#6;
  {
    \int_value:w
      \if_meaning:w 3 #1 \exp_after:wN \fp_compare_nan:w \fi:
      \if_meaning:w 3 #4 \exp_after:wN \fp_compare_nan:w \fi:
      \if_meaning:w 2 #2 - \fi:
      \if_meaning:w #2 #5
        \if_meaning:w #1 #4
          \if_meaning:w 1 #1
            \fp_compare_mantissa:ww #3; #6;
          \else:
            0
          \fi:
        \else:
          \if_int_compare:w #1 < #4 - \fi: 1
        \fi:
      \else:
        \if_meaning:w 0 #1
          \if_meaning:w 0 #4
            0
          \else:
            1
          \fi:
        \else:
          1
        \fi:
      \fi:
    \exp_stop_f:
  }
\cs_new:Npn \fp_compare_nan:w #1 \exp_stop_f: { \c_two }
\cs_new:Npn \fp_compare_mantissa:ww #1#2; #3#4;
  {
    \if_int_compare:w #1 = #3 \exp_stop_f:
      \fp_compare_mantissa:nnnnnnnn #2 #4
    \else:
      \if_int_compare:w #1 < #3 - \fi: 1
    \fi:
  }
\cs_new:Npn \fp_compare_mantissa:nnnnnnnn #1#2#3#4#5#6#7#8
  {
    \if_int_compare:w #1 = #5 \exp_stop_f:
      \if_int_compare:w #2 = #6 \exp_stop_f:
        \if_int_compare:w #3 = #7 \exp_stop_f:
          \if_int_compare:w #4 = #8 \exp_stop_f:
            0
          \else:
            \if_int_compare:w #4 < #8 - \fi: 1
          \fi:
        \else:
          \if_int_compare:w #3 < #7 - \fi: 1
        \fi:
      \else:
        \if_int_compare:w #2 < #6 - \fi: 1
      \fi:
    \else:
      \if_int_compare:w #1 < #5 - \fi: 1
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF, EXP]{\fp_compare:nNn}
% \begin{macro}[aux, EXP]{\fp_compare_aux:wn}
%   Evaluate |#1| and |#3|, using an auxiliary to expand both, in the
%   correct order.  Then compare this to |`#2-`=|, which is $-1$ for
%   |<|, $0$ for |=|, $1$ for |>| and $2$ for |?|.
%    \begin{macrocode}
\prg_new_conditional:Npnn \fp_compare:nNn #1#2#3 { p , T , F , TF }
  {
    \if_int_compare:w
        \exp_after:wN \fp_compare_aux:wn
          \tex_romannumeral:D -`0 \fp_parse:n {#3} {#1}
        = \int_eval:w `#2 - `= \int_eval_end:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\cs_new:Npn \fp_compare_aux:wn #1; #2
  {
    \exp_after:wN \fp_compare:ww
      \tex_romannumeral:D -`0 \fp_parse:n {#2} #1;
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\fp_compare:n}
% \begin{macro}[aux,EXP]{\fp_compare_aux:w}
%   For floating points the comparison operators are treated as
%   operations, so we simply evaluate then compare with \cs{c_zero_fp}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \fp_compare:n #1 { p , T , F , TF }
  {
    \exp_after:wN \fp_compare_aux:w
    \tex_romannumeral:D -`0 \fp_parse:n {#1}
  }
\cs_new:Npn \fp_compare_aux:w \s_fp \fp_use:w #1#2;
  {
    \if_meaning:w 0 #1
      \prg_return_false:
    \else:
      \prg_return_true:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Boolean operations}
%
% \begin{macro}[int, EXP]{\fp_not:w}
%   Return \texttt{true} or \texttt{false}, with two expansions, one to
%   exit the conditional, and one to please \pkg{l3fp-parse}.
%    \begin{macrocode}
\cs_new:Npn \fp_not:w \s_fp \fp_use:w #1#2;
  {
    \if_meaning:w 0 #1
      \exp_after:wN \exp_after:wN \exp_after:wN \c_true_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_false_fp
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\fp_and:ww, \fp_or:ww}
% \begin{macro}[aux, EXP]{\fp_and_return:wNw}
%   For \texttt{and}, if the first number is zero, return it (with the
%   same sign).  Otherwise, return the second one.  For \texttt{or}, the
%   logic is reversed: if the first number is non-zero, return it,
%   otherwise return the second number: we achieve that by hi-jacking
%   \cs{fp_and:ww}, inserting an extra argument, \cs{else:}, before
%   \cs{s_fp}.  In all cases, expand after the floating point number.
%    \begin{macrocode}
\cs_new:Npn \fp_and:ww #1 \s_fp \fp_use:w #2#3;
  {
    \if_meaning:w 0 #2 #1
      \fp_and_return:wNw \s_fp \fp_use:w #2#3;
    \fi:
    \fp_aux_exp_after_fp:wN
  }
\cs_new_nopar:Npn \fp_or:ww { \fp_and:ww \else: }
\cs_new:Npn \fp_and_return:wNw #1; \fi: #2#3; { \fi: #2 #1; }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, EXP]{\fp_ternary_i:ww, \fp_ternary_default:ww}
%   The first function receives the test and the true branch of the |?:|
%   ternary operator.  It returns the true branch, unless the test
%   branch is zero.  In that case, the function returns a very specific
%   \texttt{nan}.  The second function receives the output of the first
%   function, and the false branch.  It returns the previous input,
%   unless that is the special \texttt{nan}, in which case we return the
%   false branch.
%    \begin{macrocode}
\cs_new:Npn \fp_ternary_i:ww
    \s_fp \fp_use:w #1#2; #3; \tex_romannumeral:D -`0 #4#5
  {
    \if_meaning:w 0 #1
      \fp_and_return:wNw \s_fp \fp_use:w 31 \fp_aux_info_ternary: ;
    \fi:
    \fp_aux_exp_after_fp:wN #3; % fp1; F <tern> fp2; \infix_<next> fp3;
    \tex_romannumeral:D -`0
        \exp_after:wN \c_false_bool
        \exp_after:wN \fp_ternary_default:ww
        \tex_romannumeral:D -`0
        \fp_parse_uo:Nw \c_two
        \fp_aux_expand:w
    \if_meaning:w \fp_parse_infix_::N #4 \else:
      \msg_expandable_error:n { Missing~':'~clause~for~'?:'. }
      % somehow put #4
    \fi:
  }
\cs_new:Npn \fp_ternary_default:ww #1; #2;
  {
    \str_if_eq:nnTF {#1} { \s_fp \fp_use:w 3 1 \fp_aux_info_ternary: }
      { \fp_aux_exp_after_fp:wN #2; }
      { \fp_aux_exp_after_fp:wN #1; }
  }
\cs_new_eq:NN \fp_aux_info_ternary: \scan_stop:
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex