% \iffalse meta-comment
%
%% File: l3fp-logic.dtx Copyright (C) 2011-2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{l3fp-new}
\GetIdInfo$Id: l3fp-logic.dtx 3504 2012-03-06 06:38:45Z bruno $
  {L3 Experimental floating-point arithmetic}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{l3fp-new}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-logic} package\thanks{This file
%         has version number \ExplFileVersion, last
%         revised \ExplFileDate.}\\
% Floating point expressions}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3fp-logic} Implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
% \subsection{Comparison}
%
% \begin{macro}[int, EXP]{\fp_compare:ww}
% \begin{macro}[aux, EXP]
%   {
%     \fp_compare_nan:w, \fp_compare_mantissa:ww,
%     \fp_compare_mantissa:nnnnnnnn
%   }
%   \begin{syntax}
%     \cs{fp_compare:ww} \meta{X} |;| \meta{Y} |;|
%   \end{syntax}
%   Expands (in the same way as \cs{int_eval:n}) to $-1$ if $x<y$, $0$
%   if $x=y$, $1$ if $x>y$, and $2$ otherwise (denoted as $x?y$).  A
%   trick that will later be useful is that the character codes of |<|,
%   |=|, |>| and |?| are contiguous, and in the same order as the return
%   codes of \cs{fp_compare:ww}.
%    \begin{macrocode}
\cs_new:Npn \fp_compare:ww \s_fp \fp_use:w #1#2#3; \s_fp \fp_use:w #4#5#6;
  {
    \int_value:w
      \if_meaning:w 3 #1 \exp_after:wN \fp_compare_nan:w \fi:
      \if_meaning:w 3 #4 \exp_after:wN \fp_compare_nan:w \fi:
      \if_meaning:w 2 #2 - \fi:
      \if_meaning:w #2 #5
        \if_meaning:w #1 #4
          \if_meaning:w 1 #1
            \fp_compare_mantissa:ww #3; #6;
          \else:
            0
          \fi:
        \else:
          \if_int_compare:w #1 < #4 - \fi: 1
        \fi:
      \else:
        \if_meaning:w 0 #1
          \if_meaning:w 0 #4
            0
          \else:
            1
          \fi:
        \else:
          1
        \fi:
      \fi:
    \exp_stop_f:
  }
\cs_new:Npn \fp_compare_nan:w #1 \exp_stop_f: { \c_two }
\cs_new:Npn \fp_compare_mantissa:ww #1#2; #3#4;
  {
    \if_int_compare:w #1 = #3 \exp_stop_f:
      \fp_compare_mantissa:nnnnnnnn #2 #4
    \else:
      \if_int_compare:w #1 < #3 - \fi: 1
    \fi:
  }
\cs_new:Npn \fp_compare_mantissa:nnnnnnnn #1#2#3#4#5#6#7#8
  {
    \if_int_compare:w #1 = #5 \exp_stop_f:
      \if_int_compare:w #2 = #6 \exp_stop_f:
        \if_int_compare:w #3 = #7 \exp_stop_f:
          \if_int_compare:w #4 = #8 \exp_stop_f:
            0
          \else:
            \if_int_compare:w #4 < #8 - \fi: 1
          \fi:
        \else:
          \if_int_compare:w #3 < #7 - \fi: 1
        \fi:
      \else:
        \if_int_compare:w #2 < #6 - \fi: 1
      \fi:
    \else:
      \if_int_compare:w #1 < #5 - \fi: 1
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF, EXP]{\fp_compare:nNn}
% \begin{macro}[aux, EXP]{\fp_compare_aux:wn}
%   Evaluate |#1| and |#3|, using an auxiliary to expand both, in the
%   correct order.  Then compare this to |`#2-`=|, which is $-1$ for
%   |<|, $0$ for |=|, $1$ for |>| and $2$ for |?|.
%    \begin{macrocode}
\prg_new_conditional:Npnn \fp_compare:nNn #1#2#3 { p , T , F , TF }
  {
    \if_int_compare:w
        \exp_after:wN \fp_compare_aux:wn
          \tex_romannumeral:D -`0 \fp_parse:n {#3} {#1}
        = \int_eval:w `#2 - `= \int_eval_end:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\cs_new:Npn \fp_compare_aux:wn #1; #2
  {
    \exp_after:wN \fp_compare:ww
      \tex_romannumeral:D -`0 \fp_parse:n {#2} #1;
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\fp_compare:n}
% \begin{macro}[aux,EXP]{\fp_compare_aux:w}
%   For floating points the comparison operators are treated as
%   operations, so we simply evaluate then compare with \cs{c_zero_fp}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \fp_compare:n #1 { p , T , F , TF }
  {
    \exp_after:wN \fp_compare_aux:w
    \tex_romannumeral:D -`0 \fp_parse:n {#1}
  }
\cs_new:Npn \fp_compare_aux:w \s_fp \fp_use:w #1#2;
  {
    \if_meaning:w 0 #1
      \prg_return_false:
    \else:
      \prg_return_true:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Boolean operations}
%
% \begin{macro}[int, EXP]{\fp_not_fp:w}
%   Return \texttt{true} or \texttt{false}, with two expansions, one to
%   exit the conditional, and one to please \pkg{l3fp-parse}.
%    \begin{macrocode}
\cs_new:Npn \fp_not_fp:w \s_fp \fp_use:w #1#2;
  {
    \if_meaning:w 0 #1
      \exp_after:wN \exp_after:wN \exp_after:wN \c_one_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_zero_fp
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]+\fp_fp_&:ww+
% \begin{macro}[int, EXP]+\fp_fp_|:ww+
% \begin{macro}[aux, EXP]{\fp_and_return:wNw}
%   For \texttt{and}, if the first number is zero, return it (with the
%   same sign).  Otherwise, return the second one.  For \texttt{or}, the
%   logic is reversed: if the first number is non-zero, return it,
%   otherwise return the second number: we achieve that by hi-jacking
%   \cs{fp_fp_and:ww}, inserting an extra argument, \cs{else:}, before
%   \cs{s_fp}.  In all cases, expand after the floating point number.
%    \begin{macrocode}
\cs_new:cpn { fp_fp_\iow_char:N \&:ww } #1 \s_fp \fp_use:w #2#3;
  {
    \if_meaning:w 0 #2 #1
      \fp_and_return:wNw \s_fp \fp_use:w #2#3;
    \fi:
    \fp_aux_exp_after_fp:wN
  }
\cs_new_nopar:cpx { fp_fp_\iow_char:N \| :ww }
  { \exp_not:c { fp_fp_\iow_char:N \& :ww } \exp_not:N \else: }
\cs_new:Npn \fp_and_return:wNw #1; \fi: #2#3; { \fi: #2 #1; }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, EXP]
%   {\fp_ternary:NwwN, \fp_ternary_i:NwwN, \fp_ternary_ii:NwwN}
%   The first function receives the test and the true branch of the |?:|
%   ternary operator.  It returns the true branch, unless the test
%   branch is zero.  In that case, the function returns a very specific
%   \texttt{nan}.  The second function receives the output of the first
%   function, and the false branch.  It returns the previous input,
%   unless that is the special \texttt{nan}, in which case we return the
%   false branch.
%^^A todo: optimize.
%    \begin{macrocode}
\cs_new:Npn \fp_ternary:NwwN #1 #2@ #3@ #4
  {
    \if_meaning:w \fp_parse_infix_::N #4
      \fp_ternary_loop:Nw
        #2
        \s_fp \fp_use:w { \fp_ternary_loop_break:w } ;
      \prg_break_point:n { \exp_after:wN \fp_ternary_i:NwwN }
      \exp_after:wN #1
      \tex_romannumeral:D -`0
      \fp_parse_exp_after_array:wf #3 \s_fp_stop
      \exp_after:wN @
      \tex_romannumeral:D
        \fp_parse_until:Nw \c_two
        \fp_parse_expand:w
    \else:
      \fp_error:n { Missing~':'~clause~for~'?:'. }
      \exp_after:wN \fp_parse_until_test:NwN
      \exp_after:wN #1
      \tex_romannumeral:D -`0
      \fp_parse_exp_after_array:wf #3 \s_fp_stop
      \exp_after:wN #4
      \exp_after:wN #1
    \fi:
  }
\cs_new:Npn \fp_ternary_loop_break:w #1 \fi: #2 \prg_break_point:n #3
  {
    \c_zero = \c_zero \fi:
    \exp_after:wN \fp_ternary_ii:NwwN
  }
\cs_new:Npn \fp_ternary_loop:Nw \s_fp \fp_use:w #1#2;
  {
    \if_num:w #1 > \c_zero
      \exp_after:wN \prg_map_break:
    \fi:
    \fp_ternary_loop:Nw
  }
\cs_new:Npn \fp_ternary_i:NwwN #1#2@#3@#4
  {
    \exp_after:wN \fp_parse_until_test:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0
    \fp_parse_exp_after_array:wf #2 \s_fp_stop
    #4 #1
  }
\cs_new:Npn \fp_ternary_ii:NwwN #1#2@#3@#4
  {
    \exp_after:wN \fp_parse_until_test:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0
    \fp_parse_exp_after_array:wf #3 \s_fp_stop
    #4 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\fp_max:w, \fp_min:w}
%    \begin{macrocode}
\cs_new:Npn \fp_max:w #1@
  {
    \exp_after:wN \fp_minmax_loop:Nww
    \exp_after:wN \c_minus_one
    \c_minus_inf_fp
    #1
    \s_fp \fp_use:w { 3 \fp_minmax_break:w } ;
  }
\cs_new:Npn \fp_min:w #1@
  {
    \exp_after:wN \fp_minmax_loop:Nww
    \exp_after:wN \c_one
    \c_inf_fp
    #1
    \s_fp \fp_use:w { 3 \fp_minmax_break:w } ;
  }
\cs_new:Npn \fp_minmax_loop:Nww
    #1 \s_fp \fp_use:w #2#3; \s_fp \fp_use:w #4#5;
  {
    \if_meaning:w 3 #4
      \if_meaning:w 3 #2
        \fp_minmax_i:ww
      \else:
        \fp_minmax_ii:ww
      \fi:
    \else:
      \if_num:w \fp_compare:ww \s_fp \fp_use:w #2#3;
                               \s_fp \fp_use:w #4#5; = #1
        \fp_minmax_ii:ww
      \else:
        \fp_minmax_i:ww
      \fi:
    \fi:
    \fp_minmax_loop:Nww #1
      \s_fp \fp_use:w #2#3;
      \s_fp \fp_use:w #4#5;
  }
\cs_new:Npn \fp_minmax_i:ww
    #1 \fp_minmax_loop:Nww #2 \s_fp #3; \s_fp #4;
  { #1 \fp_minmax_loop:Nww #2 \s_fp #3; }
\cs_new:Npn \fp_minmax_ii:ww
    #1 \fp_minmax_loop:Nww #2 \s_fp #3; \s_fp #4;
  { #1 \fp_minmax_loop:Nww #2 \s_fp #4; }
\cs_new:Npn \fp_minmax_break:w #1 \fp_minmax_loop:Nww #2 #3; #4;
  {
    \fi:
    \fp_aux_exp_after_fp:wN #3;
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex