% \iffalse
%
%% File l3bigint.dtx Copyright (C) 2011-2017 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3bigint} package\\ Unbounded integers^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2017/04/01}
%
% \maketitle
%
% \begin{documentation}
%
% \section{\pkg{l3bigint} documentation}
%
% This package aims to provide the complete set of \pkg{l3int}
% functions, but without bounds on the integers used: such unbounded
% integers are called in this package \enquote{big integers} or
% \enquote{bigints}.  As in \pkg{l3int}, all \texttt{n}-type arguments
% expect a (big) integer expression with the operations |+-*/| and
% parentheses |()|.  The package also provides a few more elaborate
% functions such as computing the \texttt{gcd} of two numbers,
% \emph{etc.}
%
% At present, division is not implemented, hence \texttt{gcd} and other
% functions depending on it will break.
%
% The functions implemented here could be useful to some niche users
% (\emph{e.g.}, myself when developing and debugging \pkg{l3rand})
% but loading this module is useless for the great majority of
% documents, hence it should not go into the format.
%
% \section{Big integer expressions}
%
% The syntax for \meta{big integer expressions} is essentially the same
% as that for \meta{integer expressions}, with support for the four
% elementary operations |+-*/| and parentheses |()|.  The operands can
% be given
% \begin{itemize}
%   \item in explicit decimal notation: non-empty sequence of digits |0-9|,
%   \item in base $16$: |"| followed by a non-empty sequence of
%     uppercase hexadecimal digits |0-9A-F|, \emph{(not yet)}
%   \item in base $8$: |'| followed by a non-empty sequence of octal
%     digits |0-7|, \emph{(not yet)}
%   \item as the character code of a character: |`| followed by a
%     character token or a single-character control sequence
%   \item as \texttt{int} or \texttt{bigint} variables, without needing
%     an accessor function,
% \end{itemize}
% When parsing a \meta{big integer expression}, spaces are ignored, and
% something akin to \texttt{x}-expansion takes place, namely
% \texttt{f}-expansion after every character.  Some braces are ignored,
% but one should not rely on this behaviour.  For instance, the
% following are valid \meta{big integer expressions} equal to $11100$.
% \begin{verbatim}
%   10000+--1100
%   111 * ( 10 * 9 + "A )
%   `o * `\d
%   0 ~ 1 \c_space_tl 110 ~ 0
%   1 \prg_replicate:nn { 2 } { 1 } \prg_replicate:nn { 2 } { ~ 0 }
% \end{verbatim}
% All functions which are described below as expanding to a \meta{big
% integer} result in the shortest string representing the \meta{big
% integer}, a canonical form explained in more details in the
% documentation of \cs{bigint_eval:n}.
%
% Formally, a big integer \meta{expression} is a sum/difference of
% \meta{terms}; a \meta{term} is a product of \meta{factors}; a
% \meta{factor} is \meta{sign}\meta{unsigned factor}; a \meta{sign} is
% a possibly empty string of |+| and |-| character tokens; an
% \meta{unsigned factor} is either a \meta{number without sign} or
% parentheses surrounding an \meta{expression}; a \meta{number without
% sign} is either a \meta{bigint var}, a \meta{register} or a
% \meta{decimal number} or a double quote |"| followed by an
% \meta{hexadecimal number} or a single quote |'| followed by an
% \meta{octal number} or a backquote |`| followed by a character token
% or a single-character control sequence; a \meta{bigint var} is a
% variable defined by \cs{bigint_new:N}; a \meta{register} is a
% non-expandable control sequence such that acting with \tn{number} on
% it gives an integer, for instance an \meta{int var}; a \meta{decimal
% number} is a non-empty string of digits |0123456789|; a
% \meta{hexadecimal number} is a non-empty string of uppercase
% hexadecimal digits |0123456789ABCDEF|; an \meta{octal number} is a
% non-empty string of octal digits |01234567|.
%
% \begin{function}[EXP]{\bigint_eval:n}
%   \begin{syntax}
%     \cs{bigint_eval:n} \Arg{bigintexpr}
%   \end{syntax}
%   Evaluates the \meta{big integer expression} and leaves its value in
%   the input stream.  Namely, positive numbers are expressed as a
%   string of digits with no leading~|0|, negative numbers are
%   expressed similarly, with a leading~|-|, and zero is expressed
%   as~|0|.
% \end{function}
%
% \begin{function}[EXP]{\bigint_abs:n}
%   \begin{syntax}
%     \cs{bigint_abs:n} \Arg{bigintexpr}
%   \end{syntax}
%   Exaluates the \meta{big integer expression} and leaves its absolute
%   value in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_div_round:nn}
%   \begin{syntax}
%     \cs{bigint_div_round:nn} \Arg{bigintexpr_1} \Arg{bigintexpr_2}
%   \end{syntax}
%   Evaluates the two \meta{big integer expressions}, then divides the
%   first value by the second, and rounds the result to the closest
%   integer.  Ties are rounded away from zero.  Note that this is
%   identical to using |/| directly in a \meta{big integer expression}.
%   The result is left in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_div_truncate:nn}
%   \begin{syntax}
%     \cs{bigint_div_truncate:nn} \Arg{bigintexpr_1} \Arg{bigintexpr_2}
%   \end{syntax}
%   Evaluates the two \meta{big integer expressions}, then divides the
%   first value by the second, and rounds the result towards zero.
%   Note that division using |/| rounds to the closest integer instead.
%   The result is left in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_max:nn, \bigint_min:nn}
%   \begin{syntax}
%     \cs{bigint_max:nn} \Arg{bigintexpr_1} \Arg{bigintexpr_2}
%     \cs{bigint_min:nn} \Arg{bigintexpr_1} \Arg{bigintexpr_2}
%   \end{syntax}
%   Evaluates the two \meta{big integer expressions}, then leaves
%   either the larger or smaller of the two values in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_mod:nn}
%   \begin{syntax}
%     \cs{bigint_mod:nn} \Arg{bigintexpr_1} \Arg{bigintexpr_2}
%   \end{syntax}
%   Evaluates the two \meta{big integer expressions}, then calculates
%   the integer remainder of dividing the first expression by the
%   second.  This is obtained by subtracting
%   \cs{bigint_div_truncate:nn} \Arg{bigintexpr_1} \Arg{bigintexpr_2}
%   times \meta{bigintexpr_2} from \meta{bigintexpr_1}.  Thus, the
%   result is zero or has the same sign as \meta{bigintexpr_1}, and its
%   absolute value is strictly less than that of \meta{bigintexpr_2}.
%   The result is left in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_sign:n}
%   \begin{syntax}
%     \cs{bigint_sign:n} \Arg{bigintexpr}
%   \end{syntax}
%   Evaluates the \meta{big integer expression} and leaves its sign
%   ($-1$ for negative, $0$ for zero, $1$ for positive) in the input
%   stream.
% \end{function}
%
% \section{Creating and initialising big integers}
%
% \begin{function}{\bigint_new:N, \bigint_new:c}
%   \begin{syntax}
%     \cs{bigint_new:N} \meta{bigint~var}
%   \end{syntax}
%   Creates a new \meta{big integer variable} or raises an error if the
%   name is already taken.  The declaration is global.  The \meta{big
%     integer variable} will initially be equal to~$0$.
% \end{function}
%
% \begin{function}{\bigint_const:Nn, \bigint_const:cn}
%   \begin{syntax}
%     \cs{bigint_const:Nn} \meta{bigint~var} \Arg{bigintexpr}
%   \end{syntax}
%   Creates a new constant \meta{big~integer~variable} or raises an
%   error if the name is already taken.  The value of the \meta{big
%     integer variable} will be set globally to the result of
%   evaluating the \meta{big integer expression}.
% \end{function}
%
% \begin{function}
%   {\bigint_zero:N, \bigint_zero:c, \bigint_gzero:N, \bigint_gzero:c}
%   \begin{syntax}
%     \cs{bigint_zero:N} \meta{bigint~var}
%   \end{syntax}
%   Sets \meta{big integer variable} to~$0$.
% \end{function}
%
% \begin{function}
%   {
%     \bigint_zero_new:N, \bigint_zero_new:c,
%     \bigint_gzero_new:N, \bigint_gzero_new:c
%   }
%   \begin{syntax}
%     \cs{bigint_zero_new:N} \meta{bigint~var}
%   \end{syntax}
%   Ensures that the \meta{big integer variable} exists globally by
%   applying \cs{bigint_new:N} if necessary, then applies
%   \cs{bigint_(g)zero:N} to leave the \meta{big integer variable} set
%   to~$0$.
% \end{function}
%
% \begin{function}
%   {
%     \bigint_set_eq:NN,  \bigint_set_eq:cN,
%     \bigint_set_eq:Nc,  \bigint_set_eq:cc,
%     \bigint_gset_eq:NN, \bigint_gset_eq:cN,
%     \bigint_gset_eq:Nc, \bigint_gset_eq:cc
%   }
%   \begin{syntax}
%     \cs{bigint_set_eq:NN} \meta{bigint~var_1} \meta{bigint~var_2}
%   \end{syntax}
%   Sets the content of the first \meta{big integer variable} equal to
%   that of the second.
% \end{function}
%
% \begin{function}[EXP, pTF]{\bigint_if_exist:N, \bigint_if_exist:c}
%   \begin{syntax}
%     \cs{bigint_if_exist_p:N} \meta{bigint~var}
%     \cs{bigint_if_exist:NTF} \meta{bigint~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{big integer variable} is currently defined.
%   This does not check that the \meta{big integer variable} really is a
%   big integer variable.
% \end{function}
%
% \section{Setting and incrementing big integers}
%
% \begin{function}
%   {\bigint_add:Nn, \bigint_add:cn, \bigint_gadd:Nn, \bigint_gadd:cn}
%   \begin{syntax}
%     \cs{bigint_add:Nn} \meta{bigint~var} \Arg{bigintexpr}
%   \end{syntax}
%   Adds to the \meta{big integer variable} the result of evaluating
%   the \meta{big integer expression}.
% \end{function}
%
% \begin{function}
%   {\bigint_decr:N, \bigint_decr:c, \bigint_gdecr:N, \bigint_gdecr:c}
%   \begin{syntax}
%     \cs{bigint_decr:N} \meta{bigint~var}
%   \end{syntax}
%   Decreases the value stored in \meta{big integer variable} by~$1$.
% \end{function}
%
% \begin{function}
%   {\bigint_incr:N, \bigint_incr:c, \bigint_gincr:N, \bigint_gincr:c}
%   \begin{syntax}
%     \cs{bigint_incr:N} \meta{bigint~var}
%   \end{syntax}
%   Increases the value stored in \meta{big integer variable} by~$1$.
% \end{function}
%
% \begin{function}
%   {\bigint_set:Nn, \bigint_set:cn, \bigint_gset:Nn, \bigint_gset:cn}
%   \begin{syntax}
%     \cs{bigint_set:Nn} \meta{bigint~var} \Arg{bigintexpr}
%   \end{syntax}
%   Sets the \meta{big integer variable} to the result of evaluating
%   the \meta{big integer expression}.
% \end{function}
%
% \begin{function}
%   {\bigint_sub:Nn, \bigint_sub:cn, \bigint_gsub:Nn, \bigint_gsub:cn}
%   \begin{syntax}
%     \cs{bigint_sub:Nn} \meta{bigint~var} \Arg{bigintexpr}
%   \end{syntax}
%   Subtract from the \meta{big integer variable} the result of evaluating
%   the \meta{big integer expression}.
% \end{function}
%
% \section{Using integers}
%
% \begin{function}[EXP]{\bigint_use:N, \bigint_use:c}
%   \begin{syntax}
%     \cs{bigint_use:N} \meta{bigint~var}
%   \end{syntax}
%   Recovers the value of a \meta{big integer variable} and places it
%   directly in the input stream.  An error will be raised if the
%   variable does not exist or if it is invalid.  Although it is
%   possible to use a \meta{bigint~var} directly in a \meta{big integer
%   expression}, an accessor function such as \cs{bigint_use:N} or
%   \cs{bigint_eval:n} is needed to use a big integer in a normal
%   integer expression.
% \end{function}
%
% \section{Big integer conditionals}
%
% \begin{function}[EXP, pTF]{\bigint_compare:nNn}
%   \begin{syntax}
%     \cs{bigint_compare_p:nNn} \Arg{bigintexpr_1} \meta{relation} \Arg{bigintexpr_2} \\
%     \cs{bigint_compare:nNnTF}
%     ~~\Arg{bigintexpr_1} \meta{relation} \Arg{bigintexpr_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   Evaluates the \meta{big integer expressions}, then compares them
%   using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP, pTF]{\bigint_compare:n}
%   \begin{syntax}
%     \cs{bigint_compare_p:n} \\
%     ~~\{ \\
%     ~~~~\meta{bigintexpr_1} \meta{relation_1} \\
%     ~~~~\ldots{} \\
%     ~~~~\meta{bigintexpr_N} \meta{relation_N} \\
%     ~~~~\meta{bigintexpr_{N+1}} \\
%     ~~\} \\
%     \cs{bigint_compare:nTF}
%     ~~\{ \\
%     ~~~~\meta{bigintexpr_1} \meta{relation_1} \\
%     ~~~~\ldots{} \\
%     ~~~~\meta{bigintexpr_N} \meta{relation_N} \\
%     ~~~~\meta{bigintexpr_{N+1}} \\
%     ~~\} \\
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function evaluates the \meta{big integer expressions} and
%   compares consecutive result using the corresponding
%   \meta{relation}, namely it compares \meta{bigintexpr_1} and
%   \meta{bigintexpr_2} using the \meta{relation_1}, then
%   \meta{bigintexpr_2} and \meta{bigintexpr_3} using the
%   \meta{relation_2}, until finally comparing \meta{bigintexpr_N} and
%   \meta{bigintexpr_{N+1}} using the \meta{relation_N}.  The test
%   yields \texttt{true} if all comparisons are \texttt{true}.  Each
%   \meta{big integer expression} is evaluated only once, and the
%   evaluation is lazy, in the sense that if one comparison is
%   \texttt{false}, then no other \meta{big integer expression} is
%   evaluated and no other comparison is performed.  The
%   \meta{relations} can be any of the following:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP, TF]{\bigint_case:nn}
%   \begin{syntax}
%     \cs{bigint_case:nnTF} \Arg{test bigintexpr} \\
%     ~~|{| \\
%     ~~~~\Arg{bigintexpr case_1} \Arg{code case_1} \\
%     ~~~~\Arg{bigintexpr case_2} \Arg{code case_2} \\
%     ~~~~\ldots \\
%     ~~~~\Arg{bigintexpr case_n} \Arg{code case_n} \\
%     ~~|}| \\
%     ~~\Arg{true code}
%     ~~\Arg{false code}
%   \end{syntax}
%   This function evaluates the \meta{test big integer expression} and
%   compares the result in turn to each of the \meta{big integer
%   expression cases}.  If the two are equal then the associated
%   \meta{code} is left in the input stream.  If any of the cases are
%   matched, the \meta{true code} is also inserted into the input
%   stream (after the code for the appropriate case), while if none
%   match then the \meta{false code} is inserted. The function
%   \cs{bigint_case:nn}, which does nothing if there is no match, is
%   also available.  For example
%   \begin{verbatim}
%     \bigint_case:nnF
%       { 1234567890 * 10000000001 }
%       {
%         { 567 }                    { Small }
%         { 12345678901234567890 }   { Large }
%         { -1 }                     { Negative }
%       }
%       { No idea! }
%    \end{verbatim}
%    will leave \enquote{\texttt{Large}} in the input stream.
% \end{function}
%
% \begin{function}[EXP, pTF]{\bigint_if_even:n, \bigint_if_odd:n}
%   \begin{syntax}
%     \cs{bigint_if_odd_p:n} \Arg{bigintexpr}
%     \cs{bigint_if_odd:nTF} \Arg{bigintexpr} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Evaluates the \meta{big integer expression}, then tests whether it
%   is odd or even, as appropriate.
% \end{function}
%
% \begin{function}[EXP, pTF]{\bigint_if_int:n}
%   \begin{syntax}
%     \cs{bigint_if_int_p:n} \Arg{bigintexpr}
%     \cs{bigint_if_int:nTF} \Arg{bigintexpr} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Evaluates the \meta{big integer expression}, then tests whether it
%   is suitable for use in a normal \meta{integer expression} or for
%   storage in a normal \meta{integer variable}, namely whether its
%   absolute value is strictly less than~$2^{31}$.
% \end{function}
%
% \section{Factorization}
%
% \begin{function}[EXP]{\bigint_count_divisors:n}
%   \begin{syntax}
%     \cs{bigint_count_divisors:n} \Arg{bigintexpr}
%   \end{syntax}
%   Evaluates the \meta{big integer expression} then counts the number
%   of divisors of the absolute value of the result, and leaves this
%   information in the input stream.  Zero has an infinite number of
%   divisors, but this function expands to~$0$ instead, as this value
%   is not the number of divisors of any other number.
% \end{function}
%
% \begin{function}[EXP]{\bigint_factor:n}
%   \begin{syntax}
%     \cs{bigint_factor:n} \Arg{bigintexpr}
%   \end{syntax}
%   Evaluates the \meta{big integer expression}, factorizes the result,
%   and leaves the prime factors in the input stream.  The prime
%   factors are returned in decreasing order, appear multiple times if appropriate, and
%   each factor is within braces.  Negative integers lead to a result ending
%   with the item~|{-1}|.  Zero results in a single brace group |{0}|.
% \end{function}
%
% \begin{function}[EXP]{\bigint_gcd:nn}
%   \begin{syntax}
%     \cs{bigint_gcd:nn} \Arg{bigintexpr_1} \Arg{bigintexpr_2}
%   \end{syntax}
%   Evaluates the two \meta{big integer expressions} and computes their
%   greatest common divisor.  The result is left in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_lcm:nn}
%   \begin{syntax}
%     \cs{bigint_lcm:nn} \Arg{bigintexpr_1} \Arg{bigintexpr_2}
%   \end{syntax}
%   Evaluates the two \meta{big integer expressions} and computes their
%   least common multiple.  The result is left in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_phi:n}
%   \begin{syntax}
%     \cs{bigint_phi:n} \Arg{bigintexpr}
%   \end{syntax}
%   Evaluates the \meta{big integer expression} and applies to it
%   Euler's totient function.  The result is left in the input stream.
% \end{function}
%
% \section{Viewing big integers}
%
% \begin{function}{\bigint_log:N, \bigint_log:c}
%   \begin{syntax}
%     \cs{bigint_log:N} \meta{bigint~var}
%   \end{syntax}
%   Writes the value of the \meta{big integer} in the log file.
% \end{function}
%
% \begin{function}{\bigint_log:n}
%   \begin{syntax}
%     \cs{bigint_log:n} \Arg{big integer expression}
%   \end{syntax}
%   Writes the result of evaluating the \meta{big integer expression}
%   in the log file.
% \end{function}
%
% \begin{function}{\bigint_show:N, \bigint_show:c}
%   \begin{syntax}
%     \cs{bigint_show:N} \meta{bigint~var}
%   \end{syntax}
%   Displays the value of the \meta{big integer} on the terminal.
% \end{function}
%
% \begin{function}{\bigint_show:n}
%   \begin{syntax}
%     \cs{bigint_show:n} \Arg{big integer expression}
%   \end{syntax}
%   Displays the result of evaluating the \meta{big integer expression}
%   on the terminal.
% \end{function}
%
% \section{Scratch big integers}
%
% \begin{variable}{\l_tmpa_bigint, \l_tmpb_bigint}
%   Scratch big integers for local assignment.  These are never used by
%   the kernel code, and so are safe for use with any \LaTeX3-defined
%   function. However, they may be overwritten by other non-kernel
%   code and so should only be used for short-term storage.
% \end{variable}
%
% \begin{variable}{\g_tmpa_bigint, \g_tmpb_bigint}
%   Scratch big integer for global assignment.  These are never used by
%   the kernel code, and so are safe for use with any \LaTeX3-defined
%   function. However, they may be overwritten by other non-kernel
%   code and so should only be used for short-term storage.
% \end{variable}
%
% \section{Some details on \pkg{l3bigint} internals}
%
% Big integer variables are token lists of the form
% \begin{quote}
%   \cs{s_@@} \cs{@@_chk:w} \meta{count} . \meta{sign} \meta{digits} |;|
% \end{quote}
% where the \meta{sign} is |+|, |-| or |0| (for zero), the
% \meta{digits} are decimal digits of the absolute value of the big
% integer, with zeros prepended so that the total number of
% \meta{digits} is a multiple of~$8$, namely $8\times\meta{count}$.
% Zero is stored as
% \begin{quote}
%   \cs{s_@@} \cs{@@_chk:w} |0| |.| |0| |;|
% \end{quote}
% The marker \cs{s_@@} is equal to \cs{scan_stop:} and \cs{@@_chk:w} is
% protected and defined to remove the rest of the variable with an
% error.  This structures ensures that arbitrary \texttt{o}-type,
% \texttt{f}-type, or \texttt{x}-type expansions leave the contents of
% the variable unchanged, while attempting to typeset a big integer
% without an accessor function will trigger an error, as for other
% register-like variables.
%
% \begin{function}[EXP]{\__bigint_parse_do:nn}
%   \begin{syntax}
%     \cs{__bigint_parse_do:nn} \Arg{bigintexpr} \Arg{code}
%   \end{syntax}
%   Evaluates the \meta{big integer expression} and leaves the
%   \meta{code} in the input stream, followed by the result in the
%   internal form specified above (with no braces).
% \end{function}
%
% \begin{function}[EXP]{\__bigint_parse:n}
%   \begin{syntax}
%     \cs{__bigint_parse:n} \Arg{bigintexpr}
%   \end{syntax}
%   This function must appear after \cs{exp:w} or a command set
%   equal to it.  Evaluates the \meta{big integer expression} and
%   leaves the result in the input stream, in the internal form
%   specified above.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3bigint} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=bigint>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage{l3bigint}{2017/04/01}{}
  {L3 Experimental unbounded integer support}
%</package>
%    \end{macrocode}
%
% A large part of the code is related to parsing expressions, and is
% based on \pkg{l3fp}'s submodule \pkg{l3fp-parse} (and a bit on
% \pkg{l3fp-aux}), with some simplifications due to only manipulating
% integers.  Performing the actual computations is harder than for
% floating points due to the arbitrary number of digits.
%
% \subsection{General helpers}
%
% In particular, copies of primitives and internal commands from other
% packages.
%
% \begin{macro}[int]{\@@_str_cmp_x:nn}
%   This is a wrapper around the primitive \tn{pdfstrcmp} or \tn{strcmp} or some equivalent Lua code.
%    \begin{macrocode}
\cs_new_eq:NN \@@_str_cmp_x:nn \__str_if_eq_x:nn
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\use:nff, \use:nooo}
%   These functions are preferred to chains of \cs{exp_after:wN} when
%   implementing for instance multiplication, because otherwise we
%   reach \TeX{}'s maximum expansion depth too quickly.  They are
%   actually used with a single token as their first argument, so
%   semantically it would be better to use hypothetical
%   |\exp_last_two_unbraced:Nff| and |\exp_last_three_unbraced:Nooo|.
%   But |nooo| is a nice signature, don't you think?
%    \begin{macrocode}
\cs_generate_variant:Nn \use:nnn { nff }
\cs_generate_variant:Nn \use:nnnn { nooo }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_scan_new:N}
%   A poor man's version of the kernel's \cs{__scan_new:N}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_scan_new:N #1
  { \cs_new_eq:NN #1 \scan_stop: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_int_value:w, \@@_int_eval:w, \@@_int_eval_end:}
%   Copies of \TeX{}'s and \eTeX{}'s \tn{number} and \tn{numexpr}
%   primitives, used for calculations.
%    \begin{macrocode}
\cs_new_eq:NN \@@_int_value:w \tex_number:D
\cs_new_eq:NN \@@_int_eval:w \etex_numexpr:D
\cs_new_eq:NN \@@_int_eval_end: \scan_stop:
%    \end{macrocode}
% \end{macro}
%
%
% \begin{variable}[int]{\s_@@}
% \begin{macro}[aux]{\@@_chk:w}
%   Big integer variables all start with \cs{s_@@} \cs{@@_chk:w},
%   where \cs{s_@@} is equal to the \TeX{} primitive \tn{relax}, and
%   \cs{@@_chk:w} is protected.  The rest of the variable is made of
%   character tokens.  This ensures that nothing expands under
%   \texttt{f}-expansion, nor under \texttt{x}-expansion.
%   However, when typeset, \cs{s_@@} does nothing, and \cs{@@_chk:w} is
%   defined to produce an error.
%    \begin{macrocode}
\@@_scan_new:N \s_@@
\cs_new_protected:Npn \@@_chk:w #1 ;
  {
    \msg_error:nnx { bigint } { misused-var }
      { \bigint_eval:n { \s_@@ \@@_chk:w #1 ; } }
  }
%    \end{macrocode}
% \end{macro}
% \end{variable}
%
% \begin{variable}[int]{\c_@@_zero_bigint}
%   Used as an initial value for big integers.
%    \begin{macrocode}
\tl_const:Nn \c_@@_zero_bigint { \s_@@ \@@_chk:w 0 . 0 ; }
%    \end{macrocode}
% \end{variable}
%
% \subsection{Parsing}
%
% \subsubsection{Helpers for parsing}
%
% \begin{macro}[int]{\s_@@_mark, \s_@@_stop}
%   Unexpandable markers for the end of a big integer expression.
%    \begin{macrocode}
\@@_scan_new:N \s_@@_mark
\@@_scan_new:N \s_@@_stop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_return_semicolon:w}
%   This very odd function swaps its position with the following
%   \cs{fi:} and removes \cs{exp_end_continue_f:nw} normally responsible for
%   expansion.  That turns out to be useful.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_return_semicolon:w
    #1 \fi: \exp_end_continue_f:nw { \fi: ; #1 }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: optimize this a bit using custom version of parse_return_semicolon (??)
% \begin{macro}[rEXP, aux]
%   {
%     \@@_parse_digits_viii:NN ,
%     \@@_parse_digits_vii:NN  ,
%     \@@_parse_digits_vi:NN   ,
%     \@@_parse_digits_v:NN    ,
%     \@@_parse_digits_iv:NN   ,
%     \@@_parse_digits_iii:NN  ,
%     \@@_parse_digits_ii:NN   ,
%     \@@_parse_digits_i:NN    ,
%     \@@_parse_digits_:N
%   }
%   The first argument of these functions can be |0|, |"|, or |'|, and
%   they look correspondingly for some decimal, hexadecimal, or octal
%   digits.  These functions should be called within an
%   \cs{@@_int_value:w} or \cs{@@_int_eval:w} construction, and following
%   |"| or |'| for the hexadecimal or octal cases.  The function with a
%   given \meta{index} (in roman numerals) reads tokens one by one
%   as its second argument, and outputs up to \meta{index} digits in
%   the input stream, stopping at the first non-digit or at the
%   \meta{index}-th digit.  The full expansion is
%   \begin{quote}
%     \meta{digits} |;| \meta{filling 0} |;| \meta{length}
%   \end{quote}
%   where \meta{filling 0} is a string of zeros such that \meta{digits}
%   \meta{filling 0} has the length given by the index of the function,
%   and \meta{length} is the number of zeros in the \meta{filling 0}
%   string.  Each function puts a digit into the input stream and calls
%   the next function, unless finding a non-digit.  The tested tokens
%   are passed through \cs{token_to_str:N} to normalize their category
%   code.
%
%   One exception is that in the absence of digit, the |viii| function
%   returns an empty \meta{filling 0} (to avoid having $8$ extra
%   leading zeros whenever we parse a number with a multiple of $8$
%   digits) but still gives a \meta{length} of $8$ to be
%   distinguishable from the function \cs{@@_parse_digits_:N}.
%    \begin{macrocode}
\cs_gset_protected:Npn \@@_tmp:w #1 #2 #3
  {
    \cs_new:cpn { @@_parse_digits_ #1 :NN } ##1##2
      {
        \if_int_compare:w 1 < ##1 1 \token_to_str:N ##2 \exp_stop_f:
          \token_to_str:N ##2
          \exp_after:wN #2 \exp_after:wN ##1 \exp:w
        \else:
          \@@_parse_return_semicolon:w #3 ##2
        \fi:
        \exp_end_continue_f:nw
      }
  }
\@@_tmp:w {viii} \@@_parse_digits_vii:NN  { ; 8 }
\@@_tmp:w {vii}  \@@_parse_digits_vi:NN   { 0000000 ; 7 }
\@@_tmp:w {vi}   \@@_parse_digits_v:NN    { 000000 ; 6 }
\@@_tmp:w {v}    \@@_parse_digits_iv:NN   { 00000 ; 5 }
\@@_tmp:w {iv}   \@@_parse_digits_iii:NN  { 0000 ; 4 }
\@@_tmp:w {iii}  \@@_parse_digits_ii:NN   { 000 ; 3 }
\@@_tmp:w {ii}   \@@_parse_digits_i:NN    { 00 ; 2 }
\@@_tmp:w {i}    \@@_parse_digits_:N      { 0 ; 1 }
\cs_new:Npn      \@@_parse_digits_:N #1   { ; ; 0 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_type_from_scan:N, \@@_type_from_scan:w}
%   \begin{syntax}
%     \cs{@@_type_from_scan:N} \meta{token}
%   \end{syntax}
%   Grabs the pieces of the stringified \meta{token} which lies after
%   the first |s__bigint|.  If the \meta{token} does not contain that
%   string, the result is |_?|.
%    \begin{macrocode}
\use:x
  {
    \exp_not:n { \cs_new:Npn \@@_type_from_scan:N #1 }
      {
        \exp_not:n { \exp_after:wN \@@_type_from_scan:w }
        \exp_not:n { \token_to_str:N #1 \q_mark }
        \tl_to_str:n { s_@@_? } \exp_not:n { \q_mark \q_stop }
      }
    \exp_not:n { \cs_new:Npn \@@_type_from_scan:w #1 }
      \tl_to_str:n { s_@@ } \exp_not:n { #2 \q_mark #3 \q_stop {#2} }
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: either optimize or combine with fp.
% \begin{macro}[int, EXP]{\@@_exp_after_array_f:w}
% \begin{macro}[aux, EXP]{\@@_exp_after_stop_f:nw}
%   \begin{syntax}
%     \cs{@@_exp_after_array_f:w}
%       \meta{bigint_1} |;|
%       \ldots{}
%       \meta{bigint_n} |;|
%       \cs{s_@@_stop}
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \@@_exp_after_array_f:w #1
  {
    \cs:w @@_exp_after \@@_type_from_scan:N #1 _f:nw \cs_end:
      { \@@_exp_after_array_f:w }
    #1
  }
\cs_new_eq:NN \@@_exp_after_stop_f:nw \use_none:nn
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_exp_after_o:w}
%    \begin{macrocode}
\cs_new:Npn \@@_exp_after_o:w
  { \@@_exp_after_f:nw { \exp_after:wN \exp_stop_f: } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_exp_after_f:nw, \@@_exp_after_f_aux:NNNNNNNN}
%   Expand after many digits using a loop.  \TeX{}'s primitive
%   \tn{number}, here as \cs{@@_int_value:w} receives a $10$-digit
%   number starting with $1$.  The loop is stopped by giving
%   \cs{@@_exp_after_f_aux:NNNNNNNN} a multi-token argument, which
%   cleans up and triggers f-expansion of the |#1| placed at the end.
%    \begin{macrocode}
\cs_new:Npn \@@_exp_after_f:nw #1 \s_@@ \@@_chk:w #2.#3#4 ;
  {
    \exp_after:wN \s_@@
    \exp_after:wN \@@_chk:w
    \@@_int_value:w #2
      \exp_after:wN \use_i_ii:nnn
      \exp_after:wN .
      \exp_after:wN #3
    \@@_int_value:w 1
      \@@_exp_after_f_aux:NNNNNNNN #4
      {
        \exp_after:wN ; \exp:w \exp_end_continue_f:w
        \use_none_delimit_by_q_stop:w
      }
      ???? ???? \q_stop #1
  }
\cs_new:Npn \@@_exp_after_f_aux:NNNNNNNN #1#2#3#4#5#6#7#8
  {
    \exp_after:wN \@@_use_none_stop_f:n
    \@@_int_value:w 1 #1#2#3#4#5#6#7#8 \@@_exp_after_f_aux:NNNNNNNN
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_use_none_stop_f:n}
%   Get rid of the next token (typically~|1|) and stop
%   \texttt{f}-expansion.
%    \begin{macrocode}
\cs_new:Npn \@@_use_none_stop_f:n #1 { \exp_stop_f: }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Main parsing functions}
%
% \begin{variable}{\c_@@_prec_end_int, \c_@@_prec_zero_int, \c_@@_prec_add_int, \c_@@_prec_mul_int, \c_@@_prec_neg_int}
%   Precedence for various operators.
%    \begin{macrocode}
\int_const:Nn \c_@@_prec_end_int { -1 }
\int_const:Nn \c_@@_prec_zero_int { 0 }
\int_const:Nn \c_@@_prec_add_int { 9 }
\int_const:Nn \c_@@_prec_mul_int { 10 }
\int_const:Nn \c_@@_prec_neg_int { 12 }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int, EXP]{\@@_parse_do:nn}
% \begin{macro}[aux, EXP]{\@@_parse_do_aux:w}
%   Parse an expression and run some code~|#2| on the result.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_do:nn
  {
    \exp_after:wN \@@_parse_do_aux:w
    \exp:w \@@_parse:n
  }
\cs_new:Npn \@@_parse_do_aux:w #1 ; #2 { #2 #1 ; }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_parse:n}
% \begin{macro}[aux, EXP]{\@@_parse_after:ww}
%   This should be called within \cs{exp:w}.
%   The \cs{@@_parse_operand:Nw} function will perform
%   computations until reaching an operation with precedence
%   \cs{c_@@_prec_end_int} or less, namely, the end of the expression.  The
%   marker \cs{s_@@_mark} indicates that the next token is an already
%   parsed version of an infix operator, and \cs{@@_parse_infix_end:N}
%   has infinitely negative precedence.  Finally, clean up a
%   (well-defined) set of extra tokens and stop the initial expansion
%   with \cs{exp_end:}.
%    \begin{macrocode}
\cs_new:Npn \@@_parse:n #1
  {
    \exp_after:wN \@@_parse_after:ww
    \exp:w
      \@@_parse_operand:Nw \c_@@_prec_end_int
      \exp_end_continue_f:nw #1
      \s_@@_mark \@@_parse_infix_end:N
    \s_@@_stop
  }
\cs_new:Npn \@@_parse_after:ww
    #1@ \@@_parse_infix_end:N \s_@@_stop
  { \exp_end: #1 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_operand:Nw}
% \begin{macro}[aux, EXP]{\@@_parse_continue:NwN}
%   This is just a shorthand which sets up both
%   \cs{@@_parse_continue:NwN} and \cs{@@_parse_one:Nw} with the same
%   precedence. Note the trailing \cs{exp:w}. This function should
%   thus be used with much care.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_operand:Nw #1
  {
    \exp_end_continue_f:w
    \exp_after:wN \@@_parse_continue:NwN
    \exp_after:wN #1
    \exp:w \exp_end_continue_f:w
    \exp_after:wN \@@_parse_one:Nw
    \exp_after:wN #1
    \exp:w
  }
\cs_new:Npn \@@_parse_continue:NwN #1 #2 @ #3 { #3 #1 #2 @ }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_apply_binary:NwNwN}
%   Receives \meta{precedence} \meta{operand_1} |@| \meta{operation}
%   \meta{operand_2} |@| \meta{infix command}.  Builds the appropriate
%   call to the \meta{operation}~|#3|.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_apply_binary:NwNwN #1 #2@ #3 #4@ #5
  {
    \exp_after:wN \@@_parse_continue:NwN
    \exp_after:wN #1
    \exp:w \exp_end_continue_f:w \cs:w @@_#3_o:ww \cs_end: #2 #4
    \exp:w \exp_end_continue_f:w #5 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Parsing one number}
%
% \begin{macro}[aux, EXP]{\@@_parse_one:Nw}
%   This function finds one number, and packs the symbol which follows
%   in an |infix_| csname.  |#1|~is the previous \meta{precedence}, and
%   |#2|~the first token of the operand.  We distinguish four cases:
%   |#2|~is equal to \cs{scan_stop:} in meaning, |#2|~is a different
%   control sequence, |#2|~is a digit, and |#2|~is something else (this
%   last case will be split further).  Despite the earlier
%   \texttt{f}-expansion, |#2|~may still be expandable if it was
%   protected by \cs{exp_not:N}, as may happen with the \LaTeXe{}
%   command \tn{protect}.  Using a well placed \cs{reverse_if:N}, this
%   case is sent to \cs{@@_parse_one_var:NN} which deals with it
%   robustly.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_one:Nw #1 #2
  {
    \if_catcode:w \scan_stop: \exp_not:N #2
      \exp_after:wN \if_meaning:w \exp_not:N #2 #2 \else:
        \exp_after:wN \reverse_if:N
      \fi:
      \if_meaning:w \scan_stop: #2
        \exp_after:wN \exp_after:wN
        \exp_after:wN \@@_parse_one_var:NN
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \@@_parse_one_register:NN
      \fi:
    \else:
      \if_int_compare:w 9 < 1 \token_to_str:N #2 \exp_stop_f:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \@@_parse_one_digit:NN
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \@@_parse_one_other:NN
      \fi:
    \fi:
    #1 #2
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {
%     \@@_parse_one_var:NN,
%     \@@_exp_after_mark_f:nw,
%     \@@_exp_after_?_f:nw
%   }
%   This function receives a \meta{precedence} and a control sequence
%   which is either expandable or equal to \cs{scan_stop:} in meaning.
%   There are three cases, dispatched using \cs{@@_type_from_scan:N}.
%   \begin{itemize}
%     \item \cs{s_@@} starts a big integer variable, and
%       \cs{@@_exp_after_f:nw} |f|-expands after it.
%     \item \cs{s_@@_mark} is a premature end, and
%       \cs{@@_exp_after_mark_f:nw} triggers a |bigint/early-end|
%       error.
%     \item For anything else (not containing \cs{s_@@}),
%       \cs{@@_exp_after_?_f:nw} causes a |bigint/bad-variable| error.
%   \end{itemize}
%   In all cases, we make sure that the second argument of
%   \cs{@@_parse_infix:NN} is correctly expanded.
%   A special case only enabled in \LaTeXe{} is that if \tn{protect} is
%   encountered then the error message mentions the control sequence
%   which follows it rather than \tn{protect} itself.  The test for
%   \LaTeXe{} uses \tn{@unexpandable@protect} rather than \tn{protect}
%   because \tn{protect} is often \cs{scan_stop:} hence \enquote{does
%   not exist}.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_one_var:NN #1#2
  {
    \cs:w @@_exp_after \@@_type_from_scan:N #2 _f:nw \cs_end:
      {
        \exp_after:wN \@@_parse_infix:NN
        \exp_after:wN #1 \exp:w \exp_end_continue_f:nw
      }
    #2
  }
\cs_new:Npn \@@_exp_after_mark_f:nw #1
  {
    \msg_expandable_error:nn { bigint } { early-end }
    \exp_after:wN \c_@@_zero_bigint \exp:w \exp_end_continue_f:w #1
  }
\cs_new:cpn { @@_exp_after_?_f:nw } #1#2
  {
    \msg_expandable_error:nnn { bigint } { bad-var } {#2}
    \exp_after:wN \c_@@_zero_bigint \exp:w \exp_end_continue_f:w #1
  }
%<*package>
\group_begin:
  \char_set_catcode_letter:N \@
  \cs_if_exist:NT \@unexpandable@protect
    {
      \cs_gset:cpn { @@_exp_after_?_f:nw } #1#2
        {
          \exp_after:wN \c_@@_zero_bigint \exp:w \exp_end_continue_f:w #1
          \str_if_eq:nnTF {#2} { \protect }
            {
              \cs_if_eq:NNTF #2 \@unexpandable@protect { \use_i:nn } { \use:n }
              { \msg_expandable_error:nnn { bigint } { robust-cmd } }
            }
            { \msg_expandable_error:nnn { bigint } { bad-var } {#2} }
        }
    }
\group_end:
%</package>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {
%     \@@_parse_one_register:NN,
%     \@@_parse_one_register_aux:N,
%   }
%   This is called whenever~|#2| is a non-expandable control sequence
%   other than \cs{scan_stop:} in meaning.  We assume that it is a
%   register, and pass it (within braces, for safety) to
%   \cs{@@_int_value:w} to get a number out of it: if that is not
%   possible, \TeX{} will throw an error and give |0|.  After getting a
%   number, test its sign, and add |+| if positive (that is, if it
%   starts with a non-zero digit).
%    \begin{macrocode}
\cs_new:Npn \@@_parse_one_register:NN #1#2
  {
    \exp_after:wN \@@_parse_infix_after_operand:NwN
    \exp_after:wN #1
    \exp_after:wN \s_@@
    \exp_after:wN \@@_chk:w
    \exp:w \exp_end_continue_f:w
    \exp_after:wN \use:nn
    \exp_after:wN \@@_parse_one_register_aux:N
    \exp_after:wN { \@@_int_value:w #2 }
    ;
  }
\cs_new:Npn \@@_parse_one_register_aux:N #1
  { \if_int_compare:w 10 < 1 #1 ~ \exp_after:wN + \fi: #1 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_one_other:NN}
%   For this function, |#2|~is a character token which is not a digit.
%   The only valid cases are |+|, |-|, |"|, |'| and~|`|.  Call
%   |\__bigint_parse_prefix_|\meta{operator}|:Nw|, but not directly as that
%   function will not exist in case of character tokens that should not
%   appear there.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_one_other:NN #1 #2
  {
    \exp_after:wN \@@_parse_prefix:NNN
    \exp_after:wN #2
    \cs:w @@_parse_prefix_ \token_to_str:N #2 :Nw \cs_end:
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {\@@_parse_prefix:NNN, \@@_parse_prefix_unknown:NNN}
%   For this function, |#1|~is the operator just seen |#2|~is a control
%   sequence which implements the operator if it is a known operator,
%   |#3|~is the previous \meta{precedence}.  Typically call the control
%   sequence with as its first argument the \meta{precedence}.  If the
%   control sequence is \cs{scan_stop:}, then the operator is in fact
%   unknown.  Either the expression is missing a number there (if the
%   operator is valid as an infix operator), and we put $0$, wrapping
%   the infix operator in a csname as appropriate, or the character is
%   simply invalid in a big integer expression, and we continue looking
%   for a number, starting again from \cs{@@_parse_one:Nw}, and
%   remembering to expand what follows it.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_prefix:NNN #1#2#3
  {
    \if_meaning:w \scan_stop: #2
      \exp_after:wN \@@_parse_prefix_unknown:NNN
      \exp_after:wN #1
    \fi:
    #2 #3
  }
\cs_new:Npn \@@_parse_prefix_unknown:NNN #1#2#3
  {
    \cs_if_exist:cTF { @@_parse_infix_ \token_to_str:N #1 :N }
      {
        \msg_expandable_error:nnn { bigint } { missing-number } {#1}
        \exp_after:wN \c_@@_zero_bigint \exp:w \exp_end_continue_f:w
        \@@_parse_infix:NN #3 #1
      }
      {
        \msg_expandable_error:nnn { bigint } { unknown-symbol } {#1}
        \exp_after:wN \@@_parse_one:Nw \exp_after:wN #3
        \exp:w \exp_end_continue_f:nw
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Parsing a decimal number}
%
% \begin{macro}[aux, EXP]{\@@_parse_one_digit:NN}
%   A digit marks the beginning of an explicit decimal positive big
%   integer.  Once it is found, \cs{@@_parse_infix_after_operand:NwN}
%   receives the precedence |#1|, and the number (as an internal big
%   integer), and expands \cs{@@_parse_infix:NN} after the number, to
%   wrap the following infix operator as required.  Finding the number
%   itself begins by removing leading zeros: further steps are
%   described later.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_one_digit:NN #1
  {
    \exp_after:wN \@@_parse_infix_after_operand:NwN
    \exp_after:wN #1
    \exp_after:wN \s_@@
    \exp_after:wN \@@_chk:w
    \@@_int_value:w \@@_int_eval:w 0
      \@@_parse_trim_zeros:N
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_trim_zeros:N, \@@_parse_trim_end:w}
%   This function is followed by a digit.  It removes any leading zero,
%   then calls \cs{@@_parse_decimal:N} if the next token is a digit,
%   and otherwise ends the number (zero).
%    \begin{macrocode}
\cs_new:Npn \@@_parse_trim_zeros:N #1
  {
    \if:w 0 \exp_not:N #1
      \exp_after:wN \@@_parse_trim_zeros:N
      \exp:w
    \else:
      \@@_parse_trim_end:w #1
    \fi:
    \exp_end_continue_f:nw
  }
\cs_new:Npn \@@_parse_trim_end:w #1 \fi: \exp_end_continue_f:nw
  {
    \fi:
    \if_int_compare:w 9 < 1 \token_to_str:N #1 \exp_stop_f:
      \exp_after:wN \@@_parse_decimal:N
    \else:
      \exp_after:wN \@@_parse_zero:
    \fi:
    #1
  }
\cs_new:Npn \@@_parse_zero: { . 0 ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_decimal:N}
%   This function is called followed by a non-zero digit (with any
%   catcode).  The goal is to read all following digits.  This cannot
%   be done all at once, because \cs{@@_int_value:w} (which allows to
%   collect digits and continue expanding) can only go up to
%   $2^{31}-1$.  Digits will be grabbed by blocks of $8$ digits using
%   \cs{@@_parse_digits_viii:NN} and placed in an \cs{@@_int_value:w}
%   |1| construction (the |1| avoids losing leading zeros in a block),
%   with a setup removing the |1| after expansion.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_decimal:N
  {
    \exp_after:wN \@@_parse_decimal_count:w
    \exp:w \exp_end_continue_f:w \@@_parse_decimal_aux:N
  }
\cs_new:Npn \@@_parse_decimal_aux:N
  {
    \exp_after:wN \@@_parse_decimal_auxii:w
    \@@_int_value:w 1 \@@_parse_digits_viii:NN 0
  }
\cs_new:Npn \@@_parse_decimal_auxii:w 1 #1 ; #2 ; #3
  {
    \exp_after:wN \@@_use_none_stop_f:n
    \@@_int_value:w 1 #1
      \if_meaning:w 0 #3
        \exp_after:wN \@@_parse_decimal_aux:N
      \else:
        \exp_after:wN ; \@@_int_value:w 1 #2 \exp_after:wN .
      \fi:
  }
\cs_new:Npn \@@_parse_decimal_count:w #1 ; 1 #2 .
  {
    \@@_parse_decimal_count:NNNNNNNN #2 #1
      { \q_stop \@@_parse_decimal_count_end:w } ???? ??? ;
    #2 #1 ;
  }
\cs_new:Npn \@@_parse_decimal_count:NNNNNNNN #1#2#3#4#5#6#7#8
  {
    \use_none:n #1
    + 1 \@@_parse_decimal_count:NNNNNNNN
  }
\cs_new:Npn \@@_parse_decimal_count_end:w #1 ; { . + }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Parsing prefix operators}
%
% \begin{macro}[EXP, aux]{\@@_parse_prefix_+:Nw}
%   A unary~|+| does nothing: we should continue looking for a number.
%    \begin{macrocode}
\cs_new_eq:cN { @@_parse_prefix_+:Nw } \@@_parse_one:Nw
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_apply_unary:NNNwN}
%   Here, |#1| is a precedence, |#2| is some extra data used by some
%   functions, |#3| is \emph{e.g.}, \cs{@@_sin_o:w}, and expands once
%   after the calculation, |#4| is the operand, and |#5| is a
%   |\__bigint_parse_infix_...:N| function.  We feed the data~|#2|, and the
%   argument~|#4|, to the function~|#3|, which expands
%   \cs{tex_romannumeral:D} thus the \texttt{infix} function~|#5|.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_apply_unary:NNNwN #1#2#3#4@#5
  {
    #3 #2 #4 @
    \exp:w \exp_end_continue_f:w #5 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, aux]{\@@_parse_prefix_-:Nw}
%   The unary~|-| is harder: we parse the operand using
%   a precedence equal to the maximum of the previous precedence~|##1|
%   and the precedence of the unary operator, then call
%   the appropriate function \cs{@@_set_sign_o:w}.
%    \begin{macrocode}
\cs_new:cpn { @@_parse_prefix_ - :Nw } #1
  {
    \exp_after:wN \@@_parse_apply_unary:NNNwN
    \exp_after:wN #1
    \exp_after:wN ?
    \exp_after:wN \@@_set_sign_o:w
    \exp:w
    \if_int_compare:w \c_@@_prec_neg_int < #1
      \@@_parse_operand:Nw #1
    \else:
      \@@_parse_operand:Nw \c_@@_prec_neg_int
    \fi:
    \exp_end_continue_f:nw
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {\@@_parse_prefix_(:Nw, \@@_parse_lparen_after:NwN}
%   The left parenthesis is treated as a unary prefix operator because
%   it appears in exactly the same settings.  Commas will be allowed if
%   the previous precedence is $16$ (function with multiple arguments)
%   or $13$ (unary boolean \enquote{not}).  In this case, find an
%   operand using the precedence~$1$; otherwise the precedence~$0$.
%   Once the operand is found, the \texttt{lparen_after} auxiliary makes
%   sure that there was a closing parenthesis (otherwise it complains),
%   and leaves in the input stream the array it found as an operand,
%   fetching the following infix operator.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_letter:N (
  \char_set_catcode_letter:N )
  \cs_new:Npn \@@_parse_prefix_(:Nw #1
    {
      \exp_after:wN \@@_parse_lparen_after:NwN
      \exp_after:wN #1
      \exp:w
      \@@_parse_operand:Nw \c_@@_prec_zero_int
      \exp_end_continue_f:nw
    }
  \cs_new:Npn \@@_parse_lparen_after:NwN #1#2 @ #3
    {
      \token_if_eq_meaning:NNTF #3 \@@_parse_infix_):N
        {
          \@@_exp_after_array_f:w #2 \s_@@_stop
          \exp_after:wN \@@_parse_infix:NN
          \exp_after:wN #1
          \exp:w \exp_end_continue_f:nw
        }
        {
          \msg_expandable_error:nnn { bigint } { missing } { ) }
          #2 @ \use_none:n #3
        }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Parsing infix operators}
%
% \begin{macro}[aux, EXP]{\@@_parse_infix_after_operand:NwN}
%    \begin{macrocode}
\cs_new:Npn \@@_parse_infix_after_operand:NwN #1 #2;
  {
    \@@_exp_after_f:nw { \@@_parse_infix:NN #1 }
    #2;
  }
\group_begin:
  \char_set_catcode_letter:N \*
  \cs_new:Npn \@@_parse_infix:NN #1 #2
    {
      \if_catcode:w \scan_stop: \exp_not:N #2
        \str_if_eq_x:nnTF { \s_@@_mark } { \exp_not:N #2 }
          { \exp_after:wN \@@_parse_infix_mark:NNN }
          { \exp_after:wN \@@_parse_infix_juxtapose:N }
      \else:
        \exp_after:wN \@@_parse_infix_check:NNN
        \cs:w
          @@_parse_infix_ \token_to_str:N #2 :N
          \exp_after:wN
        \cs_end:
      \fi:
      #1
      #2
    }
  \cs_new:Npn \@@_parse_infix_check:NNN #1#2#3
    {
      \if_meaning:w \scan_stop: #1
        \msg_expandable_error:nnn { bigint } { missing } { * }
        \exp_after:wN \@@_parse_infix_*:N
        \exp_after:wN #2
        \exp_after:wN #3
      \else:
        \exp_after:wN #1
        \exp_after:wN #2
        \exp:w \exp_after:wN \exp_end_continue_f:nw
      \fi:
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_infix_mark:NNN}
%   As an infix operator, \cs{s_@@_mark} means that the next
%   token~(|#3|) has already gone through \cs{@@_parse_infix:NN} and
%   should be provided the precedence~|#1|.  The scan mark~|#2| is
%   discarded.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_infix_mark:NNN #1#2#3 { #3 #1 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_infix_end:N}
%   This one is a little bit odd: force every previous operator to end,
%   regardless of the precedence.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_infix_end:N #1
  { @ \use_none:n \@@_parse_infix_end:N }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]+\@@_parse_infix_):N+
%   This is very similar to \cs{@@_parse_infix_end:N}, complaining about
%   an extra closing parenthesis if the previous operator was the
%   beginning of the expression.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_letter:N \)
  \cs_new:Npn \@@_parse_infix_):N #1
    {
      \if_int_compare:w #1 = \c_@@_prec_end_int
        \msg_expandable_error:nnn { bigint } { extra } { ) }
        \exp_after:wN \@@_parse_infix:NN
        \exp_after:wN #1
        \exp:w \exp_after:wN \exp_end_continue_f:nw
      \else:
        \exp_after:wN @
        \exp_after:wN \use_none:n
        \exp_after:wN \@@_parse_infix_):N
      \fi:
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {
%     \@@_parse_infix_+:N, \@@_parse_infix_-:N,
%     \@@_parse_infix_/:N, \@@_parse_infix_*:N,
%   }
%   As described in the
%   \enquote{work plan}, each infix operator has an associated
%   \cs{infix} function, a computing function, and precedence, given as
%   arguments to \cs{@@_tmp:w}.  Using the general mechanism for
%   arithmetic operations.
%
%   The odd requirement to set \cs{+} here is to cover the case where
%   \pkg{expl3} is loaded by plain \TeX{}: \cs{+} is an \cs{outer} macro there,
%   and so the following code would otherwise give an error in that case.
%    \begin{macrocode}
\group_begin:
%<*package>
  \cs_set:Npn \+ { }
%</package>
  \char_set_catcode_letter:N \*
  \char_set_catcode_letter:N \/
  \char_set_catcode_letter:N \-
  \char_set_catcode_letter:N \+
  \cs_set_protected:Npn \@@_tmp:w #1#2#3#4
    {
      \cs_new:Npn #1 ##1
        {
          \if_int_compare:w ##1 < #3
            \exp_after:wN @
            \exp_after:wN \@@_parse_apply_binary:NwNwN
            \exp_after:wN #2
            \exp:w
            \@@_parse_operand:Nw #4
            \exp_after:wN \exp_end_continue_f:nw
          \else:
            \exp_after:wN @
            \exp_after:wN \use_none:n
            \exp_after:wN #1
          \fi:
        }
    }
  % \@@_tmp:w \@@_parse_infix_/:N / \c_@@_prec_mul_int \c_@@_prec_mul_int
  \@@_tmp:w \@@_parse_infix_*:N * \c_@@_prec_mul_int \c_@@_prec_mul_int
  \@@_tmp:w \@@_parse_infix_-:N - \c_@@_prec_add_int \c_@@_prec_add_int
  \@@_tmp:w \@@_parse_infix_+:N + \c_@@_prec_add_int \c_@@_prec_add_int
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Juxtaposition}
%
% ^^A todo: make this into an error for big integers
%
% \begin{macro}[aux, EXP]+\@@_parse_infix_(:N+
%   When an opening parenthesis appears where we expect an infix
%   operator, we compute the product of the previous operand and the
%   contents of the parentheses using \cs{@@_parse_infix_juxtapose:N}.
%    \begin{macrocode}
\cs_new:cpn { @@_parse_infix_(:N } #1
  { \@@_parse_infix_juxtapose:N #1 ( }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: can |...(1,2,3)pt| really occur?  If not, simplify.
% \begin{macro}[aux, EXP]
%   {\@@_parse_infix_juxtapose:N, \@@_parse_apply_juxtapose:NwwN}
%   Juxtaposition follows the same scheme as other binary operations,
%   but calls \cs{@@_parse_apply_juxtapose:NwwN} rather than directly
%   calling \cs{@@_parse_apply_binary:NwNwN}.  This lets us catch errors
%   such as |...(1,2,3)pt| where one operand of the juxtaposition is not
%   a single number: both |#3| and~|#5| of the \texttt{apply} auxiliary
%   must be empty.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_infix_juxtapose:N #1
  {
    \if_int_compare:w #1 < \c_@@_prec_mul_int
      \exp_after:wN @
      \exp_after:wN \@@_parse_apply_juxtapose:NwwN
      \exp:w
      \@@_parse_operand:Nw \c_@@_prec_mul_int
      \exp_after:wN \exp_end_continue_f:nw
    \else:
      \exp_after:wN @
      \exp_after:wN \use_none:n
      \exp_after:wN \@@_parse_infix_juxtapose:N
    \fi:
  }
\cs_new:Npn \@@_parse_apply_juxtapose:NwwN #1 #2;#3@ #4;#5@
  {
    \if_catcode:w ^ \tl_to_str:n { #3 #5 } ^
    \else:
      \@@_error:nffn { invalid-ii }
        { \@@_array_to_clist:n { #2; #3 } }
        { \@@_array_to_clist:n { #4; #5 } }
        { }
    \fi:
    \@@_parse_apply_binary:NwNwN #1 #2;@ * #4;@
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A end[todo]
%
% \subsection{Tree structure}
%
% \begin{macro}[int]{\@@_tree_dp:n}
%   Receives a (non-zero) multiple of $8$ digits, such that the first
%   block of $8$ digits is non-zero.  Outputs \meta{depth}.\meta{tree}
%   where a \meta{tree} is
%   \begin{itemize}
%     \item 0\Arg{tree}\Arg{tree}
%     \item 1\meta{tree}
%     \item 2\meta{8~digits}
%   \end{itemize}
%   where the |1| are positioned such that the \meta{tree} has constant depth: always the same number of steps |0|/|1|/|2| before reaching digits.
%   Examples:{\small
% \begin{verbatim}
% 0.200080008
% 1.0{200070007}{200080008}
% 2.0{1200060006}{0{200070007}{200080008}}
% 2.0{0{200050005}{200060006}}{0{200070007}{200080008}}
% 3.0{11200040004}{0{0{200050005}{200060006}}{0{200070007}{200080008}}}
% 3.0{10{200030003}{200040004}}{0{0{200050005}{200060006}}{0{200070007}{200080008}}}
% \end{verbatim}
%}
%    \begin{macrocode}
\cs_new:Npn \@@_tree_dp:n % expects "{<digits>}" (non-zero multiple of 8 digits, first block non-zero), outputs "<depth>.<tree>"
  {
    \@@_int_value:w \@@_int_eval:w -1
    \@@_tree_dp_aux:n
  }
\cs_new:Npn \@@_tree_dp_aux:n #1
  {
    \exp_after:wN \@@_tree_collect:w
    \exp:w \exp_end_continue_f:w
      \@@_tree_auxi:NNNNNNNN #1 { ? \@@_tree_auxi_end:w } ??????? ;
  }
\cs_new:Npn \@@_tree_auxi:NNNNNNNN #1#2#3#4#5#6#7#8
  {
    \use_none:n #1
    \exp_after:wN \@@_tree_push:wN \@@_int_value:w 1 #1#2#3#4#5#6#7#8
    \@@_tree_auxi:NNNNNNNN
  }
\cs_new:Npn \@@_tree_auxi_end:w #1 ;
  { ; \@@_tree_extend:nnw ; \q_stop ; }
\cs_new:Npn \@@_tree_push:wN 1 #1 ; #2
  {
    #2
      { \@@_tree_loop:nwN { ; \use_ii:nn } }
      { ; \use_i:nn }
    { 2 #1 } % tree stuff
  }
\cs_new:Npn \@@_tree_loop:nwN #1 #2 ; #3
  {
    #3
      { \@@_tree_loop:nwN { #1 ; \use_ii:nn } }
      { #1 ; \use_i:nn }
    { 0 #2 } % tree stuff
  }
\cs_new:Npn \@@_tree_extend:nnw #1 #2 #3 \q_stop
  { #2 #3 \@@_tree_extend:nnw ; \q_stop }
\cs_new:Npn \@@_tree_collect:w ; #1 #2 ; #3
  {
    + 1
    \if_meaning:w \@@_tree_extend:nnw #3
      \exp_after:wN \@@_tree_power:w
    \fi:
    #1
      { \@@_tree_collect_aux:w 1 }
      { \@@_tree_collect:w } #2 ; #3
  }
\cs_new:Npn \@@_tree_power:w #1#2#3#4 ; #5 \q_stop ; { . #4 }
\cs_new:Npn \@@_tree_collect_aux:w #1 ; #2 #3 ;
  {
    + 1
    \if_meaning:w \@@_tree_extend:nnw #2
      \exp_after:wN \@@_tree_end:w
    \fi:
    #2
      { \@@_tree_collect_aux:w 0 {#1} {#3} } % tree stuff
      { \@@_tree_collect_aux:w 1 #1 } % tree stuff
    ;
  }
\cs_new:Npn \@@_tree_end:w #1#2#3 ; \q_stop ; { \use_i:nnn . #3 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_diff_sign:w}
%   Expects \meta{tree_1} |;| \meta{tree_2} |;| of identical depths,
%   and must be used in
%   \cs{if_case:w}.  Takes case~$0$ if the numbers are equal, case~$1$
%   if \meta{tree_1} is bigger, and case~$-1$ if it is smaller, than
%   \meta{tree_2}.
%   The primitive \tn{pdfstrcmp} is not suitable as it would require
%   unpacking all of the tree rather than just the first few leaves.
%    \begin{macrocode}
\cs_new:Npn \@@_diff_sign:w #1 ; #2 ;
  { \@@_diff_sign_aux:w #1 ; #2 ; 0 \exp_stop_f: }
\cs_new:Npn \@@_diff_sign_aux:w #1#2 ; #3
  {
    \if_meaning:w #1 #3 \else:
      \if_meaning:w 1 #1 - \fi: 1 \exp_stop_f:
    \fi:
    \if_case:w #1 \exp_stop_f:
           \exp_after:wN \@@_diff_sign_pp:w
    \or:   \exp_after:wN \@@_diff_sign_aux:w
    \else: \exp_after:wN \@@_diff_sign_dd:w
    \fi:
    #2 ;
  }
\cs_new:Npn \@@_diff_sign_pp:w #1 #2 ; #3 #4 ;
  {
    \@@_diff_sign_aux:w #1 ; #3 ;
    \@@_diff_sign_aux:w #2 ; #4 ;
  }
\cs_new:Npn \@@_diff_sign_dd:w #1 ; #2 ;
  {
    \if_int_compare:w #1 < #2 - 1 \exp_stop_f: \fi:
    \if_int_compare:w #1 > #2 \exp_stop_f: 1 \exp_stop_f: \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_tint_open:w, \@@_tint_open_z:nn}
%   Convert tree to integer (stream of digits) with ``open'' integer
%   expression which can be closed by anything.
%    \begin{macrocode}
\cs_new:Npn \@@_tint_open:w #1
  {
    \if_case:w #1 \exp_stop_f:
           \exp_after:wN \@@_tint_open_z:nn
    \or:   \exp_after:wN \@@_tint_open:w
    \else: \exp_after:wN \@@:w
    \fi:
  }
\cs_new:Npn \@@_tint_open_z:nn #1#2
  { \@@_tint_open:w #1 \@@_tint_open:w #2 }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}[int, EXP]{\c_@@_carry_int, \@@_carry:N, \@@:w}
%   ^^A todo: these should be renamed.
%    \begin{macrocode}
\int_const:Nn \c_@@_carry_int { 2 0000 0000 }
\cs_new_protected:Npn \@@_carry:N #1
  {
    + #1 - 2
    \@@_int_eval_end:
  }
\cs_new_protected:Npn \@@:w
  {
    \exp_after:wN \@@_carry:N
    \@@_int_value:w \@@_int_eval:w \c_@@_carry_int +
  }
%    \end{macrocode}
% \end{variable}
%
% \subsection{Addition and subtraction}
%
% \begin{macro}[int, EXP]{\@@_wrapup:Nw}
%    \begin{macrocode}
\cs_new:Npn \@@_wrapup:Nw #1
  {
    + 1
    \@@_wrapup_zeros:wNNNNNNNN . #1 00000000 0000000
  }
\cs_new:Npn \@@_wrapup_zeros:wNNNNNNNN . #1 00000000 #2#3#4#5#6#7#8#9
  {
    \if_int_compare:w #2#3#4#5#6#7#8#9 = 0 \exp_stop_f:
      - 1 \exp_after:wN \@@_wrapup_zeros:wNNNNNNNN
    \fi:
    . #1 #2#3#4#5#6#7#8#9
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_set_sign_o:w}
% \begin{macro}[aux, EXP]{\@@_set_sign_aux_o:Nw}
%    \begin{macrocode}
\cs_new:Npn \@@_set_sign_o:w ? \s_@@ \@@_chk:w #1 . #2 #3 ; @
  {
    \if_meaning:w + #2 \@@_set_sign_aux_o:Nw - \fi:
    \if_meaning:w - #2 \@@_set_sign_aux_o:Nw + \fi:
    \@@_exp_after_o:w \s_@@ \@@_chk:w #1 . #2 #3 ;
  }
\cs_new:Npn \@@_set_sign_aux_o:Nw #1 #2 . #3 { #2 . #1 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_return_i_o:w}
%    \begin{macrocode}
\cs_new:Npn \@@_return_i_o:w #1 \s_@@ #2 ; \s_@@ #3 ;
  { \@@_exp_after_o:w \s_@@ #2 ; }
\cs_new:Npn \@@_return_ii_o:w #1 \s_@@ #2 ;
  { \@@_exp_after_o:w }
\cs_new:Npn \@@_return_zero_o:w #1 \s_@@ #2 ; \s_@@ #3 ;
  { \exp_after:wN \c_@@_zero_bigint }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_+_o:ww, \@@_-_o:ww}
%    \begin{macrocode}
\cs_new:Npn \@@_set_sign_ii:Nw #1 #2 ; #3 . #4 { #2 ; #3 . #1 }
\cs_new:Npn \@@_num_swap:www #1 \s_@@ #2 ; \s_@@ #3 ; { #1 \s_@@ #3 ; \s_@@ #2 ; }
\use:x
  {
    \exp_not:n { \cs_new:cpn { @@_-_o:ww } \s_@@ \@@_chk:w #1 ; \s_@@ \@@_chk:w #2 . #3 }
      {
        \exp_not:n { \if_meaning:w + #3 \@@_set_sign_ii:Nw - \fi: }
        \exp_not:n { \if_meaning:w - #3 \@@_set_sign_ii:Nw + \fi: }
        \exp_not:c { @@_+_o:ww }
        \exp_not:n { \s_@@ \@@_chk:w #1 ; \s_@@ \@@_chk:w #2 . #3 }
      }
  }
\cs_new:cpn { @@_+_o:ww } \s_@@ \@@_chk:w #1.#2#3 ; \s_@@ \@@_chk:w #4.#5
  {
    \if_meaning:w 0 #4 \exp_after:wN \@@_return_i_o:w \fi:
    \if_meaning:w 0 #1 \exp_after:wN \@@_return_ii_o:w \fi:
    \if_int_compare:w #1 > #4 \exp_stop_f:
      \@@_num_swap:www
    \fi:
    \@@_add_auxii_o:ww
      \s_@@ \@@_chk:w #1.#2 #3 ;
      \s_@@ \@@_chk:w #4.#5
  }
\cs_new:Npn \@@_add_auxii_o:ww
    \s_@@ \@@_chk:w #1.#2#3 ;
    \s_@@ \@@_chk:w #4.#5
  {
    \exp_after:wN \s_@@
    \exp_after:wN \@@_chk:w
    \@@_int_value:w \@@_int_eval:w #4 % will need to be incremented in case of a carry block or decremented for blocks of zeros
      \exp_after:wN \@@_add_auxiii_o:w
      \@@_int_value:w \@@_tree_dp:n {#3} ;
      { #2 #5 #1 = - #4 } #2 #5 \q_mark % { <rel-sign> <cA> = - <cB> } <sA> <sB>
  }
\cs_new:Npn \@@_add_auxiii_o:w #1 \q_mark #2 ;
  {
    \exp_after:wN \@@_add_auxiv_o:w
    \@@_int_value:w \@@_tree_dp:n {#2} ;
    #1
  }
% We can at last compare trees to find out what the final sign will be!
\cs_new:Npn \@@_add_auxiv_o:w #1 . #2 ; #3 . #4 ; #5#6#7
  {
    \if_int_compare:w #5 \exp_stop_f: % true if different signs and same number of digits
      \if_case:w \@@_diff_sign:w #4 ; #2 ;
           \exp_after:wN \@@_add_zero:w
      \or: \@@_add_swap:Nw #6
      \fi:
    \fi:
    \exp_after:wN \@@_wrapup:Nw
    \exp_after:wN #7
    \@@_int_value:w \@@_int_eval:w 0
      \prg_replicate:nn { #1 - #3 } { \@@_add_unwrap:w }
      \if_meaning:w #6 #7
        \exp_after:wN \@@_add_auxv:Nw \exp_after:wN +
      \else:
        \exp_after:wN \@@_add_auxv:Nw \exp_after:wN -
      \fi:
      \q_mark
      #2 ;
      #4 ;
      \exp_after:wN ;
  } % for now, put larges tree first for pruning by \@@_wrapup:Nw, then exchange so that testing for 1... is faster.
    % Also add \exp_after:wN so drop "_o" from names.
\cs_new:Npn \@@_add_zero:w \fi: #1 ; #2 ;
  { \fi: * 0 \exp_after:wN . \exp_after:wN 0 }
\cs_new:Npn \@@_add_swap:Nw
    #1 \fi: \fi: #2 \q_mark #3 ; #4 ;
  {
    \fi: \fi:
    \exp_after:wN \@@_wrapup:Nw
    \exp_after:wN #1
    \@@_int_value:w \@@_int_eval:w 0
      \@@_add_auxv:Nw - \q_mark #4 ; #3 ;
  }
\cs_new:Npn \@@_add_unwrap:w #1 \q_mark 0 #2 #3 ;
  {
    \@@_tint_open:w #2
    #1 \q_mark #3 ;
  }
\cs_new:Npn \@@_add_auxv:Nw #1 \q_mark #2 ; #3 ;
  { \@@_add_auxvi:Nw #1 #3 ; #2 ; } % now the smallest tree is in front.
\cs_new:Npn \@@_add_auxvi:Nw #1#2
  {
    \if_case:w #2 \exp_stop_f:
           \exp_after:wN \@@_add_auxviz:w
    \or:   \exp_after:wN \@@_add_auxvii:w
    \else: \exp_after:wN \@@_add_auxvin:w
    \fi:
    #1 #2
  }
\cs_new:Npn \@@_add_auxviz:w #1 0 #2 #3 ; 0 #4 #5 ;
  {
    \@@_add_auxvi:Nw #1 #2 ; #4 ;
    \@@_add_auxvi:Nw #1 #3 ; #5 ;
  }
\cs_new:Npn \@@_add_auxvii:w #1 1 #2 ; #3
  {
    \if_case:w #3 \exp_stop_f:
      \exp_after:wN \@@_add_auxviiz:w
    \else:
      \exp_after:wN \@@_add_auxviii:w
    \fi:
    #1 1 #2 ; #3
  }
\cs_new:Npn \@@_add_auxviiz:w #1 1 #2 ; 0 #3 #4 ;
  {
    \@@_tint_open:w #3
    \@@_add_auxvi:Nw #1 #2 ; #4 ;
  }
\cs_new:Npn \@@_add_auxviii:w #1 1 #2 ; 1 #3 ;
  { \@@_add_auxvi:Nw #1 #2 ; #3 ; }
\cs_new:Npn \@@_add_auxvin:w #1 2 #2 ; 2 #3 ;
  {
    \@@:w #3 #1 #2 % big (+|-) small
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Multiplication}
%
% \begin{macro}[int, EXP]{\@@_*_o:ww}
%   In \pkg{l3fp}, expansions are cleverly nested to avoid passing
%   arguments around too much.  For the very large numbers that
%   \pkg{l3bigint} manipulates, this is not a good idea because we
%   quickly reach \TeX{}'s maximum expansion depth (in an early
%   implementation, \pkg{l3bigint} would only handle products of
%   $512$-digit numbers before reaching an expansion depth of $10000$).
%   Crucially, the ``expansion after'' required by the parsing
%   machinery is done by \cs{@@_exp_after_o:w} after all
%   computations are done.
%    \begin{macrocode}
\cs_new:cpn { @@_*_o:ww } \s_@@ \@@_chk:w #1.#2#3 ; \s_@@ \@@_chk:w #4.#5
  {
    \if_meaning:w 0 #1 \exp_after:wN \@@_return_i_o:w \fi:
    \if_meaning:w 0 #4 \exp_after:wN \@@_return_ii_o:w \fi:
    \@@_mul_aux_o:ww
      \s_@@ \@@_chk:w #1.#2 #3 ;
      \s_@@ \@@_chk:w #4.#5
  }
\cs_new:Npn \@@_mul_aux_o:ww
    \s_@@ \@@_chk:w #1.#2#3 ;
    \s_@@ \@@_chk:w #4.#5
  {
    \exp_after:wN \@@_exp_after_o:w
    \exp_after:wN \s_@@
    \exp_after:wN \@@_chk:w
    \@@_int_value:w \@@_int_eval:w #1 + #4
      \if_meaning:w #2 #5
        \exp_after:wN \@@_wrapup:Nw
        \exp_after:wN + \@@_int_value:w
      \else:
        \exp_after:wN \@@_wrapup:Nw
        \exp_after:wN - \@@_int_value:w
      \fi:
      \@@_int_eval:w 0
        \exp_after:wN \@@_mul_auxii:w
        \@@_int_value:w \@@_tree_dp:n {#3} ;
  }
\cs_new:Npn \@@_mul_auxii:w #1 . #2 ; #3 ;
  {
    \exp_after:wN \@@_mul_auxiii:w
    \@@_int_value:w #1 \exp_after:wN .
    \@@_int_value:w \@@_tree_dp:n {#3} ; 0 . #2 ;
  }
\cs_new:Npn \@@_mul_auxiii:w #1 . #2 . % #3 ; 0 . #4 ;
  {
    \if_int_compare:w #1 = #2 \exp_stop_f: \else:
      \if_int_compare:w #1 < #2 \exp_stop_f:
        \exp_args:Nnf \@@_mul_adjust_depth:nnw
          { } { \prg_replicate:nn { #2 - #1 } { 1 } }
      \else:
        \exp_args:Nf \@@_mul_adjust_depth:nnw
          { \prg_replicate:nn { #1 - #2 } { 1 } }
          { }
      \fi:
    \fi:
    \exp_after:wN \@@_mul_auxiv:w
    \@@_int_value:w \@@_tmul:w 0 .
  }
\cs_new:Npn \@@_mul_adjust_depth:nnw #1 #2 #3 . #4 .
  { #3 . #1 #4 . #2 }
\cs_new:Npn \@@_mul_auxiv:w 0 . { \@@_tint_open:w }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}[int, EXP]{\@@_carry_v:N}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_carry_v:N #1#2 .
  {
    \@@_int_value:w \@@_int_eval:w #1 - 2 .
    2 #2 +
  }
\cs_new_protected:Npn \@@_v:Nw #1 #2 .
  {
    \exp_after:wN \@@_carry_v:N
    \@@_int_value:w \@@_int_eval:w \c_@@_carry_int
    #1 #2 0000 0000 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}[int]{\c_@@_middle_int}
%    \begin{macrocode}
\int_const:Nn \c_@@_leading_int { 2 }
\int_const:Nn \c_@@_middle_int { 1 9998 0000 }
\int_const:Nn \c_@@_trailing_int { 2 0000 0000 }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int, EXP]{\@@_topen:w}
%   \cs{@@_topen:w} should be followed by (|+|$\mid$|-|) \meta{carry}
%   |.| \meta{tree} \meta{more~intexpr} |.| It f-expands to
%   \meta{carry'} |.| \meta{tree'} |+| where the \meta{more~intexpr}
%   was added to the \meta{tree} as appropriate, with a possible carry.
%    \begin{macrocode}
\cs_new:Npn \@@_topen:w #1 #2 . #3
  {
    \if_case:w #3 \exp_stop_f:
      \exp_after:wN \@@_topen_aux:wnn
    \or:
      \exp_after:wN \@@_topen_one:w
      \@@_int_value:w \exp_after:wN \@@_topen:w
    \else:
      \exp_after:wN \@@_v:Nw
    \fi:
    #1 #2 .
  }
\cs_new:Npn \@@_topen_one:w #1 . { #1 . 1 }
\cs_new:Npn \@@_topen_aux:wnn #1 #2 . #3#4
  {
    \exp_after:wN \@@_topen_wrap:w
    \@@_int_value:w
      \@@_topen:w #1 #2 . #3 +
      \@@_topen:w #1  0 . #4
  }
\cs_new:Npn \@@_topen_wrap:w #1 . #2 + #3 + { #1 . 0 {#2} {#3} + }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_tadd_open:w}
%   \cs{@@_tadd_open:w} should be followed by (|+|$\mid$|-|)
%   \meta{carry_1} |.| \meta{tree_1} |+| \meta{carry_2} |.|
%   \meta{tree_2} \meta{more~intexpr} |.| It computes the second tree
%   (|+|$\mid$|-|) the first; the result must be in the interval
%   $[-1,8)$.  The function |f|-expands to the form \meta{carry} |.|
%   \meta{tree} |+| (including the plus sign).
%
%   We distinguish cases depending on the first digits |#2| and |#4| of
%   the two tree.
%   \begin{itemize}
%   \item $(0, 0)$ => case 0 => |pp| (pair, pair)
%   \item $(0, 1)$ => case 1 => |pt| (pair, tree)
%   \item $(2, 2)$ => case 2 => |dd| (digits, digits)
%   \item $(1, 0)$ => case 3 => |tp| (tree, pair)
%   \item $(1, 1)$ => case 13 => |tt| (tree, tree)
%   \end{itemize}
%    \begin{macrocode}
\cs_new:Npn \@@_tadd_open:w #1 . #2 #3 . #4 % <op> <carry> . <tree> + <carry> . <tree> <rest~of~intexpr> .
  {
    \if_case:w #4 \if_meaning:w 1 #2 3 \fi: \exp_stop_f:
            \exp_after:wN \@@_tadd_pp:w
    \or:    \exp_after:wN \@@_tadd_pt:w
    \or:    \exp_after:wN \@@_tadd_dd:w
    \or:    \exp_after:wN \@@_tadd_tp:w
    \else:  \exp_after:wN \@@_tadd_tt:w
    \fi:
    #1 . #2 #3 . #4
  }
\cs_new:Npn \@@_tadd_pp:w #1#2 .0 #3#4 + #5 .0#6#7
  {
    \exp_after:wN \@@_topen_wrap:w
    \@@_int_value:w
      \@@_tadd_open:w #1 #2 . #3 + #5 . #6 +
      \@@_tadd_open:w #1  0 . #4 +  0 . #7
  }
\cs_new:Npn \@@_tadd_pt:w #1 #2 .0 #3#4 + #5 .1
  {
    \exp_after:wN \@@_topen_wrap:w
    \@@_int_value:w
      \@@_topen:w #1 #2 . #3 +
      \@@_tadd_open:w #1 0 . #4 + #5 .
  }
\cs_new:Npn \@@_tadd_tp:w #1 #2 .1 #3 + #4 .0 #5#6
  {
    \exp_after:wN \@@_topen_wrap:w
    \@@_int_value:w
      \@@_topen:w + #4 . #5 +
      \@@_tadd_open:w #1 #2 . #3 + 0 . #6
  }
\cs_new:Npn \@@_tadd_tt:w #1 #2 .1 #3 + #4 .1
  {
    \exp_after:wN \@@_topen_one:w
    \@@_int_value:w \@@_tadd_open:w #1 #2 . #3 + #4 .
  }
\cs_new:Npn \@@_tadd_dd:w #1 #2 . 2 #3 + #4 . 2 % #5 <more~intexpr> .
  { \@@_v:Nw #1 #2 . #3 + #4 0000 0000 + }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_tmul:w}
%   Assume |depth(tree_1) = depth(tree_2)|, achieved in rest of code by
%   adding leading |1|.  Given |0.|\meta{tree}|;| |0.|\meta{tree}|;|
%   produces the product as |0.|\meta{tree}|;| The resulting tree has
%   |depth = 1+depth(tree_1)|, thus can have the form |0{...}{...}| or
%   |1...| but not |2...|.
%    \begin{macrocode}
\cs_new:Npn \@@_tmul:w 0 . #1 #2 ; 0 . #3
  {
    \if_case:w #3 \if_meaning:w 1 #1 3 \fi: \exp_stop_f:
            \exp_after:wN \@@_tmul_pp:w
    \or:    \exp_after:wN \@@_tmul_pt:w
    \or:    \exp_after:wN \@@_tmul_dd:w
    \or:    \exp_after:wN \@@_tmul_tp:w
    \else:  \exp_after:wN \@@_tmul_tt:w
    \fi:
    0 . #1 #2 ; 0 . #3
  }
\cs_new:Npn \@@_tmul_dd:w 0 . 2 #1#2#3#4 #5 ; 0 . 2
  { \@@_tmul_dd_aux:w #1#2#3#4 . #5 ; }
\cs_new:Npn \@@_tmul_dd_aux:w #1 . #2 ; #3#4#5#6 #7 ;
  {
    \exp_after:wN \@@_tmul_dd_last:Nwww
    \@@_int_value:w \@@_int_eval:w \c_@@_middle_int + #1 * #3#4#5#6
      \exp_after:wN \@@_tmul_dd_next:NNNNN
      \@@_int_value:w \@@_int_eval:w \c_@@_middle_int + #2 * #3#4#5#6 + #1 * #7
        \exp_after:wN \@@_tmul_dd_next:NNNNN
        \@@_int_value:w \@@_int_eval:w \c_@@_trailing_int + #2 * #7 ;
  }
\cs_new:Npn \@@_tmul_dd_next:NNNNN #1#2#3#4#5 { + #1#2#3#4#5 . }
\cs_new:Npn \@@_tmul_dd_last:Nwww #1#2 . #3 . #4 ;
  {
    \@@_int_value:w \@@_int_eval:w #1 - \c_@@_leading_int .
    0 { 2 #2 } { 2 #3 #4 } ;
  }
\cs_new:Npn \@@_tmul_tt:w 0 . 1 #1 ; 0 . 1 % #2 ;
  {
    \exp_after:wN \@@_topen_one:w
    \@@_int_value:w \@@_tmul:w 0 . #1 ; 0 . % #2 ;
  }
\cs_new:Npn \@@_tmul_pt:w 0 . 0 #1 #2 ; 0 . 1 #3 ;
  {
    \exp_last_two_unbraced:Noo \@@_tmul_tp_aux:w
      { \@@_int_value:w \@@_tmul:w 0 . #1 ; 0 . #3 ; }
      { \@@_int_value:w \@@_tmul:w 0 . #2 ; 0 . #3 ; }
  }
\cs_new:Npn \@@_tmul_tp:w 0 . 1 #1 ; 0 . 0 #2 #3 ;
  {
    \exp_last_two_unbraced:Noo \@@_tmul_tp_aux:w
      { \@@_int_value:w \@@_tmul:w 0 . #1 ; 0 . #2 ; }
      { \@@_int_value:w \@@_tmul:w 0 . #1 ; 0 . #3 ; }
  }
\cs_new:Npn \@@_tmul_tp_aux:w 0 . #1 % the second tree is necessarily 0{}{}!
  {
    \if_meaning:w 0 #1
      \exp_after:wN \@@_tmul_tp_pp:w
    \else:
      \exp_after:wN \@@_tmul_tp_tp:w
    \fi:
    0 . #1
  }
\cs_new:Npn \@@_tmul_tp_tp:w 0 . 1 #1 ; 0 . 0 #2
  {
    \exp_after:wN \@@_tmul_tp_tp_wrap:w
    \@@_int_value:w
      \@@_tadd_open:w + 0 . #1 + 0 . #2 .
  }
\cs_new:Npn \@@_tmul_tp_tp_wrap:w 0 . #1 + % #2 ;
  { 0 . 1 0 {#1} } % {#2} ;
\cs_new:Npn \@@_tmul_tp_pp:w 0 . 0 #1 #2 ; 0 . 0 #3 % #4 ;
  {
    \exp_after:wN \@@_tmul_tp_pp_wrap:w
    \@@_int_value:w
      \@@_topen:w     + 0 . #1 +
      \@@_tadd_open:w + 0 . #2 + 0 . #3 . % {#4} ;
  }
\cs_new:Npn \@@_tmul_tp_pp_wrap:w 0 . #1 + #2 + #3 ;
  { 0 . 0 { 1 #1 } { 0 {#2} {#3} } ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_tmul_pp:w}
%   This is the crux of Karatsuba's method.  To compute
%   $(10^{k} a + b)(10^{k} c + d)$, we can compute $ac$ and $bd$ and
%   compute $ad+bc = $ either as $(a+b)(c+d)-ac-bd$ or as
%   $ac+bd-(a-b)(c-d)$.  We use the differences $a-b$ and $c-d$ instead
%   of the sums, because that avoids carries which accumulate and
%   require extra code.  To avoid sign issues we need to do subtractions
%   in the correct order, and worry about the overall sign too.
%    \begin{macrocode}
\cs_new:Npn \@@_tmul_pp:w 0 . 0 #1 #2 ; 0 . 0 #3 #4 ;
  {
    \use:nooo \@@_tmul_pp_auxii:w
      {
        \@@_int_value:w
        \exp_last_two_unbraced:Noo \@@_tmul_pp_aux:w
          {
            \@@_int_value:w
            \if_case:w \@@_diff_sign:w #2 ; #1 ;
            \or: \@@_tmul_pp_swap:w
            \fi:
            \@@_tadd_open:w - 0 . #2 + 0 . #1 . +
          }
          {
            \@@_int_value:w
            \if_case:w \@@_diff_sign:w #4 ; #3 ;
            \or: \@@_tmul_pp_swap:w
            \fi:
            \@@_tadd_open:w - 0 . #4 + 0 . #3 . +
          }
      }
      { \@@_int_value:w \@@_tmul:w 0 . #2 ;  0 . #4 ; }
      { \@@_int_value:w \@@_tmul:w 0 . #1 ; 0 . #3 ; }
  }
\cs_new:Npn \@@_tmul_pp_swap:w #1 - 0 . #2 + 0 . #3 . +
  { #1 - 0 . #3 + 0 . #2 . - }
\cs_new:Npn \@@_tmul_pp_aux:w 0 . #1 + #2 0 . #3 + #4
  { \@@_tmul:w 0 . #1 ; 0 . #3 ; #2 #4 }
\cs_new:Npn \@@_tmul_pp_auxii:w 0 . #1 ; #2#3 0 . #4 ; 0 . #5#6 ;
  {
    \exp_after:wN \@@_tmul_pp_auxiii:Nw
    \exp_after:wN #5
    \@@_int_value:w
    \exp_after:wN \@@_tadd_open:w \exp_after:wN +
    \@@_int_value:w
      \if_meaning:w #2 #3
        \exp_after:wN \@@_tadd_open:w \exp_after:wN -
      \else:
        \exp_after:wN \@@_tadd_open:w \exp_after:wN +
      \fi:
      0 . #1 + 0 . #5#6 . 0 . #4 .
    0 . #4 ; 0 . #5#6 ;
  }
\cs_new:Npn \@@_tmul_pp_auxiii:Nw #1 #2 +
  {
    \if_case:w #1 \exp_stop_f:
      \exp_after:wN \@@_tmul_pp_p:w
    \else:
      \exp_after:wN \@@_tmul_pp_t:w
    \fi:
    #2 ;
  }
\cs_new:Npn \@@_tmul_pp_p:w #1 . 0 #2 #3 ; 0 . 0 #4 #5 ; 0 . 0 #6 #7 ;
  {
    \exp_after:wN \@@_tmul_pp_p_wrap:w
    \@@_int_value:w
      \@@_topen:w     +  0 . #6 +
      \@@_tadd_open:w +  0 . #7 + #1 . #2 +
      \@@_tadd_open:w +  0 . #3 + 0 . #4 . #5 ;
  }
\cs_new:Npn \@@_tmul_pp_p_wrap:w 0 . #1 + #2 + #3 + #4 ;
  { 0 . 0 { 0 {#1} {#2} } { 0 {#3} {#4} } ; }
\cs_new:Npn \@@_tmul_pp_t:w #1 . 0 #2 #3 ; 0 . 0 #4 #5 ; 0 . 1 #6 ;
  {
    \exp_after:wN \@@_tmul_pp_t_wrap:w
    \@@_int_value:w
      \@@_tadd_open:w + 0 . #6 + #1 . #2 +
      \@@_tadd_open:w + 0 . #3 +  0 . #4 . #5 ;
  }
\cs_new:Npn \@@_tmul_pp_t_wrap:w #1 . #2 + #3 + #4 ; % ^^A todo: can #1 be non-zero???
  { #1 . 0 { 1 #2 } { 0 {#3} {#4} } ; }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Division, rounded and truncated}
%
% Will be based on [Christoph Burnikel and Joachim Ziegler. Fast
% Recursive Division. Research Report MPI-I-98-1-022,
% Max-Planck-Institut f\"ur Informatik, Im Stadtwald, D-66123
% Saarbr\"ucken, Germany, October 1998], but with a lot of boiler-plate
% code due to writing this in \TeX{}.
%
% \subsection{Big integer expressions}
%
% \begin{macro}[EXP]{\bigint_use:N, \bigint_use:c, \bigint_eval:n}
% \begin{macro}[int, EXP]{\@@_use:w}
% \begin{macro}[aux, EXP]{\@@_use_aux:NN}
%   Expand the variable or parse the expression with \cs{@@_parse:n}.
%   Then \cs{@@_use:w}.
%    \begin{macrocode}
\cs_new:Npn \bigint_use:N #1 { \exp_after:wN \@@_use:w #1 }
\cs_generate_variant:Nn \bigint_use:N { c }
\cs_new:Npn \bigint_eval:n
  { \exp_after:wN \@@_use:w \exp:w \@@_parse:n }
\cs_new:Npn \@@_use:w \s_@@ \@@_chk:w #1 . #2#3 ;
  {
    \token_if_eq_meaning:NNTF 0 #2
      { 0 }
      { \@@_int_value:w #2 \@@_use_aux:NN \exp_stop_f: }
    #3
  }
\cs_new:Npn \@@_use_aux:NN \exp_stop_f: #1
  {
    #1
    \if_meaning:w 0 #1
      \exp_after:wN \@@_use_aux:NN
    \fi:
    \exp_stop_f:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_abs:n}
% \begin{macro}[int, EXP]{\@@_abs:w}
%    \begin{macrocode}
\cs_new:Npn \bigint_abs:n
  { \exp_after:wN \@@_abs:w \exp:w \@@_parse:n }
\cs_new:Npn \@@_abs:w \s_@@ \@@_chk:w #1 . #2#3 ;
  {
    \token_if_eq_meaning:NNTF 0 #2
      { 0 }
      { \@@_int_value:w \@@_use_aux:NN \exp_stop_f: }
    #3
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_div_round:nn}
%   ^^A todo: missing!
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_div_truncate:nn}
%   ^^A todo: missing!
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_max:nn, \bigint_min:nn}
% \begin{macro}[aux, EXP]{\@@_max:wwN}
%   Parse, compare, and use.
%    \begin{macrocode}
\cs_new:Npn \bigint_max:nn #1#2
  {
    \@@_parse_do:nn {#2}
      { \@@_parse_do:nn {#1} { \@@_max:wwN } } >
  }
\cs_new:Npn \bigint_min:nn #1#2
  {
    \@@_parse_do:nn {#2}
      { \@@_parse_do:nn {#1} { \@@_max:wwN } } <
  }
\cs_new:Npn \@@_max:wwN #1 ; #2 ; #3
  {
    \int_compare:nNnTF
      { \@@_compare:ww #1 ; #2 ; } #3 { 0 }
      { \@@_use:w #1 ; }
      { \@@_use:w #2 ; }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_mod:nn}
%   ^^A todo: missing!
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_sign:n}
% \begin{macro}[int, EXP]{\@@_sign:w}
%   Parse the expression with \cs{@@_parse:n}, then \cs{@@_sign:w}.
%    \begin{macrocode}
\cs_new:Npn \bigint_sign:n
  { \exp_after:wN \@@_sign:w \exp:w \@@_parse:n }
\cs_new:Npn \@@_sign:w \s_@@ \@@_chk:w #1 . #2#3 ;
  {
    \token_if_eq_meaning:NNTF 0 #2
      { 0 }
      { \token_if_eq_meaning:NNF + #2 { - } 1 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Creating and initialising big integers}
%
% \begin{macro}{\bigint_new:N, \bigint_new:c}
%   Big integers are simply token lists initialized at~$0$.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_new:N #1
  { \cs_new_eq:NN #1 \c_@@_zero_bigint }
\cs_generate_variant:Nn \bigint_new:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}
%   {\l_tmpa_bigint, \l_tmpb_bigint,\g_tmpa_bigint, \g_tmpb_bigint}
%    \begin{macrocode}
\bigint_new:N \l_tmpa_bigint
\bigint_new:N \l_tmpb_bigint
\bigint_new:N \g_tmpa_bigint
\bigint_new:N \g_tmpb_bigint
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\bigint_const:Nn, \bigint_const:cn}
%   Constant token list.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_const:Nn #1#2
  { \tl_const:Nx #1 { \exp:w \@@_parse:n {#2} } }
\cs_generate_variant:Nn \bigint_const:Nn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\bigint_zero:N, \bigint_zero:c}
% \begin{macro}{\bigint_gzero:N, \bigint_gzero:c}
%   Functions that reset a \meta{big integer} to zero.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_zero:N  #1 { \cs_set_eq:NN #1 \c_@@_zero_bigint }
\cs_new_protected:Npn \bigint_gzero:N #1 { \cs_gset_eq:NN #1 \c_@@_zero_bigint }
\cs_generate_variant:Nn \bigint_zero:N  { c }
\cs_generate_variant:Nn \bigint_gzero:N { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {
%     \bigint_zero_new:N, \bigint_zero_new:c,
%     \bigint_gzero_new:N, \bigint_gzero_new:c
%   }
%   Create a variable if needed, otherwise clear it.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_zero_new:N  #1
  { \bigint_if_exist:NTF #1 { \bigint_zero:N #1 } { \bigint_new:N #1 } }
\cs_new_protected:Npn \bigint_gzero_new:N #1
  { \bigint_if_exist:NTF #1 { \bigint_gzero:N #1 } { \bigint_new:N #1 } }
\cs_generate_variant:Nn \bigint_zero_new:N  { c }
\cs_generate_variant:Nn \bigint_gzero_new:N { c }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: document that the RHS shouldn't be a normal integer (or change the code)
% \begin{macro}
%   {
%     \bigint_set_eq:NN, \bigint_set_eq:cN,
%     \bigint_set_eq:Nc, \bigint_set_eq:cc,
%     \bigint_gset_eq:NN, \bigint_gset_eq:cN,
%     \bigint_gset_eq:Nc, \bigint_gset_eq:cc
%   }
%   Copy the tl functions.
%    \begin{macrocode}
\cs_new_eq:NN \bigint_set_eq:NN \tl_set_eq:NN
\cs_new_eq:NN \bigint_gset_eq:NN \tl_gset_eq:NN
\cs_generate_variant:Nn \bigint_set_eq:NN { c , Nc , cc }
\cs_generate_variant:Nn \bigint_gset_eq:NN { c , Nc , cc }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\bigint_if_exist:N, \bigint_if_exist:c}
%   Copies of the \texttt{cs} functions defined in \pkg{l3basics}.
%    \begin{macrocode}
\prg_new_eq_conditional:NNn \bigint_if_exist:N \cs_if_exist:N { TF , T , F , p }
\prg_new_eq_conditional:NNn \bigint_if_exist:c \cs_if_exist:c { TF , T , F , p }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Setting and incrementing big integers}
%
% \begin{macro}{\bigint_add:Nn, \bigint_add:cn}
% \begin{macro}{\bigint_gadd:Nn, \bigint_gadd:cn}
% \begin{macro}{\bigint_sub:Nn, \bigint_sub:cn}
% \begin{macro}{\bigint_gsub:Nn, \bigint_gsub:cn}
%   Use \cs{bigint_set:Nn} or \cs{bigint_gset:Nn} with the appropriate
%   expression, remembering to put parentheses so that the minus sign
%   applies to the whole expression~|#2|.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_add:Nn #1#2
  { \bigint_set:Nn  #1 { #1 +  #2  } }
\cs_new_protected:Npn \bigint_gadd:Nn #1#2
  { \bigint_gset:Nn #1 { #1 +  #2  } }
\cs_new_protected:Npn \bigint_sub:Nn #1#2
  { \bigint_set:Nn  #1 { #1 - (#2) } }
\cs_new_protected:Npn \bigint_gsub:Nn #1#2
  { \bigint_gset:Nn #1 { #1 - (#2) } }
\cs_generate_variant:Nn \bigint_add:Nn  { c }
\cs_generate_variant:Nn \bigint_gadd:Nn { c }
\cs_generate_variant:Nn \bigint_sub:Nn  { c }
\cs_generate_variant:Nn \bigint_gsub:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\bigint_incr:N, \bigint_incr:c}
% \begin{macro}{\bigint_gincr:N, \bigint_gincr:c}
% \begin{macro}{\bigint_decr:N, \bigint_decr:c}
% \begin{macro}{\bigint_gdecr:N, \bigint_gdecr:c}
%   The same, using $1$ as a second argument.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_incr:N #1 { \bigint_add:Nn #1 { 1 } }
\cs_new_protected:Npn \bigint_decr:N #1 { \bigint_sub:Nn #1 { 1 } }
\cs_new_protected:Npn \bigint_gincr:N #1 { \bigint_gadd:Nn #1 { 1 } }
\cs_new_protected:Npn \bigint_gdecr:N #1 { \bigint_gsub:Nn #1 { 1 } }
\cs_generate_variant:Nn \bigint_incr:N  { c }
\cs_generate_variant:Nn \bigint_decr:N  { c }
\cs_generate_variant:Nn \bigint_gincr:N { c }
\cs_generate_variant:Nn \bigint_gdecr:N { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\bigint_set:Nn, \bigint_set:cn}
% \begin{macro}{\bigint_gset:Nn, \bigint_gset:cn}
%   Use \cs{tl_set:Nx} with \cs{@@_parse:n} to evaluate the expression.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_set:Nn #1#2
  { \tl_set:Nx  #1 { \exp:w \@@_parse:n {#2} } }
\cs_new_protected:Npn \bigint_gset:Nn #1#2
  { \tl_gset:Nx #1 { \exp:w \@@_parse:n {#2} } }
\cs_generate_variant:Nn \bigint_set:Nn  { c }
\cs_generate_variant:Nn \bigint_gset:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Big integer conditionals}
%
% \begin{macro}[int, EXP]{\@@_compare:ww}
%   Expands to $-1$, $0$, or $1$ like \tn{pdfstrcmp} does.  If the
%   numbers have different signs, it is easy to find which number is
%   biggest, by comparing signs |#2| and |#5| (these are $0$, $1$, or
%   $-1$).  If the numbers have the same sign but different lengths,
%   the longest is bigger.  If they have the same sign and length, the
%   primitive \tn{pdfstrcmp} does the right thing.
%    \begin{macrocode}
\cs_new:Npn \@@_compare:ww
    \s_@@ \@@_chk:w #1 . #2 #3 ;
    \s_@@ \@@_chk:w #4 . #5 #6 ;
  {
    \int_compare:nNnTF { #2 1 } = { #5 1 }
      {
        \int_compare:nNnTF {#1} = {#4}
          { \@@_str_cmp_x:nn {#3} {#6} }
          { \int_compare:nNnF {#1} > {#4} { - } 1 }
      }
      { \int_compare:nNnF { #2 1 } > { #5 1 } { - } 1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\bigint_compare:nNn}
%   Parse the \meta{big integer} operands, and compare them with
%   \cs{@@_compare:ww}, which expands to $-1$, $0$, or~$1$ depending on
%   whether the first \meta{big integer} is smaller than, equal to, or
%   bigger than the second.
%    \begin{macrocode}
\prg_new_conditional:Npnn \bigint_compare:nNn #1#2#3 { p , T , F , TF }
  {
    \if_int_compare:w
        \@@_parse_do:nn {#3}
          { \@@_parse_do:nn {#1} \@@_compare:ww }
        #2 0 \exp_stop_f:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\bigint_compare:n}
%   ^^A todo: missing!
% \end{macro}
%
% ^^A todo: using \exp:w \@@_parse:n would be faster (no removal of leading 0)
% \begin{macro}[EXP]{\bigint_case:nn}
% \begin{macro}[EXP, TF]{\bigint_case:nn}
% \begin{macro}[EXP, aux]{\@@_case:nnTF, \@@_case:nw, \@@_case_end:nw}
%   For integer cases, the first task to fully expand the check
%   condition. After that, a loop is started to compare each possible
%   value and stop if the test is true. The tested value is put at the
%   end to ensure that there is necessarily a match, which will fire the
%   \enquote{else} pathway. Start off with an
%   expansion which is then stopped in \cs{@@_case_end:nw}.  The
%   comparison is not done with \cs{bigint_compare:nNnTF} because it
%   would repeatedly parse the number to compare.  Instead, we rely on
%   uniqueness of the decimal representation.
%   This code is inspired from the code of \cs{tl_case:Nn}(TF).
%    \begin{macrocode}
\cs_new:Npn \bigint_case:nnTF #1
  {
    \exp:w
    \exp_args:Nf \@@_case:nnTF { \bigint_eval:n {#1} }
  }
\cs_new:Npn \bigint_case:nnT #1#2#3
  {
    \exp:w
    \exp_args:Nf \@@_case:nnTF { \bigint_eval:n {#1} } {#2} {#3} { }
  }
\cs_new:Npn \bigint_case:nnF #1#2
  {
    \exp:w
    \exp_args:Nf \@@_case:nnTF { \bigint_eval:n {#1} } {#2} { }
  }
\cs_new:Npn \bigint_case:nn #1#2
  {
    \exp:w
    \exp_args:Nf \@@_case:nnTF { \bigint_eval:n {#1} } {#2} { } { }
  }
\cs_new:Npn \@@_case:nnTF #1#2#3#4
  { \@@_case:nw {#1} #2 {#1} { } \q_mark {#3} \q_mark {#4} \q_stop }
\cs_new:Npn \@@_case:nw #1#2#3
  {
    \str_if_eq_x:nnTF {#1} { \bigint_eval:n {#2} }
      { \@@_case_end:nw {#3} }
      { \@@_case:nw {#1} }
  }
\cs_new:Npn \@@_case_end:nw #1#2#3 \q_mark #4#5 \q_stop
  { \exp_end: #1 #4 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\bigint_if_even:n, \bigint_if_odd:n}
% \begin{macro}[EXP, aux]{\@@_if_odd:w, \@@_if_odd:NNNNNNNN}
%   A predicate function.  Parse the number.  Then discard digits until
%   the last, and ask \TeX{} to test its parity.  We make use of the
%   fact that the number of digits is known to be a multiple of~$8$.
%    \begin{macrocode}
\prg_new_conditional:Npnn \bigint_if_odd:n #1 { p , T , F , TF}
  {
    \if_int_odd:w
        \exp_after:wN \@@_if_odd:w \exp:w \@@_parse:n {#1}
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\prg_new_conditional:Npnn \bigint_if_even:n #1 { p , T , F , TF}
  {
    \if_int_odd:w
        \exp_after:wN \@@_if_odd:w \exp:w \@@_parse:n {#1}
      \prg_return_false:
    \else:
      \prg_return_true:
    \fi:
  }
\cs_new:Npn \@@_if_odd:w \s_@@ \@@_chk:w #1 . #2 #3 ;
  {
    \@@_if_odd:NNNNNNNN 0 #3
      { ? \use_i_delimit_by_q_stop:nw } ?? ???? \q_stop
    \exp_stop_f:
  }
\cs_new:Npn \@@_if_odd:NNNNNNNN #1#2#3#4#5#6#7#8
  { \use_none:n #2 #1 \@@_if_odd:NNNNNNNN }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\bigint_if_int:n}
% \begin{macro}[EXP, aux]{\@@_if_int:w}
%   True if the argument's \meta{absolute value} is less than~$2^{31}$,
%   hardcoded here.  Use string comparison to limit the amount of code
%   needed.
%    \begin{macrocode}
\prg_new_conditional:Npnn \bigint_if_int:n #1 { p , T , F , TF }
  { \exp_after:wN \@@_if_int:w \exp:w \@@_parse:n {#1} }
\cs_new:Npn \@@_if_int:w \s_@@ \@@_chk:w #1 . #2 #3 ;
  {
    \if_case:w #1 \exp_stop_f:
      \prg_return_true:
    \or: \prg_return_true:
    \or:
      \if_int_compare:w
          \@@_str_cmp_x:nn {#3} { 00000021 47483648 }
          = - 1 \exp_stop_f:
        \prg_return_true:
      \else:
        \prg_return_false:
      \fi:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Factorization}
%
% \begin{macro}[EXP]{\bigint_factor:n}
% \begin{macro}[EXP, aux]{\@@_factor:w, \@@_factor:n, \@@_factor:nn}
%   This expands to the factorization of its argument, with each factor
%   enclosed in braces, an item of the resulting token list.  The
%   factors appear in descending order.  Negative integers have a
%   trailing |{-1}| factor.  Zero gives |{0}|.  Since we find factors
%   by adding $2$ at every step, they are never realistically going to
%   go beyond the limit of \TeX{}'s integers, so use \cs{int_eval:n}
%   there.  However, it is plausible that the square (used to test
%   whether we are left with a prime number) goes beyond $2^31$, so
%   leave that to big integers.
%    \begin{macrocode}
\cs_new:Npn \bigint_factor:n
  { \exp_after:wN \@@_factor:w \exp:w \@@_parse:n }
\cs_new:Npn \@@_factor:w \s_@@ \@@_chk:w #1 . #2 #3 ;
  {
    \token_if_eq_meaning:NNTF 0 #2
      { { 0 } }
      {
        \token_if_eq_meaning:NNTF + #2
          { \@@_factor:n {#3} }
          { \@@_factor:n {#3} {-1} }
      }
  }
\cs_new:Npn \@@_factor:n #1
  {
    \bigint_if_even:nTF {#1}
      { \exp_args:Nf \@@_factor:n { \bigint_eval:n { #1 / 2 } } {2} }
      { \@@_factor:nn { 3 } {#1} }
  }
\cs_new:Npn \@@_factor:nn #1#2
  {
    \bigint_compare:nNnTF { #1 * #1 } > { #2 }
      { {#2} }
      {
        \bigint_compare:nNnTF { \bigint_mod:nn {#2} {#1} } = { 0 }
          {
            \exp_args:Nff \@@_factor:nn {#1} { \bigint_eval:nn { #2 / #1 } }
            {#1}
          }
          { \exp_args:Nf \@@_factor:nn { \int_eval:n { #1 + 2 } } {#2} }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_phi:n}
% \begin{macro}[EXP, aux]{\@@_phi:, \@@_phi:nnw}
%   Euler's totient function $\phi$.  Start with $1$, then multiply for
%   each prime factor $p$ by $p$ or $p-1$ depending on whether the
%   previous prime factor was also $p$.
%    \begin{macrocode}
\cs_new:Npn \bigint_phi:n #1
  {
    \bigint_eval:n
      {
        \exp_last_unbraced:Nf \@@_phi:
          { \bigint_factor:n {#1} } {-1} \q_stop
      }
  }
\cs_new:Npn \@@_phi: { \@@_phi:nn { 1 } }
\cs_new:Npn \@@_phi:nn #1#2
  {
    \tl_if_head_eq_charcode:nNTF {#2} -
      { \use_i_delimit_by_q_stop:nw 1 }
      {
        \bigint_compare:nNnTF {#1} = {#2}
          {#2} { \bigint_eval:n { #2 - 1 } }
        *
      }
    \@@_phi:nn {#2}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_count_divisors:n}
% \begin{macro}[EXP, aux]{\@@_count_divisors:n, \@@_count_divisors:nnn}
%   Number of divisors, obtained from the factorization. The auxiliary
%   \cs{@@_count_divisors:nnn} does most of the work: its first
%   argument is the number of times the current factor has appeared,
%   the second is the last factor, and the last is the current factor.
%    \begin{macrocode}
\cs_new:Npn \bigint_count_divisors:n #1
  {
    \bigint_eval:n
      {
        \exp_last_unbraced:Nf \@@_count_divisors:n
          { \bigint_factor:n {#1} } { -1 } { -1 } \q_stop
      }
  }
\cs_new:Npn \@@_count_divisors:n #1
  {
    \if_meaning:w 0 #1
      0 \use_i_delimit_by_q_stop:nw
    \fi:
    \@@_count_divisors:nnn { 2 } {#1}
  }
\cs_new:Npn \@@_count_divisors:nnn #1#2#3
  {
    \str_if_eq:nnT {#2} {-1} { \use_none_delimit_by_q_stop:w }
    \str_if_eq:nnTF {#2} {#3}
      { \@@_count_divisors:nnn { 1 + #1 } }
      { * \int_eval:n {#1} \@@_count_divisors:nnn { 2 } }
    {#3}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% ^^A todo: what happens to signs in gcd/lcm?  Just use \bigint_abs:n ?
%
% \begin{macro}[EXP]{\bigint_gcd:nn}
% \begin{macro}[EXP, aux]{\@@_gcd:nn}
%   First evaluate the expressions.  Then apply Euclid's algorithm: if
%   an operand is $0$, we're done, otherwise compute |#2| modulo |#1|
%   and recurse with that and |#1| as arguments.
%    \begin{macrocode}
\cs_new:Npn \bigint_gcd:nn #1#2
  {
    \exp_args:Nff \@@_gcd:nn
      { \bigint_eval:n {#1} }
      { \bigint_eval:n {#2} }
  }
\cs_new:Npn \@@_gcd:nn #1#2
  {
    \str_if_eq:nnTF {#1} { 0 }
      {#2}
      { \exp_args:Nf \@@_gcd:nn { \bigint_mod:nn {#2} {#1} } {#1} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_lcm:nn}
% \begin{macro}[EXP, aux]{\@@_lcm:nn}
%   Evaluate the two operands.  If either one is zero, this is the
%   result.  Otherwise, compute $ab/\operatorname{gcd}(a,b)$, minimizing
%   the operands by first computing $a/\operatorname{gcd}(a,b)$, an
%   integer, then multiplying by $b$.
%    \begin{macrocode}
\cs_new:Npn \bigint_lcm:nn #1#2
  {
    \exp_args:Nff \@@_lcm:nn
      { \bigint_eval:n {#1} ; }
      { \bigint_eval:n {#2} ; }
  }
\cs_new:Npn \@@_lcm:nn #1#2
  {
    \str_if_eq:nnTF {#1} { 0 } { 0 }
      {
        \str_if_eq:nnTF {#2} { 0 } { 0 }
          { \bigint_eval:n { #2 / \@@_gcd:nn {#1} {#2} * #1 } }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Viewing big integers}
%
% ^^A todo: try to avoid kernel internals!
% \begin{macro}{\bigint_show:N, \bigint_show:c, \bigint_show:n}
% \begin{macro}{\bigint_log:N, \bigint_log:c, \bigint_log:n}
%   This sadly uses kernel internals.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_show:N #1
  {
    \__msg_show_variable:NNNnn #1 \bigint_if_exist:NTF ? { }
      { > ~ \token_to_str:N #1 = \bigint_use:N #1 }
  }
\cs_new_protected:Npn \bigint_show:n
  { \__msg_show_wrap:Nn \bigint_eval:n }
\cs_generate_variant:Nn \bigint_show:N { c }
\cs_new_protected:Npn \bigint_log:N
  { \__msg_log_next: \bigint_show:N }
\cs_new_protected:Npn \bigint_log:n
  { \__msg_log_next: \bigint_show:n }
\cs_generate_variant:Nn \bigint_log:N { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\msg_new:nnn { bigint } { missing }
  { Missing~#1~inserted! }
\msg_new:nnn { bigint } { extra }
  { Extra~#1~ignored! }
\msg_new:nnn { bigint } { early-end }
  { Premature~end~in~bigint~expression! }
\msg_new:nnn { bigint } { missing-number }
  { Missing~number~before~'#1'! }
\msg_new:nnn { bigint } { bad-var }
  { Undefined~variable~#1~in~expression! }
\msg_new:nnn { bigint } { unknown-symbol }
  { Unknown~symbol~#1~ignored! }
%<*package>
\cs_if_exist:cT { @unexpandable@protect }
  {
    \msg_new:nnn { bigint } { robust-cmd }
      { Robust~command~#1 invalid~in~expression! }
  }
%</package>
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
