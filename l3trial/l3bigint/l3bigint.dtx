% \iffalse
%
%% File l3bigint.dtx Copyright (C) 2011,2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id: l3bigint.dtx 2968 2011-11-20 06:03:34Z bruno $
  {L3 Experimental support for unbounded integers}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3bigint} package\\ Unbounded integers^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{\pkg{l3bigint} documentation}
%
% This package aims to provide the complete set of \pkg{l3int}
% functions, but without bounds on the integers used.  The package will
% also provide more elaborate functions, useful for factorization,
% computing the \texttt{gcd} of two numbers, \emph{etc.}  There is no
% plan to implement expression parsing.  Thus, \cs{bigint_set:Nn} only
% accepts a single number as its second argument.
%
% The functions implemented here could be useful to some niche users
% (\emph{e.g.} myself when developping \pkg{l3rand}), but should not go
% into the format.
%
% A \meta{big integer} consists of a \meta{sign} (arbitrary, possibly
% empty, string of |+| or |-| tokens) and a \meta{mantissa} (arbitrary
% non-empty string of decimal digits), or any token list |f|-expanding
% to a \meta{big integer}.  Spaces are ignored (except that they stop
% |f|-expansion).
%
% \section{Unary big-integer operations}
%
% \begin{function}[EXP]{\bigint_abs:n}
%   \begin{syntax}
%     \cs{bigint_abs:n} \Arg{bigint}
%   \end{syntax}
%   Expands to the absolute value of the \meta{big integer}.
% \end{function}
%
% \begin{function}[EXP]{\bigint_sign:n}
%   \begin{syntax}
%     \cs{bigint_sign:n} \Arg{bigint}
%   \end{syntax}
%   Expands to the sign ($-1$, $0$, or $1$) of the \meta{big integer}.
% \end{function}
%
% \section{Binary big-integer operations}
%
% \begin{function}[EXP]{\bigint_add:nn}
%   \begin{syntax}
%     \cs{bigint_add:nn} \Arg{bigint} \Arg{bigint}
%   \end{syntax}
%   Evaluates the sum of the two \meta{big integers}, and leaves the
%   result in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_sub:nn}
%   \begin{syntax}
%     \cs{bigint_sub:nn} \Arg{bigint} \Arg{bigint}
%   \end{syntax}
%   Evaluates the difference of the two \meta{big integers}, and leaves
%   the result in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_mul:nn}
%   \begin{syntax}
%     \cs{bigint_mul:nn} \Arg{bigint} \Arg{bigint}
%   \end{syntax}
%   Evaluates the product of the two \meta{big integers}, and leaves the
%   result in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_div_round:nn}
%   \begin{syntax}
%     \cs{bigint_div_round:nn} \Arg{bigint_1} \Arg{bigint_2}
%   \end{syntax}
%   Evaluates the result of dividing the first \meta{big integer} by the
%   second, rounding any remainder.  Ties are rounded away from zero.
%   The result is left in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_div_truncate:nn}
%   \begin{syntax}
%     \cs{bigint_div_truncate:nn} \Arg{bigint_1} \Arg{bigint_2}
%   \end{syntax}
%   Evaluates the result of dividing the first \meta{big integer} by the
%   second, truncating any remainder.  The result is left in the input
%   stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_max:nn, \bigint_min:nn}
%   \begin{syntax}
%     \cs{bigint_max:nn} \Arg{bigint_1} \Arg{bigint_2}
%     \cs{bigint_min:nn} \Arg{bigint_1} \Arg{bigint_2}
%   \end{syntax}
%   Leaves either the larger or smaller of the two \meta{big integers}
%   in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_mod:nn}
%   \begin{syntax}
%     \cs{bigint_mod:nn} \Arg{bigint_1} \Arg{intexpr_2}
%   \end{syntax}
%   Evaluates the integer remainder of dividing the first \meta{big
%     integer} by the second, and leaves the result in the input stream.
% \end{function}
%
% \section{Creating and initialising big integers}
%
% \begin{function}{\bigint_new:N, \bigint_new:c}
%   \begin{syntax}
%     \cs{bigint_new:N} \meta{bigint~var}
%   \end{syntax}
%   Creates a new \meta{big integer variable} or raises an error if the
%   name is already taken.  The declaration is global.  The \meta{big
%     integer variable} will initially be equal to $0$.
% \end{function}
%
% \begin{function}{\bigint_const:Nn, \bigint_const:cn}
%   \begin{syntax}
%     \cs{bigint_const:Nn} \meta{bigint~var} \Arg{bigint}
%   \end{syntax}
%   Creates a new constant \meta{big~integer~variable} or raises an
%   error if the name is already taken.  The value of the
%   \meta{big~integer~variable} will be set globally to the
%   \meta{bigint}.
% \end{function}
%
% \begin{function}
%   {\bigint_zero:N, \bigint_zero:c, \bigint_gzero:N, \bigint_gzero:c}
%   \begin{syntax}
%     \cs{bigint_zero:N} \meta{bigint~var}
%   \end{syntax}
%   Sets \meta{big integer variable} to $0$.
% \end{function}
%
% \begin{function}
%   {
%     \bigint_zero_new:N, \bigint_zero_new:c,
%     \bigint_gzero_new:N, \bigint_gzero_new:c
%   }
%   \begin{syntax}
%     \cs{bigint_zero_new:N} \meta{bigint~var}
%   \end{syntax}
%   Ensures that the \meta{big integer variable} exists globally by
%   applying \cs{bigint_new:N} if necessary, then applies
%   \cs{bigint_(g)zero:N} to leave the \meta{big integer variable} set
%   to zero.
% \end{function}
%
% \begin{function}
%   {
%     \bigint_set_eq:NN,  \bigint_set_eq:cN,
%     \bigint_set_eq:Nc,  \bigint_set_eq:cc,
%     \bigint_gset_eq:NN, \bigint_gset_eq:cN,
%     \bigint_gset_eq:Nc, \bigint_gset_eq:cc
%   }
%   \begin{syntax}
%     \cs{bigint_set_eq:NN} \meta{bigint~var_1} \meta{bigint~var_2}
%   \end{syntax}
%   Sets the content of \meta{bigint~var_1} equal to that of
%   \meta{bigint~var_2}.
% \end{function}
%
% \begin{function}[EXP, pTF]{\bigint_if_exist:N, \bigint_if_exist:c}
%   \begin{syntax}
%     \cs{bigint_if_exist_p:N} \meta{bigint~var}
%     \cs{bigint_if_exist:NTF} \meta{bigint~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{bigint~var} is currently defined.  This does
%   not check that the \meta{bigint~var} really is a big integer
%   variable.
% \end{function}
%
% \section{Setting and incrementing big integers}
%
% \begin{function}
%   {\bigint_add:Nn, \bigint_add:cn, \bigint_gadd:Nn, \bigint_gadd:cn}
%   \begin{syntax}
%     \cs{bigint_add:Nn} \meta{bigint~var} \Arg{bigint}
%   \end{syntax}
%   Adds the \meta{big integer} to the content of the \meta{big integer
%     variable}.
% \end{function}
%
% \begin{function}
%   {\bigint_decr:N, \bigint_decr:c, \bigint_gdecr:N, \bigint_gdecr:c}
%   \begin{syntax}
%     \cs{bigint_decr:N} \meta{bigint~var}
%   \end{syntax}
%   Decreases the value stored in \meta{big integer variable} by $1$.
% \end{function}
%
% \begin{function}
%   {\bigint_incr:N, \bigint_incr:c, \bigint_gincr:N, \bigint_gincr:c}
%   \begin{syntax}
%     \cs{bigint_incr:N} \meta{bigint~var}
%   \end{syntax}
%   Increases the value stored in \meta{big integer variable} by $1$.
% \end{function}
%
% \begin{function}
%   {\bigint_set:Nn, \bigint_set:cn, \bigint_gset:Nn, \bigint_gset:cn}
%   \begin{syntax}
%     \cs{bigint_set:Nn} \meta{bigint~var} \Arg{bigint}
%   \end{syntax}
%   Sets the \meta{big integer variable} to the value of the \meta{big
%     integer}.
% \end{function}
%
% \begin{function}
%   {\bigint_sub:Nn, \bigint_sub:cn, \bigint_gsub:Nn, \bigint_gsub:cn}
%   \begin{syntax}
%     \cs{bigint_sub:Nn} \meta{bigint~var} \Arg{bigint}
%   \end{syntax}
%   Subtracts the \meta{big integer} from the content of the \meta{big
%     integer variable}.
% \end{function}
%
% \section{Using integers}
%
% \begin{function}[EXP]{\bigint_use:N, \bigint_use:c}
%   \begin{syntax}
%     \cs{bigint_use:N} \meta{bigint~var}
%   \end{syntax}
%   Recovers the content of a \meta{big integer variable} and places it
%   directly in the input stream.  An error will be raised if the
%   variable does not exist or if it is invalid.  This can be omitted in
%   places where an \meta{big integer} is required (such as in the first
%   and third arguments of \cs{bigint_compare:nNnTF}).
% \end{function}
%
% \section{Integer expression conditionals}
%
% \begin{function}[EXP,pTF]{\bigint_compare:nNn}
%   \begin{syntax}
%     \cs{bigint_compare_p:nNn} \Arg{bigint_1} \meta{relation} \Arg{bigint_2} \\
%     \cs{bigint_compare:nNnTF}
%     ~~\Arg{bigint_1} \meta{relation} \Arg{bigint_2}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{big integers}.  The
%   two numbers are then compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                 & |=| \\
%       Greater than          & |>| \\
%       Less than             & |<| \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP,pTF]{\bigint_compare:n}
%   \begin{syntax}
%     \cs{bigint_compare_p:n} \{ \meta{bigint_1} \meta{relation} \meta{bigint_2} \} \\
%     \cs{bigint_compare:nTF}
%     ~~\{ \meta{bigint_1} \meta{relation} \meta{bigint_2} \}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function first evaluates each of the \meta{big integers}.  The
%   two results are then compared using the \meta{relation}:
%   \begin{center}
%     \begin{tabular}{ll}
%       Equal                    & |=| or |==| \\
%       Greater than or equal to & |>=|        \\
%       Greater than             & |>|         \\
%       Less than or equal to    & |<=|        \\
%       Less than                & |<|         \\
%       Not equal                & |!=|        \\
%     \end{tabular}
%   \end{center}
% \end{function}
%
% \begin{function}[EXP]{\bigint_case:nnn}
%   \begin{syntax}
%     \cs{bigint_case:nnn} \Arg{big integer} \\
%     ~~|{| \\
%     ~~~~\Arg{bigint case_1} \Arg{code case_1} \\
%     ~~~~\Arg{bigint case_2} \Arg{code case_2} \\
%     ~~~~\ldots \\
%     ~~~~\Arg{bigint case_n} \Arg{code case_n} \\
%     ~~|}| \\
%     ~~\Arg{else code}
%   \end{syntax}
%   This function compares the \meta{big integer} in turn to each of the
%   \meta{big integer cases}.  If the two are equal then the associated
%   \meta{code} is left in the input stream.  If none of the tests are
%   \texttt{true} then the \texttt{else code} will be left in the input
%   stream.  For example
%   \begin{verbatim}
%     \bigint_case:nnn
%       { 12345678901234567890 }
%       {
%         { 567 }                    { Small }
%         { 12345678901234567890 }   { Large }
%         { -1 }                     { Negative }
%       }
%       { No idea! }
%    \end{verbatim}
%    will leave \enquote{\texttt{Large}} in the input stream.
% \end{function}
%
% \begin{function}[EXP,pTF]{\bigint_if_even:n, \bigint_if_odd:n}
%   \begin{syntax}
%     \cs{bigint_if_odd_p:n} \Arg{big integer}
%     \cs{bigint_if_odd:nTF} \Arg{big integer} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   This function evaluates whether the \meta{big integer} is odd or
%   even, as appropriate.
% \end{function}
%
% \section{Viewing big integers}
%
% \begin{function}{\bigint_show:N, \bigint_show:c}
%   \begin{syntax}
%     \cs{bigint_show:N} \meta{bigint~var}
%   \end{syntax}
%   Displays the value of the \meta{big integer} on the terminal.
% \end{function}
%
% \begin{function}{\bigint_show:n}
%   \begin{syntax}
%     \cs{bigint_show:n} \meta{big integer}
%   \end{syntax}
%   Displays the value of the \meta{big integer} on the terminal.
% \end{function}
%
% \section{Scratch big integers}
%
% \begin{variable}{\l_tmpa_bigint, \l_tmpb_bigint}
%   Scratch big integers for local assignment.  These are never used by
%   the kernel code, and so are safe for use with any \LaTeX3-defined
%   function. However, they may be overwritten by other non-kernel
%   code and so should only be used for short-term storage.
% \end{variable}
%
% \begin{variable}{\g_tmpa_bigint, \g_tmpb_bigint}
%   Scratch big integer for global assignment.  These are never used by
%   the kernel code, and so are safe for use with any \LaTeX3-defined
%   function. However, they may be overwritten by other non-kernel
%   code and so should only be used for short-term storage.
% \end{variable}
%
% \subsection{Factorization}
%
% \begin{function}[EXP]{\bigint_count_divisors:n}
%   \begin{syntax}
%     \cs{int_count_divisors:n} \Arg{intexpr}
%   \end{syntax}
%   Counts the number of divisors of the integer obtained from
%   evaluating the \meta{integer expression}, and leaves this
%   information in the input stream.  Negative numbers have the same
%   number of divisors as their absolute value.  Zero triggers an
%   (expandable) error, then leads to the same result as~$1$,
%   namely~$1$.
% \end{function}
%
% \begin{function}[EXP]{\bigint_factor:n}
%   \begin{syntax}
%     \cs{int_factor:n} \Arg{intexpr}
%   \end{syntax}
%   Factorizes the integer obtained from evaluating the \meta{integer
%     expression} and leaves the resulting prime factors in the input
%   stream.  The prime factors are returned in decreasing order, with
%   multiplicity, and each factor is braced.  Negative integers lead to
%   a result ending with the item~|{-1}|.  Zero triggers an (expandable)
%   error and an empty result, identical to the result for~$1$.
% \end{function}
%
% \begin{function}[EXP]{\bigint_gcd:nn}
%   \begin{syntax}
%     \cs{int_gcd:nn} \Arg{intexpr_1} \Arg{intexpr_2}
%   \end{syntax}
%   Evaluates the two \meta{integer expressions} and computes their
%   greatest common divisor, leaving the result in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_lcm:nn}
%   \begin{syntax}
%     \cs{int_lcm:nn} \Arg{intexpr_1} \Arg{intexpr_2}
%   \end{syntax}
%   Evaluates the two \meta{integer expressions} and computes their
%   least common multiple, leaving the result in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\bigint_phi:n}
%   \begin{syntax}
%     \cs{int_phi:n} \Arg{intexpr}
%   \end{syntax}
%   Applies Euler's totient function to the integer obtained from
%   evaluating the \meta{integer expression} and leaves the result in
%   the input stream.
% \end{function}
%
% \subsection{Modular bigint}
%
% \begin{function}[EXP]{\bigint_add_mod:nnn}
%   \begin{syntax}
%     \cs{int_add_mod:nnn} \Arg{intexpr_1} \Arg{intexpr_2} \Arg{modulo}
%   \end{syntax}
%   Evaluates the three integer expressions, then calculates the integer
%   remainder of dividing the sum of the first two results by the
%   third.  This is left in the input stream as an \meta{integer
%     denotation}.
%   \begin{texnote}
%     This function avoids the overflow that may occur if the
%     \meta{intexpr_1} and the \meta{intexpr_2} are both close to
%     \TeX{}'s maximum integer.
%   \end{texnote}
% \end{function}
%
% \begin{function}[EXP]{\bigint_mul_mod:nnn}
%   \begin{syntax}
%     \cs{int_mul_mod:nnn} \Arg{intexpr_1} \Arg{intexpr_2} \Arg{modulo}
%   \end{syntax}
%   Evaluates the three integer expressions, then calculates the integer
%   remainder of dividing the product of the first two results by the
%   third.  This is left in the input stream as an \meta{integer
%     denotation}.
%   \begin{texnote}
%     This function avoids the overflow that may occur if the
%     \meta{intexpr_1} and the \meta{intexpr_2} are both close to
%     \TeX{}'s maximum integer.
%   \end{texnote}
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3bigint} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=bigint>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%    \end{macrocode}
%
% \subsection{Helpers}
%
% \begin{macro}[aux, EXP]{\use:nff}
%   A variant to expand the arguments of various operations.
%    \begin{macrocode}
\cs_generate_variant:Nn \use:nnn { nff }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP, pTF]{\@@_if_digit:N}
%   A rather standard test for digits: if |#1| is not a digit, the
%   right-hand side of the comparison ends with $1$, otherwise, the
%   digit is taken in to give a two-digit integer.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_digit:N #1 { p , T , F , TF }
  {
    \if_int_compare:w \c_nine < 1 \exp_not:N #1 \exp_stop_f:
      \prg_return_true: \else: \prg_return_false: \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Big integer value}
%
% \begin{macro}[EXP]{\bigint_value:n}
% \begin{macro}[aux, EXP]
%   {
%     \@@_value_sign:N,
%     \@@_value_sign_after:NNw,
%     \@@_value_mantissa_zeros:N,
%     \@@_value_mantissa:Nw,
%     \@@_value_end:wNN
%   }
%   Read the sign within an integer expression starting with~$1$:
%   \cs{@@_value_sign_after:NNw} sees either~|2| (positive sign) or~|0|
%   (negative sign), followed by the mantissa.  If there is no digit,
%   trigger the \enquote{Missing number treated as zero} error, and
%   produce |00\s__stop| (the first zero is the sign).  Otherwise,
%   convert the sign to a proper |+|~or~|-|, then discard any leading
%   zero, then read the \meta{mantissa} one digit at a time, placing
%   each digit just before \cs{s__stop} as they come, until seeing a
%   non-digit.  If that non-digit is not the~|;| trailing delimiter,
%   complain.  In any case, remove what's before the semicolon, and the
%   trailing \cs{s__stop}.  Note that at this point, the \meta{mantissa}
%   is empty in the case of zero.  We thus add a test in
%   \cs{@@_value_end:wNN} for that case.  The result is a \meta{sign}
%   (|+|~or~|-|) followed by a (non-empty) \meta{mantissa}, which starts
%   with~|0| if and only if the number is zero.  Both~|-0| and~|+0| can
%   result.
%    \begin{macrocode}
\cs_new:Npn \bigint_value:n #1
  {
    \exp_after:wN \@@_value_sign_after:NNw
    \int_use:N \__int_eval:w \c_one -
      \exp_after:wN \@@_value_sign:N \tex_romannumeral:D -`0
      #1 ; \s__stop
  }
\cs_new:Npn \@@_value_sign:N #1
  {
    \if:w + \if:w - \exp_not:N #1 + \fi: \token_to_str:N #1
      \exp_after:wN \@@_value_sign:N
    \else:
      \c_one \exp_after:wN \__int_eval_end: \exp_after:wN #1
    \fi:
  }
\cs_new:Npn \@@_value_sign_after:NNw #1#2#3 \s__stop
  {
    \@@_if_digit:NTF #2
      {
        \token_if_eq_meaning:NNTF #1 0
          { \@@_value_mantissa_zeros:N #2 #3 + \s__stop }
          { \@@_value_mantissa_zeros:N #2 #3 - \s__stop }
      }
      { \exp_after:wN 0 \__int_value:w \s__stop }
  }
\cs_new:Npn \@@_value_mantissa_zeros:N #1
  {
    \token_if_eq_charcode:NNTF 0 #1
      { \@@_value_mantissa_zeros:N }
      { \@@_value_mantissa:Nw #1 }
  }
\cs_new:Npn \@@_value_mantissa:Nw #1 #2 \s__stop
  {
    \@@_if_digit:NTF #1
      { \@@_value_mantissa:Nw #2 #1 \s__stop }
      {
        \token_if_eq_charcode:NNF #1 ;
          {
            \__msg_kernel_expandable_error:nnn
              { bigint } { unexpected-char } {#1}
          }
        \@@_value_end:wNN #1 #2 \s__stop
      }
  }
\cs_new:Npn \@@_value_end:wNN #1 ; #2 #3 \s__stop
  { \tl_if_empty:nTF {#3} { #2 0 } { #2 #3 } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF]{\bigint_if_zero:n}
%    \begin{macrocode}
\prg_new_conditional:Npnn \bigint_if_zero:n #1 { p , T , F , TF }
  {
    \__str_if_eq_x_return:nn { 0 }
      { \exp_last_unbraced:Nf \use_none:n \bigint_value:n {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Big integer unary operations}
%
% \begin{macro}[EXP]{\bigint_abs:n}
%   Read the value of the big integer, then remove the sign |+| or |-|.
%    \begin{macrocode}
\cs_new:Npn \bigint_abs:n #1
  { \exp_last_unbraced:Nf \use_none:n { \bigint_value:n {#1} } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_sign:n}
% \begin{macro}[aux, EXP]{\@@_sign:NNw}
%   Read the value of the big integer.  If the \meta{mantissa} |#2#3|
%   starts with a zero, the number is zero.  Otherwise, return $1$ times
%   the sign |#1|.
%    \begin{macrocode}
\cs_new:Npn \bigint_sign:n #1
  { \exp_last_unbraced:Nf \@@_sign:NNw { \bigint_value:n {#1} } ; }
\cs_new:Npn \@@_sign:NNw #1#2#3 ;
  { \__int_value:w \if_meaning:w 0 #2 0 \else: #1 1 \fi: \exp_stop_f: }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Big integer binary operations}
%
% \begin{macro}[EXP]{\bigint_max:nn, \bigint_min:nn}
% \begin{macro}[aux, EXP]{\@@_max:NwNwN}
%   Parse, compare, and use.
%    \begin{macrocode}
\cs_new:Npn \bigint_max:nn #1#2
  {
    \use:nff \@@_max:NwNwN
      { \bigint_value:n {#1} ; }
      { \bigint_value:n {#2} ; }
      \c_one
  }
\cs_new:Npn \bigint_min:nn #1#2
  {
    \use:nff \@@_max:NwNwN
      { \bigint_value:n {#1} ; }
      { \bigint_value:n {#2} ; }
      \c_minus_one
  }
\cs_new:Npn \@@_max:NwNwN #1#2 ; #3#4 ; #5
  {
    \int_compare:nNnTF { \@@_compare:NwNw #1#2 ; #3#4 ; } = { #5 }
      { #1 #2 }
      { #3 #4 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_add:nn, \bigint_sub:nn}
% \begin{macro}[aux, EXP]{\@@_add:NwNwn, \@@_add:Nww, \@@_sub:Nww}
%   Parse the two big integers.  Find out if the two numbers have the
%   same sign or not.
%    \begin{macrocode}
\cs_new:Npn \bigint_add:nn #1#2
  {
    \use:nff \@@_add:NwNwn
      { \bigint_value:n {#1} ; }
      { \bigint_value:n {#2} ; }
      { }
  }
\cs_new:Npn \bigint_sub:nn #1#2
  {
    \use:nff \@@_add:NwNwn
      { \bigint_value:n {#1} ; }
      { \bigint_value:n {#2} ; }
      \reverse_if:N
  }
\cs_new:Npn \@@_add:NwNwn #1#2 ; #3#4 ; #5
  {
    #5 \if_meaning:w #1 #3
      \exp_after:wN \@@_add:NNww
      \exp_after:wN #1
      \exp_after:wN +
    \else:
      \exp_after:wN \@@_add:NNww
      \exp_after:wN #1
      \exp_after:wN -
    \fi:
    #2 ; #4 ;
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {
%     \@@_add:NNww, \@@_add_ii:NNww, \@@_add_iii:NNwNwN,
%     \@@_add_carry:Nw, \@@_add_after:wwN
%   }
%   \begin{quote}
%     \cs{@@_add:NNww} \meta{overall sign} \meta{operation}
%     \meta{mantissa_1} |;| \meta{mantissa_2} |;|
%   \end{quote}
%   Compare the two \meta{mantissas}.  Swap the numbers so that the
%   smaller one is in front.  Non-intuitively, we correct the
%   \meta{overall sign} if we are \emph{not} swapping the numbers (and
%   are doing a subtraction).  Then pad the smaller number with leading
%   zeros.  Add trailing |*|, so the loop stops correctly.
%    \begin{macrocode}
\cs_new:Npn \@@_add:NNww #1#2 #3; #4;
  {
    \int_compare:nNnTF { \@@_compare:NwNw + #3; + #4; } < \c_zero
      {
        \exp_last_unbraced:Nf \@@_add_ii:NNww
          { \token_if_eq_meaning:NNTF #1 #2 { + } { - } }
          #2 #3; #4;
      }
      { \@@_add_ii:NNww #1 #2 #4; #3; }
  }
\cs_new:Npn \@@_add_ii:NNww #1 #2 #3; #4;
  {
    \exp_after:wN \@@_add_after:wwN
    \__int_value:w
      \exp_after:wN \@@_add_iii:NNwNwN
      \exp_after:wN #2
      \tex_romannumeral:D -`0
        \prg_replicate:nn
          { \tl_count:n {#4} - \tl_count:n {#3} } {0}
        #3 * ; #4 * ; #1
  }
\cs_new:Npn \@@_add_iii:NNwNwN #1 #2#3; #4#5;
  {
    \token_if_eq_meaning:NNTF #2 *
      { + 2 ; ; }
      {
        \exp_after:wN \@@_add_carry:Nw
        \int_use:N \__int_eval:w 18 #1 #2 + #4
          \@@_add_iii:NNwNwN #1 #3; #5;
      }
  }
\cs_new:Npn \@@_add_carry:Nw #1 #2; { + #1 ; #2 }
\cs_new:Npn \@@_add_after:wwN 2 ; #1 ; #2 { #2 #1 }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Creating and initialising big integers}
%
% \begin{variable}{\c_zero_bigint}
%   A token list containing just zero.
%    \begin{macrocode}
\cs_new_nopar:Npn \c_zero_bigint { 0 }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\bigint_new:N, \bigint_new:c}
%   Big integers are simply token lists initialized at $0$.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_new:N #1
  { \cs_new_eq:NN #1 \c_zero_bigint }
\cs_generate_variant:Nn \bigint_new:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\bigint_const:Nn, \bigint_const:cn}
%   Constant token list.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_const:Nn #1#2
  { \tl_const:Nx #1 { \bigint_value:n {#2} } }
\cs_generate_variant:Nn \bigint_const:Nn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\bigint_zero:N, \bigint_zero:c}
% \begin{macro}{\bigint_gzero:N, \bigint_gzero:c}
%   Functions that reset a \meta{big integer} to zero.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_zero:N  #1 { \cs_set_eq:NN #1 \c_zero_bigint }
\cs_new_protected:Npn \bigint_gzero:N #1 { \cs_gset_eq:NN #1 \c_zero_bigint }
\cs_generate_variant:Nn \bigint_zero:N  { c }
\cs_generate_variant:Nn \bigint_gzero:N { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {
%     \bigint_zero_new:N, \bigint_zero_new:c,
%     \bigint_gzero_new:N, \bigint_gzero_new:c
%   }
%   Create a variable if needed, otherwise clear it.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_zero_new:N  #1
  { \bigint_if_exist:NTF #1 { \bigint_zero:N #1 } { \bigint_new:N #1 } }
\cs_new_protected:Npn \bigint_gzero_new:N #1
  { \bigint_if_exist:NTF #1 { \bigint_gzero:N #1 } { \bigint_new:N #1 } }
\cs_generate_variant:Nn \bigint_zero_new:N  { c }
\cs_generate_variant:Nn \bigint_gzero_new:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \bigint_set_eq:NN, \bigint_set_eq:cN,
%     \bigint_set_eq:Nc, \bigint_set_eq:cc,
%     \bigint_gset_eq:NN, \bigint_gset_eq:cN,
%     \bigint_gset_eq:Nc, \bigint_gset_eq:cc
%   }
%   Copy the tl functions.
%    \begin{macrocode}
\cs_new_eq:NN \bigint_set_eq:NN \tl_set_eq:NN
\cs_new_eq:NN \bigint_gset_eq:NN \tl_gset_eq:NN
\cs_generate_variant:Nn \bigint_set_eq:NN { c , Nc , cc }
\cs_generate_variant:Nn \bigint_gset_eq:NN { c , Nc , cc }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\bigint_if_exist:N, \bigint_if_exist:c}
%   Copies of the \texttt{cs} functions defined in \pkg{l3basics}.
%    \begin{macrocode}
\cs_new_eq:NN \bigint_if_exist:NTF \cs_if_exist:NTF
\cs_new_eq:NN \bigint_if_exist:NT  \cs_if_exist:NT
\cs_new_eq:NN \bigint_if_exist:NF  \cs_if_exist:NF
\cs_new_eq:NN \bigint_if_exist_p:N \cs_if_exist_p:N
\cs_new_eq:NN \bigint_if_exist:cTF \cs_if_exist:cTF
\cs_new_eq:NN \bigint_if_exist:cT  \cs_if_exist:cT
\cs_new_eq:NN \bigint_if_exist:cF  \cs_if_exist:cF
\cs_new_eq:NN \bigint_if_exist_p:c \cs_if_exist_p:c
%    \end{macrocode}
% \end{macro}
%
% \subsection{Setting and incrementing big integers}
%
% \begin{macro}{\bigint_add:Nn, \bigint_add:cn}
% \begin{macro}{\bigint_gadd:Nn, \bigint_gadd:cn}
% \begin{macro}{\bigint_sub:Nn, \bigint_sub:cn}
% \begin{macro}{\bigint_gsub:Nn, \bigint_gsub:cn}
%   Use \cs{bigint_add:nn} and the like.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_add:Nn #1#2
  { \bigint_set:Nn #1 { \bigint_add:nn {#1} {#2} } }
\cs_new_protected:Npn \bigint_gadd:Nn #1#2
  { \bigint_gset:Nn #1 { \bigint_add:nn {#1} {#2} } }
\cs_new_protected:Npn \bigint_sub:Nn #1#2
  { \bigint_set:Nn #1 { \bigint_sub:nn {#1} {#2} } }
\cs_new_protected:Npn \bigint_gsub:Nn #1#2
  { \bigint_gset:Nn #1 { \bigint_sub:nn {#1} {#2} } }
\cs_generate_variant:Nn \bigint_add:Nn  { c }
\cs_generate_variant:Nn \bigint_gadd:Nn { c }
\cs_generate_variant:Nn \bigint_sub:Nn  { c }
\cs_generate_variant:Nn \bigint_gsub:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\bigint_incr:N, \bigint_incr:c}
% \begin{macro}{\bigint_gincr:N, \bigint_gincr:c}
% \begin{macro}{\bigint_decr:N, \bigint_decr:c}
% \begin{macro}{\bigint_gdecr:N, \bigint_gdecr:c}
%   The same, using $1$ as a second argument.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_incr:N #1 { \bigint_add:Nn #1 { 1 } }
\cs_new_protected:Npn \bigint_decr:N #1 { \bigint_sub:Nn #1 { 1 } }
\cs_new_protected:Npn \bigint_gincr:N #1 { \bigint_gadd:Nn #1 { 1 } }
\cs_new_protected:Npn \bigint_gdecr:N #1 { \bigint_gsub:Nn #1 { 1 } }
\cs_generate_variant:Nn \bigint_incr:N  { c }
\cs_generate_variant:Nn \bigint_decr:N  { c }
\cs_generate_variant:Nn \bigint_gincr:N { c }
\cs_generate_variant:Nn \bigint_gdecr:N { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\bigint_set:Nn, \bigint_set:cn}
% \begin{macro}{\bigint_gset:Nn, \bigint_gset:cn}
%   Use \cs{tl_set:Nx} with \cs{bigint_value:n}.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_set:Nn #1#2
  { \tl_set:Nx #1 { \bigint_value:n {#2} } }
\cs_new_protected:Npn \bigint_gset:Nn #1#2
  { \tl_gset:Nx #1 { \bigint_value:n {#2} } }
\cs_generate_variant:Nn \bigint_set:Nn  { c }
\cs_generate_variant:Nn \bigint_gset:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Using integers}
%
% \begin{macro}{\bigint_use:N, \bigint_use:c}
%   Big integers are just token lists.
%    \begin{macrocode}
\cs_new_eq:NN \bigint_use:N \tl_use:N
\cs_new_eq:NN \bigint_use:c \tl_use:c
%    \end{macrocode}
% \end{macro}
%
% \subsection{Big integer conditionals}
%
% \begin{macro}[EXP]{\@@_compare:nn, \@@_compare:NwNw}
%   Comparing two numbers yields the sign of their difference, $-1$ if
%   $x<y$, $0$ if $x=y$, $1$ if $x>y$.
%    \begin{macrocode}
\cs_new:Npn \@@_compare:nn #1#2
  {
    \use:nff \@@_compare:NwNw
      { \bigint_value:n {#1} ; }
      { \bigint_value:n {#2} ; }
  }
\cs_new:Npn \@@_compare:NwNw #1#2; #3#4;
  {
    \__int_value:w
      #1
      \token_if_eq_meaning:NNTF #1#3
        {
          \int_compare:nNnTF
            { \tl_count:n {#2} } < { \tl_count:n {#4} }
            { -1 }
            {
              \int_compare:nNnTF
                { \tl_count:n {#2} } > { \tl_count:n {#4} }
                { 1 }
                { \pdftex_strcmp:D {#2} {#4} }
            }
        }
        {
          \str_if_eq:nnTF {#2} {0}
            { \str_if_eq:nnTF {#4} {0} { 0 } { -1 } }
            { -1 }
        }
    \exp_stop_f:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\bigint_compare:n}
%   ^^A todo: not implemented!
%    \begin{macrocode}
\prg_new_conditional:Npnn \bigint_compare:n #1 { p , T , F , TF }
  { \ERROR }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\bigint_compare:nNn}
%   More efficient but less natural in typing.
%    \begin{macrocode}
\prg_new_conditional:Npnn \bigint_compare:nNn #1#2#3 { p , T , F , TF }
  {
    \if_int_compare:w \@@_compare:nn {#1} {#3} #2 \c_zero
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\bigint_case:nnn}
% \begin{macro}[aux]{\@@_case:nnn}
% \begin{macro}[aux]{\@@_case:nw, \@@_case_end:nw}
%   For integer cases, the first task to fully expand the check
%   condition. After that, a loop is started to compare each possible
%   value and stop if the test is true. The tested value is put at the
%   end to ensure that there is necessarily a match, which will fire the
%   \enquote{else} pathway. The leading \tn{romannumeral} triggers an
%   expansion which is then stopped in \cs{@@_case_end:nw}.
%    \begin{macrocode}
\cs_new:Npn \bigint_case:nnn #1
  {
    \tex_romannumeral:D
    \exp_args:Nf \@@_case:nnn { \bigint_value:n {#1} }
  }
\cs_new:Npn \@@_case:nnn #1#2#3
  { \@@_case:nw {#1} #2 {#1} {#3} \q_recursion_stop }
\cs_new:Npn \@@_case:nw #1#2#3
  {
    \bigint_compare:nNnTF {#1} = {#2}
      { \@@_case_end:nw {#3} }
      { \@@_case:nw {#1} }
  }
\cs_new_eq:NN \@@_case_end:nw \__prg_case_end:nw
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF]{\bigint_if_odd:n}
% \begin{macro}[pTF]{\bigint_if_even:n}
%   A predicate function.  Parse the number.  Then discard digits until
%   the last, and ask \TeX{} to test its parity.
%    \begin{macrocode}
\prg_new_conditional:Npnn \bigint_if_odd:n #1 { p , T , F , TF}
  {
    \if_int_odd:w
        \exp_last_unbraced:Nf \@@_if_odd:NN \bigint_value:n {#1} ;
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\prg_new_conditional:Npnn \bigint_if_even:n #1 { p , T , F , TF}
  {
    \if_int_odd:w
        \exp_last_unbraced:Nf \@@_if_odd:NN \bigint_value:n {#1} ;
      \prg_return_false:
    \else:
      \prg_return_true:
    \fi:
  }
\cs_new:Npn \@@_if_odd:NN #1#2
  {
    \token_if_eq_meaning:NNTF #2 ;
      { #1 \exp_stop_f: } { \@@_if_odd:NN #2 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Big integer expression loops}
%
% \begin{macro}[EXP]{\bigint_while_do:nn}
% \begin{macro}[EXP]{\bigint_until_do:nn}
% \begin{macro}[EXP]{\bigint_do_while:nn}
% \begin{macro}[EXP]{\bigint_do_until:nn}
%   Well, \cs{bigint_compare:nTF} is not implemented yet, so this will
%   fail.  ^^A todo: implement!
%    \begin{macrocode}
\cs_new:Npn \bigint_while_do:nn #1#2
  {
    \bigint_compare:nT {#1}
      {
        #2
        \bigint_while_do:nn {#1} {#2}
      }
  }
\cs_new:Npn \bigint_until_do:nn #1#2
  {
    \bigint_compare:nF {#1}
      {
        #2
        \bigint_until_do:nn {#1} {#2}
      }
  }
\cs_new:Npn \bigint_do_while:nn #1#2
  {
    #2
    \bigint_compare:nT {#1}
      { \bigint_do_while:nn {#1} {#2} }
  }
\cs_new:Npn \bigint_do_until:nn #1#2
  {
    #2
    \bigint_compare:nF {#1}
      { \bigint_do_until:nn {#1} {#2} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_while_do:nNnn}
% \begin{macro}[EXP]{\bigint_until_do:nNnn}
% \begin{macro}[EXP]{\bigint_do_while:nNnn}
% \begin{macro}[EXP]{\bigint_do_until:nNnn}
%    As above but not using the more natural syntax.
%    \begin{macrocode}
\cs_new:Npn \bigint_while_do:nNnn #1#2#3#4
  {
    \bigint_compare:nNnT {#1} #2 {#3}
      {
        #4
        \bigint_while_do:nNnn {#1} #2 {#3} {#4}
      }
  }
\cs_new:Npn \bigint_until_do:nNnn #1#2#3#4
  {
    \bigint_compare:nNnF {#1} #2 {#3}
      {
        #4
        \bigint_until_do:nNnn {#1} #2 {#3} {#4}
      }
  }
\cs_new:Npn \bigint_do_while:nNnn #1#2#3#4
  {
    #4
    \bigint_compare:nNnT {#1} #2 {#3}
      { \bigint_do_while:nNnn {#1} #2 {#3} {#4} }
  }
\cs_new:Npn \bigint_do_until:nNnn #1#2#3#4
  {
    #4
    \bigint_compare:nNnF {#1} #2 {#3}
      { \bigint_do_until:nNnn {#1} #2 {#3} {#4} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Viewing big integers}
%
% \begin{macro}{\bigint_show:N, \bigint_show:c}
%   Copies of the tl functions.
%    \begin{macrocode}
\cs_new_eq:NN \bigint_show:N \tl_show:N
\cs_new_eq:NN \bigint_show:c \tl_show:c
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\bigint_show:n}
%   Feed the result of \cs{bigint_value:n} to \cs{tl_show:n}.
%    \begin{macrocode}
\cs_new_protected:Npn \bigint_show:n #1
  { \exp_args:Nf \tl_show:n { \bigint_value:n {#1} } }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Scratch big integers}
%
% \begin{variable}{\l_tmpa_bigint, \l_tmpb_bigint}
% \begin{variable}{\g_tmpa_bigint, \g_tmpb_bigint}
%    We provide two local and two global scratch counters, maybe we
%    need more or less.
%    \begin{macrocode}
\bigint_new:N \l_tmpa_bigint
\bigint_new:N \l_tmpb_bigint
\bigint_new:N \g_tmpa_bigint
\bigint_new:N \g_tmpb_bigint
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \subsection{Factorization}
%
% \begin{macro}[EXP]{\bigint_factor:n}
% \begin{macro}[EXP,aux]{\@@_factor:n}
% \begin{macro}[EXP,aux]{\@@_factor:w}
% \begin{macro}[EXP,aux]{\@@_factor:ww}
%   This expands to the factorization of its argument, with each
%   factor enclosed in braces, an item of the resulting token list.
%   The factors appear in descending order.
%   Negative integers have a trailing |{-1}| factor.
%   Zero raises an error.
%    \begin{macrocode}
\cs_new:Npn \bigint_factor:n #1
  { \exp_args:Nf \@@_factor:n { \bigint_value:n {#1} } }
\cs_new:Npn \@@_factor:n #1
  {
    \bigint_compare:nNnTF {#1} = { 0 }
      { \__msg_kernel_expandable_error:nn { bigint } { factor-zero } }
      {
        \bigint_compare:nNnTF {#1} < { 0 }
          { \exp_after:wN \@@_factor:w \use_none:n #1 ; {-1} }
          { \@@_factor:w #1 ; }
      }
  }
\cs_new:Npn \@@_factor:w #1 ;
  {
    \bigint_if_even:nTF {#1}
      {
        \exp_last_unbraced:Nf \@@_factor:w
          \bigint_div_round:nn {#1} {2} ;
        {2}
      }
      {
        \bigint_compare:nNnF {#1} = { 1 }
          { \@@_factor:ww 3 ; #1 ; }
      }
  }
\cs_new:Npn \@@_factor:ww #1 ; #2 ;
  {
    \bigint_compare:nNnTF
      { \bigint_mul:nn {#1} {#1} } > { #2 }
      { {#2} }
      {
        \bigint_compare:nNnTF
          { \bigint_mod:nn {#2} {#1} } = { 0 }
          {
            \use:nff \@@_factor:ww
              { \bigint_value:n {#1} ; }
              { \bigint_div_truncate:nn {#2} {#1} ; }
            {#1}
          }
          {
            \exp_last_unbraced:Nf \@@_factor:ww
              { \bigint_value:n { #1 + 2 } } ;
            #2 ;
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_phi:n}
% \begin{macro}[EXP, aux]{\@@_phi:}
% \begin{macro}[EXP, aux]{\@@_phi:nnw}
%   Euler's totient function $\phi$.  Start with $1$, then multiply for
%   each prime factor $p$ by $p$ or $p-1$ depending on whether the
%   previous prime factor was also $p$.
%    \begin{macrocode}
\cs_new:Npn \bigint_phi:n #1
  {
    \exp_last_unbraced:Nf \@@_phi:
      { \bigint_factor:n {#1} } {-1} ? \q_stop
  }
\cs_new:Npn \@@_phi: { \@@_phi:nnw { 1 } }
\cs_new:Npn \@@_phi:nnw #1#2#3 \q_stop
  {
    \tl_if_head_eq_charcode:nNTF {#2} -
      { 1 }
      {
        \bigint_mul:nn
          {
            \bigint_compare:nNnTF {#1} = {#2}
              {#2} { \bigint_sub:nn {#2} {1} }
          }
          { \@@_phi:nnw {#2} #3 \q_stop }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_count_divisors:n}
% \begin{macro}[EXP, aux]{\@@_count_divisors:}
% \begin{macro}[EXP, aux]{\@@_count_divisors:nn}
%   Number of divisors. %^^A todo: reimplement!
%    \begin{macrocode}
\cs_new:Npn \bigint_count_divisors:n #1
  {
    \bigint_eval:n
      {
        (
          1
          \exp_last_unbraced:Nf \@@_count_divisors:
            { \bigint_factor:n {#1} } { -1 } \q_stop
        )
      }
  }
\cs_new:Npn \@@_count_divisors: { \@@_count_divisors:nn { 1 } }
\cs_new:Npn \@@_count_divisors:nn #1#2
  {
    \bigint_compare:nNnF {#2} > { 0 } { \use_none_delimit_by_q_stop:w }
    \bigint_compare:nNnTF {#1} = {#2}
      { + 1 }
      { )*( 2 }
    \@@_count_divisors:nn {#2}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Euclid's algorithm}
%
% ^^A todo: redo!
%
% \begin{macro}[EXP]{\bigint_gcd:nn}
% \begin{macro}[EXP, aux]{\@@_gcd:ww}
%   First evaluate the expressions without their sign.  Then apply
%   Euclid's algorithm: if an operand is $0$, we're done, otherwise
%   compute |#2| modulo |#1| and recurse with that and |#1| as
%   arguments.
%    \begin{macrocode}
\cs_new:Npn \bigint_gcd:nn #1#2
  {
    \use:nff \@@_gcd:ww
      { \bigint_value:n {#1} ; }
      { \bigint_value:n {#2} ; }
  }
\cs_new:Npn \@@_gcd:ww #1 ; #2 ;
  {
    \bigint_if_zero:nTF {#1}
      {#2}
      {
        \exp_last_unbraced:Nf \@@_gcd:ww
          \bigint_mod:nn {#2} {#1} ; #1 ;
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\bigint_lcm:nn}
% \begin{macro}[EXP]{\@@_lcm:ww}
%   Evaluate the two operands.  If either one is zero, this is the
%   result.  Otherwise, compute $ab/\operatorname{gcd}(a,b)$, playing it
%   safe with overflow by first computing $a/\operatorname{gcd}(a,b)$,
%   an integer, then multiplying by $b$.
%    \begin{macrocode}
\cs_new:Npn \bigint_lcm:nn #1#2
  {
    \use:nff \@@_lcm:ww
      { \bigint_value:n {#1} ; }
      { \bigint_value:n {#2} ; }
  }
\cs_new:Npn \@@_lcm:ww #1 ; #2 ;
  {
    \bigint_if_zero:nTF {#1}
      { 0 }
      {
        \bigint_if_zero:nTF {#2}
          { 0 }
          {
            \bigint_mul:nn {#1}
              { \bigint_div_truncate:nn {#2} { \@@_gcd:ww #1 ; #2 ; } }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\__msg_kernel_new:nnn { bigint } { factor-zero } { Zero~cannot~be~factored. }
\__msg_kernel_new:nnn { bigint } { negative-power-mod }
  { Negative~power~in~#2^#1~(mod~#3). }
%    \end{macrocode}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
