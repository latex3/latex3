% \iffalse meta-comment
%
%% File: l3candidates.dtx Copyright(C) 2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3kernel bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{l3names}
\GetIdInfo$Id: l3candidates.dtx 3633 2012-05-12 20:11:32Z joseph $
  {L3 Experimental additions to l3kernel}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{l3candidates} package\\ Experimental additions to
%   \pkg{l3kernel}^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
% 
% This module provides a space in which functions can be added to
% \pkg{l3kernel} (\pkg{expl3}) while still being experimental. As such, the
% functions here may not remain in their current form, or indeed at all,
% in \pkg{l3kernel} in the future. In contrast to the material in
% \pkg{l3experimental}, the functions here are all \emph{small} additions to
% the kernel. We encourage programmers to test them out and report back on
% the \texttt{LaTeX-L} mailing list.
% 
% \section{Additions to \pkg{l3box}}
% 
% \subsection{Affine transformations}
%
% Affine transformations are changes which (informally) preserve straight
% lines. Simple translations are affine transformations, but are better handled
% in \TeX{} by doing the translation first, then inserting an unmodified box.
% On the other hand, rotation and resizing of boxed material can best be
% handled by modifying boxes. These transformations are described here.
%
% \begin{function}{\box_resize:Nnn, \box_resize:cnn}
%   \begin{syntax}
%     \cs{box_resize:Nnn} \meta{box} \Arg{x-size} \Arg{y-size}
%   \end{syntax}
%   Resize the \meta{box} to \meta{x-size} horizontally and \meta{y-size}
%   vertically (both of the sizes are dimension expressions).
%   The \meta{y-size} is the vertical size (height plus depth) of
%   the box. The updated \meta{box} will be an hbox, irrespective of the nature
%   of the \meta{box}  before the resizing is applied. Negative sizes will
%   cause the material in the \meta{box} to be reversed in direction, but the
%   reference point of the \meta{box} will be unchanged. The resizing applies
%   within the current \TeX{} group level.
% \end{function}
%
% \begin{function}
%   {\box_resize_to_ht_plus_dp:Nn, \box_resize_to_ht_plus_dp:cn}
%   \begin{syntax}
%     \cs{box_resize_to_ht_plus_dp:Nn} \meta{box} \Arg{y-size}
%   \end{syntax}
%   Resize the \meta{box} to \meta{y-size} vertically, scaling the horizontal
%   size by the same amount (\meta{y-size} is a dimension expression).
%   The \meta{y-size} is the vertical size (height plus depth) of
%   the box.
%   The updated \meta{box} will be an hbox, irrespective of the nature
%   of the \meta{box}  before the resizing is applied. A negative size will
%   cause the material in the \meta{box} to be reversed in direction, but the
%   reference point of the \meta{box} will be unchanged. The resizing applies
%   within the current \TeX{} group level.
% \end{function}
%
% \begin{function}{\box_resize_to_wd:Nn, \box_resize_to_wd:cn}
%   \begin{syntax}
%     \cs{box_resize_to_wd:Nn} \meta{box} \Arg{x-size}
%   \end{syntax}
%   Resize the \meta{box} to \meta{x-size} horizontally, scaling the vertical
%   size by the same amount (\meta{x-size} is a dimension expression).
%   The updated \meta{box} will be an hbox, irrespective of the nature
%   of the \meta{box}  before the resizing is applied. A negative size will
%   cause the material in the \meta{box} to be reversed in direction, but the
%   reference point of the \meta{box} will be unchanged. The resizing applies
%   within the current \TeX{} group level.
% \end{function}
%
% \begin{function}{\box_rotate:Nn, \box_rotate:cn}
%   \begin{syntax}
%     \cs{box_rotate:Nn} \meta{box} \Arg{angle}
%   \end{syntax}
%   Rotates the \meta{box} by \meta{angle} (in degrees) anti-clockwise about
%   its reference point. The reference point of the updated box will be moved
%   horizontally such that it is at the left side of the smallest rectangle
%   enclosing the rotated material.
%   The updated \meta{box} will be an hbox, irrespective of the nature
%   of the \meta{box} before the rotation is applied. The rotation applies
%   within the current \TeX{} group level.
% \end{function}
%
% \begin{function}{\box_scale:Nnn, \box_scale:cnn}
%   \begin{syntax}
%     \cs{box_scale:Nnn} \meta{box} \Arg{x-scale} \Arg{y-scale}
%   \end{syntax}
%   Scales the \meta{box} by factors \meta{x-scale} and \meta{y-scale} in
%   the horizontal and vertical directions, respectively (both scales are
%   integer expressions). The updated \meta{box} will be an hbox, irrespective
%   of the nature of the \meta{box} before the scaling is applied. Negative
%   scalings will cause the material in the \meta{box} to be reversed in
%   direction, but the reference point of the \meta{box} will be unchanged.
%   The scaling applies within the current \TeX{} group level.
% \end{function}
%
% \subsection{Viewing part of a box}
%
% \begin{function}{\box_clip:N, \box_clip:c}
%   \begin{syntax}
%     \cs{box_clip:N} \meta{box}
%   \end{syntax}
%   Clips the \meta{box} in the output so that only material inside the
%   bounding box is displayed in the output. The updated \meta{box} will be an
%   hbox, irrespective of the nature of the \meta{box} before the clipping is
%   applied. The clipping applies within the current \TeX{} group level.
%   
%   \textbf{These functions require the \LaTeX3 native drivers: they will
%   not work with the \LaTeXe{} \pkg{graphics} drivers!}
%
%   \begin{texnote}
%     Clipping is implemented by the driver, and as such the full content of
%     the box is places in the output file. Thus clipping does not remove
%     any information from the raw output, and hidden material can therefore
%     be viewed by direct examination of the file.
%   \end{texnote}
% \end{function}
%
% \begin{function}{\box_trim:Nnnnn, \box_trim:cnnnn}
%   \begin{syntax}
%     \cs{box_trim:Nnnnn} \meta{box} \Arg{left} \Arg{bottom} \Arg{right} \Arg{top}
%   \end{syntax}
%   Adjusts the bounding box of the \meta{box} \meta{left} is removed from
%   the left-hand edge of the bounding box, \meta{right} from the right-hand
%   edge and so fourth. All adjustments are \meta{dimension expressions}.
%   Material output of the bounding box will still be displayed in the output
%   unless \cs{box_clip:N} is subsequently applied.
%   The updated \meta{box} will be an
%   hbox, irrespective of the nature of the \meta{box} before the viewport
%   operation is applied. The adjustment applies within the current \TeX{}
%   group level.
% \end{function}
%
% \begin{function}{\box_viewport:Nnnnn, \box_viewport:cnnnn}
%   \begin{syntax}
%     \cs{box_viewport:Nnnnn} \meta{box} \Arg{llx} \Arg{lly} \Arg{urx} \Arg{ury}
%   \end{syntax}
%   Adjusts the bounding box of the \meta{box} such that it has lower-left
%   co-ordinates (\meta{llx}, \meta{lly}) and upper-right co-ordinates
%   (\meta{urx}, \meta{ury}). All four co-ordinate positions are
%   \meta{dimension expressions}. Material output of the bounding box will
%   still be displayed in the output unless \cs{box_clip:N} is
%   subsequently applied.
%   The updated \meta{box} will be an
%   hbox, irrespective of the nature of the \meta{box} before the viewport
%   operation is applied. The adjustment applies within the current \TeX{}
%   group level.
% \end{function}
% 
% \section{Additions to \pkg{l3clist}}
%
% \begin{function}{\clist_count:N, \clist_count:c, \clist_count:n}
%   \begin{syntax}
%     \cs{clist_count:N} \meta{comma list}
%   \end{syntax}
%   Leaves the number of items in the \meta{comma list} in the input
%   stream as an \meta{integer denotation}. The total number of items
%   in a \meta{comma list} will include those which are duplicates,
%   \emph{i.e.}~every item in a \meta{comma list} is unique.
% \end{function}
%
% \begin{function}{\clist_item:Nn, \clist_item:cn, \clist_item:nn}
%   \begin{syntax}
%     \cs{clist_item:Nn} \meta{comma list} \Arg{integer expression}
%   \end{syntax}
%   Indexing items in the \meta{comma list} from $0$ at the top (left), this
%   function will evaluate the \meta{integer expression} and leave the
%   appropriate item from the comma list in the input stream. If the
%   \meta{integer expression} is negative, indexing occurs from the
%   bottom (right) of the comma list. When the \meta{integer expression}
%   is larger than the number of items in the \meta{comma list} (as
%   calculated by \cs{clist_count:N}) then the function will expand to
%   nothing.
%   \begin{texnote}
%     The result is returned within the \tn{unexpanded}
%     primitive (\cs{exp_not:n}), which means that the \meta{item}
%     will not expand further when appearing in an \texttt{x}-type
%     argument expansion.
%   \end{texnote}
% \end{function}
%
% \begin{function}
%   {
%     \clist_set_from_seq:NN,  \clist_set_from_seq:cN,
%     \clist_set_from_seq:Nc,  \clist_set_from_seq:cc,
%     \clist_gset_from_seq:NN, \clist_gset_from_seq:cN,
%     \clist_gset_from_seq:Nc, \clist_gset_from_seq:cc
%   }
%   \begin{syntax}
%     \cs{clist_set_from_seq:NN} \meta{comma list} \meta{sequence}
%   \end{syntax}
%   Sets the \meta{comma list} to be equal to the content of the
%   \meta{sequence}.
%   Items which contain either spaces or commas are surrounded by braces.
% \end{function}
%
% \begin{function}
%   {
%     \clist_const:Nn, \clist_const:Nx,
%     \clist_const:cn, \clist_const:cx
%   }
%   \begin{syntax}
%     \cs{clist_const:Nn} \meta{clist~var} \Arg{comma list}
%   \end{syntax}
%   Creates a new constant \meta{clist~var} or raises an error
%   if the name is already taken. The value of the
%   \meta{clist~var} will be set globally to the
%   \meta{comma list}.
% \end{function}
%
% \begin{function}[EXP, pTF]{\clist_if_empty:n}
%   \begin{syntax}
%     \cs{clist_if_empty_p:n} \Arg{comma list}
%     \cs{clist_if_empty:nTF} \Arg{comma list} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the \meta{comma list} is empty (containing no items).
%   The rules for space trimming are as for other \texttt{n}-type
%   comma-list functions, hence the comma list |{~,~,,~}| (without
%   outer braces) is empty, while |{~,{},}| (without outer braces)
%   contains one element, which happens to be empty: the comma-list
%   is not empty.
% \end{function}
% 
% \section{Additions to \pkg{l3coffins}}
%
% \begin{function}{\coffin_resize:Nnn, \coffin_resize:cnn}
%   \begin{syntax}
%     \cs{coffin_resize:Nnn} \meta{coffin} \Arg{width} \Arg{total-height}
%   \end{syntax}
%   Resized the \meta{coffin} to \meta{width} and \meta{total-height},
%   both of which should be given as dimension expressions. These may
%   include the terms \cs{TotalHeight}, \cs{Height}, \cs{Depth} and
%   \cs{Width}, which will evaluate to the appropriate dimensions of
%   the \meta{coffin}.
% \end{function}
%
% \begin{function}{\coffin_rotate:Nn, \coffin_rotate:cn}
%   \begin{syntax}
%     \cs{coffin_rotate:Nn} \meta{coffin} \Arg{angle}
%   \end{syntax}
%   Rotates the \meta{coffin} by the given \meta{angle} (given in
%   degrees counter-clockwise). This process will rotate both the
%   coffin content and poles. Multiple rotations will not result in
%   the bounding box of the coffin growing unnecessarily.
% \end{function}
%
% \begin{function}{\coffin_scale:Nnn, \coffin_scale:cnn}
%   \begin{syntax}
%     \cs{coffin_scale:Nnn} \meta{coffin} \Arg{x-scale} \Arg{y-scale}
%   \end{syntax}
%   Scales the \meta{coffin} by a factors \meta{x-scale} and
%   \meta{y-scale} in the horizontal and vertical directions,
%   respectively. The two scale factors should be given as real numbers.
% \end{function}
% 
% \section{Additions to \pkg{l3file}}
%
% \begin{function}[added = 2012-02-11]{\ior_map_inline:Nn}
%   \begin{syntax}
%     \cs{ior_map_inline:Nn} \meta{stream} \Arg{inline function}
%   \end{syntax}
%   Applies the \meta{inline function} to \meta{items} obtained by
%   reading one or more lines (until an equal number of left and right
%   braces are found) from the \meta{stream}. The \meta{inline function}
%   should consist of code which will receive the \meta{line} as |#1|.
% \end{function}
%
% \begin{function}[added = 2012-02-11]{\ior_str_map_inline:nn}
%   \begin{syntax}
%     \cs{ior_str_map_inline:Nn} \Arg{stream} \Arg{inline function}
%   \end{syntax}
%   Applies the \meta{inline function} to every \meta{line}
%   in the \meta{file}. The material is read from the \meta{stream}
%   as a series of tokens with category code $12$ (other), with the
%   exception of space characters which are given category code $10$
%   (space). The \meta{inline function} should consist of code which
%   will receive the \meta{line} as |#1|.
% \end{function}
% 
% \section{Additions to \pkg{l3prop}}
%
% \begin{function}[rEXP]
%   {\prop_map_tokens:Nn, \prop_map_tokens:cn}
%   \begin{syntax}
%     \cs{prop_map_tokens:Nn} \meta{property list} \Arg{code}
%   \end{syntax}
%   Analogue of \cs{prop_map_function:NN} which maps several tokens
%   instead of a single function.  The \meta{code} receives each
%   key--value pair in the \meta{property list} as two trailing brace
%   groups. For instance,
%   \begin{verbatim}
%     \prop_map_tokens:Nn \l_my_prop { \str_if_eq:nnT { mykey } }
%   \end{verbatim}
%   will expand to the value corresponding to \texttt{mykey}: for each
%   pair in \cs{l_my_prop} the function \cs{str_if_eq:nnT} receives
%   \texttt{mykey}, the \meta{key} and the \meta{value} as its three
%   arguments.  For that specific task, \cs{prop_get:Nn} is faster.
% \end{function}
%
% \begin{function}[EXP]{\prop_get:Nn, \prop_get:cn}
%   \begin{syntax}
%     \cs{prop_get:Nn} \meta{property list} \Arg{key}
%   \end{syntax}
%   Expands to the \meta{value} corresponding to the \meta{key} in
%   the \meta{property list}. If the \meta{key} is missing, this has
%   an empty expansion.
%   \begin{texnote}
%     This function is slower than the non-expandable analogue
%     \cs{prop_get:NnN}.
%     The result is returned within the \tn{unexpanded}
%     primitive (\cs{exp_not:n}), which means that the \meta{value}
%     will not expand further when appearing in an x-type
%     argument expansion.
%   \end{texnote}
% \end{function}
% 
% \section{Additions to \pkg{l3skip}}
%
% \begin{function}{\skip_split_finite_else_action:nnNN}
%   \begin{syntax}
%     \cs{skip_split_finite_else_action:nnNN} \Arg{skipexpr} \Arg{action}
%     ~~\meta{dimen1} \meta{dimen2}
%   \end{syntax}
%   Checks if the \meta{skipexpr} contains finite glue. If it does then it
%   assigns
%   \meta{dimen1} the stretch component and \meta{dimen2} the shrink
%   component. If
%   it contains infinite glue set \meta{dimen1} and \meta{dimen2} to $0$\,pt
%   and place |#2| into the input stream: this is usually an error or
%   warning message of some sort.
% \end{function}
% 
% \section{Additions to \pkg{l3tl}}
%
% \begin{function}[EXP]{\tl_reverse_tokens:n}
%   \begin{syntax}
%     \cs{tl_reverse_tokens:n} \Arg{tokens}
%   \end{syntax}
%   This function, which works directly on \TeX{} tokens, reverses
%   the order of the \meta{tokens}: the first will be the last and
%   the last will become first. Spaces are preserved. The reversal
%   also operates within brace groups, but the braces themselves
%   are not exchanged, as this would lead to an unbalanced token
%   list. For instance, \cs{tl_reverse_tokens:n} |{a~{b()}}|
%   leaves |{)(b}~a| in the input stream. This function requires
%   two steps of expansion.
%   \begin{texnote}
%     The result is returned within the \tn{unexpanded}
%     primitive (\cs{exp_not:n}), which means that the token
%     list will not expand further when appearing in an x-type
%     argument expansion.
%   \end{texnote}
% \end{function}
%
% \begin{function}[added = 2012-05-13, EXP]{\tl_count_tokens:n}
%   \begin{syntax}
%     \cs{tl_count_tokens:n} \Arg{tokens}
%   \end{syntax}
%   Counts the number of \TeX{} tokens in the \meta{tokens} and leaves
%   this information in the input stream. Every token, including spaces and
%   braces, contributes one to the total; thus for instance, the token count of
%   |a~{bc}| is $6$.
%   This function requires three expansions,
%   giving an \meta{integer denotation}.
% \end{function}
%
% \begin{function}[EXP]{\tl_expandable_uppercase:n,\tl_expandable_lowercase:n}
%   \begin{syntax}
%     \cs{tl_expandable_uppercase:n} \Arg{tokens}
%     \cs{tl_expandable_lowercase:n} \Arg{tokens}
%   \end{syntax}
%   The \cs{tl_expandable_uppercase:n} function works through all of
%   the \meta{tokens}, replacing characters in the range |a|--|z|
%   (with arbitrary category code) by the corresponding letter
%   in the range |A|--|Z|, with category code $11$ (letter). Similarly,
%   \cs{tl_expandable_lowercase:n} replaces characters in the range
%   |A|--|Z| by letters in the range |a|--|z|, and leaves other tokens
%   unchanged. This function requires two steps of expansion.
%   \begin{texnote}
%     Begin-group and end-group characters are normalized and become
%     |{| and |}|, respectively.
%     The result is returned within the \tn{unexpanded}
%     primitive (\cs{exp_not:n}), which means that the token
%     list will not expand further when appearing in an x-type
%     argument expansion.
%   \end{texnote}
% \end{function}
%
% \begin{function}[EXP]{\tl_item:nn, \tl_item:Nn, \tl_item:cn}
%   \begin{syntax}
%     \cs{tl_item:nn} \Arg{token list} \Arg{integer expression}
%   \end{syntax}
%   Indexing items in the \meta{token list} from $0$ on the left, this
%   function will evaluate the \meta{integer expression} and leave the
%   appropriate item from the \meta{token list} in the input stream.
%   If the \meta{integer expression} is negative, indexing occurs from
%   the right of the token list, starting at $-1$ for the right-most item.
%   If the index is out of bounds, then thr function expands to nothing.
%   \begin{texnote}
%     The result is returned within the \tn{unexpanded}
%     primitive (\cs{exp_not:n}), which means that the \meta{item}
%     will not expand further when appearing in an x-type
%     argument expansion.
%   \end{texnote}
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3candidates} Implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\package_check_loaded_expl:
%</package>
%    \end{macrocode}
%    
% \subsection{Additions to \pkg{l3box}}
% 
% \subsection{Affine transformations}
%
% \begin{variable}{\l_box_angle_fp}
%   When rotating boxes, the angle itself may be needed by the
%   engine-dependent code. This is done using the \pkg{fp} module so
%   that the value is tidied up properly.
%    \begin{macrocode}
\fp_new:N \l_box_angle_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_box_cos_fp, \l_box_sin_fp}
%   These are used to hold the calculated sine and cosine values while
%   carrying out a rotation.
%    \begin{macrocode}
\fp_new:N \l_box_cos_fp
\fp_new:N \l_box_sin_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {\l_box_top_dim, \l_box_bottom_dim, \l_box_left_dim, \l_box_right_dim}
%   These are the positions of the four edges of a box before
%   manipulation.
%    \begin{macrocode}
\dim_new:N \l_box_top_dim
\dim_new:N \l_box_bottom_dim
\dim_new:N \l_box_left_dim
\dim_new:N \l_box_right_dim
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%  {
%    \l_box_top_new_dim,  \l_box_bottom_new_dim ,
%    \l_box_left_new_dim, \l_box_right_new_dim
%  }
%   These are the positions of the four edges of a box after
%   manipulation.
%    \begin{macrocode}
\dim_new:N \l_box_top_new_dim
\dim_new:N \l_box_bottom_new_dim
\dim_new:N \l_box_left_new_dim
\dim_new:N \l_box_right_new_dim
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_box_internal_box}
%   Scratch space.
%    \begin{macrocode}
\box_new:N \l_box_internal_box
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\box_rotate:Nn}
% \begin{macro}[aux]{\box_rotate_aux:N}
% \begin{macro}[aux]{\box_rotate_x:nnN, \box_rotate_y:nnN}
% \begin{macro}[aux]
%   {
%     \box_rotate_quadrant_one:,   \box_rotate_quadrant_two:,
%     \box_rotate_quadrant_three:, \box_rotate_quadrant_four:
%   }
%   Rotation of a box starts with working out the relevant sine and
%   cosine. The actual rotation is in an auxiliary to keep the flow slightly
%   clearer
%    \begin{macrocode}
\cs_new_protected:Npn \box_rotate:Nn #1#2
  {
    \hbox_set:Nn #1
      {
        \group_begin:
          \fp_set:Nn \l_box_angle_fp {#2}
          \fp_set:Nn \l_box_sin_fp { sin ( \l_box_angle_fp * deg ) }
          \fp_set:Nn \l_box_cos_fp { cos ( \l_box_angle_fp * deg ) }
          \box_rotate_aux:N #1
        \group_end:
    }
  }
%    \end{macrocode}
%   The edges of the box are then recorded: the left edge will
%   always be at zero. Rotation of the four edges then takes place: this is
%   most efficiently done on a quadrant by quadrant basis.
%    \begin{macrocode}
\cs_new_protected:Npn \box_rotate_aux:N #1
  {
    \dim_set:Nn \l_box_top_dim    {  \box_ht:N #1 }
    \dim_set:Nn \l_box_bottom_dim { -\box_dp:N #1 }
    \dim_set:Nn \l_box_right_dim  {  \box_wd:N #1 }
    \dim_zero:N \l_box_left_dim
%    \end{macrocode}
%   The next step is to work out the $x$ and $y$ coordinates of vertices of
%   the rotated box in relation to its original coordinates. The box can be
%   visualized with vertices $B$, $C$, $D$ and $E$ is illustrated
%   (Figure~\ref{fig:rotation}). The vertex $O$ is the reference point on the
%   baseline, and in this implementation is also the centre of rotation.
%   \begin{figure}
%     \centering
%     \setlength{\unitlength}{3pt}^^A
%     \begin{picture}(34,36)(12,44)
%       \thicklines
%       \put(20,52){\dashbox{1}(20,21){}}
%       \put(20,80){\line(0,-1){36}}
%       \put(12,58){\line(1, 0){34}}
%       \put(41,59){A}
%       \put(40,74){B}
%       \put(21,74){C}
%       \put(21,49){D}
%       \put(40,49){E}
%       \put(21,59){O}
%     \end{picture}
%     \caption{Co-ordinates of a box prior to rotation.}
%     \label{fig:rotation}
%   \end{figure}
%   The formulae are, for a point $P$ and angle $\alpha$:
%   \[
%     \begin{array}{l}
%       P'_x = P_x - O_x \\
%       P'_y = P_y - O_y \\
%       P''_x =  ( P'_x \cos(\alpha)) - ( P'_y \sin(\alpha) ) \\
%       P''_y =  ( P'_x \sin(\alpha)) + ( P'_y \cos(\alpha) ) \\
%       P'''_x = P''_x + O_x + L_x \\
%       P'''_y = P''_y + O_y
%    \end{array}
%   \]
%   The \enquote{extra} horizontal translation $L_x$ at the end is calculated
%   so that the leftmost point of the resulting box has $x$-coordinate $0$.
%   This is desirable as \TeX{} boxes must have the reference point at
%   the left edge of the box. (As $O$ is always $(0,0)$, this part of the
%   calculation is omitted here.)
%    \begin{macrocode}
    \fp_compare:nNnTF \l_box_sin_fp > \c_zero_fp
      {
        \fp_compare:nNnTF \l_box_cos_fp > \c_zero_fp
          { \box_rotate_quadrant_one: }
          { \box_rotate_quadrant_two: }
      }
      {
        \fp_compare:nNnTF \l_box_cos_fp < \c_zero_fp
          { \box_rotate_quadrant_three: }
          { \box_rotate_quadrant_four: }
      }
%    \end{macrocode}
%   The position of the box edges are now known, but the box at this
%   stage be misplaced relative to the current \TeX{} reference point. So the
%   content of the box is moved such that the reference point of the
%   rotated box will be in the same place as the original.
%    \begin{macrocode}
    \hbox_set:Nn \l_box_internal_box { \box_use:N #1 }
    \hbox_set:Nn \l_box_internal_box
      {
        \tex_kern:D -\l_box_left_new_dim
        \hbox:n
          {
            \driver_box_rotate_begin:
            \box_use:N \l_box_internal_box
            \driver_box_rotate_end:
          }
      }
%    \end{macrocode}
%   Tidy up the size of the box so that the material is actually inside
%   the bounding box. The result can then be used to reset the original
%   box.
%    \begin{macrocode}
    \box_set_ht:Nn \l_box_internal_box {  \l_box_top_new_dim }
    \box_set_dp:Nn \l_box_internal_box { -\l_box_bottom_new_dim }
    \box_set_wd:Nn \l_box_internal_box
      { \l_box_right_new_dim - \l_box_left_new_dim }
    \box_use:N \l_box_internal_box
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%   These functions take a general point $(|#1|, |#2|)$ and rotate its
%   location about the origin, using the previously-set sine and cosine
%   values. Each function gives only one component of the location of the
%   updated point. This is because for rotation of a box each step needs
%   only one value, and so performance is gained by avoiding working
%   out both $x'$ and $y'$ at the same time. Contrast this with
%   the equivalent function in the \pkg{l3coffins} module, where both parts
%   are needed.
%    \begin{macrocode}
\cs_new_protected:Npn \box_rotate_x:nnN #1#2#3
  {
    \dim_set:Nn #3
      {
        \fp_to_dim:n
          {
                \l_box_cos_fp * \dim_to_fp:n {#1}
            - ( \l_box_sin_fp * \dim_to_fp:n {#2} )
          }
      }  
  }
\cs_new_protected:Npn \box_rotate_y:nnN #1#2#3
  {
    \dim_set:Nn #3
      {
        \fp_to_dim:n
          {
              \l_box_sin_fp * \dim_to_fp:n {#1}
            + \l_box_cos_fp * \dim_to_fp:n {#2}
          }
      }  
  }
%    \end{macrocode}
%   Rotation of the edges is done using a different formula for each
%   quadrant. In every case, the top and bottom edges only need the
%   resulting $y$-values, whereas the left and right edges need the
%   $x$-values. Each case is a question of picking out which corner
%   ends up at with the maximum top, bottom, left and right value. Doing
%   this by hand means a lot less calculating and avoids lots of
%   comparisons.
%    \begin{macrocode}
\cs_new_protected:Npn \box_rotate_quadrant_one:
  {
    \box_rotate_y:nnN \l_box_right_dim \l_box_top_dim
      \l_box_top_new_dim
    \box_rotate_y:nnN \l_box_left_dim  \l_box_bottom_dim
      \l_box_bottom_new_dim
    \box_rotate_x:nnN \l_box_left_dim  \l_box_top_dim
      \l_box_left_new_dim
    \box_rotate_x:nnN \l_box_right_dim \l_box_bottom_dim
      \l_box_right_new_dim
  }
\cs_new_protected:Npn \box_rotate_quadrant_two:
  {
    \box_rotate_y:nnN \l_box_right_dim \l_box_bottom_dim
      \l_box_top_new_dim
    \box_rotate_y:nnN \l_box_left_dim  \l_box_top_dim
      \l_box_bottom_new_dim
    \box_rotate_x:nnN \l_box_right_dim  \l_box_top_dim
      \l_box_left_new_dim
    \box_rotate_x:nnN \l_box_left_dim   \l_box_bottom_dim
      \l_box_right_new_dim
  }
\cs_new_protected:Npn \box_rotate_quadrant_three:
  {
    \box_rotate_y:nnN \l_box_left_dim  \l_box_bottom_dim
      \l_box_top_new_dim
    \box_rotate_y:nnN \l_box_right_dim \l_box_top_dim
      \l_box_bottom_new_dim
    \box_rotate_x:nnN \l_box_right_dim \l_box_bottom_dim
      \l_box_left_new_dim
    \box_rotate_x:nnN \l_box_left_dim   \l_box_top_dim
      \l_box_right_new_dim
  }
\cs_new_protected:Npn \box_rotate_quadrant_four:
  {
    \box_rotate_y:nnN \l_box_left_dim  \l_box_top_dim
      \l_box_top_new_dim
    \box_rotate_y:nnN \l_box_right_dim \l_box_bottom_dim
      \l_box_bottom_new_dim
    \box_rotate_x:nnN \l_box_left_dim  \l_box_bottom_dim
      \l_box_left_new_dim
    \box_rotate_x:nnN \l_box_right_dim \l_box_top_dim
      \l_box_right_new_dim
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\l_box_scale_x_fp, \l_box_scale_y_fp}
%   Scaling is potentially-different in the two axes.
%    \begin{macrocode}
\fp_new:N \l_box_scale_x_fp
\fp_new:N \l_box_scale_y_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\box_resize:Nnn, \box_resize:cnn}
% \begin{macro}[aux]{\box_resize_aux:Nnn}
%   Resizing a box starts by working out the various dimensions of the
%   existing box.
%    \begin{macrocode}
\cs_new_protected:Npn \box_resize:Nnn #1#2#3
  {
    \hbox_set:Nn #1
      {
        \group_begin:
          \dim_set:Nn \l_box_top_dim    {  \box_ht:N #1 }
          \dim_set:Nn \l_box_bottom_dim { -\box_dp:N #1 }
          \dim_set:Nn \l_box_right_dim  {  \box_wd:N #1 }
          \dim_zero:N \l_box_left_dim
%    \end{macrocode}
%   The $x$-scaling and resulting box size is easy enough to work
%   out: the dimension is that given as |#2|, and the scale is simply the
%   new width divided by the old one.
%    \begin{macrocode}
          \fp_set:Nn \l_box_scale_x_fp
            { \dim_to_fp:n {#2} / ( \dim_to_fp:n \l_box_right_dim ) }
%    \end{macrocode}
%   The $y$-scaling needs both the height and the depth of the current box.
%    \begin{macrocode}
          \fp_set:Nn \l_box_scale_y_fp
            {
              \dim_to_fp:n {#3} /
                ( \dim_to_fp:n { \l_box_top_dim - \l_box_bottom_dim } )
            }
%    \end{macrocode}
%   Hand off to the auxiliary which does the work.
%    \begin{macrocode}
          \box_resize_aux:Nnn #1 {#2} {#3}
        \group_end:
      }
  }
\cs_generate_variant:Nn \box_resize:Nnn { c }
%    \end{macrocode}
%   With at least one real scaling to do, the next phase is to find the new
%   edge co-ordinates. In the $x$~direction this is relatively easy: just
%   scale the right edge. This is done using the absolute value of the
%   scale so that the new edge is in the correct place. In the $y$~direction,
%   both dimensions have to be scaled, and this again needs the absolute
%   scale value. Once that is all done, the common resize/rescale code can
%   be employed.
%    \begin{macrocode}
\cs_new_protected:Npn \box_resize_aux:Nnn #1#2#3
  {
    \dim_compare:nNnTF {#2} > \c_zero_dim
      { \dim_set:Nn \l_box_right_new_dim {#2} }
      { \dim_set:Nn \l_box_right_new_dim { \c_zero_dim - ( #2 ) } }
    \dim_compare:nNnTF {#3} > \c_zero_dim
      {
        \dim_set:Nn \l_box_top_new_dim
          { \fp_use:N \l_box_scale_y_fp \l_box_top_dim }
        \dim_set:Nn \l_box_bottom_new_dim
          { \fp_use:N \l_box_scale_y_fp \l_box_bottom_dim }
      }
      {
        \dim_set:Nn \l_box_top_new_dim
          { - \fp_use:N \l_box_scale_y_fp \l_box_top_dim }
        \dim_set:Nn \l_box_bottom_new_dim
          { - \fp_use:N \l_box_scale_y_fp \l_box_bottom_dim }
      }
    \box_resize_common:N #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\box_resize_to_ht_plus_dp:Nn, \box_resize_to_ht_plus_dp:cn}
% \begin{macro}{\box_resize_to_wd:Nn, \box_resize_to_wd:cn}
%   Scaling to a total height or to a width is a simplified version of the main
%   resizing operation, with the scale simply copied between the two parts. The
%   internal auxiliary is called using the scaling value twice, as the sign for
%   both parts is needed (as this allows the same internal code to be used as
%   for the general case).
%    \begin{macrocode}
\cs_new_protected:Npn \box_resize_to_ht_plus_dp:Nn #1#2
  {
    \hbox_set:Nn #1
      {
        \group_begin:
          \dim_set:Nn \l_box_top_dim    {  \box_ht:N #1 }
          \dim_set:Nn \l_box_bottom_dim { -\box_dp:N #1 }
          \dim_set:Nn \l_box_right_dim  {  \box_wd:N #1 }
          \dim_zero:N \l_box_left_dim
          \fp_set:Nn \l_box_scale_y_fp
            {
              \dim_to_fp:n {#2} /
                ( \dim_to_fp:n { \l_box_top_dim - \l_box_bottom_dim } )
            }
          \fp_set_eq:NN \l_box_scale_x_fp \l_box_scale_y_fp
          \box_resize_aux:Nnn #1 {#2} {#2}
        \group_end:
      }
  }
\cs_generate_variant:Nn \box_resize_to_ht_plus_dp:Nn { c }
\cs_new_protected:Npn \box_resize_to_wd:Nn #1#2
  {
    \hbox_set:Nn #1
      {
        \group_begin:
          \dim_set:Nn \l_box_top_dim    {  \box_ht:N #1 }
          \dim_set:Nn \l_box_bottom_dim { -\box_dp:N #1 }
          \dim_set:Nn \l_box_right_dim  {  \box_wd:N #1 }
          \dim_zero:N \l_box_left_dim
          \fp_set:Nn \l_box_scale_x_fp
            { \dim_to_fp:n {#2} / ( \dim_to_fp:n \l_box_right_dim ) }
          \fp_set_eq:NN \l_box_scale_y_fp \l_box_scale_x_fp
          \box_resize_aux:Nnn #1 {#2} {#2}
        \group_end:
      }
  }
\cs_generate_variant:Nn \box_resize_to_wd:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\box_scale:Nnn, \box_scale:cnn}
% \begin{macro}[aux]{\box_scale_aux:Nnn}
%   When scaling a box, setting the scaling itself is easy enough. The
%   new dimensions are also relatively easy to find, allowing only for
%   the need to keep them positive in all cases. Once that is done then
%   after a check for the trivial scaling a hand-off can be made to the
%   common code. The dimension scaling operations are carried out using
%   the \TeX{} mechanism as it avoids needing to use \texttt{fp}
%   operations.
%    \begin{macrocode}
\cs_new_protected:Npn \box_scale:Nnn #1#2#3
  {
    \hbox_set:Nn #1
      {
        \group_begin:
          \fp_set:Nn \l_box_scale_x_fp {#2}
          \fp_set:Nn \l_box_scale_y_fp {#3}
          \dim_set:Nn \l_box_top_dim    {  \box_ht:N #1 }
          \dim_set:Nn \l_box_bottom_dim { -\box_dp:N #1 }
          \dim_set:Nn \l_box_right_dim  {  \box_wd:N #1 }
          \dim_zero:N \l_box_left_dim
          \box_scale_aux:Nnn #1 {#2} {#3}
        \group_end:
      }
  }
\cs_generate_variant:Nn \box_scale:Nnn { c }
\cs_new_protected:Npn \box_scale_aux:Nnn #1#2#3
  {
    \fp_compare:nNnTF \l_box_scale_y_fp > \c_zero_fp
      {
        \dim_set:Nn \l_box_top_new_dim    { #3 \l_box_top_dim }
        \dim_set:Nn \l_box_bottom_new_dim { #3 \l_box_bottom_dim }
      }
      {
        \dim_set:Nn  \l_box_top_new_dim    { -#3 \l_box_bottom_dim }
        \dim_set:Nn  \l_box_bottom_new_dim { -#3 \l_box_top_dim }
      }
    \fp_compare:nNnTF \l_box_scale_x_fp > \c_zero_fp
      { \l_box_right_new_dim #2 \l_box_right_dim }
      { \l_box_right_new_dim -#2 \l_box_right_dim }
    \box_resize_common:N #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\box_resize_common:N}
%   The main resize function places in input into a box which will start
%   of with zero width, and includes the handles for engine rescaling.
%    \begin{macrocode}
\cs_new_protected:Npn \box_resize_common:N #1
  {
    \hbox_set:Nn \l_box_internal_box
      {
        \driver_box_scale_begin:
        \hbox_overlap_right:n { \box_use:N #1 }
        \driver_box_scale_end:
      }
%    \end{macrocode}
%   The new height and depth can be applied directly.
%    \begin{macrocode}
    \box_set_ht:Nn \l_box_internal_box { \l_box_top_new_dim }
    \box_set_dp:Nn \l_box_internal_box { \l_box_bottom_new_dim }
%    \end{macrocode}
%   Things are not quite as obvious for the width, as the reference point
%   needs to remain unchanged. For positive scaling factors resizing the
%   box is all that is needed. However, for case of a negative scaling
%   the material must be shifted such that the reference point ends up in
%   the right place.
%    \begin{macrocode}
    \fp_compare:nNnTF \l_box_scale_x_fp < \c_zero_fp
      {
        \hbox_to_wd:nn { \l_box_right_new_dim }
          {
            \tex_kern:D \l_box_right_new_dim
            \box_use:N \l_box_internal_box
            \tex_hss:D
          }
      }
      {
        \box_set_wd:Nn \l_box_internal_box { \l_box_right_new_dim }
        \box_use:N \l_box_internal_box
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Viewing part of a box}
%
% \begin{macro}{\box_clip:N, \box_clip:c}
%   A wrapper around the driver-dependent code.
%    \begin{macrocode}
\cs_new_protected:Npn \box_clip:N #1
  { \hbox_set:Nn #1 { \driver_box_use_clip:N #1 } }
\cs_generate_variant:Nn \box_clip:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\box_trim:Nnnnn, \box_trim:cnnnn}
%   Trimming from the left- and right-hand edges of the box is easy. The total
%   width is set to remove from the right, and a skip will shift the material
%   to remove from the left.
%    \begin{macrocode}
\cs_new_protected:Npn \box_trim:Nnnnn #1#2#3#4#5
  {
    \box_set_wd:Nn #1 { \box_wd:N #1 - (#4) - (#2) }
    \hbox_set:Nn #1
      {
        \skip_horizontal:n { - \dim_eval:n {#2} }
        \box_use:N #1
      }
%    \end{macrocode}
%   For the height and depth, there is a need to watch the baseline is
%   respected. Material always has to stay on the correct side, so trimming
%   has to check that there is enough material to trim.
%    \begin{macrocode}
    \dim_compare:nNnTF { \box_dp:N #1 } > {#3}
      { \box_set_dp:Nn #1 { \box_dp:N #1 - (#3) } }
      {
        \hbox_set:Nn #1
          { \box_move_down:nn { #3 - \box_dp:N #1 } { \box_use:N #1 } }
        \box_set_dp:Nn #1 \c_zero_dim
      }
    \dim_compare:nNnTF { \box_ht:N #1 } > {#5}
      { \box_set_ht:Nn #1 { \box_ht:N #1 - (#5) } }
      {
        \hbox_set:Nn #1
          { \box_move_up:nn { #5 - \box_ht:N #1 } { \box_use:N #1 } }
        \box_set_ht:Nn #1 \c_zero_dim
      }
  }
\cs_generate_variant:Nn \box_trim:Nnnnn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\box_viewport:Nnnnn, \box_viewport:cnnnn}
%   The same general logic as for clipping, but with absolute dimensions.
%   Thus again width is easy and height is harder.
%    \begin{macrocode}
\cs_new_protected:Npn \box_viewport:Nnnnn #1#2#3#4#5
  {
    \box_set_wd:Nn #1 { (#4) - (#2) }
    \hbox_set:Nn #1
      {
        \skip_horizontal:n { - \dim_eval:n {#2} }
        \box_use:N #1
      }
    \dim_compare:nNnTF {#3} > \c_zero_dim
      {
        \hbox_set:Nn #1 { \box_move_down:nn {#3} { \box_use:N #1 } }
        \box_set_dp:Nn #1 \c_zero_dim
      }
      { \box_set_dp:Nn #1 { - \dim_eval:n {#3} } }
    \dim_compare:nNnTF {#5} > \c_zero_dim
      { \box_set_ht:Nn #1 {#5} }
      {
        \hbox_set:Nn #1
          { \box_move_up:nn { -\dim_eval:n {#5} } { \box_use:N #1 } }
        \box_set_ht:Nn #1 \c_zero_dim
      }
  }
\cs_generate_variant:Nn \box_viewport:Nnnnn { c }
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Additions to \pkg{l3clist}}
%
% \begin{macro}{\clist_count:N, \clist_count:c}
% \begin{macro}{\clist_count:n}
% \begin{macro}[aux]{\clist_count_aux:w}
%   Counting the items in a comma list is done using the same approach as for
%   other token count functions: turn each entry into a \texttt{+1} then use
%   integer evaluation to actually do the mathematics.
%   In the case of an \texttt{n}-type comma-list, we could of course use
%   \cs{clist_map_function:nN}, but that is very slow, because it carefully
%   removes spaces. Instead, we loop manually, and skip blank items
%   (but not |{}|, hence the extra spaces).
%    \begin{macrocode}
\cs_new:Npn \clist_count:N #1
  {
    \int_eval:n
      {
        0
        \clist_map_function:NN #1 \clist_count_aux:n
      }
  }
\cs_new:Npn \clist_count_aux:n #1 { + \c_one }
\cs_new:Npx \clist_count:n #1
  {
    \exp_not:N \int_eval:n
      {
        0
        \exp_not:N \clist_count_n_aux:w \c_space_tl
        #1 \exp_not:n { , \q_recursion_tail , \q_recursion_stop }
      }
  }
\cs_new:Npx \clist_count_n_aux:w #1 ,
  {
    \exp_not:n { \exp_args:Nf \quark_if_recursion_tail_stop:n } {#1}
    \exp_not:N \tl_if_blank:nF {#1} { + \c_one }
    \exp_not:N \clist_count_n_aux:w \c_space_tl
  }
\cs_generate_variant:Nn \clist_count:N { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\clist_item:Nn, \clist_item:cn}
% \begin{macro}[aux]{\clist_item_aux:nnNn}
% \begin{macro}[aux]{\clist_item_N_loop:nw}
%   To avoid needing to test the end of the list at each step,
%   we first compute the \meta{length} of the list. If the item number
%   is less than $-\meta{length}$ or more than $\meta{length}-1$,
%   the result is empty. If it is negative, but not less than $-\meta{length}$,
%   add the \meta{length} to the item number before performing the loop.
%   The loop itself is very simple, return the item if the counter
%   reached zero, otherwise, decrease the counter and repeat.
%    \begin{macrocode}
\cs_new:Npn \clist_item:Nn #1#2
  {
    \exp_args:Nfo \clist_item_aux:nnNn
      { \clist_count:N #1 }
      #1
      \clist_item_N_loop:nw
      {#2}
  }
\cs_new:Npn \clist_item_aux:nnNn #1#2#3#4
  {
    \int_compare:nNnTF {#4} < \c_zero
      {
        \int_compare:nNnTF {#4} < { - #1 }
          { \use_none_delimit_by_q_stop:w }
          { \exp_args:Nf #3 { \int_eval:n { #4 + #1 } } }
      }
      {
        \int_compare:nNnTF {#4} < {#1}
          { #3 {#4} }
          { \use_none_delimit_by_q_stop:w }
      }
    #2, \q_stop
  }
\cs_new:Npn \clist_item_N_loop:nw #1 #2,
  {
    \int_compare:nNnTF {#1} = \c_zero
      { \use_i_delimit_by_q_stop:nw { \exp_not:n {#2} } }
      { \exp_args:Nf \clist_item_N_loop:nw { \int_eval:n { #1 - 1 } } }
  }
\cs_generate_variant:Nn \clist_item:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\clist_item:nn}
% \begin{macro}[aux]{
%     \clist_item_n_aux:nw,
%     \clist_item_n_loop:nw,
%     \clist_item_n_end:n,
%     \clist_item_n_strip:w}
%   This starts in the same way as \cs{clist_item:Nn} by checking the length
%   of the comma list. The final item should be space-trimmed before being
%   brace-stripped, hence we insert a couple of odd-looking
%   \cs{prg_do_nothing:} to avoid losing braces. Blank items are ignored.
%    \begin{macrocode}
\cs_new:Npn \clist_item:nn #1#2
  {
    \exp_args:Nf \clist_item_aux:nnNn
      { \clist_count:n {#1} }
      {#1}
      \clist_item_n_aux:nw
      {#2}
  }
\cs_new:Npn \clist_item_n_aux:nw #1
  { \clist_item_n_loop:nw {#1} \prg_do_nothing: }
\cs_new:Npn \clist_item_n_loop:nw #1 #2,
  {
    \exp_args:No \tl_if_blank:nTF {#2}
      { \clist_item_n_loop:nw {#1} \prg_do_nothing: }
      {
        \int_compare:nNnTF {#1} = \c_zero
          { \exp_args:No \clist_item_n_end:n {#2} }
          {
            \exp_args:Nf \clist_item_n_loop:nw
              { \int_eval:n { #1 - 1 } }
              \prg_do_nothing:
          }
      }
  }
\cs_new:Npn \clist_item_n_end:n #1 #2 \q_stop
  {
    \exp_after:wN \exp_after:wN \exp_after:wN \clist_item_n_strip:w
    \tl_trim_spaces:n {#1} ,
  }
\cs_new:Npn \clist_item_n_strip:w #1 , { \exp_not:n {#1} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {
%     \clist_set_from_seq:NN, \clist_set_from_seq:cN,
%     \clist_set_from_seq:Nc, \clist_set_from_seq:cc
%   }
% \UnitTested
% \begin{macro}
%   {
%     \clist_gset_from_seq:NN, \clist_gset_from_seq:cN,
%     \clist_gset_from_seq:Nc, \clist_gset_from_seq:cc
%   }
% \UnitTested
% \begin{macro}[aux]{\clist_set_from_seq_aux:NNNN}
% \begin{macro}[aux]{\clist_wrap_item:n}
%   Setting a comma list from a comma-separated list is done using a simple
%   mapping. We wrap most items with \cs{exp_not:n}, and a comma. Items which
%   contain a comma or a space are surrounded by an extra set of braces. The
%   first comma must be removed, except in the case of an empty comma-list.
%    \begin{macrocode}
\cs_new_protected:Npn \clist_set_from_seq:NN
  { \clist_set_from_seq_aux:NNNN \clist_clear:N  \tl_set:Nx  }
\cs_new_protected:Npn \clist_gset_from_seq:NN
  { \clist_set_from_seq_aux:NNNN \clist_gclear:N \tl_gset:Nx }
\cs_new_protected:Npn \clist_set_from_seq_aux:NNNN #1#2#3#4
  {
    \seq_if_empty:NTF #4
      { #1 #3 }
      {
        #2 #3
          {
            \exp_last_unbraced:Nf \use_none:n
              { \seq_map_function:NN #4 \clist_wrap_item:n }
          }
      }
  }
\cs_new:Npn \clist_wrap_item:n #1
  {
    ,
    \tl_if_empty:oTF { \clist_set_from_seq_aux:w #1 ~ , #1 ~ }
      { \exp_not:n   {#1}   }
      { \exp_not:n { {#1} } }
  }
\cs_new:Npn \clist_set_from_seq_aux:w #1 , #2 ~ { }
\cs_generate_variant:Nn \clist_set_from_seq:NN  {     Nc }
\cs_generate_variant:Nn \clist_set_from_seq:NN  { c , cc }
\cs_generate_variant:Nn \clist_gset_from_seq:NN {     Nc }
\cs_generate_variant:Nn \clist_gset_from_seq:NN { c , cc }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {
%     \clist_const:Nn, \clist_const:cn,
%     \clist_const:Nx, \clist_const:cx
%   }
%   Creating and initializing a constant comma list is done in a way
%   similar to \cs{clist_set:Nn} and \cs{clist_gset:Nn}, being careful
%   to strip spaces.
%    \begin{macrocode}
\cs_new_protected:Npn \clist_const:Nn #1#2
  { \tl_const:Nx #1 { \clist_trim_spaces:n {#2} } }
\cs_generate_variant:Nn \clist_const:Nn { c , Nx , cx }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\clist_if_empty:n}
% \begin{macro}[aux, EXP]{\clist_if_empty_n_aux:w}
% \begin{macro}[aux, EXP]{\clist_if_empty_n_aux:wNw}
%   As usual, we insert a token (here |?|) before grabbing
%   any argument: this avoids losing braces. The argument
%   of \cs{tl_if_empty:oTF} is empty if |#1| is |?| followed
%   by blank spaces (besides, this particular variant of
%   the emptyness test is optimized). If the item of the
%   comma list is blank, grab the next one. As soon as one
%   item is non-blank, exit: the second auxiliary will grab
%   \cs{prg_return_false:} as |#2|, unless every item in
%   the comma list was blank and the loop actually got broken
%   by the trailing |\q_mark \prg_return_false:| item.
%    \begin{macrocode}
\prg_new_conditional:Npnn \clist_if_empty:n #1 { p , T , F , TF }
  {
    \clist_if_empty_n_aux:w ? #1
    , \q_mark \prg_return_false:
    , \q_mark \prg_return_true:
    \q_stop
  }
\cs_new:Npn \clist_if_empty_n_aux:w #1 ,
  {
    \tl_if_empty:oTF { \use_none:nn #1 ? }
      { \clist_if_empty_n_aux:w ? }
      { \clist_if_empty_n_aux:wNw }
  }
\cs_new:Npn \clist_if_empty_n_aux:wNw #1 \q_mark #2#3 \q_stop {#2}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Additions to \pkg{l3coffins}}
% 
% \subsection{Rotating coffins}
%
% \begin{variable}{\l_coffin_sin_fp}
% \begin{variable}{\l_coffin_cos_fp}
%   Used for rotations to get the sine and cosine values.
%    \begin{macrocode}
\fp_new:N \l_coffin_sin_fp
\fp_new:N \l_coffin_cos_fp
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\l_coffin_bounding_prop}
%   A property list for the bounding box of a coffin. This is only needed
%   during the rotation, so there is just the one.
%    \begin{macrocode}
\prop_new:N \l_coffin_bounding_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_coffin_bounding_shift_dim}
%   The shift of the bounding box of a coffin from the real content.
%    \begin{macrocode}
\dim_new:N \l_coffin_bounding_shift_dim
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_coffin_left_corner_dim}
% \begin{variable}{\l_coffin_right_corner_dim}
% \begin{variable}{\l_coffin_bottom_corner_dim}
% \begin{variable}{\l_coffin_top_corner_dim}
%   These are used to hold maxima for the various corner values: these
%   thus define the minimum size of the bounding box after rotation.
%    \begin{macrocode}
\dim_new:N \l_coffin_left_corner_dim
\dim_new:N \l_coffin_right_corner_dim
\dim_new:N \l_coffin_bottom_corner_dim
\dim_new:N \l_coffin_top_corner_dim
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \begin{macro}{\coffin_rotate:Nn, \coffin_rotate:cn}
%   Rotating a coffin requires several steps which can be conveniently
%   run together. The first step is to convert the angle given in degrees
%   to one in radians. This is then used to set \cs{l_coffin_sin_fp} and
%   \cs{l_coffin_cos_fp}, which are carried through unchanged for the rest
%   of the procedure.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_rotate:Nn #1#2
  {
    \fp_set:Nn \l_coffin_sin_fp { sin ( ( #2 ) * deg ) }
    \fp_set:Nn \l_coffin_cos_fp { cos ( ( #2 ) * deg ) }
%    \end{macrocode}
%   The corners and poles of the coffin can now be rotated around the
%    origin. This is best achieved using mapping functions.
%    \begin{macrocode}
    \prop_map_inline:cn { l_coffin_corners_ \int_value:w #1 _prop }
      { \coffin_rotate_corner:Nnnn #1 {##1} ##2 }
    \prop_map_inline:cn { l_coffin_poles_ \int_value:w #1 _prop }
      { \coffin_rotate_pole:Nnnnnn #1 {##1} ##2 }
%    \end{macrocode}
%   The bounding box of the coffin needs to be rotated, and to do this
%   the corners have to be found first. They are then rotated in the same
%   way as the corners of the coffin material itself.
%    \begin{macrocode}
    \coffin_set_bounding:N #1
    \prop_map_inline:Nn \l_coffin_bounding_prop
      { \coffin_rotate_bounding:nnn {##1} ##2 }
%    \end{macrocode}
%   At this stage, there needs to be a calculation to find where the
%   corners of the content and the box itself will end up.
%    \begin{macrocode}
    \coffin_find_corner_maxima:N #1
    \coffin_find_bounding_shift:
    \box_rotate:Nn #1 {#2}
%    \end{macrocode}
%   The correction of the box position itself takes place here. The idea
%   is that the bounding box for a coffin is tight up to the content, and
%   has the reference point at the bottom-left. The $x$-direction is
%   handled by moving the content by the difference in the positions of
%   the bounding box and the content left edge. The $y$-direction is
%   dealt with by moving the box down by any depth it has acquired.
%    \begin{macrocode}
    \hbox_set:Nn #1
      {
        \tex_kern:D \l_coffin_bounding_shift_dim
        \tex_kern:D -\l_coffin_left_corner_dim
        \box_move_down:nn { \l_coffin_bottom_corner_dim }
          { \box_use:N #1 }
      }
%    \end{macrocode}
%   If there have been any previous rotations then the size of the
%   bounding box will be bigger than the contents. This can be corrected
%   easily by setting the size of the box to the height and width of the
%   content.
%    \begin{macrocode}
    \box_set_ht:Nn #1
      { \l_coffin_top_corner_dim - \l_coffin_bottom_corner_dim }
    \box_set_dp:Nn #1 { 0 pt }
    \box_set_wd:Nn #1
      { \l_coffin_right_corner_dim - \l_coffin_left_corner_dim }
%    \end{macrocode}
%   The final task is to move the poles and corners such that they are
%   back in alignment with the box reference point.
%    \begin{macrocode}
    \prop_map_inline:cn { l_coffin_corners_ \int_value:w #1 _prop }
      { \coffin_shift_corner:Nnnn #1 {##1} ##2 }
    \prop_map_inline:cn { l_coffin_poles_ \int_value:w #1 _prop }
      { \coffin_shift_pole:Nnnnnn #1 {##1} ##2 }
  }
\cs_generate_variant:Nn \coffin_rotate:Nn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\coffin_set_bounding:N}
%   The bounding box corners for a coffin are easy enough to find: this
%   is the same code as for the corners of the material itself, but
%   using a dedicated property list.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_set_bounding:N #1
  {
   \prop_put:Nnx \l_coffin_bounding_prop { tl }
      { { 0 pt } { \dim_use:N \box_ht:N #1 } }
    \prop_put:Nnx \l_coffin_bounding_prop { tr }
      { { \dim_use:N \box_wd:N #1 } { \dim_use:N \box_ht:N #1 } }
    \dim_set:Nn \l_coffin_internal_dim { - \box_dp:N #1 }
    \prop_put:Nnx \l_coffin_bounding_prop { bl }
      { { 0 pt } { \dim_use:N \l_coffin_internal_dim } }
    \prop_put:Nnx \l_coffin_bounding_prop { br }
      { { \dim_use:N \box_wd:N #1 } { \dim_use:N \l_coffin_internal_dim } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\coffin_rotate_bounding:nnn}
% \begin{macro}{\coffin_rotate_corner:Nnnn}
%   Rotating the position of the corner of the coffin is just a case
%   of treating this as a vector from the reference point. The same
%   treatment is used for the corners of the material itself and the
%   bounding box.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_rotate_bounding:nnn #1#2#3
  {
    \coffin_rotate_vector:nnNN {#2} {#3} \l_coffin_x_dim \l_coffin_y_dim
    \prop_put:Nnx \l_coffin_bounding_prop {#1}
      { { \dim_use:N \l_coffin_x_dim } { \dim_use:N \l_coffin_y_dim } }
  }
\cs_new_protected:Npn \coffin_rotate_corner:Nnnn #1#2#3#4
  {
    \coffin_rotate_vector:nnNN {#3} {#4} \l_coffin_x_dim \l_coffin_y_dim
    \prop_put:cnx { l_coffin_corners_ \int_value:w #1 _prop } {#2}
      { { \dim_use:N \l_coffin_x_dim } { \dim_use:N \l_coffin_y_dim } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\coffin_rotate_pole:Nnnnnn}
%   Rotating a single pole simply means shifting the co-ordinate of
%   the pole and its direction. The rotation here is about the bottom-left
%   corner of the coffin.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_rotate_pole:Nnnnnn #1#2#3#4#5#6
  {
    \coffin_rotate_vector:nnNN {#3} {#4} \l_coffin_x_dim \l_coffin_y_dim
    \coffin_rotate_vector:nnNN {#5} {#6}
      \l_coffin_x_prime_dim \l_coffin_y_prime_dim
    \coffin_set_pole:Nnx #1 {#2}
      {
        { \dim_use:N \l_coffin_x_dim } { \dim_use:N \l_coffin_y_dim }
        { \dim_use:N \l_coffin_x_prime_dim }
        { \dim_use:N \l_coffin_y_prime_dim }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\coffin_rotate_vector:nnNN}
%   A rotation function, which needs only an input vector (as dimensions)
%   and an output space. The values \cs{l_coffin_cos_fp} and
%   \cs{l_coffin_sin_fp} should previously have been set up correctly.
%   Working this way means that the floating point work is kept to a
%   minimum: for any given rotation the sin and cosine values do no
%   change, after all.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_rotate_vector:nnNN #1#2#3#4
  {
    \dim_set:Nn #3
      {
        \fp_to_dim:n
          {
                \dim_to_fp:n {#1} * \l_coffin_cos_fp
            - ( \dim_to_fp:n {#2} * \l_coffin_sin_fp )
          }
      }
    \dim_set:Nn #4
      {
        \fp_to_dim:n
          {
                \dim_to_fp:n {#1} * \l_coffin_sin_fp
            + ( \dim_to_fp:n {#2} * \l_coffin_cos_fp )
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\coffin_find_corner_maxima:N}
% \begin{macro}[aux]{\coffin_find_corner_maxima_aux:nn}
%   The idea here is to find the extremities of the content of the
%   coffin. This is done by looking for the smallest values for the bottom
%   and left corners, and the largest values for the top and right
%   corners. The values start at the maximum dimensions so that the
%   case where all are positive or all are negative works out correctly.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_find_corner_maxima:N #1
  {
    \dim_set:Nn \l_coffin_top_corner_dim   { -\c_max_dim }
    \dim_set:Nn \l_coffin_right_corner_dim { -\c_max_dim }
    \dim_set:Nn \l_coffin_bottom_corner_dim { \c_max_dim }
    \dim_set:Nn \l_coffin_left_corner_dim   { \c_max_dim }
    \prop_map_inline:cn { l_coffin_corners_ \int_value:w #1 _prop }
      { \coffin_find_corner_maxima_aux:nn ##2 }
  }
\cs_new_protected:Npn \coffin_find_corner_maxima_aux:nn #1#2
  {
    \dim_set_min:Nn \l_coffin_left_corner_dim   {#1}
    \dim_set_max:Nn \l_coffin_right_corner_dim  {#1}
    \dim_set_min:Nn \l_coffin_bottom_corner_dim {#2}
    \dim_set_max:Nn \l_coffin_top_corner_dim    {#2}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\coffin_find_bounding_shift:}
% \begin{macro}[aux]{\coffin_find_bounding_shift_aux:nn}
%   The approach to finding the shift for the bounding box is similar to
%   that for the corners. However, there is only one value needed here and
%   a fixed input property list, so things are a bit clearer.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \coffin_find_bounding_shift:
  {
    \dim_set:Nn \l_coffin_bounding_shift_dim { \c_max_dim }
    \prop_map_inline:Nn \l_coffin_bounding_prop
      { \coffin_find_bounding_shift_aux:nn ##2 }
  }
\cs_new_protected:Npn \coffin_find_bounding_shift_aux:nn #1#2
  { \dim_set_min:Nn \l_coffin_bounding_shift_dim {#1} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\coffin_shift_corner:Nnnn}
% \begin{macro}{\coffin_shift_pole:Nnnnnn}
%   Shifting the corners and poles of a coffin means subtracting the
%   appropriate values from the $x$- and $y$-components. For
%   the poles, this means that the direction vector is unchanged.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_shift_corner:Nnnn #1#2#3#4
  {
    \prop_put:cnx { l_coffin_corners_ \int_value:w #1 _ prop } {#2}
      {
        { \dim_eval:n { #3 - \l_coffin_left_corner_dim } }
        { \dim_eval:n { #4 - \l_coffin_bottom_corner_dim } }
      }
  }
\cs_new_protected:Npn \coffin_shift_pole:Nnnnnn #1#2#3#4#5#6
  {
    \prop_put:cnx { l_coffin_poles_ \int_value:w #1 _ prop } {#2}
      {
        { \dim_eval:n { #3 - \l_coffin_left_corner_dim } }
        { \dim_eval:n { #4 - \l_coffin_bottom_corner_dim } }
        {#5} {#6}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}

%
% \subsection{Resizing coffins}
%
% \begin{variable}{\l_coffin_scale_x_fp}
% \begin{variable}{\l_coffin_scale_y_fp}
%   Storage for the scaling factors in $x$ and $y$, respectively.
%    \begin{macrocode}
\fp_new:N \l_coffin_scale_x_fp
\fp_new:N \l_coffin_scale_y_fp
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\l_coffin_scaled_total_height_dim}
% \begin{variable}{\l_coffin_scaled_width_dim}
%   When scaling, the values given have to be turned into absolute values.
%    \begin{macrocode}
\dim_new:N \l_coffin_scaled_total_height_dim
\dim_new:N \l_coffin_scaled_width_dim
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{macro}{\coffin_resize:Nnn, \coffin_resize:cnn}
%   Resizing a coffin begins by setting up the user-friendly names for
%   the dimensions of the coffin box. The new sizes are then turned into
%   scale factor. This is the same operation as takes place for the
%   underlying box, but that operation is grouped and so the same
%   calculation is done here.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_resize:Nnn #1#2#3
  {
    \coffin_set_user_dimensions:N #1
    \box_resize:Nnn #1 {#2} {#3}
    \fp_set:Nn \l_coffin_scale_x_fp
      { \dim_to_fp:n {#2} / \dim_to_fp:n \Width }
    \fp_set:Nn \l_coffin_scale_y_fp
      { \dim_to_fp:n {#3} / \dim_to_fp:n \TotalHeight }
    \coffin_resize_common:Nnn #1 {#2} {#3}
  }
\cs_generate_variant:Nn \coffin_resize:Nnn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\coffin_resize_common:Nnn}
%   The poles and corners of the coffin are scaled to the appropriate
%   places before actually resizing the underlying box.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_resize_common:Nnn #1#2#3
  {
    \prop_map_inline:cn { l_coffin_corners_ \int_value:w #1 _prop }
      { \coffin_scale_corner:Nnnn #1 {##1} ##2 }
    \prop_map_inline:cn { l_coffin_poles_ \int_value:w #1 _prop }
      { \coffin_scale_pole:Nnnnnn #1 {##1} ##2 }
%    \end{macrocode}
%   Negative $x$-scaling values will place the poles in the wrong
%   location: this is corrected here.
%    \begin{macrocode}
    \fp_compare:nNnT \l_coffin_scale_x_fp < \c_zero_fp
      {
        \prop_map_inline:cn { l_coffin_corners_ \int_value:w #1 _prop }
          { \coffin_x_shift_corner:Nnnn #1 {##1} ##2 }
        \prop_map_inline:cn { l_coffin_poles_ \int_value:w #1 _prop }
          { \coffin_x_shift_pole:Nnnnnn #1 {##1} ##2 }
      }
    \coffin_end_user_dimensions:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\coffin_scale:Nnn, \coffin_scale:cnn}
%   For scaling, the opposite calculation is done to find the new
%   dimensions for the coffin. Only the total height is needed, as this
%   is the shift required for corners and poles. The scaling is done
%   the \TeX{} way as this works properly with floating point values
%   without needing to use the \texttt{fp} module.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_scale:Nnn #1#2#3
  {
    \box_scale:Nnn #1 {#2} {#3}
    \coffin_set_user_dimensions:N #1
    \fp_set:Nn \l_coffin_scale_x_fp {#2}
    \fp_set:Nn \l_coffin_scale_y_fp {#3}
    \fp_compare:nNnTF \l_coffin_scale_y_fp > \c_zero_fp
      { \l_coffin_scaled_total_height_dim #3 \TotalHeight }
      { \l_coffin_scaled_total_height_dim -#3 \TotalHeight }
    \fp_compare:nNnTF \l_coffin_scale_x_fp > \c_zero_fp
      { \l_coffin_scaled_width_dim -#2 \Width }
      { \l_coffin_scaled_width_dim #2 \Width }
    \coffin_resize_common:Nnn #1
      { \l_coffin_scaled_width_dim } { \l_coffin_scaled_total_height_dim }
  }
\cs_generate_variant:Nn \coffin_scale:Nnn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\coffin_scale_vector:nnNN}
%   This functions scales a vector from the origin using the pre-set scale
%   factors in $x$ and $y$. This is a much less complex operation
%   than rotation, and as a result the code is a lot clearer.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_scale_vector:nnNN #1#2#3#4
  {
    \dim_set:Nn #3
      { \fp_to_dim:n { \dim_to_fp:n {#1} * \l_coffin_scale_x_fp } }
    \dim_set:Nn #4
      { \fp_to_dim:n { \dim_to_fp:n {#2} * \l_coffin_scale_y_fp } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\coffin_scale_corner:Nnnn}
% \begin{macro}{\coffin_scale_pole:Nnnnnn}
%   Scaling both corners and poles is a simple calculation using the
%   preceding vector scaling.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_scale_corner:Nnnn #1#2#3#4
  {
    \coffin_scale_vector:nnNN {#3} {#4} \l_coffin_x_dim \l_coffin_y_dim
    \prop_put:cnx { l_coffin_corners_ \int_value:w #1 _prop } {#2}
      { { \dim_use:N \l_coffin_x_dim } { \dim_use:N \l_coffin_y_dim } }
  }
\cs_new_protected:Npn \coffin_scale_pole:Nnnnnn #1#2#3#4#5#6
  {
    \coffin_scale_vector:nnNN {#3} {#4} \l_coffin_x_dim \l_coffin_y_dim
    \coffin_set_pole:Nnx #1 {#2}
      {
        { \dim_use:N \l_coffin_x_dim } { \dim_use:N \l_coffin_y_dim }
        {#5} {#6}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\coffin_x_shift_corner:Nnnn}
% \begin{macro}{\coffin_x_shift_pole:Nnnnnn}
%   These functions correct for the $x$ displacement that takes
%   place with a negative horizontal scaling.
%    \begin{macrocode}
\cs_new_protected:Npn \coffin_x_shift_corner:Nnnn #1#2#3#4
  {
    \prop_put:cnx { l_coffin_corners_ \int_value:w #1 _prop } {#2}
      {
        { \dim_eval:n { #3 + \box_wd:N #1 } } {#4}
    }
  }
\cs_new_protected:Npn \coffin_x_shift_pole:Nnnnnn #1#2#3#4#5#6
  {
    \prop_put:cnx { l_coffin_poles_ \int_value:w #1 _prop } {#2}
      {
        { \dim_eval:n #3 + \box_wd:N #1 } {#4}
        {#5} {#6}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Additions to \pkg{l3file}}
%
% \begin{macro}{\ior_map_inline:Nn, \ior_str_map_inline:Nn}
% \begin{macro}[aux]{\ior_str_map_inline_aux:NNn}
% \begin{macro}[aux]{\ior_str_map_inline_aux:NNNn}
% \begin{macro}[aux]{\ior_str_map_inline_loop:NNN}
% \begin{variable}{\l_ior_internal_tl}
%   Mapping to an input stream can be done on either a token or a string
%   basis, hence the set up. Within that, there is a check to avoid reading
%   past the end of a file, hence the two applications of \cs{ior_if_eof:N}.
%   This mapping cannot be nested as the stream has only one \enquote{current
%   line}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \ior_map_inline:Nn
  { \ior_map_inline_aux:NNn \ior_to:NN }
\cs_new_protected_nopar:Npn \ior_str_map_inline:Nn
  { \ior_map_inline_aux:NNn \ior_str_to:NN }
\cs_new_protected_nopar:Npn \ior_map_inline_aux:NNn
  {
    \exp_args:Nc \ior_map_inline_aux:NNNn
      { ior_map_ \int_use:N \g_prg_map_int :n }
  }
\cs_new_protected:Npn \ior_map_inline_aux:NNNn #1#2#3#4
  {
    \cs_set:Npn #1 ##1 {#4}
    \int_gincr:N \g_prg_map_int
    \ior_if_eof:NF #3 { \ior_map_inline_loop:NNN #1#2#3 }
    \prg_break_point:n { \int_gdecr:N \g_prg_map_int }
  }
\cs_new_protected:Npn \ior_map_inline_loop:NNN #1#2#3
  {
    #2 #3 \l_ior_internal_tl
    \ior_if_eof:NF #3
      {
        \exp_args:No #1 \l_ior_internal_tl
        \ior_map_inline_loop:NNN #1#2#3
      }
  }
\tl_new:N  \l_ior_internal_tl
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% \subsection{Additions to \pkg{l3prop}}
% 
% \begin{macro}[rEXP]{\prop_map_tokens:Nn, \prop_map_tokens:cn}
% \begin{macro}[aux]{\prop_map_tokens_aux:nwn}
%   The mapping grabs one key--value pair at a time, and stops when
%   reaching the marker key \cs{q_recursion_tail}, which
%   cannot appear in normal keys since those are strings. The odd
%   construction |\use:n {#1}| allows |#1| to contain any token.
%    \begin{macrocode}
\cs_new:Npn \prop_map_tokens:Nn #1#2
  {
    \exp_last_unbraced:Nno \prop_map_tokens_aux:nwn {#2} #1
    \q_recursion_tail \q_prop { }
    \prg_break_point:n { }
  }
\cs_new:Npn \prop_map_tokens_aux:nwn #1 \q_prop #2 \q_prop #3
  {
    \if_meaning:w \q_recursion_tail #2
       \exp_after:wN \prop_map_break:
    \fi:
    \use:n {#1} {#2} {#3}
    \prop_map_tokens_aux:nwn {#1}
  }
\cs_generate_variant:Nn \prop_map_tokens:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\prop_get:Nn, \prop_get:cn}
% \begin{macro}[aux]{\prop_get_Nn_aux:nwn}
%   Getting the value corresponding to a key in a property list in an
%   expandable fashion is a simple instance of mapping some tokens.
%   Map the function \cs{prop_get_aux:nnn} which takes as its three
%   arguments the \meta{key} that we are looking for, the current
%   \meta{key} and the current \meta{value}. If the \meta{keys} match,
%   the \meta{value} is returned. If none of the keys match, this expands
%   to nothing.
%    \begin{macrocode}
\cs_new:Npn \prop_get:Nn #1#2
  {
    \exp_last_unbraced:Noo \prop_get_Nn_aux:nwn
      { \tl_to_str:n {#2} } #1
      \tl_to_str:n {#2} \q_prop { }
    \prg_break_point:n { }
  }
\cs_new:Npn \prop_get_Nn_aux:nwn #1 \q_prop #2 \q_prop #3
  {
    \str_if_eq:xxTF {#1} {#2}
      { \prg_map_break:n { \exp_not:n {#3} } }
      { \prop_get_Nn_aux:nwn {#1} }
  }
\cs_generate_variant:Nn \prop_get:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Additions to \pkg{l3skip}}
% 
% \begin{macro}{\skip_split_finite_else_action:nnNN}
%   This macro is useful when performing error checking in certain
%   circumstances. If the \meta{skip} register holds finite glue it sets
%   |#3| and |#4| to the stretch and shrink component, resp. If it holds
%   infinite glue set |#3| and |#4| to zero and issue the special action
%   |#2| which is probably an error message.
%   Assignments are local.
%    \begin{macrocode}
\cs_new:Npn \skip_split_finite_else_action:nnNN #1#2#3#4
  {
    \skip_if_finite:nTF {#1}
      {
        #3 = \etex_gluestretch:D #1 \scan_stop:
        #4 = \etex_glueshrink:D  #1 \scan_stop:
      }
      {
        #3 = \c_zero_skip
        #4 = \c_zero_skip
        #2
      }
  }
%    \end{macrocode}
%  \end{macro}
%  
% \subsection{Additions to \pkg{l3tl}}
%
% \begin{macro}[EXP]{\str_if_eq_return:xx}
%   It turns out that we often need to compare a token list
%   with the result of applying some function to it, and
%   return with \cs{prg_return_true/false:}. This test is
%   similar to \cs{str_if_eq:nnTF}, but hard-coded for speed.
%    \begin{macrocode}
\cs_new:Npn \str_if_eq_return:xx #1 #2
  {
    \if_int_compare:w \pdftex_strcmp:D {#1} {#2} = \c_zero
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\tl_if_single:N}
%   Expand the token list and feed it to \cs{tl_if_single:n}.
%    \begin{macrocode}
\cs_new:Npn \tl_if_single_p:N { \exp_args:No \tl_if_single_p:n }
\cs_new:Npn \tl_if_single:NT  { \exp_args:No \tl_if_single:nT  }
\cs_new:Npn \tl_if_single:NF  { \exp_args:No \tl_if_single:nF  }
\cs_new:Npn \tl_if_single:NTF { \exp_args:No \tl_if_single:nTF }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\tl_if_single:n}
%   A token list has exactly one item if it is either a single
%   token surrounded by optional explicit spaces, or a single brace
%   group surrounded by optional explicit spaces. The naive
%   version of this test would do \cs{use_none:n} |#1|, and
%   test if the result is empty. However, this will fail when
%   the token list is empty. Furthermore, it does not allow optional
%   trailing spaces.
%    \begin{macrocode}
\prg_new_conditional:Npnn \tl_if_single:n #1 { p , T , F , TF }
  { \str_if_eq_return:xx { \exp_not:o { \use_none:nn #1 ?? } } {?} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\tl_if_single_token:n}
%   There are four cases: empty token list, token list starting with
%   a normal token, with a brace group, or with a space token.
%   If the token list starts with a normal token, remove it
%   and check for emptyness. Otherwise, compare with a single
%   space, only case where we have a single token.
%    \begin{macrocode}
\prg_new_conditional:Npnn \tl_if_single_token:n #1 { p , T , F , TF }
  {
    \tl_if_head_N_type:nTF {#1}
      { \str_if_eq_return:xx { \exp_not:o { \use_none:n #1 } } { } }
      { \str_if_eq_return:xx { \exp_not:n {#1} } { ~ } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\q_tl_act_mark,\q_tl_act_stop}
%   The \cs{tl_act} functions may be applied to any token list.
%   Hence, we use two private quarks, to allow any token, even quarks,
%   in the token list.^^A in particular critical for future \::e.
%   Only \cs{q_tl_act_mark} and \cs{q_tl_act_stop} may not appear
%   in the token lists manipulated by \cs{tl_act} functions. The quarks
%   are effectively defined in \pkg{l3quark}.
% \end{variable}
%
% \begin{macro}[EXP]{\tl_act:NNNnn,\tl_act_aux:NNNnn}
% \begin{macro}[EXP]{\tl_act_output:n,\tl_act_reverse_output:n,
%     \tl_act_group_recurse:Nnn}
% \begin{macro}[EXP,aux]{\tl_act_loop:w,\tl_act_normal:NwnNNN,
%     \tl_act_group:nwnNNN,\tl_act_space:wwnNNN,\tl_act_end:w}
%   To help control the expansion, \cs{tl_act:NNNnn} starts with
%   \tn{romannumeral} and ends by producing \cs{c_zero}
%   once the result has been obtained. Then loop over tokens,
%   groups, and spaces in |#5|. The marker \cs{q_tl_act_mark}
%   is used both to avoid losing outer braces and to detect the
%   end of the token list more easily. The result is stored
%   as an argument for the dummy function \cs{tl_act_result:n}.
%    \begin{macrocode}
\cs_new:Npn \tl_act:NNNnn { \tex_romannumeral:D \tl_act_aux:NNNnn }
\cs_new:Npn \tl_act_aux:NNNnn #1 #2 #3 #4 #5
  {
    \group_align_safe_begin:
    \tl_act_loop:w #5 \q_tl_act_mark \q_tl_act_stop
    {#4} #1 #2 #3
    \tl_act_result:n { }
  }
%    \end{macrocode}
%   In the loop, we check how the token list begins and act
%   accordingly. In the \enquote{normal} case, we may have
%   reached \cs{q_tl_act_mark}, the end of the list. Then
%   leave \cs{c_zero} and the result in the input stream,
%   to terminate the expansion of \tn{romannumeral}.
%   Otherwise, apply the relevant function to the
%   \enquote{arguments}, |#3|
%   and to the head of the token list. Then repeat the loop.
%   The scheme is the same if the token list starts with a
%   group or with a space. Some extra work is needed to
%   make \cs{tl_act_space:wwnNNN} gobble the space.
%    \begin{macrocode}
\cs_new:Npn \tl_act_loop:w #1 \q_tl_act_stop
  {
    \tl_if_head_N_type:nTF {#1}
      { \tl_act_normal:NwnNNN }
      {
        \tl_if_head_group:nTF {#1}
          { \tl_act_group:nwnNNN }
          { \tl_act_space:wwnNNN }
      }
    #1 \q_tl_act_stop
  }
\cs_new:Npn \tl_act_normal:NwnNNN #1 #2 \q_tl_act_stop #3#4
  {
    \if_meaning:w \q_tl_act_mark #1
      \exp_after:wN \tl_act_end:wn
    \fi:
    #4 {#3} #1
    \tl_act_loop:w #2 \q_tl_act_stop
    {#3} #4
  }
\cs_new:Npn \tl_act_end:wn #1 \tl_act_result:n #2
  { \group_align_safe_end: \c_zero #2 }
\cs_new:Npn \tl_act_group:nwnNNN #1 #2 \q_tl_act_stop #3#4#5
  {
    #5 {#3} {#1}
    \tl_act_loop:w #2 \q_tl_act_stop
    {#3} #4 #5
  }
\exp_last_unbraced:NNo
  \cs_new:Npn \tl_act_space:wwnNNN \c_space_tl #1 \q_tl_act_stop #2#3#4#5
  {
    #5 {#2}
    \tl_act_loop:w #1 \q_tl_act_stop
    {#2} #3 #4 #5
  }
%    \end{macrocode}
%   Typically, the output is done to the right of what was already output,
%   using \cs{tl_act_output:n}, but for the \cs{tl_act_reverse} functions,
%   it should be done to the left.
%    \begin{macrocode}
\cs_new:Npn \tl_act_output:n #1 #2 \tl_act_result:n #3
  { #2 \tl_act_result:n { #3 #1 } }
\cs_new:Npn \tl_act_reverse_output:n #1 #2 \tl_act_result:n #3
  { #2 \tl_act_result:n { #1 #3 } }
%    \end{macrocode}
%   In many applications of \cs{tl_act:NNNnn}, we need to recursively
%   apply some transformation within brace groups, then output. In this
%   code, |#1| is the output function, |#2| is the transformation,
%   which should expand in two steps, and |#3| is the group.
%    \begin{macrocode}
\cs_new:Npn \tl_act_group_recurse:Nnn #1#2#3
  {
    \exp_args:Nf #1
      { \exp_after:wN \exp_after:wN \exp_after:wN { #2 {#3} } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\tl_reverse_tokens:n}
% \begin{macro}[EXP,aux]{\tl_act_reverse_normal:nN,
%     \tl_act_reverse_group:nn, \tl_act_reverse_space:n}
%   The goal is to reverse a token list. This is done by feeding
%   \cs{tl_act_aux:NNNnn} three functions, an empty fourth argument
%   (we don't use it for \cs{tl_act_reverse_tokens:n}), and as
%   a fifth argument the token list to be reversed.
%   Spaces and normal tokens are output to the left of the current
%   output. For groups, we must recursively apply
%   \cs{tl_act_reverse_tokens:n} to the group, and output, still
%   on the left. Note that in all three cases, we throw one argument
%   away: this \meta{parameter} is where for instance the
%   upper/lowercasing action stores the information of whether it
%   is uppercasing or lowercasing.
%    \begin{macrocode}
\cs_new:Npn \tl_reverse_tokens:n #1
  {
    \etex_unexpanded:D \exp_after:wN
      {
        \tex_romannumeral:D
        \tl_act_aux:NNNnn
          \tl_act_reverse_normal:nN
          \tl_act_reverse_group:nn
          \tl_act_reverse_space:n
          { }
          {#1}
      }
  }
\cs_new:Npn \tl_act_reverse_space:n #1
  { \tl_act_reverse_output:n {~} }
\cs_new:Npn \tl_act_reverse_normal:nN #1 #2
  { \tl_act_reverse_output:n {#2} }
\cs_new:Npn \tl_act_reverse_group:nn #1
  {
    \tl_act_group_recurse:Nnn
      \tl_act_reverse_output:n
      { \tl_reverse_tokens:n }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\tl_reverse:n,\tl_reverse:o,\tl_reverse:V}
% \begin{macro}[EXP,aux]{\tl_reverse_group_preserve:nn}
%     The goal here is to reverse without losing spaces nor braces.
%     The only difference with \cs{tl_reverse_tokens:n} is that
%     we now simply output groups without entering them.
%    \begin{macrocode}
\cs_new:Npn \tl_reverse:n #1
  {
    \etex_unexpanded:D \exp_after:wN
      {
        \tex_romannumeral:D
        \tl_act_aux:NNNnn
          \tl_act_reverse_normal:nN
          \tl_act_reverse_group_preserve:nn
          \tl_act_reverse_space:n
          { }
          {#1}
      }
  }
\cs_new:Npn \tl_act_reverse_group_preserve:nn #1 #2
  { \tl_act_reverse_output:n { {#2} } }
\cs_generate_variant:Nn \tl_reverse:n { o , V }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\tl_reverse:N, \tl_reverse:c, \tl_greverse:N, \tl_greverse:c}
%   This reverses the list, leaving \cs{exp_stop_f:} in front,
%   which stops the \texttt{f}-expansion.
%    \begin{macrocode}
\cs_new_protected:Npn \tl_reverse:N #1
  { \tl_set:Nx #1 { \exp_args:No \tl_reverse:n { #1 } } }
\cs_new_protected:Npn \tl_greverse:N #1
  { \tl_gset:Nx #1 { \exp_args:No \tl_reverse:n { #1 } } }
\cs_generate_variant:Nn \tl_reverse:N  { c }
\cs_generate_variant:Nn \tl_greverse:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\tl_count_tokens:n}
% \begin{macro}[EXP,aux]{\tl_act_count_normal:nN,
%     \tl_act_count_group:nn,\tl_act_count_space:n}
%   The token coung is computed through an \cs{int_eval:n} construction.
%   Each \texttt{1+} is output to the \emph{left}, into the integer
%   expression, and the sum is ended by the \cs{c_zero} inserted by
%   \cs{tl_act_end:wn}. Somewhat a hack.
%    \begin{macrocode}
\cs_new:Npn \tl_count_tokens:n #1
  {
    \int_eval:n
      {
        \tl_act_aux:NNNnn
          \tl_act_count_normal:nN
          \tl_act_count_group:nn
          \tl_act_count_space:n
          { }
          {#1}
      }
  }
\cs_new:Npn \tl_act_count_normal:nN #1 #2 { 1 + }
\cs_new:Npn \tl_act_count_space:n #1 { 1 + }
\cs_new:Npn \tl_act_count_group:nn #1 #2
  { 2 + \tl_count_tokens:n {#2} + }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\c_tl_act_uppercase_tl, \c_tl_act_lowercase_tl}
%   These constants contain the correspondance between lowercase
%   and uppercase letters, in the form |aAbBcC...| and |AaBbCc...|
%   respectively.
%    \begin{macrocode}
\tl_const:Nn \c_tl_act_uppercase_tl
  {
    aA bB cC dD eE fF gG hH iI jJ kK lL mM
    nN oO pP qQ rR sS tT uU vV wW xX yY zZ
  }
\tl_const:Nn \c_tl_act_lowercase_tl
  {
    Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm
    Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[EXP]{\tl_expandable_uppercase:n,\tl_expandable_lowercase:n}
% \begin{macro}[EXP,aux]{\tl_act_case_normal:nN,
%     \tl_act_case_group:nn,\tl_act_case_space:n}
%   The only difference between uppercasing and lowercasing is
%   the table of correspondance that is used. As for other
%   token list actions, we feed \cs{tl_act_aux:NNNnn} three
%   functions, and this time, we use the \meta{parameters}
%   argument to carry which case-changing we are applying.
%   A space is simply output. A normal token is compared
%   to each letter in the alphabet using \cs{str_if_eq:nn}
%   tests, and converted if necessary to upper/lowercase,
%   before being output. For a group, we must perform the
%   conversion within the group (the \cs{exp_after:wN} trigger
%   \tn{romannumeral}, which expands fully to give the
%   converted group), then output.
%    \begin{macrocode}
\cs_new:Npn \tl_expandable_uppercase:n #1
  {
    \etex_unexpanded:D \exp_after:wN
      {
        \tex_romannumeral:D
          \tl_act_case_aux:nn { \c_tl_act_uppercase_tl } {#1}
      }
  }
\cs_new:Npn \tl_expandable_lowercase:n #1
  {
    \etex_unexpanded:D \exp_after:wN
      {
        \tex_romannumeral:D
          \tl_act_case_aux:nn { \c_tl_act_lowercase_tl } {#1}
      }
  }
\cs_new:Npn \tl_act_case_aux:nn
  {
    \tl_act_aux:NNNnn
      \tl_act_case_normal:nN
      \tl_act_case_group:nn
      \tl_act_case_space:n
  }
\cs_new:Npn \tl_act_case_space:n #1 { \tl_act_output:n {~} }
\cs_new:Npn \tl_act_case_normal:nN #1 #2
  {
    \exp_args:Nf \tl_act_output:n
      {
        \exp_args:NNo \prg_case_str:nnn #2 {#1}
          { \exp_stop_f: #2 }
      }
  }
\cs_new:Npn \tl_act_case_group:nn #1 #2
  {
    \exp_after:wN \tl_act_output:n \exp_after:wN
      { \exp_after:wN { \tex_romannumeral:D \tl_act_case_aux:nn {#1} {#2} } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\tl_item:nn, \tl_item:Nn, \tl_item:cn}
% \begin{macro}[aux]{\tl_item_aux:nn}
%   The idea here is to find the offset of the item from the left, then use
%   a loop to grab the correct item. If the resulting offset is too large,
%   then \cs{quark_if_recursion_tail_stop:n} terminates the loop, and returns
%   nothing at all.
%    \begin{macrocode}
\cs_new:Npn \tl_item:nn #1#2
  {
    \exp_args:Nf \tl_item_aux:nn
      {
        \int_eval:n
          {
            \int_compare:nNnT {#2} < \c_zero
              { \tl_count:n {#1} + }
            #2
          }
      }
    #1
    \q_recursion_tail
    \prg_break_point:n { }
  }
\cs_new:Npn \tl_item_aux:nn #1#2
  {
    \quark_if_recursion_tail_break:n {#2}
    \int_compare:nNnTF {#1} = \c_zero
      { \tl_map_break:n { \exp_not:n {#2} } }
      { \exp_args:Nf \tl_item_aux:nn { \int_eval:n { #1 - 1 } } }
  }
\cs_new_nopar:Npn \tl_item:Nn { \exp_args:No \tl_item:nn }
\cs_generate_variant:Nn \tl_item:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF]{\tl_if_empty:x}
%   We can test expandably the emptyness of an expanded token list
%   thanks to the primitive \tn{pdfstrcmp} which expands its argument:
%   a token list is empty if and only if its string representation is
%   empty.
%    \begin{macrocode}
\prg_new_conditional:Npnn \tl_if_empty:x #1 { p , T , F , TF }
  { \str_if_eq_return:xx { } {#1} }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
