% \iffalse meta-comment
%
%% File: l3prop.dtx Copyright (C) 1990-2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3kernel bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{l3bootstrap}
\GetIdInfo$Id$
  {L3 Property lists}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3prop} package\\ Property lists^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \LaTeX3 implements a \enquote{property list} data type, which contain
% an unordered list of entries each of which consists of a \meta{key} and
% an associated \meta{value}. The \meta{key} and \meta{value} may both be
% any \meta{balanced text}. It is possible to map functions to property lists
% such that the function is applied to every key--value pair within
% the list.
%
% Each entry in a property list must have a unique \meta{key}: if an entry is
% added to a property list which already contains the \meta{key} then the new
% entry will overwrite the existing one. The \meta{keys} are compared on a
% string basis, using the same method as \cs{str_if_eq:nn}.
%
% Property lists are intended for storing key-based information for use within
% code.  This is in contrast to key--value lists, which are a form of
% \emph{input} parsed by the \pkg{keys} module.
%
% \section{Creating and initialising property lists}
%
% \begin{function}{\prop_new:N, \prop_new:c}
%   \begin{syntax}
%     \cs{prop_new:N} \meta{property list}
%   \end{syntax}
%   Creates a new \meta{property list} or raises an error if the name is
%   already taken. The declaration is global. The \meta{property list} will
%   initially contain no entries.
% \end{function}
%
% \begin{function}
%   {\prop_clear:N, \prop_clear:c, \prop_gclear:N, \prop_gclear:c}
%   \begin{syntax}
%     \cs{prop_clear:N} \meta{property list}
%   \end{syntax}
%   Clears all entries from the \meta{property list}.
% \end{function}
%
% \begin{function}
%   {
%     \prop_clear_new:N,  \prop_clear_new:c,
%     \prop_gclear_new:N, \prop_gclear_new:c
%   }
%   \begin{syntax}
%     \cs{prop_clear_new:N} \meta{property list}
%   \end{syntax}
%   Ensures that the \meta{property list} exists globally by applying
%   \cs{prop_new:N} if necessary, then applies \cs{prop_(g)clear:N} to leave
%   the list empty.
% \end{function}
%
% \begin{function}
%   {
%     \prop_set_eq:NN,  \prop_set_eq:cN,  \prop_set_eq:Nc,  \prop_set_eq:cc,
%     \prop_gset_eq:NN, \prop_gset_eq:cN, \prop_gset_eq:Nc, \prop_gset_eq:cc
%   }
%   \begin{syntax}
%     \cs{prop_set_eq:NN} \meta{property list_1} \meta{property list_2}
%   \end{syntax}
%   Sets the content of \meta{property list_1} equal to that of
%   \meta{property list_2}.
% \end{function}
%
% \section{Adding entries to property lists}
%
% \begin{function}[updated = 2012-07-09]
%   {
%     \prop_put:Nnn,  \prop_put:NnV,  \prop_put:Nno,  \prop_put:Nnx,
%     \prop_put:NVn,  \prop_put:NVV,  \prop_put:Non,  \prop_put:Noo,
%     \prop_put:cnn,  \prop_put:cnV,  \prop_put:cno,  \prop_put:cnx,
%     \prop_put:cVn,  \prop_put:cVV,  \prop_put:con,  \prop_put:coo,
%     \prop_gput:Nnn, \prop_gput:NnV, \prop_gput:Nno, \prop_gput:Nnx,
%     \prop_gput:NVn, \prop_gput:NVV, \prop_gput:Non, \prop_gput:Noo,
%     \prop_gput:cnn, \prop_gput:cnV, \prop_gput:cno, \prop_gput:cnx,
%     \prop_gput:cVn, \prop_gput:cVV, \prop_gput:con, \prop_gput:coo
%   }
%   \begin{syntax}
%     \cs{prop_put:Nnn} \meta{property list} \Arg{key} \Arg{value}
%   \end{syntax}
%   Adds an entry to the \meta{property list} which may be accessed
%   using the \meta{key} and which has \meta{value}. Both the \meta{key}
%   and \meta{value} may contain any \meta{balanced text}. The \meta{key}
%   is stored after processing with \cs{tl_to_str:n}, meaning that
%   category codes are ignored. If the \meta{key} is already present
%   in the \meta{property list}, the existing entry is overwritten
%   by the new \meta{value}.
% \end{function}
%
% \begin{function}
%   {
%     \prop_put_if_new:Nnn,  \prop_put_if_new:cnn,
%     \prop_gput_if_new:Nnn, \prop_gput_if_new:cnn
%   }
%   \begin{syntax}
%     \cs{prop_put_if_new:Nnn} \meta{property list} \Arg{key} \Arg{value}
%   \end{syntax}
%   If the \meta{key} is present in the \meta{property list} then
%   no action is taken. If the \meta{key} is not present in the
%   \meta{property list} then a new entry is added. Both the \meta{key}
%   and \meta{value} may contain any \meta{balanced text}. The \meta{key}
%   is stored after processing with \cs{tl_to_str:n}, meaning that
%   category codes are ignored.
% \end{function}
%
% \section{Recovering values from property lists}
%
% \begin{function}[updated = 2011-08-28]
%   {
%     \prop_get:NnN, \prop_get:NVN, \prop_get:NoN,
%     \prop_get:cnN, \prop_get:cVN, \prop_get:coN,
%   }
%   \begin{syntax}
%     \cs{prop_get:NnN} \meta{property list} \Arg{key} \meta{tl var}
%   \end{syntax}
%   Recovers the \meta{value} stored with \meta{key} from the
%   \meta{property list}, and places this in the \meta{token list
%   variable}. If the \meta{key} is not found in the
%   \meta{property list} then the \meta{token list variable} will
%   contain the special marker \cs{q_no_value}. The \meta{token list
%     variable} is set within the current \TeX{} group. See also
%   \cs{prop_get:NnNTF}.
% \end{function}
%
% \begin{function}[updated = 2011-08-18]
%   {\prop_pop:NnN, \prop_pop:NoN, \prop_pop:cnN, \prop_pop:coN}
%   \begin{syntax}
%     \cs{prop_pop:NnN} \meta{property list} \Arg{key} \meta{tl var}
%   \end{syntax}
%   Recovers the \meta{value} stored with \meta{key} from the
%   \meta{property list}, and places this in the \meta{token list
%   variable}. If the \meta{key} is not found in the
%   \meta{property list} then the \meta{token list variable} will
%   contain the special marker \cs{q_no_value}. The \meta{key} and
%   \meta{value} are then deleted from the property list. Both
%   assignments are local.  See also \cs{prop_pop:NnNTF}.
% \end{function}
%
% \begin{function}[updated = 2011-08-18]
%   {\prop_gpop:NnN, \prop_gpop:NoN, \prop_gpop:cnN, \prop_gpop:coN}
%   \begin{syntax}
%     \cs{prop_gpop:NnN} \meta{property list} \Arg{key} \meta{tl var}
%   \end{syntax}
%   Recovers the \meta{value} stored with \meta{key} from the
%   \meta{property list}, and places this in the \meta{token list
%   variable}. If the \meta{key} is not found in the
%   \meta{property list} then the \meta{token list variable} will
%   contain the special marker \cs{q_no_value}. The \meta{key} and
%   \meta{value} are then deleted from the property list.
%   The \meta{property list} is modified globally, while the assignment of
%   the \meta{token list variable} is local.  See also \cs{prop_gpop:NnNTF}.
% \end{function}
%
% \section{Modifying property lists}
%
% \begin{function}[added = 2012-05-12]
%   {
%     \prop_remove:Nn,  \prop_remove:NV,  \prop_remove:cn,  \prop_remove:cV,
%     \prop_gremove:Nn, \prop_gremove:NV, \prop_gremove:cn, \prop_gremove:cV
%   }
%   \begin{syntax}
%     \cs{prop_remove:Nn} \meta{property list} \Arg{key}
%   \end{syntax}
%   Removes the entry listed under \meta{key} from the
%   \meta{property list}.  If the \meta{key} is
%   not found in the \meta{property list} no change occurs,
%   \emph{i.e}~there is no need to test for the existence of a key before
%   deleting it.
% \end{function}
%
% \section{Property list conditionals}
%
% \begin{function}[EXP, pTF, added = 2012-03-03]
%   {\prop_if_exist:N, \prop_if_exist:c}
%   \begin{syntax}
%     \cs{prop_if_exist_p:N} \meta{property list}
%     \cs{prop_if_exist:NTF} \meta{property list} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{property list} is currently defined.  This does not
%   check that the \meta{property list} really is a property list variable.
% \end{function}
%
% \begin{function}[EXP,pTF]{\prop_if_empty:N, \prop_if_empty:c}
%   \begin{syntax}
%     \cs{prop_if_empty_p:N} \meta{property list}
%     \cs{prop_if_empty:NTF} \meta{property list} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the \meta{property list} is empty (containing no entries).
% \end{function}
%
% \begin{function}[updated = 2011-09-15, EXP, pTF]
%   {
%     \prop_if_in:Nn, \prop_if_in:NV, \prop_if_in:No,
%     \prop_if_in:cn, \prop_if_in:cV, \prop_if_in:co
%   }
%   \begin{syntax}
%     \cs{prop_if_in:NnTF} \meta{property list} \Arg{key} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the \meta{key} is present in the \meta{property list},
%   making the comparison using the method described by \cs{str_if_eq:nnTF}.
%   \begin{texnote}
%     This function iterates through every key--value pair in the
%     \meta{property list} and is therefore slower than using the
%     non-expandable \cs{prop_get:NnNTF}.
%   \end{texnote}
% \end{function}
%
% \section{Recovering values from property lists with branching}
%
% The functions in this section combine tests for the presence of a key
% in a property list with  recovery of the associated valued. This makes them
% useful for cases where different cases follow dependent on the presence
% or absence of a key in a property list. They offer increased readability
% and performance over separate testing and recovery phases.
%
% \begin{function}[updated = 2012-05-19, TF]
%   {
%     \prop_get:NnN, \prop_get:NVN, \prop_get:NoN,
%     \prop_get:cnN, \prop_get:cVN, \prop_get:coN
%   }
%   \begin{syntax}
%     \cs{prop_get:NnNTF} \meta{property list} \Arg{key} \meta{token list variable} \\
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   If the \meta{key} is not present in the \meta{property list}, leaves
%   the \meta{false code} in the input stream.  The value of the
%   \meta{token list variable} is not defined in this case and should
%   not be relied upon.  If the \meta{key} is present in the
%   \meta{property list}, stores the corresponding \meta{value} in the
%   \meta{token list variable} without removing it from the
%   \meta{property list}, then leaves the \meta{true code} in the input
%   stream.  The \meta{token list variable} is assigned locally.
% \end{function}
%
% \begin{function}[TF, added = 2011-08-18, updated = 2012-05-19]
%   {\prop_pop:NnN, \prop_pop:cnN}
%   \begin{syntax}
%     \cs{prop_pop:NnNTF} \meta{property list} \Arg{key} \meta{token list variable} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   If the \meta{key} is not present in the \meta{property list}, leaves
%   the \meta{false code} in the input stream.  The value of the
%   \meta{token list variable} is not defined in this case and should
%   not be relied upon.  If the \meta{key} is present in
%   the \meta{property list}, pops the corresponding \meta{value}
%   in the \meta{token list variable}, \emph{i.e.}~removes the item from
%   the \meta{property list}.
%   Both the \meta{property list} and the \meta{token list variable}
%   are assigned locally.
% \end{function}
%
% \begin{function}[TF, added = 2011-08-18, updated = 2012-05-19]
%   {\prop_gpop:NnN, \prop_gpop:cnN}
%   \begin{syntax}
%     \cs{prop_gpop:NnNTF} \meta{property list} \Arg{key} \meta{token list variable} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   If the \meta{key} is not present in the \meta{property list}, leaves
%   the \meta{false code} in the input stream.  The value of the
%   \meta{token list variable} is not defined in this case and should
%   not be relied upon.  If the \meta{key} is present in
%   the \meta{property list}, pops the corresponding \meta{value}
%   in the \meta{token list variable}, \emph{i.e.}~removes the item from
%   the \meta{property list}.
%   The \meta{property list} is modified globally, while the
%   \meta{token list variable} is assigned locally.
% \end{function}
%
% \section{Mapping to property lists}
%
% \begin{function}[updated = 2012-06-29, rEXP]
%   {\prop_map_function:NN, \prop_map_function:cN}
%   \begin{syntax}
%     \cs{prop_map_function:NN} \meta{property list} \meta{function}
%   \end{syntax}
%   Applies \meta{function} to every \meta{entry} stored in the
%   \meta{property list}. The \meta{function} will receive two argument for
%   each iteration: the \meta{key} and associated \meta{value}.
%   The order in which \meta{entries} are returned is not defined and
%   should not be relied upon.
% \end{function}
%
% \begin{function}[updated = 2012-06-29]
%   {\prop_map_inline:Nn, \prop_map_inline:cn}
%   \begin{syntax}
%     \cs{prop_map_inline:Nn} \meta{property list} \Arg{inline function}
%   \end{syntax}
%   Applies \meta{inline function} to every \meta{entry} stored
%   within the \meta{property list}. The \meta{inline function} should
%   consist of code which will receive the \meta{key} as |#1| and the
%   \meta{value} as |#2|.
%   The order in which \meta{entries} are returned is not defined and
%   should not be relied upon.
% \end{function}
%
% \begin{function}[updated = 2012-06-29, rEXP]{\prop_map_break:}
%   \begin{syntax}
%     \cs{prop_map_break:}
%   \end{syntax}
%   Used to terminate a \cs{prop_map_\ldots} function before all
%   entries in the \meta{property list} have been processed. This will
%   normally take place within a conditional statement, for example
%   \begin{verbatim}
%     \prop_map_inline:Nn \l_my_prop
%       {
%         \str_if_eq:nnTF { #1 } { bingo }
%           { \prop_map_break: }
%           {
%             % Do something useful
%           }
%       }
%   \end{verbatim}
%   Use outside of a \cs{prop_map_\ldots} scenario will lead to low
%   level \TeX{} errors.
% \end{function}
%
% \begin{function}[updated = 2012-06-29, rEXP]{\prop_map_break:n}
%   \begin{syntax}
%     \cs{prop_map_break:n} \Arg{tokens}
%   \end{syntax}
%   Used to terminate a \cs{prop_map_\ldots} function before all
%   entries in the \meta{property list} have been processed, inserting
%   the \meta{tokens} after the mapping has ended. This will
%   normally take place within a conditional statement, for example
%   \begin{verbatim}
%     \prop_map_inline:Nn \l_my_prop
%       {
%         \str_if_eq:nnTF { #1 } { bingo }
%           { \prop_map_break:n { <tokens> } }
%           {
%             % Do something useful
%           }
%       }
%   \end{verbatim}
%   Use outside of a \cs{prop_map_\ldots} scenario will lead to low
%   level \TeX{} errors.
% \end{function}
%
% \section{Viewing property lists}
%
% \begin{function}{\prop_show:N, \prop_show:c}
%   \begin{syntax}
%     \cs{prop_show:N} \meta{property list}
%   \end{syntax}
%   Displays the entries in the \meta{property list} in the terminal.
% \end{function}
%
% \section{Scratch property lists}
%
% \begin{variable}[added = 2012-06-23]{\l_tmpa_prop, \l_tmpb_prop}
%   Scratch property lists for local assignment. These are never used by
%   the kernel code, and so are safe for use with any \LaTeX3-defined
%   function. However, they may be overwritten by other non-kernel
%   code and so should only be used for short-term storage.
% \end{variable}
%
% \begin{variable}[added = 2012-06-23]{\g_tmpa_prop, \g_tmpb_prop}
%   Scratch property lists for global assignment. These are never used by
%   the kernel code, and so are safe for use with any \LaTeX3-defined
%   function. However, they may be overwritten by other non-kernel
%   code and so should only be used for short-term storage.
% \end{variable}
%
% \section{Constants}
%
% \begin{variable}{\c_empty_prop}
%   A permanently-empty property list used for internal comparisons.
% \end{variable}
%
% \section{Internal property list functions}
%
% \begin{variable}{\q__prop}
%   The internal token used to separate out property list entries, separating
%   both the \meta{key} from the \meta{value} and also one entry from another.
% \end{variable}
%
% \begin{function}{\__prop_split:NnTF}
%   \begin{syntax}
%     \cs{__prop_split:NnTF} \meta{property list} \Arg{key} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Splits the \meta{property list} at the \meta{key}, giving three
%   groups: the \meta{extract} of \meta{property list} before the
%   \meta{key}, the \meta{value} associated with the \meta{key} and the
%   \meta{extract} of the \meta{property list} after the \meta{value}.
%   The first \meta{extract} retains the internal structure of a property
%   list. The second is only missing the leading separator \cs{q__prop}.
%   This ensures that the concatenation of the two \meta{extracts} is a
%   property list.
%   If the \meta{key} is present in the \meta{property list} then the
%   \meta{true code} is left in the input stream, followed by the three
%   groups: thus the \meta{true code} should properly absorb three arguments.
%   If the \meta{key} is not present in the \meta{property list} then
%   the \meta{false code} is left in the input stream, with no trailing
%   material.
%   The \meta{key} comparison takes place as described for \cs{str_if_eq:nn}.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3prop} implementation}
%
% \TestFiles{m3prop001, m3prop002, m3prop003, m3prop004, m3show001}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=prop>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\__expl_package_check:
%</package>
%    \end{macrocode}
%
% A property list is a macro whose top-level expansion is for the form
% \begin{quote}
%   \cs{q_@@} \meta{key_1} \cs{q_@@} \Arg{value_1} \\
%   \ldots{} \\
%   \cs{q_@@} \meta{key_n} \cs{q_@@} \Arg{value_n} \\
%   \cs{q_@@}
% \end{quote}
% where the trailing \cs{q_@@} is always present for performance
% reasons: this means that empty property lists are not actually empty.
%
% \begin{macro}[int]{\q_@@}
%   A private quark is used as a marker between entries.
%    \begin{macrocode}
\quark_new:N \q_@@
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}[tested = m3prop004]{\c_empty_prop}
%   An empty prop contains exactly one \cs{q_@@}.
%    \begin{macrocode}
\tl_const:Nn \c_empty_prop { \q_@@ }
%    \end{macrocode}
% \end{variable}
%
% \subsection{Allocation and initialisation}
%
% \begin{macro}[tested = m3prop001]{\prop_new:N,\prop_new:c}
%   Internally, property lists are token lists, but an empty prop
%   is not an empty tl, so we need to do things by hand.
%    \begin{macrocode}
\cs_new_protected:Npn \prop_new:N #1 { \cs_new_eq:NN  #1  \c_empty_prop }
\cs_new_protected:Npn \prop_new:c #1 { \cs_new_eq:cN {#1} \c_empty_prop }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[tested = m3prop001]{\prop_clear:N, \prop_clear:c}
% \begin{macro}[tested = m3prop001]{\prop_gclear:N, \prop_gclear:c}
%   The same idea for  clearing
%    \begin{macrocode}
\cs_new_protected:Npn \prop_clear:N #1  { \cs_set_eq:NN   #1  \c_empty_prop }
\cs_generate_variant:Nn \prop_clear:N { c }
\cs_new_protected:Npn \prop_gclear:N #1 { \cs_gset_eq:NN  #1  \c_empty_prop }
\cs_generate_variant:Nn \prop_gclear:N { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[tested = m3prop001]{\prop_clear_new:N, \prop_clear_new:c}
% \begin{macro}[tested = m3prop001]{\prop_gclear_new:N, \prop_gclear_new:c}
%   Once again a simple copy from the token list functions.
%    \begin{macrocode}
\cs_new_protected:Npn \prop_clear_new:N #1
  { \prop_if_exist:NTF #1 { \prop_clear:N #1 } { \prop_new:N #1 } }
\cs_generate_variant:Nn \prop_clear_new:N { c }
\cs_new_protected:Npn \prop_gclear_new:N #1
  { \prop_if_exist:NTF #1 { \prop_gclear:N #1 } { \prop_new:N #1 } }
\cs_generate_variant:Nn \prop_gclear_new:N { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[tested = m3prop001]
%   {\prop_set_eq:NN, \prop_set_eq:cN, \prop_set_eq:Nc, \prop_set_eq:cc}
% \begin{macro}[tested = m3prop001]
%   {\prop_gset_eq:NN, \prop_gset_eq:cN, \prop_gset_eq:Nc, \prop_gset_eq:cc}
%   Once again, these are simply copies from the token list functions.
%    \begin{macrocode}
\cs_new_eq:NN \prop_set_eq:NN  \tl_set_eq:NN
\cs_new_eq:NN \prop_set_eq:Nc  \tl_set_eq:Nc
\cs_new_eq:NN \prop_set_eq:cN  \tl_set_eq:cN
\cs_new_eq:NN \prop_set_eq:cc  \tl_set_eq:cc
\cs_new_eq:NN \prop_gset_eq:NN \tl_gset_eq:NN
\cs_new_eq:NN \prop_gset_eq:Nc \tl_gset_eq:Nc
\cs_new_eq:NN \prop_gset_eq:cN \tl_gset_eq:cN
\cs_new_eq:NN \prop_gset_eq:cc \tl_gset_eq:cc
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{variable}[tested = m3prop004]{\l_tmpa_prop, \l_tmpb_prop}
% \begin{variable}[tested = m3prop004]{\g_tmpa_prop, \g_tmpb_prop}
%   We can now initialize the scratch variables.
%    \begin{macrocode}
\prop_new:N \l_tmpa_prop
\prop_new:N \l_tmpb_prop
\prop_new:N \g_tmpa_prop
\prop_new:N \g_tmpb_prop
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \subsection{Accessing data in property lists}
%
% \begin{macro}[int]{\@@_split:NnTF}
% \begin{macro}[aux]{\@@_split_aux:NnTF}
% \begin{macro}[aux]{\@@_split_aux:nnnn}
% \begin{macro}[aux]{\@@_split_aux:w}
%   This function is used by most of the module, and hence must be fast.
%   The aim here is to split a property list at a given key into the part
%   before the key--value pair, the value associated with the key and the part
%   after the key--value pair. To do this, the key is first detokenized (to
%   avoid repeatedly doing this), then a delimited function is constructed to
%   match the key. It will match \cs{q_@@} \meta{detokenized key} \cs{q_@@}
%   \Arg{value} \meta{extra argument}, effectively separating an
%   \meta{extract_1} before the key in the property list and an \meta{extract_2}
%   after the key.
%
%   If the key is present in the property list, then \meta{extra argument}
%   is simply \cs{q_@@}, and \cs{@@_split_aux:nnnn} will gobble this
%   and the false branch (|#4|), leaving the correct code on the input
%   stream. More precisely, it leaves the user code (true branch), followed
%   by three groups, \Arg{extract_1} \Arg{value} \Arg{extract_2}.
%   In order for \meta{extract_1}\meta{extract_2} to be a well-formed
%   property list, \meta{extract_1} has a leading and trailing \cs{q_@@},
%   retaining exactly the structure of a property list, while \meta{extract_2}
%   omits the leading \cs{q_@@}.
%
%   If the key is not there, then \meta{extra argument} is |?|
%   \cs{use_ii:nn} |{ }|, and \cs{@@_split_aux:nnnn} |?| \cs{use_ii:nn}
%   |{ }| removes the three brace groups that just follow.  Then
%   \cs{use_ii:nn} removes the true branch, leaving the false branch,
%   with no trailing material.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_split:NnTF #1#2
  { \exp_args:NNo \@@_split_aux:NnTF #1 { \tl_to_str:n {#2} } }
\cs_new_protected:Npn \@@_split_aux:NnTF #1#2
  {
    \cs_set_protected:Npn \@@_split_aux:w
      ##1 \q_@@ #2 \q_@@ ##2 ##3 ##4 \q_mark ##5 \q_stop
      { \@@_split_aux:nnnn ##3 { {##1 \q_@@ } {##2} {##4} } }
    \exp_after:wN \@@_split_aux:w #1 \q_mark
         \q_@@ #2 \q_@@ { } { ? \use_ii:nn { } } \q_mark \q_stop
  }
\cs_new:Npn \@@_split_aux:nnnn #1#2#3#4 { #3 #2 }
\cs_new_protected:Npn \@@_split_aux:w { }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[tested = m3prop002]
%   {\prop_remove:Nn, \prop_remove:NV, \prop_remove:cn, \prop_remove:cV}
% \begin{macro}[tested = m3prop002]
%   {\prop_gremove:Nn, \prop_gremove:NV, \prop_gremove:cn, \prop_gremove:cV}
% \begin{macro}[aux]{\@@_remove:NNnnn}
%   Deleting from a property starts by splitting the list.
%   If the key is present in the property list, the returned value is ignored.
%   If the key is missing, nothing happens.
%    \begin{macrocode}
\cs_new_protected:Npn \prop_remove:Nn #1#2
  { \@@_split:NnTF #1 {#2} { \@@_remove:NNnnn \tl_set:Nn #1 } { } }
\cs_new_protected:Npn \prop_gremove:Nn #1#2
  { \@@_split:NnTF #1 {#2} { \@@_remove:NNnnn \tl_gset:Nn #1 } { } }
\cs_new_protected:Npn \@@_remove:NNnnn #1#2#3#4#5
  { #1 #2 { #3 #5 } }
\cs_generate_variant:Nn \prop_remove:Nn  {     NV }
\cs_generate_variant:Nn \prop_remove:Nn  { c , cV }
\cs_generate_variant:Nn \prop_gremove:Nn {     NV }
\cs_generate_variant:Nn \prop_gremove:Nn { c , cV }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[tested = m3prop002]
%   {
%     \prop_get:NnN, \prop_get:NVN, \prop_get:NoN,
%     \prop_get:cnN, \prop_get:cVN, \prop_get:coN
%   }
% \begin{macro}[aux]{\@@_get:Nnnn}
%   Getting an item from a list is very easy: after splitting,
%   if the key is in the property list, just set the token list variable
%   to the return value, otherwise to \cs{q_no_value}.
%    \begin{macrocode}
\cs_new_protected:Npn \prop_get:NnN #1#2#3
  {
    \@@_split:NnTF #1 {#2}
      { \@@_get:Nnnn #3 }
      { \tl_set:Nn #3 { \q_no_value } }
  }
\cs_new_protected:Npn \@@_get:Nnnn #1#2#3#4
  { \tl_set:Nn #1 {#3} }
\cs_generate_variant:Nn \prop_get:NnN {     NV , No }
\cs_generate_variant:Nn \prop_get:NnN { c , cV , co }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[tested = m3prop002]
%   {\prop_pop:NnN, \prop_pop:NoN, \prop_pop:cnN, \prop_pop:coN}
% \begin{macro}[tested = m3prop002]
%   {\prop_gpop:NnN, \prop_gpop:NoN, \prop_gpop:cnN, \prop_gpop:coN}
% \begin{macro}[aux]{\@@_pop:NNNnnn}
%   Popping a value also starts by doing the split.
%   If the key is present, save the value in the token list and update the
%   property list as when deleting.
%   If the key is missing, save \cs{q_no_value} in the token list.
%    \begin{macrocode}
\cs_new_protected:Npn \prop_pop:NnN #1#2#3
  {
    \@@_split:NnTF #1 {#2}
      { \@@_pop:NNNnnn \tl_set:Nn #1 #3 }
      { \tl_set:Nn #3 { \q_no_value } }
  }
\cs_new_protected:Npn \prop_gpop:NnN #1#2#3
  {
    \@@_split:NnTF #1 {#2}
      { \@@_pop:NNNnnn \tl_gset:Nn #1 #3 }
      { \tl_set:Nn #3 { \q_no_value } }
  }
\cs_new_protected:Npn \@@_pop:NNNnnn #1#2#3#4#5#6
  {
    \tl_set:Nn #3 {#5}
    #1 #2 { #4 #6 }
  }
\cs_generate_variant:Nn \prop_pop:NnN  {     No }
\cs_generate_variant:Nn \prop_pop:NnN  { c , co }
\cs_generate_variant:Nn \prop_gpop:NnN {     No }
\cs_generate_variant:Nn \prop_gpop:NnN { c , co }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[TF, tested = m3prop004]
%   {\prop_pop:NnN, \prop_pop:cnN, \prop_gpop:NnN, \prop_gpop:cnN}
% \begin{macro}[aux]{\@@_pop_true:NNNnnn}
%   Popping an item from a property list, keeping track of whether
%   the key was present or not, is implemented as a conditional.
%   If the key was missing, neither the property list, nor the token
%   list are altered. Otherwise, \cs{prg_return_true:} is used after
%   the assignments.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \prop_pop:NnN #1#2#3 { T , F , TF }
  {
    \@@_split:NnTF #1 {#2}
      { \@@_pop_true:NNNnnn \tl_set:Nn #1 #3 }
      { \prg_return_false: }
  }
\prg_new_protected_conditional:Npnn \prop_gpop:NnN #1#2#3 { T , F , TF }
  {
    \@@_split:NnTF #1 {#2}
      { \@@_pop_true:NNNnnn \tl_gset:Nn #1 #3 }
      { \prg_return_false: }
  }
\cs_new_protected:Npn \@@_pop_true:NNNnnn #1#2#3#4#5#6
  {
    \tl_set:Nn #3 {#5}
    #1 #2 { #4 #6 }
    \prg_return_true:
  }
\cs_generate_variant:Nn \prop_pop:NnNT   { c }
\cs_generate_variant:Nn \prop_pop:NnNF   { c }
\cs_generate_variant:Nn \prop_pop:NnNTF  { c }
\cs_generate_variant:Nn \prop_gpop:NnNT  { c }
\cs_generate_variant:Nn \prop_gpop:NnNF  { c }
\cs_generate_variant:Nn \prop_gpop:NnNTF { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[tested = m3prop002]
%   {
%     \prop_put:Nnn, \prop_put:NnV, \prop_put:Nno, \prop_put:Nnx,
%     \prop_put:NVn, \prop_put:NVV, \prop_put:Non, \prop_put:Noo,
%     \prop_put:cnn, \prop_put:cnV, \prop_put:cno, \prop_put:cnx,
%     \prop_put:cVn, \prop_put:cVV, \prop_put:con, \prop_put:coo
%   }
% \begin{macro}[tested = m3prop002]
%   {
%     \prop_gput:Nnn, \prop_gput:NnV, \prop_gput:Nno, \prop_gput:Nnx,
%     \prop_gput:NVn, \prop_gput:NVV, \prop_gput:Non, \prop_gput:Noo,
%     \prop_gput:cnn, \prop_gput:cnV, \prop_gput:cno, \prop_gput:cnx,
%     \prop_gput:cVn, \prop_gput:cVV, \prop_gput:con, \prop_gput:coo
%   }
% \begin{macro}[aux]{\@@_put:NNNnn, \@@_put:NNnnnnn}
%   Putting a key--value pair in a property list starts by splitting to
%   remove any existing value.  If the \meta{key} was absent, append the
%   new key--value pair.  Otherwise, the property list is reconstructed
%   from the two remaining parts |#5| and |#7|, and the updated entry.
%   The updated entry is placed at the same spot as the original
%   \meta{key} in the property list, preserving the order of entries.
%    \begin{macrocode}
\cs_new_protected:Npn \prop_put:Nnn
  { \@@_put:NNNnn \tl_set:Nx \tl_put_right:Nx }
\cs_new_protected:Npn \prop_gput:Nnn
  { \@@_put:NNNnn \tl_gset:Nx \tl_gput_right:Nx }
\cs_new_protected:Npn \@@_put:NNNnn #1#2#3#4#5
  {
    \@@_split:NnTF #3 {#4}
      { \@@_put:NNnnnnn #1 #3 {#4} {#5} }
      { #2 #3 { \tl_to_str:n {#4} \exp_not:n { \q_@@ {#5} \q_@@ } } }
  }
\cs_new_protected:Npn \@@_put:NNnnnnn #1#2#3#4#5#6#7
  {
    #1 #2
      {
        \exp_not:n {#5}
        \tl_to_str:n {#3} \exp_not:n { \q_@@ {#4} \q_@@ }
        \exp_not:n {#7}
      }
  }
\cs_generate_variant:Nn \prop_put:Nnn
  {     NnV , Nno , Nnx , NV , NVV , No , Noo }
\cs_generate_variant:Nn \prop_put:Nnn
  { c , cnV , cno , cnx , cV , cVV , co , coo }
\cs_generate_variant:Nn \prop_gput:Nnn
  {     NnV , Nno , Nnx , NV , NVV , No , Noo }
\cs_generate_variant:Nn \prop_gput:Nnn
  { c , cnV , cno , cnx , cV , cVV , co , coo }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[tested = m3prop002]
%   {\prop_put_if_new:Nnn, \prop_put_if_new:cnn}
% \begin{macro}[tested = m3prop002]
%   {\prop_gput_if_new:Nnn, \prop_gput_if_new:cnn}
% \begin{macro}[aux]{\@@_put_if_new:NNnn}
%   Adding conditionally also splits. If the key is already present,
%   the three brace groups given by \cs{@@_split:NnTF} are removed.
%   If the key is new, then the value is added, being careful to
%   convert the key to a string using \cs{tl_to_str:n}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \prop_put_if_new:Nnn
  { \@@_put_if_new:NNnn \tl_put_right:Nx }
\cs_new_protected_nopar:Npn \prop_gput_if_new:Nnn
  { \@@_put_if_new:NNnn \tl_gput_right:Nx }
\cs_new_protected:Npn \@@_put_if_new:NNnn #1#2#3#4
  {
    \@@_split:NnTF #2 {#3}
      { \use_none:nnn }
      {
        #1 #2
          { \tl_to_str:n {#3} \exp_not:n { \q_@@ {#4} \q_@@ } }
      }
  }
\cs_generate_variant:Nn \prop_put_if_new:Nnn  { c }
\cs_generate_variant:Nn \prop_gput_if_new:Nnn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Property list conditionals}
%
% \begin{macro}[pTF, tested = m3prop004]{\prop_if_exist:N, \prop_if_exist:c}
%   Copies of the \texttt{cs} functions defined in \pkg{l3basics}.
%    \begin{macrocode}
\cs_new_eq:NN \prop_if_exist:NTF \cs_if_exist:NTF
\cs_new_eq:NN \prop_if_exist:NT  \cs_if_exist:NT
\cs_new_eq:NN \prop_if_exist:NF  \cs_if_exist:NF
\cs_new_eq:NN \prop_if_exist_p:N \cs_if_exist_p:N
\cs_new_eq:NN \prop_if_exist:cTF \cs_if_exist:cTF
\cs_new_eq:NN \prop_if_exist:cT  \cs_if_exist:cT
\cs_new_eq:NN \prop_if_exist:cF  \cs_if_exist:cF
\cs_new_eq:NN \prop_if_exist_p:c \cs_if_exist_p:c
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF, tested = m3prop003]{\prop_if_empty:N, \prop_if_empty:c}
%   The test here uses \cs{c_empty_prop} as it is not really empty!
%    \begin{macrocode}
\prg_new_conditional:Npnn \prop_if_empty:N #1 { p, T , F , TF }
  {
    \if_meaning:w #1 \c_empty_prop
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\cs_generate_variant:Nn \prop_if_empty_p:N {c}
\cs_generate_variant:Nn \prop_if_empty:NTF {c}
\cs_generate_variant:Nn \prop_if_empty:NT  {c}
\cs_generate_variant:Nn \prop_if_empty:NF  {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF, tested = m3prop003]
%   {
%     \prop_if_in:Nn, \prop_if_in:NV, \prop_if_in:No,
%     \prop_if_in:cn, \prop_if_in:cV, \prop_if_in:co
%   }
% \begin{macro}[aux]{\@@_if_in:nwn,\@@_if_in:N}
%   Testing expandably if a key is in a property list
%   requires to go through the key--value pairs one by one.
%   This is rather slow, and a faster test would be
%   \begin{verbatim}
%     \prg_new_protected_conditional:Npnn \prop_if_in:Nn #1 #2
%       {
%         \@@_split:NnTF #1 {#2}
%           {
%             \prg_return_true:
%             \use_none:nnn
%           }
%         { \prg_return_false: }
%       }
%   \end{verbatim}
%   but \cs{@@_split:NnTF} is non-expandable.
%
%   Instead, the key is compared to each key in turn using \cs{str_if_eq_x:nn},
%   which is expandable. To terminate the mapping, we add the key that
%   is search for at the end of the property list. This second
%   \cs{tl_to_str:n} is not expanded at the start, but only when included
%   in the \cs{str_if_eq_x:nn}. It cannot make the breaking mechanism choke,
%   because the arbitrary token list material is enclosed in braces.
%   When ending, we test the next token: it is either \cs{q_@@}
%   or \cs{q_recursion_tail} in the case of a missing key.
%   Here, \cs{prop_map_function:NN} is not sufficient for the mapping,
%   since it can only map a single token, and cannot carry the key that
%   is searched for.
%    \begin{macrocode}
\prg_new_conditional:Npnn \prop_if_in:Nn #1#2 { p , T , F , TF }
  {
    \exp_last_unbraced:Noo \@@_if_in:nwn
      { \tl_to_str:n {#2} } #1
      \tl_to_str:n {#2} \q_@@ { }
    \q_recursion_tail % could be any cs != \q_@@
    \__prg_break_point:
  }
\cs_new:Npn \@@_if_in:nwn #1 \q_@@ #2 \q_@@ #3
  {
    \str_if_eq_x:nnTF {#1} {#2}
      { \@@_if_in:N }
      { \@@_if_in:nwn {#1} }
  }
\cs_new:Npn \@@_if_in:N #1
  {
    \if_meaning:w \q_@@ #1
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
    \__prg_break:
  }
\cs_generate_variant:Nn \prop_if_in_p:Nn {     NV , No }
\cs_generate_variant:Nn \prop_if_in_p:Nn { c , cV , co }
\cs_generate_variant:Nn \prop_if_in:NnT  {     NV , No }
\cs_generate_variant:Nn \prop_if_in:NnT  { c , cV , co }
\cs_generate_variant:Nn \prop_if_in:NnF  {     NV , No }
\cs_generate_variant:Nn \prop_if_in:NnF  { c , cV , co }
\cs_generate_variant:Nn \prop_if_in:NnTF {     NV , No }
\cs_generate_variant:Nn \prop_if_in:NnTF { c , cV , co }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Recovering values from property lists with branching}
%
% \begin{macro}[TF, tested = m3prop004]
%   {
%     \prop_get:NnN, \prop_get:NVN, \prop_get:NoN,
%     \prop_get:cnN, \prop_get:cVN, \prop_get:coN
%   }
% \begin{macro}[aux]{\@@_get_true:Nnnn}
%   Getting the value corresponding to a key, keeping track of whether
%   the key was present or not, is implemented as a conditional (with
%   side effects). If the key was absent, the token list is not altered.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \prop_get:NnN #1#2#3 { T , F , TF }
  {
    \@@_split:NnTF #1 {#2}
      { \@@_get_true:Nnnn #3 }
      { \prg_return_false: }
  }
\cs_new_protected:Npn \@@_get_true:Nnnn #1#2#3#4
  {
    \tl_set:Nn #1 {#3}
    \prg_return_true:
  }
\cs_generate_variant:Nn \prop_get:NnNT  {     NV , No }
\cs_generate_variant:Nn \prop_get:NnNF  {     NV , No }
\cs_generate_variant:Nn \prop_get:NnNTF {     NV , No }
\cs_generate_variant:Nn \prop_get:NnNT  { c , cV , co }
\cs_generate_variant:Nn \prop_get:NnNF  { c , cV , co }
\cs_generate_variant:Nn \prop_get:NnNTF { c , cV , co }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Mapping to property lists}
%
% \begin{macro}[tested = m3prop003]
%   {
%     \prop_map_function:NN, \prop_map_function:Nc,
%     \prop_map_function:cN, \prop_map_function:cc
%   }
% \begin{macro}[aux]{\@@_map_function:Nwn}
%   The fastest way to do a recursion here would be to use an
%   \cs{if_meaning:w} test: the keys are strings, and thus
%   cannot match the marker \cs{q_recursion_tail}.
%    \begin{macrocode}
\cs_new:Npn \prop_map_function:NN #1#2
  {
    \exp_last_unbraced:NNo \@@_map_function:Nwn #2
      #1 \q_recursion_tail \q_@@ { }
    \__prg_break_point:Nn \prop_map_break: { }
  }
\cs_new:Npn \@@_map_function:Nwn #1 \q_@@ #2 \q_@@ #3
  {
    \__quark_if_recursion_tail_break:nN {#2} \prop_map_break:
    #1 {#2} {#3}
    \@@_map_function:Nwn #1
  }
\cs_generate_variant:Nn \prop_map_function:NN {     Nc }
\cs_generate_variant:Nn \prop_map_function:NN { c , cc }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[tested = m3prop003]{\prop_map_inline:Nn, \prop_map_inline:cn}
%   Mapping in line requires a nesting level counter.
%    \begin{macrocode}
\cs_new_protected:Npn \prop_map_inline:Nn #1#2
  {
    \int_gincr:N \g__prg_map_int
    \cs_gset:cpn { __prg_map_ \int_use:N \g__prg_map_int :w } ##1##2 {#2}
    \exp_last_unbraced:Nco \@@_map_function:Nwn
      { __prg_map_ \int_use:N \g__prg_map_int :w }
      #1
      \q_recursion_tail \q_@@ { }
    \__prg_break_point:Nn \prop_map_break: { \int_gdecr:N \g__prg_map_int }
  }
\cs_generate_variant:Nn \prop_map_inline:Nn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[tested = m3prop003]{\prop_map_break:}
% \begin{macro}[tested = m3prop003]{\prop_map_break:n}
%   The break statements are based on the general \cs{__prg_map_break:Nn}.
%    \begin{macrocode}
\cs_new_nopar:Npn \prop_map_break:
  { \__prg_map_break:Nn \prop_map_break: { } }
\cs_new_nopar:Npn \prop_map_break:n
  { \__prg_map_break:Nn \prop_map_break: }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Viewing property lists}
%
% \begin{macro}[tested = m3show001]{\prop_show:N, \prop_show:c}
%   Apply the general \cs{__msg_show_variable:Nnx}. Contrarily
%   to sequences and comma lists, we use \cs{__msg_show_item:nn}
%   to format both the key and the value for each pair.
%    \begin{macrocode}
\cs_new_protected:Npn \prop_show:N #1
  {
    \__msg_show_variable:Nnx #1 { prop }
      { \prop_map_function:NN #1 \__msg_show_item:nn }
  }
\cs_generate_variant:Nn \prop_show:N { c }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Deprecated interfaces}
%
% Deprecated on 2011-05-27, for removal by 2011-08-31.
%
% \begin{macro}{\prop_display:N, \prop_display:c}
%   An older name for \cs{prop_show:N}.
%    \begin{macrocode}
%<*deprecated>
\cs_new_eq:NN \prop_display:N \prop_show:N
\cs_new_eq:NN \prop_display:c \prop_show:c
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\prop_gget:NnN, \prop_gget:NVN, \prop_gget:cnN, \prop_gget:cVN}
% \begin{macro}[aux]{\prop_gget_aux:Nnnn}
%   Getting globally is no longer supported: this is a conceptual change, so
%   the necessary code for the transition is provided directly.
%    \begin{macrocode}
%<*deprecated>
\tl_new:N \l_@@_internal_tl
\cs_new_protected:Npn \prop_gget:NnN #1#2#3
  {
    \prop_get:NnN #1 {#2} \l_@@_internal_tl
    \tl_gset_eq:NN #3 \l_@@_internal_tl
  }
\cs_generate_variant:Nn \prop_gget:NnN {     NV }
\cs_generate_variant:Nn \prop_gget:NnN { c , cV }
%</deprecated>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\prop_get_gdel:NnN}
%   This name seems very odd.
%    \begin{macrocode}
%<*deprecated>
\cs_new_eq:NN \prop_get_gdel:NnN \prop_gpop:NnN
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\prop_if_in:cc}
%   A hang-over from an ancient implementation
%    \begin{macrocode}
%<*deprecated>
\cs_generate_variant:Nn \prop_if_in:NnT  { cc }
\cs_generate_variant:Nn \prop_if_in:NnF  { cc }
\cs_generate_variant:Nn \prop_if_in:NnTF { cc }
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\prop_gput:ccx}
%   Another one.
%    \begin{macrocode}
%<*deprecated>
\cs_generate_variant:Nn \prop_gput:Nnn { ccx }
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]
%   {\prop_if_eq:NN, \prop_if_eq:Nc, \prop_if_eq:cN, \prop_if_eq:cc}
%   These ones do no even make sense!
%    \begin{macrocode}
%<*deprecated>
\prg_new_eq_conditional:NNn \prop_if_eq:NN \tl_if_eq:NN { p , T , F , TF }
\prg_new_eq_conditional:NNn \prop_if_eq:cN \tl_if_eq:cN { p , T , F , TF }
\prg_new_eq_conditional:NNn \prop_if_eq:Nc \tl_if_eq:Nc { p , T , F , TF }
\prg_new_eq_conditional:NNn \prop_if_eq:cc \tl_if_eq:cc { p , T , F , TF }
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% Deprecated on 2012-05-12, for removal by 2012-11-30.
%
% \begin{macro}{\prop_del:Nn, \prop_del:NV, \prop_del:cn, \prop_del:cV}
% \begin{macro}{\prop_gdel:Nn, \prop_gdel:NV, \prop_gdel:cn, \prop_gdel:cV}
%    \begin{macrocode}
\cs_new_eq:NN \prop_del:Nn \prop_remove:Nn
\cs_new_eq:NN \prop_del:NV \prop_remove:NV
\cs_new_eq:NN \prop_del:cn \prop_remove:cn
\cs_new_eq:NN \prop_del:cV \prop_remove:cV
\cs_new_eq:NN \prop_gdel:Nn \prop_gremove:Nn
\cs_new_eq:NN \prop_gdel:NV \prop_gremove:NV
\cs_new_eq:NN \prop_gdel:cn \prop_gremove:cn
\cs_new_eq:NN \prop_gdel:cV \prop_gremove:cV
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
