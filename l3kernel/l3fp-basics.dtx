% \iffalse meta-comment
%
%% File: l3fp-basics.dtx Copyright (C) 2011-2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3kernel bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver>
\RequirePackage{l3bootstrap}
\GetIdInfo$Id$
  {L3 Floating-point arithmetic}
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-basics} package\thanks{This file
%         has version number \ExplFileVersion, last
%         revised \ExplFileDate.}\\
% Floating point arithmetic}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3fp-basics} Implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=fp>
%    \end{macrocode}
%
% All operations implemented in this module yield the outcome of
% rounding the infinitely precise result of the operation to the
% nearest representable number.
%
% ^^A begin[todo]
%
% Some algorithms used below end up being quite similar to some
% described in \enquote{What Every Computer Scientist Should Know About
%   Floating Point Arithmetic}, by David Goldberg, which can be found at
% \texttt{http://cr.yp.to/2005-590/goldberg.pdf}. I need to compare them
% very carefully.
%
% ^^A end[todo]
%
% \subsection{Common to several operations}
%
% \begin{macro}[EXP]
%   {
%     \@@_basics_pack_low:NNNNNw  ,
%     \@@_basics_pack_high:NNNNNw ,
%     \@@_basics_pack_high_carry:w
%   }
%   Addition and multiplication of mantissas are done in two steps:
%   first compute a (more or less) exact result,
%   then round and pack digits in the final (braced) form.
%   These functions take care of the packing, with special attention
%   given to the case where rounding has caused a carry.
%   In \cs{@@_basics_pack_high_carry:w}, |#1| should
%   always be $0000$.
%    \begin{macrocode}
\cs_new:Npn \@@_basics_pack_low:NNNNNw #1 #2#3#4#5 #6;
  {
    \if_meaning:w 2 #1
      + \c_one
    \fi:
    ; {#2#3#4#5} {#6} ;
  }
\cs_new:Npn \@@_basics_pack_high:NNNNNw #1 #2#3#4#5 #6;
  {
    \if_meaning:w 2 #1
      \@@_basics_pack_high_carry:w
    \fi:
    ; {#2#3#4#5} {#6}
  }
\cs_new:Npn \@@_basics_pack_high_carry:w \fi: ; #1
  { \fi: + \c_one ; {1000} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_basics_return_nan_nan:NNww ,
%     \@@_basics_return_zero:NNww    ,
%     \@@_basics_return_inf:NNww     ,
%     \@@_basics_return_i:NNNNww     ,
%     \@@_basics_return_ii:NNNNww    ,
%     \@@_basics_return_nan:NNNNww
%   }
%   \begin{syntax}
%     \cs{@@_basics_return_...:NNww}
%     ~~\meta{sign_1} \meta{sign_2} \meta{body_1} |;| \meta{body_2} |;|
%   \end{syntax}
%   Used for binary operations, to return a value for some special
%   cases (common to several operations). All functions expand once
%   after their arguments.
%
%   ^^A todo: redoc, changed.
%   The \texttt{nan_nan} function combines the \texttt{info} fields
%   of the two \texttt{nan}.\footnote{Bruno: check that messages are
%     kept.}
%   The \texttt{zero} and \texttt{inf} functions return $\pm 0$ or
%   $\pm\infty$ with a sign equal to the product of the two signs:
%   three \cs{exp_after:wN} are needed to escape out of the
%   conditional, and expand once after.
%   The \texttt{i} and \texttt{ii} functions return one of their
%   operands and expand after using \cs{@@_exp_after_o:w}.
%   In some cases, this could be optimized, since we know in advance
%   what case of number we have. However, it seems better to keep the
%   number of control sequences low: these functions are called only
%   in special cases anyways, so performance is not an issue.
%    \begin{macrocode}
\cs_new:Npn \@@_basics_return_nan_nan:NNww #1#2 #3; #4;
  { \@@_exp_after_o:w \s_@@ \@@_chk:w 3 1 #3 ; }
\cs_new:Npn \@@_basics_return_zero:NNww #1#2 #3; #4;
  {
    \if_meaning:w #1 #2
      \exp_after:wN \exp_after:wN \exp_after:wN \c_zero_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_minus_zero_fp
    \fi:
  }
\cs_new:Npn \@@_basics_return_inf:NNww #1#2 #3; #4;
  {
    \if_meaning:w #1 #2
      \exp_after:wN \exp_after:wN \exp_after:wN \c_inf_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_minus_inf_fp
    \fi:
  }
\cs_new:Npn \@@_basics_return_i:NNNNww #1#2 #3#4 #5; #6;
  { \@@_exp_after_o:w \s_@@ \@@_chk:w #1 #3 #5; }
\cs_new:Npn \@@_basics_return_ii:NNNNww #1#2 #3#4 #5; #6;
  { \@@_exp_after_o:w \s_@@ \@@_chk:w #2 #4 #6; }
\cs_new:Npn \@@_basics_return_nan:NNww #1#2
  {
    \if_meaning:w 1 #1
      \exp_after:wN \@@_basics_return_i:NNNNww
    \else:
      \exp_after:wN \@@_basics_return_ii:NNNNww
    \fi:
    3 3 #1 #2
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Addition and subtraction}
%
% We define here two functions, \cs{@@_-_o:ww} and \cs{@@_+_o:ww}, which
% perform the subtraction and addition of their two floating point
% operands, and expand the tokens following the result once.
%
% A more obscure function, \cs{@@_add_big_i_o:wNww}, is used in
% \pkg{l3fp-expo}.
%
% The logic goes as follows:
% \begin{itemize}
%   \item \cs{@@_-_o:ww} calls \cs{@@_+_o:ww} to do the work, with the
%     sign of the second operand flipped;
%   \item \cs{@@_+_o:ww} dispatches depending on the type of floating
%     point, calling specialized auxiliaries;
%   \item in all cases except summing two normal floating point numbers,
%     we return one or the other operands depending on the signs, or
%     detect an invalid operation in the case of $\infty - \infty$;
%   \item for normal floating point numbers, compare the signs;
%   \item to add two floating point numbers of the same sign or of
%     opposite signs, shift the mantissa of the smaller one to match the
%     bigger one, perform the addition or subtraction of mantissas, and
%     check for a carry.
% \end{itemize}
% The trickiest part is to round correctly when adding or subtracting
% normal floating point numbers.
%
% \subsubsection{Sign, exponent, and special numbers}
%
% \begin{macro}[int, EXP]{\@@_-_o:ww}
%   A previous version of this function grabbed its two operands,
%   changed the sign of the second, and called \cs{@@_+_o:ww}.  However,
%   for efficiency reasons, the operands were swapped in the process,
%   which means that error messages ended up wrong.  Now, the
%   \cs{@@_+_o:ww} auxiliary has a hook: it takes one argument between
%   the first \cs{s_@@} and \cs{@@_chk:w}, which is applied to the sign
%   of the second operand.
%    \begin{macrocode}
\cs_new:cpx { @@_-_o:ww } \s_@@
  {
    \exp_not:c { @@_+_o:ww }
    \exp_not:n { \s_@@ \@@_neg_sign:N }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_+_o:ww}
%   This function is either called directly with an empty |#1| to
%   compute an addition, or it is called by \cs{@@_-_o:ww} with
%   \cs{@@_neg_sign:N} as |#1| to compute the subtraction (equivalent to
%   changing the \meta{sign_2} of the second operand).  If the
%   \meta{types} |#2| and |#4| are the same, dispatch to case |#2| ($0$,
%   $1$, $2$, or $3$), where we call specialized functions: thanks to
%   \cs{__int_value:w}, those receive the tweaked \meta{sign_2}
%   (expansion of |#1#5|) as an argument.  If the \meta{types} are
%   distinct, the result is simply the floating point number with the
%   highest \meta{type}.  Since case $3$ (used for two \texttt{nan})
%   also picks the first operand, we can also use it when \meta{type_1}
%   is greater than \meta{type_2}.  Also note that we don't need to
%   worry about \meta{sign_2} in that case since the second operand is
%   discarded.
%    \begin{macrocode}
\cs_new:cpn { @@_+_o:ww }
    \s_@@ #1 \@@_chk:w #2 #3 ; \s_@@ \@@_chk:w #4 #5
  {
    \if_case:w
      \if_meaning:w #2 #4
        #2 \exp_stop_f:
      \else:
        \if_int_compare:w #2 > #4 \exp_stop_f:
          \c_three
        \else:
          \c_minus_one
        \fi:
      \fi:
           \exp_after:wN \@@_add_zeros_o:Nww \__int_value:w
    \or:   \exp_after:wN \@@_add_normal_o:Nww \__int_value:w
    \or:   \exp_after:wN \@@_add_inf_o:Nww \__int_value:w
    \or:   \@@_case_return_i_o:ww
    \else: \exp_after:wN \@@_add_return_ii_o:Nww \__int_value:w
    \fi:
    #1 #5
    \s_@@ \@@_chk:w #2 #3 ;
    \s_@@ \@@_chk:w #4 #5
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_return_ii_o:Nww}
%   Ignore the first operand, and return the second, but using the sign
%   |#1| rather than |#4|.  As usual, expand after the floating point.
%    \begin{macrocode}
\cs_new:Npn \@@_add_return_ii_o:Nww #1 #2 ; \s_@@ \@@_chk:w #3 #4
  { \@@_exp_after_o:w \s_@@ \@@_chk:w #3 #1 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_zeros_o:Nww}
%   Adding two zeros yields \cs{c_zero_fp}, except if both zeros were
%   $-0$.
%    \begin{macrocode}
\cs_new:Npn \@@_add_zeros_o:Nww #1 \s_@@ \@@_chk:w 0 #2
  {
    \if_int_compare:w #2 #1 = 20 \exp_stop_f:
      \exp_after:wN \@@_add_return_ii_o:Nww
    \else:
      \@@_case_return_i_o:ww
    \fi:
    #1
    \s_@@ \@@_chk:w 0 #2
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_inf_o:Nww}
%   If both infinities have the same sign, just return that infinity,
%   otherwise, it is an invalid operation.  We find out if that invalid
%   operation is an addition or a subtraction by testing whether the
%   tweaked \meta{sign_2} (|#1|) and the \meta{sign_2} (|#4|) are
%   identical.
%    \begin{macrocode}
\cs_new:Npn \@@_add_inf_o:Nww
    #1 \s_@@ \@@_chk:w 2 #2 #3; \s_@@ \@@_chk:w 2 #4
  {
    \if_meaning:w #1 #2
      \@@_case_return_i_o:ww
    \else:
      \@@_case_use:nw
        {
          \if_meaning:w #1 #4
            \exp_after:wN \@@_invalid_operation_o:Nww
            \exp_after:wN +
          \else:
            \exp_after:wN \@@_invalid_operation_o:Nww
            \exp_after:wN -
          \fi:
        }
    \fi:
    \s_@@ \@@_chk:w 2 #2 #3;
    \s_@@ \@@_chk:w 2 #4
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_normal_o:Nww}
%   \begin{quote}
%     \cs{@@_add_normal_o:Nww} \meta{sign_2}
%       \cs{s_@@} \cs{@@_chk:w} |1| \meta{sign_1}
%       \meta{exp_1} \meta{body_1} |;|
%       \cs{s_@@} \cs{@@_chk:w} |1| \meta{initial sign_2}
%       \meta{exp_2} \meta{body_2} |;|
%   \end{quote}
%   We now have two normal numbers to add, and we have to check signs
%   and exponents more carefully before performing the addition.
%    \begin{macrocode}
\cs_new:Npn \@@_add_normal_o:Nww #1 \s_@@ \@@_chk:w 1 #2
  {
    \if_meaning:w #1#2
      \exp_after:wN \@@_add_npos_o:NnwNnw
    \else:
      \exp_after:wN \@@_sub_npos_o:NnwNnw
    \fi:
    #2
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute addition}
%
% In this subsection, we perform the addition of two positive normal
% numbers.
%
% \begin{macro}[aux, EXP]{\@@_add_npos_o:NnwNnw}
%   \begin{quote}
%     \cs{@@_add_npos_o:NnwNnw} \meta{sign_1} \meta{exp_1} \meta{body_1}
%     |;| \cs{s_@@} \cs{@@_chk:w} |1| \meta{initial sign_2} \meta{exp_2}
%     \meta{body_2} |;|
%   \end{quote}
%   Since we are doing an addition, the final sign is \meta{sign_1}.
%   Start an \cs{__int_eval:w}, responsible for computing the exponent:
%   the result, and the \meta{final sign} are then given to
%   \cs{@@_sanitize:Nw} which checks for overflow.  The exponent is
%   computed as the largest exponent |#2| or |#5|, incremented if there
%   is a carry.  To add the mantissas, we decimate the smaller number by
%   the difference between the exponents.  This is done by
%   \cs{@@_add_big_i:wNww} or \cs{@@_add_big_ii:wNww}.  We need to bring
%   the final sign with us in the midst of the calculation to round
%   properly at the end.
%    \begin{macrocode}
\cs_new:Npn \@@_add_npos_o:NnwNnw #1#2#3 ; \s_@@ \@@_chk:w 1 #4 #5
  {
    \exp_after:wN \@@_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \__int_eval:w
      \if_int_compare:w #2 > #5 \exp_stop_f:
        #2
        \exp_after:wN \@@_add_big_i_o:wNww \__int_value:w -
      \else:
        #5
        \exp_after:wN \@@_add_big_ii_o:wNww \__int_value:w
      \fi:
      \__int_eval:w #5 - #2 ; #1 #3;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_add_big_i_o:wNww}
% \begin{macro}[aux, EXP]{\@@_add_big_ii_o:wNww}
%   \begin{quote}
%     \cs{@@_add_big_i_o:wNww} \meta{shift} |;| \meta{final sign}
%       \meta{body_1} |;| \meta{body_2} |;|
%   \end{quote}
%   Shift the mantissa of the small number, then add with
%   \cs{@@_add_mantissa_o:NnnwnnnnN}.
%    \begin{macrocode}
\cs_new:Npn \@@_add_big_i_o:wNww #1; #2 #3; #4;
  {
    \@@_decimate:nNnnnn {#1}
      \@@_add_mantissa_o:NnnwnnnnN
      #4
    #3
    #2
  }
\cs_new:Npn \@@_add_big_ii_o:wNww #1; #2 #3; #4;
  {
    \@@_decimate:nNnnnn {#1}
      \@@_add_mantissa_o:NnnwnnnnN
      #3
    #4
    #2
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_mantissa_o:NnnwnnnnN}
% \begin{macro}[aux, EXP]
%   {\@@_add_mantissa_pack:NNNNNNN, \@@_add_mantissa_test_o:N}
%   \begin{quote}
%     \cs{@@_add_mantissa_o:NnnwnnnnN}
%       \meta{rounding digit}
%       \Arg{Y'_1} \Arg{Y'_2} \meta{extra-digits} |;|
%       \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4}
%       \meta{final sign}
%   \end{quote}
%   To round properly, we must know at which digit the rounding
%   should occur. This requires to know whether the addition
%   produces an overall carry or not. Thus, we do the computation
%   now and check for a carry, then go back and do the rounding.
%   The rounding may cause a carry in very rare cases such as
%   $0.99\cdots 95 \to 1.00\cdots 0$, but this situation always
%   give an exact power of $10$, for which it is easy to correct
%   the result at the end.
%    \begin{macrocode}
\cs_new:Npn \@@_add_mantissa_o:NnnwnnnnN #1 #2#3 #4; #5#6#7#8
  {
    \exp_after:wN \@@_add_mantissa_test_o:N
    \int_use:N \__int_eval:w 1#5#6 + #2
      \exp_after:wN \@@_add_mantissa_pack:NNNNNNN
      \int_use:N \__int_eval:w 1#7#8 + #3 ; #1
  }
\cs_new:Npn \@@_add_mantissa_pack:NNNNNNN #1 #2#3#4#5#6#7
  {
    \if_meaning:w 2 #1
      + \c_one
    \fi:
    ; #2 #3 #4 #5 #6 #7 ;
  }
\cs_new:Npn \@@_add_mantissa_test_o:N #1
  {
    \if_meaning:w 2 #1
      \exp_after:wN \@@_add_mantissa_carry_o:wwNNNN
    \else:
      \exp_after:wN \@@_add_mantissa_no_carry_o:wwNNNN
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_mantissa_no_carry_o:wwNNNN}
%   \begin{quote}
%     \cs{@@_add_mantissa_no_carry_o:wwNNNN}
%       \meta{8d} |;| \meta{6d} |;| \meta{2d} |;|
%       \meta{rounding digit} \meta{sign}
%   \end{quote}
%   If there's no carry, grab all the digits again and round.  The
%   packing function \cs{@@_basics_pack_high:NNNNNw} takes care of the
%   case where rounding brings a carry.
%    \begin{macrocode}
\cs_new:Npn \@@_add_mantissa_no_carry_o:wwNNNN
    #1; #2; #3#4 ; #5#6
  {
    \exp_after:wN \@@_basics_pack_high:NNNNNw
    \int_use:N \__int_eval:w 1 #1
      \exp_after:wN \@@_basics_pack_low:NNNNNw
      \int_use:N \__int_eval:w 1 #2 #3#4
        + \@@_round:NNN #6 #4 #5
        \exp_after:wN ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_mantissa_carry_o:wwNNNN}
% \begin{macro}[aux, EXP]
%   {
%     \@@_add_mantissa_carry_pack_ii:NNNNw,
%     \@@_add_mantissa_carry_pack:NNNNNNNNw
%   }
%   \begin{quote}
%     \cs{@@_add_mantissa_carry_o:wwNNNN}
%       \meta{8d} |;| \meta{6d} |;| \meta{2d} |;|
%       \meta{rounding digit} \meta{sign}
%   \end{quote}
%   The case where there is a carry is very similar.  Rounding can even
%   raise the first digit from $1$ to $2$, but we don't care.
%    \begin{macrocode}
\cs_new:Npn \@@_add_mantissa_carry_o:wwNNNN
    #1; #2; #3#4; #5#6
  {
    + \c_one
    \exp_after:wN \@@_add_mantissa_carry_pack:NNNNNNNNw
    \int_use:N \__int_eval:w 1 #1
      \exp_after:wN \@@_add_mantissa_carry_pack_ii:NNNNw
      \int_use:N \__int_eval:w 1 #2#3
        + \@@_round:NNNN #6 #3 #4 #5
        \exp_after:wN ;
  }
\cs_new:Npn \@@_add_mantissa_carry_pack_ii:NNNNw #1 #2#3#4 #5;
  {
    \if:w 2 #1
      + \c_one
    \fi:
    \__int_eval_end:
    #2#3#4; {#5} ;
  }
\cs_new:Npn \@@_add_mantissa_carry_pack:NNNNNNNNw
    #1#2#3#4 #5#6#7#8 #9; { ; {#1#2#3#4} {#5#6#7#8} {#9} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Absolute subtraction}
%
% \begin{macro}[aux, EXP]{\@@_sub_npos_o:NnwNnw}
% \begin{macro}[aux, EXP]{\@@_sub_eq_o:Nnwnw, \@@_sub_npos_ii_o:Nnwnw}
%   \begin{quote}
%     \cs{@@_sub_npos_o:NnwNnw}
%       \meta{sign_1} \meta{exp_1} \meta{body_1} |;|
%       \cs{s_@@} \cs{@@_chk:w} |1|
%       \meta{initial sign_2} \meta{exp_2} \meta{body_2} |;|
%   \end{quote}
%   Rounding properly in some modes requires to know what the sign of
%   the result will be.  Thus, we start by comparing the exponents and
%   mantissas.  If the numbers coincide, return zero.  If the second
%   number is larger, swap the numbers and call
%   \cs{@@_sub_npos_i_o:Nnwnw} with the opposite of \meta{sign_1}.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_npos_o:NnwNnw #1#2#3; \s_@@ \@@_chk:w 1 #4#5#6;
  {
    \if_case:w \@@_compare_npos:nwnw {#2} #3; {#5} #6; \exp_stop_f:
      \exp_after:wN \@@_sub_eq_o:Nnwnw
    \or:
      \exp_after:wN \@@_sub_npos_i_o:Nnwnw
    \else:
      \exp_after:wN \@@_sub_npos_ii_o:Nnwnw
    \fi:
    #1 {#2} #3; {#5} #6;
  }
\cs_new:Npn \@@_sub_eq_o:Nnwnw #1#2; #3; { \exp_after:wN \c_zero_fp }
\cs_new:Npn \@@_sub_npos_ii_o:Nnwnw #1 #2; #3;
  {
    \exp_after:wN \@@_sub_npos_i_o:Nnwnw
      \int_use:N \__int_eval:w \c_two - #1 \__int_eval_end:
      #3; #2;
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_sub_npos_i_o:Nnwnw}
%   After the computation is done, \cs{@@_sanitize:Nw} checks for
%   overflow/underflow.  It expects the \meta{final sign} and the
%   \meta{exponent} (delimited by |;|).  Start an integer expression for
%   the exponent, which starts with the exponent of the largest number,
%   and may be decreased if the two numbers are very close.  If the two
%   numbers have the same exponent, call the \texttt{near} auxiliary.
%   Otherwise, decimate $y$, then call the \texttt{far} auxiliary to
%   evaluate the difference between the two mantissas.  Note that we
%   decimate by $1$ less than one would expect.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_npos_i_o:Nnwnw #1 #2#3; #4#5;
  {
    \exp_after:wN \@@_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \__int_eval:w
      #2
      \if_int_compare:w #2 = #4 \exp_stop_f:
        \exp_after:wN \@@_sub_back_near_o:nnnnnnnnN
      \else:
        \exp_after:wN \@@_decimate:nNnnnn \exp_after:wN
          { \int_use:N \__int_eval:w #2 - #4 - \c_one \exp_after:wN }
          \exp_after:wN \@@_sub_back_far_o:NnnwnnnnN
      \fi:
        #5
      #3
      #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_sub_back_near_o:nnnnnnnnN}
% \begin{macro}[aux, EXP]
%   {\@@_sub_back_near_pack:NNNNNNw, \@@_sub_back_near_after:wNNNNw}
%   \begin{quote}
%     \cs{@@_sub_back_near_o:nnnnnnnnN}
%       \Arg{Y_1} \Arg{Y_2} \Arg{Y_3} \Arg{Y_4}
%       \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4}
%       \meta{final sign}
%   \end{quote}
%   In this case, the subtraction is exact, so we discard the
%   \meta{final sign} |#9|.  The very large shifts of $10^{9}$ and
%   $1.1\cdot10^{9}$ are unnecessary here, but allow the auxiliaries to
%   be reused later.  Each integer expression produces a $10$ digit
%   result.  If the resulting $16$ digits start with a $0$, then we need
%   to shift the group, padding with trailing zeros.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_near_o:nnnnnnnnN #1#2#3#4 #5#6#7#8 #9
  {
    \exp_after:wN \@@_sub_back_near_after:wNNNNw
    \int_use:N \__int_eval:w 10#5#6 - #1#2 - \c_eleven
      \exp_after:wN \@@_sub_back_near_pack:NNNNNNw
      \int_use:N \__int_eval:w 11#7#8 - #3#4 \exp_after:wN ;
  }
\cs_new:Npn \@@_sub_back_near_pack:NNNNNNw #1#2#3#4#5#6#7 ;
  { + #1#2 ; {#3#4#5#6} {#7} ; }
\cs_new:Npn \@@_sub_back_near_after:wNNNNw 10 #1#2#3#4 #5 ;
  {
    \if_meaning:w 0 #1
      \exp_after:wN \@@_sub_back_shift:wnnnn
    \fi:
    ; {#1#2#3#4} {#5}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_sub_back_shift:wnnnn}
% \begin{macro}[aux, EXP]
%   {
%     \@@_sub_back_shift_ii:ww,
%     \@@_sub_back_shift_iii:NNNNNNNNw,
%     \@@_sub_back_shift_iv:nnnnw
%   }
%   \begin{quote}
%     \cs{@@_sub_back_shift:wnnnn} |;|
%       \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} |;|
%   \end{quote}
%   This function is called with $\meta{Z_1}\leq 999$.  Act with
%   \tn{number} to trim leading zeros from \meta{Z_1} \meta{Z_2} (we
%   don't do all four blocks at once, since non-zero blocks would then
%   overflow \TeX{}'s integers).  If the first two blocks are zero, the
%   auxiliary receives an empty |#1| and trims |#2#30| from leading
%   zeros, yielding a total shift between $7$ and~$16$ to the exponent.
%   Otherwise we get the shift from |#1| alone, yielding a result
%   between $1$ and~$6$.  Once the exponent is taken care of, trim
%   leading zeros from |#1#2#3| (when |#1| is empty, the space before
%   |#2#3| is ignored), get four blocks of $4$~digits and finally clean
%   up.  Trailing zeros are added so that digits can be grabbed safely.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_shift:wnnnn ; #1#2
  {
    \exp_after:wN \@@_sub_back_shift_ii:ww
    \__int_value:w #1 #2 0 ;
  }
\cs_new:Npn \@@_sub_back_shift_ii:ww #1 0 ; #2#3 ;
  {
    \if_meaning:w @ #1 @
      - \c_seven
      - \exp_after:wN \use_i:nnn
        \exp_after:wN \@@_sub_back_shift_iii:NNNNNNNNw
        \__int_value:w #2#3 0 ~ 123456789;
    \else:
      - \@@_sub_back_shift_iii:NNNNNNNNw #1 123456789;
    \fi:
    \exp_after:wN \@@_pack_twice_four:wNNNNNNNN
    \exp_after:wN \@@_pack_twice_four:wNNNNNNNN
    \exp_after:wN \@@_sub_back_shift_iv:nnnnw
    \exp_after:wN ;
    \__int_value:w
    #1 ~ #2#3 0 ~ 0000 0000 0000 000 ;
  }
\cs_new:Npn \@@_sub_back_shift_iii:NNNNNNNNw #1#2#3#4#5#6#7#8#9; {#8}
\cs_new:Npn \@@_sub_back_shift_iv:nnnnw #1 ; #2 ; { ; #1 ; }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_sub_back_far_o:NnnwnnnnN}
%   \begin{quote}
%     \cs{@@_sub_back_far_o:NnnwnnnnN}
%       \meta{rounding} \Arg{Y'_1} \Arg{Y'_2} \meta{extra-digits} |;|
%       \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4}
%       \meta{final sign}
%   \end{quote}
%   If the difference is greater than $10^{\meta{expo_x}}$, call the
%   \texttt{very_far} auxiliary.  If the result is less than
%   $10^{\meta{expo_x}}$, call the \texttt{not_far} auxiliary.  If it is
%   too close a call to know yet, namely if $1 \meta{Y'_1} \meta{Y'_2} =
%   \meta{X_1} \meta{X_2} \meta{X_3} \meta{X_4} 0$, then call the
%   \texttt{quite_far} auxiliary.  We use the odd combination of space
%   and semi-colon delimiters to allow the \texttt{not_far} auxiliary to
%   grab each piece individually, the \texttt{very_far} auxiliary to use
%   \cs{@@_pack_eight:wNNNNNNNN}, and the \texttt{quite_far} to ignore
%   the mantissas easily (using the |;| delimiter).
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_far_o:NnnwnnnnN #1 #2#3 #4; #5#6#7#8
  {
    \if_case:w
      \if_int_compare:w 1 #2 = #5#6 \use_i:nnnn #7 \exp_stop_f:
        \if_int_compare:w #3 = \use_none:n #7#8 0 \exp_stop_f:
          \c_zero
        \else:
          \if_int_compare:w #3 > \use_none:n #7#8 0 - \fi: \c_one
        \fi:
      \else:
        \if_int_compare:w 1 #2 > #5#6 \use_i:nnnn #7 - \fi: \c_one
      \fi:
           \exp_after:wN \@@_sub_back_quite_far_o:wwNN
    \or:   \exp_after:wN \@@_sub_back_very_far_o:wwwwNN
    \else: \exp_after:wN \@@_sub_back_not_far_o:wwwwNN
    \fi:
    #2 ~ #3 ; #5 #6 ~ #7 #8 ; #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_sub_back_quite_far_o:wwNN}
% \begin{macro}[aux, EXP]{\@@_sub_back_quite_far_ii:NN}
%   The easiest case is when $x-y$ is extremely close to a power of
%   $10$, namely the first digit of $x$ is $1$, and all others vanish
%   when subtracting $y$.  Then the \meta{rounding} |#3| and the
%   \meta{final sign} |#4| control whether we get $1$ or $0.9999 9999
%   9999 9999$.  In the usual round-to-nearest mode, we will get $1$
%   whenever the \meta{rounding} digit is less than or equal to $5$
%   (remember that the \meta{rounding} digit is only equal to $5$ if
%   there was no further non-zero digit).
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_quite_far_o:wwNN #1; #2; #3#4
  {
    \exp_after:wN \@@_sub_back_quite_far_ii:NN
    \exp_after:wN #3
    \exp_after:wN #4
  }
\cs_new:Npn \@@_sub_back_quite_far_ii:NN #1#2
  {
    \if_case:w \@@_round_neg:NNN #2 0 #1
      \exp_after:wN \use_i:nn
    \else:
      \exp_after:wN \use_ii:nn
    \fi:
      { ; {1000} {0000} {0000} {0000} ; }
      { - \c_one ; {9999} {9999} {9999} {9999} ; }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_sub_back_not_far_o:wwwwNN}
%   In the present case, $x$ and $y$ have different exponents, but
%   $y$~is large enough that $x-y$ has a smaller exponent than~$x$.
%   Decrement the exponent (with |- \c_one|).  Then proceed in a way
%   similar to the \texttt{near} auxiliaries seen earlier, but
%   multiplying $x$ by~$10$ (|#30| and |#40| below), and with the added
%   quirk that the \meta{rounding} digit has to be taken into account.
%   Namely, we may have to decrease the result by one unit if
%   \cs{@@_round_neg:NNN} returns~$1$.  This function expects the
%   \meta{final sign}~|#6|, the last digit of |1100000000+#40-#2|, and
%   the \meta{rounding} digit.  Instead of redoing the computation for
%   the second argument, we note that \cs{@@_round_neg:NNN} only cares
%   about its parity, which is identical to that of the last digit
%   of~|#2|.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_not_far_o:wwwwNN #1 ~ #2; #3 ~ #4; #5#6
  {
    - \c_one
    \exp_after:wN \@@_sub_back_near_after:wNNNNw
    \int_use:N \__int_eval:w 1#30 - #1 - \c_eleven
      \exp_after:wN \@@_sub_back_near_pack:NNNNNNw
      \int_use:N \__int_eval:w 11 0000 0000 + #40 - #2
        - \exp_after:wN \@@_round_neg:NNN
          \exp_after:wN #6
          \use_none:nnnnnnn #2 #5
        \exp_after:wN ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_sub_back_very_far_o:wwwwNN}
% \begin{macro}[aux, EXP]
%   {
%     \@@_sub_back_very_far_ii_o:nnNwwNN,
%     \@@_sub_back_very_far_pack:NNNNNw,
%     \@@_sub_back_very_far_after:wNNNNw,
%   }
%   The case where $x-y$ and $x$ have the same exponent is a bit more
%   tricky, mostly because it cannot reuse the same auxiliaries.  Shift
%   the $y$~mantissa by adding a leading~$0$.  Then the logic is similar
%   to the \texttt{not_far} functions above.  Rounding is a bit more
%   complicated: we have two \meta{rounding} digits |#3| and |#6| (from
%   the decimation, and from the new shift) to take into account, and
%   getting the parity of the main result requires a computation.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_very_far_o:wwwwNN #1#2#3#4#5#6#7
  {
    \@@_pack_eight:wNNNNNNNN
    \@@_sub_back_very_far_ii_o:nnNwwNN
    {0 #1#2#3 #4#5#6#7 }
    ;
  }
\cs_new:Npn \@@_sub_back_very_far_ii_o:nnNwwNN #1#2 ; #3 ; #4 ~ #5; #6#7
  {
    \exp_after:wN \@@_sub_back_very_far_after:wNNNNw
    \int_use:N \__int_eval:w 2#4 - #1 - \c_two
      \exp_after:wN \@@_sub_back_very_far_pack:NNNNNw
      \int_use:N \__int_eval:w 2#5 - #2 -
        \if_int_odd:w \__int_eval:w #5 - #2 \__int_eval_end:
          \@@_round:NNNN #7 1 #3 #6
        \else: % ^^A todo: should be \@@_round_neg:NNNN
          \@@_round:NNNN #7 0 #3 #6
        \fi:
      \exp_after:wN ;
  }
\cs_new:Npn \@@_sub_back_very_far_pack:NNNNNw #1#2#3#4#5 #6;
  { + #1 ; {#2#3#4#5} {#6} ; }
\cs_new:Npn \@@_sub_back_very_far_after:wNNNNw 2 #1#2#3#4 #5;
  { ; {#1#2#3#4} {#5} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Multiplication}
%
% \begin{macro}[int, EXP]{\@@_*_o:ww}
%   For multiplication, everything is easy.  No need to grab the
%   \meta{body_2}.
%    \begin{macrocode}
\cs_new:cpn { @@_*_o:ww }
    \s_@@ \@@_chk:w #1 #2 #3 ; \s_@@ \@@_chk:w #4 #5
  { \@@_mul_cases:NN #1 #4 #2 #5 #3 ; }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Signs, and special numbers}
%
% \begin{macro}[EXP,aux]{\@@_mul_cases:NN}
%   \begin{syntax}
%     \cs{@@_mul_cases:NN} \meta{type_1} \meta{type_2}
%     ~~\meta{sign_1} \meta{sign_2} \meta{body_1} |;| \meta{body_2} |;|
%   \end{syntax}
%   Expands the following tokens on the input stream once.
%   The special cases are coded at the start of this module,
%   and identical to the ones for division.\footnote{Bruno: \texttt{nan}
%     are not treated properly: $\infty\times 0$ should signal.}
%^^A todo: use the faster \if_meaning:w.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_cases:NN #1 #2
  {
    \if_case:w \if_meaning:w 1 #1 #2 \else:
               \if_meaning:w 1 #2 #1 \else:
               \if_meaning:w #1#2 #1 \else:
               \if_int_compare:w \__int_eval:w #1 + #2 > \c_two
                 3 \else: 4 \fi: \fi: \fi: \fi:
               \exp_stop_f:
         \exp_after:wN \@@_basics_return_zero:NNww
    \or: \exp_after:wN \@@_mul_normal:NNww
    \or: \exp_after:wN \@@_basics_return_inf:NNww
    \or: \exp_after:wN \@@_basics_return_nan:NNww
    \or:
      \exp_after:wN \@@_mul_invalid:NNNNww
      \exp_after:wN #1
      \exp_after:wN #2
    \fi:
  }
\cs_new:Npn \@@_mul_invalid:NNNNww #1#2#3#4#5; #6;
  {
    \@@_invalid_operation_o:Nww *
      \s_@@ \@@_chk:w #1 #3 #5 ;
      \s_@@ \@@_chk:w #2 #4 #6 ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_mul_normal:NNww}
%   \begin{syntax}
%     \cs{@@_mul_normal:NNww} \meta{sign_1} \meta{sign_2}
%     ~~\Arg{exp_1}  \meta{body_1} |;| \Arg{exp_2} \meta{body_2} |;|
%   \end{syntax}
%   We now have two normal numbers to multiply. Combine the signs.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_normal:NNww #1#2
  {
    \if:w #1#2
      \exp_after:wN \@@_mul_npos:Nnwnw
      \exp_after:wN 0
    \else:
      \exp_after:wN \@@_mul_npos:Nnwnw
      \exp_after:wN 2
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute multiplication}
%
% In this subsection, we perform the multiplication
% of two positive normal numbers.
%
% \begin{macro}[EXP]{\@@_mul_npos:Nnwnw}
%   \begin{syntax}
%     \cs{@@_mul_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp_1}  \meta{body_1} |;| \Arg{exp_2} \meta{body_2} |;|
%   \end{syntax}
%   As for addition, \meta{sign} is the final sign. After the computation,
%   \cs{@@_sanitize:Nw} checks for overflow or underflow.
%   As before, \cs{__int_eval:w} computes the exponent, catching any
%   shift coming from the computation in the mantissa. Again, the
%   \meta{sign} is needed for rounding to be done properly, so we move
%   it around with us. We setup the post-expansion here, triggered by
%   \cs{@@_mul_mantissa:nnnnNnnnn}.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_npos:Nnwnw #1 #2#3; #4 #5;
  {
    \exp_after:wN \@@_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \__int_eval:w
      #2 + #4
      \@@_mul_mantissa:nnnnNnnnn #3 #1 #5
    \exp_after:wN ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_mul_mantissa:nnnnNnnnn}
%   \begin{syntax}
%     \cs{@@_mul_mantissa:nnnnNnnnn}
%     ~~\Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4} \meta{sign}
%     ~~\Arg{Y_1} \Arg{Y_2} \Arg{Y_3} \Arg{Y_4} \meta{;}
%   \end{syntax}
%   After one expansion, the token following \meta{Y_4} must be a semicolon
%   (represented by \meta{;}).
%
%   The product of two $16$ digit integers has $31$ or $32$ digits,
%   but it is impossible to know which one before computing. The place
%   where we round depends on that number of digits, and may depend
%   on all digits until the last in some rare cases. The approach is
%   thus to compute the $5$ first blocks of $4$ digits (the first one
%   is between $100$ and $9999$ inclusive), and a compact version of
%   the remaining $3$ blocks. Afterwards, the number of digits is
%   known, and we can do the rounding within yet another set of
%   \cs{__int_eval:w}.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_mantissa:nnnnNnnnn #1#2#3#4 #5 #6#7#8#9
  {
    \exp_after:wN \@@_mul_mantissa_after:NNN
    \exp_after:wN #5
    \int_use:N \__int_eval:w 99990000 + #1*#6 +
      \exp_after:wN \@@_mul_mantissa_keep:NNNNNw
      \int_use:N \__int_eval:w 99990000 + #1*#7 + #2*#6 +
        \exp_after:wN \@@_mul_mantissa_keep:NNNNNw
        \int_use:N \__int_eval:w 99990000 + #1*#8 + #2*#7 + #3*#6 +
          \exp_after:wN \@@_mul_mantissa_drop:NNNNNw
          \int_use:N \__int_eval:w  99990000 + #1*#9 + #2*#8 + #3*#7 + #4*#6 +
            \exp_after:wN \@@_mul_mantissa_drop:NNNNNw
            \int_use:N \__int_eval:w  99990000 + #2*#9 + #3*#8 + #4*#7 +
              \exp_after:wN \@@_mul_mantissa_drop:NNNNNw
              \int_use:N \__int_eval:w  99990000 + #3*#9 + #4*#8 +
                \exp_after:wN \@@_mul_mantissa_drop:NNNNNw
                \int_use:N \__int_eval:w 100000000 + #4*#9 \exp_after:wN ;
  }
\cs_new:Npn \@@_mul_mantissa_drop:NNNNNw #1#2#3#4#5 #6;
  { #1#2#3#4#5 ; + #6 }
\cs_new:Npn \@@_mul_mantissa_keep:NNNNNw #1#2#3#4#5 #6;
  { #1#2#3#4#5 ; #6 ; }
%    \end{macrocode}
%   Once the first \cs{int_use:N} \cs{__int_eval:w}, and all the
%   \cs{@@_mul_mantissa_...:NNNNNw} have been expanded,
%   we get
%   \begin{quote}
%     \cs{@@_mul_mantissa_after:NNN} \meta{sign} |1|
%     ~~\meta{digits 1--8} |;| \meta{digits 9--12} |;| \meta{digits 13--16} |;|
%     ~~|+| \meta{digits 17--20} |+| \meta{digits 21--24}
%     ~~|+| \meta{digits 25--28} |+| \meta{digits 29--32} |;|
%   \end{quote}
%   If the \meta{digit 1} is non-zero, then for rounding we only care
%   about the digits $16$ and $17$, and whether all other digits are zero
%   or not (check for exact ties). On the other hand, if \meta{digit 1}
%   is zero, we care about digits $17$ and $18$, and whether all others are
%   zero.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_mantissa_after:NNN #1 #2 #3
  {
    \if:w 0 #3
      \exp_after:wN \@@_mul_mantissa_small:NNwwwN
    \else:
      \exp_after:wN \@@_mul_mantissa_large:NwwNNNN
    \fi:
    #1 #3
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_mul_mantissa_large:NwwNNNN}
%   In this branch, \meta{digit 1} is non-zero. The result is thus
%   \meta{digits 1--16}, plus some rounding which depends on the digits
%   $16$, $17$, and whether all subsequent digits are zero or not.
%   Here, \cs{@@_round_s:NNNw} takes the \meta{sign}, followed by
%   digits $16$, $17$, and an integer expression which is zero if and
%   only if all further digits are zero.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_mantissa_large:NwwNNNN #1 #2; #3; #4#5#6#7; +
  {
    \exp_after:wN \@@_basics_pack_high:NNNNNw
    \int_use:N \__int_eval:w 1#2
      \exp_after:wN \@@_basics_pack_low:NNNNNw
      \int_use:N \__int_eval:w 1#3#4#5#6#7 + \@@_round_s:NNNw #1 #7
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_mul_mantissa_small:NNwwwN}
%   In this branch, \meta{digit 1} is zero. Our result will thus be
%   \meta{digits 2--17}, plus some rounding which depends on the digits
%   $17$, $18$, and whether all subsequent digits are zero or not.
%   The $8$ digits |1#3| are followed, after expansion of the
%   \texttt{small_pack} auxiliary, by the next digit, to form a $9$
%   digit number. Also, rounding may have caused a carry, which is
%   then converted to \cs{c_ten} rather than the usual \cs{c_one},
%   because of the shift.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_mantissa_small:NNwwwN #1 #2#3; #4; #5; + #6
  {
    - \c_one
    \exp_after:wN \@@_basics_pack_high:NNNNNw
    \int_use:N \__int_eval:w 1#3
      \exp_after:wN \@@_mul_mantissa_small_pack:NNNNNNw
      \int_use:N \__int_eval:w 1#4#5#6 + \@@_round_s:NNNw #1 #6
  }
\cs_new:Npn \@@_mul_mantissa_small_pack:NNNNNNw #1#2 #3#4#5#6 #7;
  {
    #2
    \if:w 2 #1
      + \c_ten
    \fi:
    ; {#3#4#5#6} {#7} ;
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Division}
%
% Time is now ripe to tackle the hardest of the four elementary
% operations: division.
%
% \begin{macro}[EXP]{\@@_/_o:ww}
%   For division we swap the two floating point numbers.
%    \begin{macrocode}
\cs_new:cpn { @@_/_o:ww }
    \s_@@ \@@_chk:w #1 #2 #3 ; \s_@@ \@@_chk:w #4 #5 #6 ;
  { \@@_div_back_cases:NN #4 #1 #5 #2 #6 ; #3 ; }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Signs, and special numbers}
%
% In the case of division, the order of the operands matters,
% and it turns out to be slightly simpler if we internally
% compute the \enquote{backwards} division.
%
% \begin{macro}[EXP,aux]{\@@_div_back_cases:NN}
%   \begin{syntax}
%     \cs{@@_div_back_cases:NN} \meta{type_2} \meta{type_1}
%     ~~\meta{sign_2} \meta{sign_1} \meta{body_2} |;| \meta{body_1} |;|
%   \end{syntax}
%   Expands the following tokens on the input stream once.
%    \begin{macrocode}
\cs_new:Npn \@@_div_back_cases:NN #1 #2
  {
    \if_case:w \if_int_compare:w #1 = #2 \exp_stop_f:
                 #1 \exp_stop_f:
               \else:
                 \if_int_compare:w #1 < #2 \exp_stop_f:
                   \if:w 3 #2 \c_four \else: \c_five \fi:
                 \else:
                   \if:w 3 #1 \c_six \else: \c_seven \fi:
                 \fi:
               \fi:
         \exp_after:wN \@@_div_back_invalid:NNNww \exp_after:wN 0
    \or: \exp_after:wN \@@_div_back_normal:NNww
    \or: \exp_after:wN \@@_div_back_invalid:NNNww \exp_after:wN 2
    \or: \exp_after:wN \@@_basics_return_nan_nan:NNww
    \or:
      \exp_after:wN \@@_basics_return_ii:NNNNww
      \exp_after:wN #1
      \exp_after:wN #2
    \or: \exp_after:wN \@@_basics_return_inf:NNww %^^A todo: division_by_zero
    \or:
      \exp_after:wN \@@_basics_return_i:NNNNww
      \exp_after:wN #1
      \exp_after:wN #2
    \or: \exp_after:wN \@@_basics_return_zero:NNww
    \fi:
  }
%    \end{macrocode}
%   Most of the special cases are common with some
%   previous operations. We only need to write the cases of
%   $0/0$ and $\infty/\infty$.
%    \begin{macrocode}
\cs_new:Npn \@@_div_back_invalid:NNNww #1#2#3 #4; #5;
  {
    \@@_invalid_operation_o:Nww /
      \s_@@ \@@_chk:w #1 #3 #5 ;
      \s_@@ \@@_chk:w #1 #2 #4 ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_div_back_normal:NNww}
%   \begin{syntax}
%     \cs{@@_div_back_normal:NNww} \meta{sign_1} \meta{sign_2}
%     ~~\Arg{exp_1}  \meta{body_1} |;| \Arg{exp_2} \meta{body_2} |;|
%   \end{syntax}
%   We now have two normal numbers to divide. Combine the signs.
%    \begin{macrocode}
\cs_new:Npn \@@_div_back_normal:NNww #1#2
  {
    \if:w #1#2
      \exp_after:wN \@@_div_back_npos:Nnwnw
      \exp_after:wN 0
    \else:
      \exp_after:wN \@@_div_back_npos:Nnwnw
      \exp_after:wN 2
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute (backwards) division}
%
% In this subsection, we perform the division
% of two positive normal numbers.
%
% \begin{macro}[EXP]{\@@_div_back_npos:Nnwnw}
%   \begin{syntax}
%     \cs{@@_div_back_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp Z} \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} |;|
%     ~~\Arg{exp A} \Arg{A_1} \Arg{A_2} \Arg{A_3} \Arg{A_4} |;|
%   \end{syntax}
%   We want to compute $A/Z$. As for addition and multiplication,
%   \meta{sign} is the final sign. Checking for underflow and
%   overflow is done using the same auxiliary as for multiplication.
%   As explained just below, we first compute $y$, which is
%   the $5$ first digits of $Z$, plus $1$, and then compute pieces
%   of the quotient roughly $4$ digits at a time. Here, |#1| is
%   a single digit, |#2| and |#7| are the exponents (integers),
%   |#8| is three brace groups, and all others are each $4$ digits.
%    \begin{macrocode}
\cs_new:Npn \@@_div_back_npos:Nnwnw #1 #2 #3#4#5#6; #7 #8;
  {
    \exp_after:wN \@@_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \__int_eval:w
      #7 - #2
      \@@_div_mantissa_i:wNwnn #3; #4;
      #8 {#3}{#4}{#5}{#6} #1
  }
%    \end{macrocode}
% \end{macro}
%
%   We are given two numbers, $A=0.A_{1}A_{2}A_{3}A_{4}$
%   and $Z=0.Z_{1}Z_{2}Z_{3}Z_{4}$, in blocks of $4$ digits,
%   and we know that the first digits of $A_{1}$ and of $Z_{1}$
%   are non-zero. To compute $A/Z$, we proceed as follows.
%   \begin{itemize}
%   \item Find an integer $Q_{1} \simeq 10^4 A / Z$.
%   \item Replace $A$ by $B = 10^4 A - Q_{1} Z$.
%   \item Find an integer $Q_{2} \simeq 10^4 B / Z$.
%   \item Replace $B$ by $C = 10^4 B - Q_{2} Z$.
%   \item Find an integer $Q_{3} \simeq 10^4 C / Z$.
%   \item Replace $C$ by $D = 10^4 C - Q_{3} Z$.
%   \item Find an integer $Q_{4} \simeq 10^4 D / Z$.
%   \item Consider $E = 10^4 D - Q_{4} Z$, and ensure
%     correct rounding.
%   \end{itemize}
%   The calculations of $B$, $C$, $D$, and $E$ can be done
%   exactly with only $16$ (or $17$) digits.
%
%   Unfortunately, things are not as easy as they seem.
%   Firstly, we make sure that all intermediate steps are positive,
%   since negative results would require extra calculations at the end.
%   This requires that $Q_{1} \leq 10^4 A / Z$ etc. A reasonable
%   attempt would be to define $Q_{1}$ as
%   \[
%   \cs{int_eval:n} \left\{
%     \frac{ A_{1} A_{2} }{ Z_{1} + 1 } - 1 \right\}.
%   \]
%   Subtracting $1$ at the end takes care of the fact that e\TeX{}'s
%   \cs{__int_eval:w} rounds instead of truncating. We add $1$ to $Z_{1}$
%   because $ Z_{1} \leq 10^4 Z < Z_{1}+1$ and we need $Q_{1}$
%   to be an underestimate. However, we are now underestimating
%   $Q_{1}$ too much: it can be wrong by up to $100$, for instance
%   when $Z = 0.1$ and $A \simeq 1$. Then $B$ could take values up to
%   $10$ (maybe more), and a few steps down the line, we would run into
%   arithmetic overflow, since \TeX{} can only handle integers less than
%   roughly $2\cdot 10^9$.
%
%   A better formula is to take
%   \[
%   Q_{1} = \cs{int_eval:n} \left\{
%     \frac{ 10 \cdot A_{1} A_{2} }
%       { \left\lfloor 10^{-3} \cdot Z_{1} Z_{2} \right\rfloor + 1 }
%     - 1 \right\}.
%   \]
%   This is always less than $10^9 A / (10^5 Z)$, as we wanted.
%   In words, we take the $5$ first digits of $Z$ into account,
%   and the $8$ first digits of $A$, using $0$ as a $9$-th digit
%   rather than the true digit for efficiency reasons. We shall
%   prove that using this formula to define all the $Q_{i}$
%   leads to no overflow. For convenience, let us denote
%   \[
%   y = \left\lfloor 10^{-3} \cdot Z_{1} Z_{2} \right\rfloor + 1,
%   \]
%   so that, taking into account the fact that e\TeX{} rounds ties
%   away from zero,
%   \[
%   Q_{1} = \left\lfloor A_{1}A_{2}0/y - 1/2 \right\rfloor.
%   \]
%   Note that $10^4<y\leq 10^5$, and $999 \leq Q_{1} \leq 99989$.
%   Also note that this formula does not cause an overflow as long as
%   $A<2.147\cdots$, since the numerator involves an integer slightly
%   smaller than $10^9A$.
%
%   Let us bound $B$:
%   \begin{align*}
%   10^5 B
%   &=
%   A_{1}A_{2}0 + 10 \cdot 0.A_{3}A_{4}
%   - 10 \cdot Z_{1}.Z_{2}Z_{3}Z_{4}
%   \cdot \left\lfloor A_{1}A_{2}0/y - 1/2 \right\rfloor
%   \\
%   &<
%   A_{1}A_{2}0
%   \cdot \left( 1 - 10 \frac{Z_{1}.Z_{2}Z_{3}Z_{4}}{y} \right)
%   + \frac{3}{2} \cdot 10 \cdot Z_{1}.Z_{2}Z_{3}Z_{4} + 10
%   \\
%   &\leq
%   \frac{A_{1}A_{2}0 \cdot (y - 10 Z_{1}.Z_{2}Z_{3}Z_{4})}{y}
%   + \frac{3}{2} y + 10
%   \\
%   &\leq
%   \frac{A_{1}A_{2}0}{y} + \frac{3}{2} y + 10
%   \leq
%   \frac{10^9 A}{y} + 1.6 y
%   \end{align*}
%   At the last step, we hide $10$ into the second term
%   for later convenience. The same reasoning yields\footnote{Bruno:
%     I need to find much better notations. These are not great.}
%   \begin{align*}
%     10^5 B &< 10^9 A/y + 1.6 y, \\
%     10^5 C &< 10^9 B/y + 1.6 y, \\
%     10^5 D &< 10^9 C/y + 1.6 y, \\
%     10^5 E &< 10^9 D/y + 1.6 y. \\
%   \end{align*}
%   The goal is now to prove that none of $B$, $C$, $D$, and $E$
%   can go beyond $2.147\cdots$. Simply bounding each term on the
%   right-hand side separately will not be tight enough: for instance,
%   we would get $10^5 B < 10^5 + 1.6\cdot 10^5 = 2.6 \cdot 10^5$,
%   which is too large.
%
%   Combining the various inequalities together with $A<1$, we get
%   \begin{align*}
%     10^5 B &< 10^9/y + 1.6 y, \\
%     10^5 C &< 10^{13}/y^2 + 1.6 (y + 10^4), \\
%     10^5 D &< 10^{17}/y^3 + 1.6 (y + 10^4 + 10^8/y), \\
%     10^5 E &< 10^{21}/y^4 + 1.6 (y + 10^4 + 10^8/y + 10^{12}/y^2). \\
%   \end{align*}
%   All of those bounds are convex functions of $y$ (since every power
%   of $y$ involved is convex, and hte coefficients are positive), and
%   thus maximal at one of the end-points of the allowed range
%   $10^4<y\leq 10^5$. Thus,
%   \begin{align*}
%     10^5 B &< \mathrm{max} ( 1.16\cdot 10^5, 1.7 \cdot 10^5), \\
%     10^5 C &< \mathrm{max} ( 1.32\cdot 10^5, 1.77 \cdot 10^5), \\
%     10^5 D &< \mathrm{max} ( 1.48\cdot 10^5, 1.777 \cdot 10^5), \\
%     10^5 E &< \mathrm{max} ( 1.64\cdot 10^5, 1.7777 \cdot 10^5). \\
%   \end{align*}
%   All of those bounds are less than $2.147\cdot 10^5$, and
%   we are thus within \TeX{}'s bounds in all cases!\footnote{Bruno:
%     but I need to check this very carefully again.}
%
%   We will later need to have a bound on the $Q_{i}$. Their
%   definitions imply that $Q_{1} < 10^9 A/y - 1/2 < 10^5 A$ and
%   similarly for the other $Q_{i}$. Thus each of them is at most
%   $177770$.
%
%   The last step is to ensure correct rounding. We have
%   \[
%   A/Z = \sum_{i=1}^4 \left(10^{-4i} Q_{i}\right) + 10^{-16} E/Z
%   \]
%   exactly. Furthermore, we know that the result will be between
%   $0.1$ (inclusive) and $10$, so we only need to know the integer
%   part of $E/Z$, and a \enquote{rounding} digit encoding the rest
%   (see maybe addition for an explanation of why). Equivalently,
%   we need to find the integer part of $2E/Z$, and determine whether
%   it was an exact integer or not (this serves to detect ties). Since
%   \[
%   \frac{2E}{Z} = 2\frac{10^5 E}{10^5 Z}
%   \leq 2\frac{10^5 E}{10^4} < 36,
%   \]
%   this integer part is between $0$ and $35$ inclusive. We let
%   e\TeX{} round
%   \[
%   P = \cs{int_eval:n} \left\{
%     2 \frac{E_{1}E_{2}}{Z_{1}Z_{2}} \right\},
%   \]
%   which differs from $2E/Z$ by at most
%   \[
%   \frac{1}{2}
%   + 2 \left\lvert \frac{E}{Z} - \frac{E}{10^{-8} Z_{1}Z_{2}}\right\rvert
%   + 2 \left\lvert \frac{10^8 E - E_{1}E_{2}}{Z_{1}Z_{2}}\right\rvert
%   < 1,
%   \]
%   ($1/2$ comes from e\TeX{}'s rounding) because each absolute value
%   is less than $10^{-7}$. Thus $P$ is either the correct integer part,
%   or an overestimate by $1$ (impossible if $2E/Z$ is an integer). It
%   then suffices to compare $PZ$ with $2E$ to get the integer part of
%   $2E/Z$ and the information of whether it was an exact quotient or not.
%
% \begin{macro}[EXP]{\@@_div_mantissa_i:wNwnn}
%   \begin{syntax}
%     \cs{@@_div_mantissa_i:wNwnn}
%     ~~\meta{Z_1} |;| \meta{Z_2} |;|
%     ~~\Arg{A_1} \Arg{A_2} \Arg{A_3} \Arg{A_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{syntax}
%   First compute $y$ from the first $5$ digits of $Z$, and
%   unbrace \meta{A_1} and \meta{A_2}.
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_i:wNwnn #1; #2 #3; #4 #5
  {
    \exp_after:wN \@@_div_mantissa_ii:ww
    \int_use:N \__int_eval:w #1#2 + \c_one ;
    #4 #5 ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{@@_div_mantissa_ii:ww}
%     ~~\meta{y} |;| \meta{A_1} \meta{A_2} |;| \Arg{A_3} \Arg{A_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   Compute $Q_{1}$ by evaluating $\meta{A_1}\meta{A_2}0/y - 1$.
%   The result will be output to the left, in an \cs{__int_eval:w}
%   which we start now.
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_ii:ww #1; #2;
  {
    \exp_after:wN \@@_div_mantissa_iii:www
    \__int_value:w #1 \exp_after:wN ;
    \__int_value:w
      \exp_after:wN \@@_div_mantissa_calc:Nwwnnnnnn
      \int_use:N \__int_eval:w #20/#1 + 999999 ; #2 ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{@@_div_mantissa_calc:Nwwnnnnnn} \meta{$10^6+{}$Q_1} |;|
%     ~~\meta{A_1} \meta{A_2} |;| \Arg{A_3} \Arg{A_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   The goal here is to expand to
%   \begin{quote}
%     \meta{$10^6+{}$Q_1} |;| \meta{B_1} \meta{B_2} |;| \Arg{B_3} \Arg{B_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   where $B = 10^4 A - Q_{1} \cdot Z$. More generally, this function
%   is used with $A\to B$, $B\to C$ and $Q_{1} \to Q_{2}$, etc.
%
%   Computing the product $Q_{1} \cdot Z$ is almost simple, since
%   $Q_{1}$ is rather small, but not quite:
%   the product of $Q_{1}$ with each block of four digits $Z_{i}$
%   is within \TeX{}'s bounds, but we wouldn't be able to use the
%   usual trick of adding a large power of $10$ to ensure that the
%   number of digits is fixed (see other operations for many examples
%   of this). Instead, we split off the digit of $10^5$ in $Q_{1}$
%   (and more generally $Q_{i}$), and do something similar to the
%   case of the full multiplication.
%
%   We know that $0<Q_{i}<1.8\cdot 10^5$, so $10^6+Q_{i}$ starts
%   with the digit $1$, followed by $\#1 = 1$ or $0$, then |#2|, which
%   is $5$ more digits. It would be somewhat simpler if we got |#1|
%   to be two digits, and |#2| four, but we are constrained by the $9$
%   arguments limit.
%
%   The result we want is then (the overall power of $10$ is arbitrary):
%   \begin{align*}
%   &10^{-4} ( \#3 - \#2 \cdot \#6 - 10 \cdot \#1 \cdot \#6\#7 )
%   + 10^{-8} ( \#4 - \#2 \cdot \#7 - 10 \cdot \#1 \cdot \#8 ) \\
%   &+ 10^{-12}( \#5 - \#2 \cdot \#8 - 10 \cdot \#1 \cdot \#9 )
%   + 10^{-16}(     - \#2 \cdot \#9 ).
%   \end{align*}
%   The factors of $10$ come from the fact that
%   $Q_{i} = 10\cdot 10^4 \cdot \#1 + \#2$. As usual, to combine
%   all the terms, we need to choose some shifts which must ensure
%   that the number of digits of the second, third, and fourth terms
%   are each fixed. Here, a good choice is $2\cdot 10^9$.
%   We are flirting with \TeX{}'s limits once more.
%
%   If $\#1=0$, then each term in parentheses (omitting the first)
%   is in the open interval $(-10^9, 10^4)$. Thus, adding
%   $2\cdot 10^9$ to it gives a $10$ digits number.\footnote{Bruno:
%     check that the carry from below does not screw that up. This
%   requires slightly tighter bounds.}
%
%   If $\#1=1$, then $\#2 < 7.8 \cdot 10^4$, and each term
%   in parentheses (omitting the first) is in the interval
%   $(-8\cdot 10^8, 10^4)$, and we are even safer.
%
%   We add the terms containing $\#1$ in a slightly tricky way
%   for efficiency reasons: if $\#1=0$, no need to do any computation,
%   while if $\#1=1$ we want $10$ times some number, simply obtained
%   by appending a $0$ digit.
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_calc:Nwwnnnnnn 1#1#2; #3;#4#5 #6#7#8#9
  {
    1 #1 #2 \exp_after:wN ;
    \int_use:N \__int_eval:w
      - 200000 + #3 - #2 * #6
      \if_meaning:w 1 #1
        - #6#70
      \fi:
      +
      \exp_after:wN \@@_div_mantissa_calc_last:NNNNNN
      \int_use:N \__int_eval:w
        1999800000 + #4 - #2*#7
        \if_meaning:w 1 #1
          - #80
        \fi:
        +
        \exp_after:wN \@@_div_mantissa_calc_pack:NNNNNNw
        \int_use:N \__int_eval:w
          1999800000 + #5 - #2*#8
          \if_meaning:w 1 #1
            - #90
          \fi:
          +
          \exp_after:wN \@@_div_mantissa_calc_pack:NNNNNNw
          \int_use:N \__int_eval:w 2000000000 - #2*#9 ;
    {#6}{#7}{#8}{#9}
  }
\cs_new:Npn \@@_div_mantissa_calc_pack:NNNNNNw #1#2#3#4#5#6 #7;
  { #1#2#3#4#5#6 ; {#7} }
\cs_new:Npn \@@_div_mantissa_calc_last:NNNNNN #1#2#3#4#5#6
  { #1#2#3#4#5#6 \__int_eval_end: }
%    \end{macrocode}
%   \begin{quote}
%     \cs{@@_div_mantissa_iii:www} \meta{y} |;| \meta{$10^6+{}$Q_1} |;|
%     ~~\meta{B_1} \meta{B_2} |;| \Arg{B_3} \Arg{B_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_iii:www #1; #2; #3;
  {
    \exp_after:wN \@@_div_mantissa_iii_after:w
    \int_use:N \__int_eval:w #2
      \exp_after:wN \@@_div_mantissa_iv:www
      \__int_value:w #1 \exp_after:wN ;
      \__int_value:w
        \exp_after:wN \@@_div_mantissa_calc:Nwwnnnnnn
        \int_use:N \__int_eval:w #30/#1 + 999999 ;
        #3 ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{@@_div_mantissa_iv:www} \meta{y} |;| \meta{$10^6+{}$Q_2} |;|
%     ~~\meta{C_1} \meta{C_2} |;| \Arg{C_3} \Arg{C_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_iv:www #1; #2; #3;
  {
    \exp_after:wN \@@_div_mantissa_pack:NNN
    \int_use:N \__int_eval:w #2
      \exp_after:wN \@@_div_mantissa_v:www
      \__int_value:w #1 \exp_after:wN ;
      \__int_value:w
        \exp_after:wN \@@_div_mantissa_calc:Nwwnnnnnn
        \int_use:N \__int_eval:w #30/#1 + 999999 ;
        #3 ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{@@_div_mantissa_v:www} \meta{y} |;| \meta{$10^6+{}$Q_3} |;|
%     ~~\meta{D_1} \meta{D_2} |;| \Arg{D_3} \Arg{D_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_v:www #1; #2; #3;
  {
    \exp_after:wN \@@_div_mantissa_pack:NNN
    \int_use:N \__int_eval:w #2
      \exp_after:wN \@@_div_mantissa_vi:wwnnnn
      \__int_value:w
        \exp_after:wN \@@_div_mantissa_calc:Nwwnnnnnn
        \int_use:N \__int_eval:w #30/#1 + 999999 ;
        #3 ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{@@_div_mantissa_vi:wwnnnn} \meta{$10^6+{}$Q_4} |;|
%     ~~\meta{E_1} \meta{E_2} |;| \Arg{E_3} \Arg{E_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   We compute $P$ by rounding $2 E_{1} E_{2}/Z_{1}Z_{2}$.
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_vi:wwnnnn #1; #2;#3#4 #5#6
  {
    \exp_after:wN \@@_div_mantissa_pack:NNN
    \int_use:N \__int_eval:w #10
      \exp_after:wN \@@_div_mantissa_vii:wwnnnnnn
      \int_use:N \__int_eval:w (\c_two*#2)/#5#6 ; % <- P
      #2;{#3}{#4}
      {#5}{#6}
  }
%    \end{macrocode}
%   Note that we used |#10| instead of |#2| which we had previously.
%   Two reasons: firstly, since we dropped $y$, the argument which
%   holds $Q_{i}$ has changed, and secondly, we will want the
%   fourth piece of the result to have $5$ digits, including the
%   \meta{rounding} digit, which we shall compute now from $P$.
%   \begin{quote}
%     \cs{@@_div_mantissa_vii:wwnnnnnn} \meta{P} |;|
%     ~~\meta{E_1} \meta{E_2} |;| \Arg{E_3} \Arg{E_4}
%     ~~\Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   Then compute $2E-PZ$. Once more, we need to be careful and show
%   that the calculation $\#1\cdot\#5\#6$ below does not cause an
%   overflow: naively, $P$ can be up to $35$, and $\#5\#6$ up to
%   $10^8$, but both cannot happen simultaneously. To show that things
%   are fine, we split in two (non-disjoint) cases.
%   \begin{itemize}
%   \item For small $P$, say, $P< 10$, the product obeys
%     $P\cdot\#5\#6 < 10^8 \cdot P < 10^9 $.
%   \item For large $P$, say, $P\geq 3$, the rounding error on $P$,
%     which is at most $1$, is less than a factor of $2$, hence
%     $P\leq 4E/Z$, and $P\cdot \#5\#6 \leq 4E\cdot 10^8 < 10^9$.
%   \end{itemize}
%   Both inequalities could be made tighter if needed.
%
%   Note however that $P\cdot \#7\#8$ may overflow,
%   since the two factors are now independent, and the result may reach
%   $3.5\cdot 10^9$.
%
%   Also, we add $10\cdot P/2$ to the \enquote{fourth piece} of the result
%   as a first estimate of $10$ times $E/Z$. The goal is that the last digit
%   (for now $0$ or $5$) should be the \meta{rounding} digit. More precisely,
%   it will be corrected later by adding or subtracting $1$ depending on
%   whether $F$ was the correct integer part, or an overestimate (and nothing
%   is added when the quotient was exact). This does not give the
%   \enquote{correct} \meta{rounding} digit, but it always gives a digit
%   in the right \enquote{class} ($0$, $[1,4]$, $5$, or $[6-9]$), enough
%   for rounding purposes.
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_vii:wwnnnnnn #1; #2;#3#4 #5#6#7#8
  {
    + \c_five * #1
    \exp_after:wN \@@_div_mantissa_ix:Nww
    \int_use:N \__int_eval:w -20 + 2*#2 - #1*#5#6 +
      \exp_after:wN \@@_div_mantissa_viii:NNw
      \int_use:N \__int_eval:w 199980 + 2*#3 - #1*#7 +
        \exp_after:wN \@@_div_mantissa_viii:NNw
        \int_use:N \__int_eval:w 200000 + 2*#4 - #1*#8 ; ;
  }
\cs_new:Npn \@@_div_mantissa_viii:NNw #1#2#3; { #1#2 ; + #3 }
%    \end{macrocode}
%   \begin{quote}
%     \cs{@@_div_mantissa_ix:Nww}
%     ~~\meta{F_1} \meta{F_2} |;| |+| \meta{F_3} |+| \meta{F_4} |;| \meta{sign}
%   \end{quote}
%   where $F=2E-PZ$. We only need to know whether it is positive,
%   negative, or exactly zero.
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_ix:Nww #1#2;#3;
  {
    \if_meaning:w 0 #1
      \exp_after:wN \@@_div_mantissa_x:w
      \int_use:N \__int_eval:w #3
    \else:
      \if_meaning:w - #1
        -
      \else:
        +
      \fi:
      \c_one
    \fi:
    ;
  }
\cs_new:Npn \@@_div_mantissa_x:w #1;
  {
    \if_int_compare:w #1 > \c_zero
      + \c_one
    \fi:
    ;
  }
%    \end{macrocode}
%   We now obtain the following code, where \TeX{} is in the process
%   of expanding each of the integer expressions, and thus expands
%   the function at the bottom before the ones above it.
%   \begin{quote}
%     \cs{@@_div_mantissa_iii_after:w}  $10^6 + Q_{1}$
%     \cs{@@_div_mantissa_pack:NNN} $10^6 + Q_{2}$
%     \cs{@@_div_mantissa_pack:NNN} $10^6 + Q_{3}$
%     \cs{@@_div_mantissa_pack:NNN}
%     $10^7 + 10\cdot Q_{4} + 5 \cdot P + \varepsilon$ |;| \meta{sign}
%   \end{quote}
%   Here, $\varepsilon$ is $0$ in case $2E=PZ$ (\emph{i.e.}, $F=0$),
%   $1$ in case $2E>PZ$, which means that $P$ was the correct value,
%   but not with an exact quotient, and $-1$ if $2E<PZ$, \emph{i.e.},
%   $P$ was an overestimate.
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_pack:NNN 1 #1 #2 { + #1 #2 ; }
%    \end{macrocode}
%   Once those have been expanded, we get
%   \begin{quote}
%     \cs{@@_div_mantissa_iii_after:w} |1| |0| \meta{5d} |;|
%     ~~\meta{4d} |;| \meta{4d} |;| \meta{5d} |;| \meta{sign}
%   \end{quote}
%   The reason we know that the first two digits are |1| and |0|
%   is that the final result is known to be between $0.1$ (inclusive)
%   and $10$, hence $\widetilde{Q_{1}}$ (the tilde denoting the
%   contribution from the other $Q_{i}$) is at most $99999$,
%   and $10^6+\widetilde{Q_{1}} = 10\cdots$.
%
%   It is now time to round. This depends on how many digits
%   the final result will have.
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_iii_after:w 10 #1
  {
    \if_meaning:w 0 #1
      \exp_after:wN \@@_div_mantissa_small:wwwNNNNwN
    \else:
      \exp_after:wN \@@_div_mantissa_large:wwwNNNNwN
    \fi:
    #1
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{@@_div_mantissa_small:wwwNNNNwN} |0| \meta{4d} |;|
%     ~~\meta{4d} |;| \meta{4d} |;| \meta{5d} |;| \meta{sign}
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_small:wwwNNNNwN
    0 #1; #2; #3; #4#5#6#7#8; #9
  {
    \exp_after:wN \@@_basics_pack_high:NNNNNw
    \int_use:N \__int_eval:w 1 #1#2
      \exp_after:wN \@@_basics_pack_low:NNNNNw
      \int_use:N \__int_eval:w 1 #3#4#5#6#7
        + \@@_round:NNN #9 #7 #8
        \exp_after:wN ;
  }
%    \end{macrocode}
%   \begin{quote}
%     \cs{@@_div_mantissa_large:wwwNNNNwN} \meta{5d} |;|
%     ~~\meta{4d} |;| \meta{4d} |;| \meta{5d} |;| \meta{sign}
%   \end{quote}
%   \footnote{Bruno: rename the \enquote{add mantissa carry pack} function.}
%    \begin{macrocode}
\cs_new:Npn \@@_div_mantissa_large:wwwNNNNwN
    #1; #2; #3; #4#5#6#7#8; #9
  {
    + \c_one
    \exp_after:wN \@@_div_mantissa_large_pack:NNNNNNNNw
    \int_use:N \__int_eval:w 1 #1 #2 %<- 1+9d
      \exp_after:wN \@@_add_mantissa_carry_pack_ii:NNNNw
      \int_use:N \__int_eval:w 1 #3 #4 #5 #6
        + \@@_round:NNNN #9 #6 #7 #8
        \exp_after:wN ;
  }
\cs_new:Npn \@@_div_mantissa_large_pack:NNNNNNNNw
    1 #1#2#3#4 #5#6#7#8 #9; { ; {#1#2#3#4} {#5#6#7#8} {#9} }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Unary operations}
%
% \begin{macro}{\@@_neg:w}
%   This function flips the sign of the \meta{floating point}
%   and expands after it in the input stream, just like
%   \cs{@@_+_o:ww} etc.
%    \begin{macrocode}
\cs_new:Npn \@@_neg:w \s_@@ \@@_chk:w #1 #2
  {
    \exp_after:wN \@@_exp_after_o:w
    \exp_after:wN \s_@@
    \exp_after:wN \@@_chk:w
    \exp_after:wN #1
    \int_use:N \__int_eval:w \c_two - #2 \__int_eval_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_abs:w}
%   This function sets the sign of the \meta{floating point} to be
%   positive, and expands after itself in the input stream, just like
%   \cs{@@_neg:w}.
%    \begin{macrocode}
\cs_new:Npn \@@_abs:w \s_@@ \@@_chk:w #1 #2
  { \@@_exp_after_o:w \s_@@ \@@_chk:w #1 0 }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex
