% \iffalse meta-comment
%
%% File: l3fp-basics.dtx Copyright (C) 2011-2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3kernel bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver>
\RequirePackage{l3bootstrap}
\GetIdInfo$Id$
  {L3 Floating-point arithmetic}
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-basics} package\thanks{This file
%         has version number \ExplFileVersion, last
%         revised \ExplFileDate.}\\
% Floating point arithmetic}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3fp-basics} Implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=fp>
%    \end{macrocode}
%
% The \pkg{l3fp-basics} module implements addition, subtraction,
% multiplication, and division of two floating points, and the absolute
% value and sign-changing operations on one floating point.
% All operations implemented in this module yield the outcome of
% rounding the infinitely precise result of the operation to the
% nearest floating point.
%
% Some algorithms used below end up being quite similar to some
% described in \enquote{What Every Computer Scientist Should Know About
%   Floating Point Arithmetic}, by David Goldberg, which can be found at
% \texttt{http://cr.yp.to/2005-590/goldberg.pdf}.
%
% \subsection{Common to several operations}
%
% \begin{macro}[aux, EXP]
%   {
%     \@@_basics_pack_low:NNNNNw,
%     \@@_basics_pack_high:NNNNNw,
%     \@@_basics_pack_high_carry:w
%   }
%   Addition and multiplication of significands are done in two steps:
%   first compute a (more or less) exact result, then round and pack
%   digits in the final (braced) form.  These functions take care of the
%   packing, with special attention given to the case where rounding has
%   caused a carry.  Since rounding can only shift the final digit by
%   $1$, a carry always produces an exact power of $10$.  Thus,
%   \cs{@@_basics_pack_high_carry:w} is always followed by four times
%   |{0000}|.
%    \begin{macrocode}
\cs_new:Npn \@@_basics_pack_low:NNNNNw #1 #2#3#4#5 #6;
  {
    \if_meaning:w 2 #1
      + \c_one
    \fi:
    ; {#2#3#4#5} {#6} ;
  }
\cs_new:Npn \@@_basics_pack_high:NNNNNw #1 #2#3#4#5 #6;
  {
    \if_meaning:w 2 #1
      \@@_basics_pack_high_carry:w
    \fi:
    ; {#2#3#4#5} {#6}
  }
\cs_new:Npn \@@_basics_pack_high_carry:w \fi: ; #1
  { \fi: + \c_one ; {1000} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {
%     \@@_basics_pack_weird_low:NNNNw,
%     \@@_basics_pack_weird_high:NNNNNNNNw
%   }
%   I don't fully understand those functions, used for additions and
%   divisions.  Hence the name.
%    \begin{macrocode}
\cs_new:Npn \@@_basics_pack_weird_low:NNNNw #1 #2#3#4 #5;
  {
    \if_meaning:w 2 #1
      + \c_one
    \fi:
    \__int_eval_end:
    #2#3#4; {#5} ;
  }
\cs_new:Npn \@@_basics_pack_weird_high:NNNNNNNNw
   1 #1#2#3#4 #5#6#7#8 #9; { ; {#1#2#3#4} {#5#6#7#8} {#9} }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Addition and subtraction}
%
% We define here two functions, \cs{@@_-_o:ww} and \cs{@@_+_o:ww}, which
% perform the subtraction and addition of their two floating point
% operands, and expand the tokens following the result once.
%
% A more obscure function, \cs{@@_add_big_i_o:wNww}, is used in
% \pkg{l3fp-expo}.
%
% The logic goes as follows:
% \begin{itemize}
%   \item \cs{@@_-_o:ww} calls \cs{@@_+_o:ww} to do the work, with the
%     sign of the second operand flipped;
%   \item \cs{@@_+_o:ww} dispatches depending on the type of floating
%     point, calling specialized auxiliaries;
%   \item in all cases except summing two normal floating point numbers,
%     we return one or the other operands depending on the signs, or
%     detect an invalid operation in the case of $\infty - \infty$;
%   \item for normal floating point numbers, compare the signs;
%   \item to add two floating point numbers of the same sign or of
%     opposite signs, shift the significand of the smaller one to match the
%     bigger one, perform the addition or subtraction of significands,
%     check for a carry, round, and pack using the
%     |\__fp_basics_pack_...| functions.
% \end{itemize}
% The trickiest part is to round correctly when adding or subtracting
% normal floating point numbers.
%
% \subsubsection{Sign, exponent, and special numbers}
%
% \begin{macro}[int, EXP]{\@@_-_o:ww}
%   A previous version of this function grabbed its two operands,
%   changed the sign of the second, and called \cs{@@_+_o:ww}.  However,
%   for efficiency reasons, the operands were swapped in the process,
%   which means that error messages ended up wrong.  Now, the
%   \cs{@@_+_o:ww} auxiliary has a hook: it takes one argument between
%   the first \cs{s_@@} and \cs{@@_chk:w}, which is applied to the sign
%   of the second operand.  Positioning the hook there means that
%   \cs{@@_+_o:ww} can still check that it was followed by \cs{s_@@} and
%   not arbitrary junk.
%    \begin{macrocode}
\cs_new_nopar:cpx { @@_-_o:ww } \s_@@
  {
    \exp_not:c { @@_+_o:ww }
    \exp_not:n { \s_@@ \@@_neg_sign:N }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_+_o:ww}
%   This function is either called directly with an empty |#1| to
%   compute an addition, or it is called by \cs{@@_-_o:ww} with
%   \cs{@@_neg_sign:N} as |#1| to compute a subtraction (equivalent to
%   changing the \meta{sign_2} of the second operand).  If the
%   \meta{types} |#2| and |#4| are the same, dispatch to case |#2| ($0$,
%   $1$, $2$, or $3$), where we call specialized functions: thanks to
%   \cs{__int_value:w}, those receive the tweaked \meta{sign_2}
%   (expansion of |#1#5|) as an argument.  If the \meta{types} are
%   distinct, the result is simply the floating point number with the
%   highest \meta{type}.  Since case $3$ (used for two \texttt{nan})
%   also picks the first operand, we can also use it when \meta{type_1}
%   is greater than \meta{type_2}.  Also note that we don't need to
%   worry about \meta{sign_2} in that case since the second operand is
%   discarded.
%    \begin{macrocode}
\cs_new:cpn { @@_+_o:ww }
    \s_@@ #1 \@@_chk:w #2 #3 ; \s_@@ \@@_chk:w #4 #5
  {
    \if_case:w
      \if_meaning:w #2 #4
        #2 \exp_stop_f:
      \else:
        \if_int_compare:w #2 > #4 \exp_stop_f:
          \c_three
        \else:
          \c_minus_one
        \fi:
      \fi:
           \exp_after:wN \@@_add_zeros_o:Nww \__int_value:w
    \or:   \exp_after:wN \@@_add_normal_o:Nww \__int_value:w
    \or:   \exp_after:wN \@@_add_inf_o:Nww \__int_value:w
    \or:   \@@_case_return_i_o:ww
    \else: \exp_after:wN \@@_add_return_ii_o:Nww \__int_value:w
    \fi:
    #1 #5
    \s_@@ \@@_chk:w #2 #3 ;
    \s_@@ \@@_chk:w #4 #5
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_return_ii_o:Nww}
%   Ignore the first operand, and return the second, but using the sign
%   |#1| rather than |#4|.  As usual, expand after the floating point.
%    \begin{macrocode}
\cs_new:Npn \@@_add_return_ii_o:Nww #1 #2 ; \s_@@ \@@_chk:w #3 #4
  { \@@_exp_after_o:w \s_@@ \@@_chk:w #3 #1 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_zeros_o:Nww}
%   Adding two zeros yields \cs{c_zero_fp}, except if both zeros were
%   $-0$.
%    \begin{macrocode}
\cs_new:Npn \@@_add_zeros_o:Nww #1 \s_@@ \@@_chk:w 0 #2
  {
    \if_int_compare:w #2 #1 = 20 \exp_stop_f:
      \exp_after:wN \@@_add_return_ii_o:Nww
    \else:
      \@@_case_return_i_o:ww
    \fi:
    #1
    \s_@@ \@@_chk:w 0 #2
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_inf_o:Nww}
%   If both infinities have the same sign, just return that infinity,
%   otherwise, it is an invalid operation.  We find out if that invalid
%   operation is an addition or a subtraction by testing whether the
%   tweaked \meta{sign_2} (|#1|) and the \meta{sign_2} (|#4|) are
%   identical.
%    \begin{macrocode}
\cs_new:Npn \@@_add_inf_o:Nww
    #1 \s_@@ \@@_chk:w 2 #2 #3; \s_@@ \@@_chk:w 2 #4
  {
    \if_meaning:w #1 #2
      \@@_case_return_i_o:ww
    \else:
      \@@_case_use:nw
        {
          \if_meaning:w #1 #4
            \exp_after:wN \@@_invalid_operation_o:Nww
            \exp_after:wN +
          \else:
            \exp_after:wN \@@_invalid_operation_o:Nww
            \exp_after:wN -
          \fi:
        }
    \fi:
    \s_@@ \@@_chk:w 2 #2 #3;
    \s_@@ \@@_chk:w 2 #4
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_add_normal_o:Nww}
%   \begin{quote}
%     \cs{@@_add_normal_o:Nww} \meta{sign_2}
%       \cs{s_@@} \cs{@@_chk:w} |1| \meta{sign_1}
%       \meta{exp_1} \meta{body_1} |;|
%       \cs{s_@@} \cs{@@_chk:w} |1| \meta{initial sign_2}
%       \meta{exp_2} \meta{body_2} |;|
%   \end{quote}
%   We now have two normal numbers to add, and we have to check signs
%   and exponents more carefully before performing the addition.
%    \begin{macrocode}
\cs_new:Npn \@@_add_normal_o:Nww #1 \s_@@ \@@_chk:w 1 #2
  {
    \if_meaning:w #1#2
      \exp_after:wN \@@_add_npos_o:NnwNnw
    \else:
      \exp_after:wN \@@_sub_npos_o:NnwNnw
    \fi:
    #2
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute addition}
%
% In this subsection, we perform the addition of two positive normal
% numbers.
%
% \begin{macro}[aux, EXP]{\@@_add_npos_o:NnwNnw}
%   \begin{quote}
%     \cs{@@_add_npos_o:NnwNnw} \meta{sign_1} \meta{exp_1} \meta{body_1}
%     |;| \cs{s_@@} \cs{@@_chk:w} |1| \meta{initial sign_2} \meta{exp_2}
%     \meta{body_2} |;|
%   \end{quote}
%   Since we are doing an addition, the final sign is \meta{sign_1}.
%   Start an \cs{__int_eval:w}, responsible for computing the exponent:
%   the result, and the \meta{final sign} are then given to
%   \cs{@@_sanitize:Nw} which checks for overflow.  The exponent is
%   computed as the largest exponent |#2| or |#5|, incremented if there
%   is a carry.  To add the significands, we decimate the smaller number by
%   the difference between the exponents.  This is done by
%   \cs{@@_add_big_i:wNww} or \cs{@@_add_big_ii:wNww}.  We need to bring
%   the final sign with us in the midst of the calculation to round
%   properly at the end.
%    \begin{macrocode}
\cs_new:Npn \@@_add_npos_o:NnwNnw #1#2#3 ; \s_@@ \@@_chk:w 1 #4 #5
  {
    \exp_after:wN \@@_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \__int_eval:w
      \if_int_compare:w #2 > #5 \exp_stop_f:
        #2
        \exp_after:wN \@@_add_big_i_o:wNww \__int_value:w -
      \else:
        #5
        \exp_after:wN \@@_add_big_ii_o:wNww \__int_value:w
      \fi:
      \__int_eval:w #5 - #2 ; #1 #3;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, rEXP]{\@@_add_big_i_o:wNww}
% \begin{macro}[aux, rEXP]{\@@_add_big_ii_o:wNww}
%   \begin{quote}
%     \cs{@@_add_big_i_o:wNww} \meta{shift} |;| \meta{final sign}
%       \meta{body_1} |;| \meta{body_2} |;|
%   \end{quote}
%   Shift the significand of the small number, then add with
%   \cs{@@_add_significand_o:NnnwnnnnN}.
%    \begin{macrocode}
\cs_new:Npn \@@_add_big_i_o:wNww #1; #2 #3; #4;
  {
    \@@_decimate:nNnnnn {#1}
      \@@_add_significand_o:NnnwnnnnN
      #4
    #3
    #2
  }
\cs_new:Npn \@@_add_big_ii_o:wNww #1; #2 #3; #4;
  {
    \@@_decimate:nNnnnn {#1}
      \@@_add_significand_o:NnnwnnnnN
      #3
    #4
    #2
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_add_significand_o:NnnwnnnnN}
% \begin{macro}[aux, rEXP]
%   {\@@_add_significand_pack:NNNNNNN, \@@_add_significand_test_o:N}
%   \begin{quote}
%     \cs{@@_add_significand_o:NnnwnnnnN}
%       \meta{rounding digit}
%       \Arg{Y'_1} \Arg{Y'_2} \meta{extra-digits} |;|
%       \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4}
%       \meta{final sign}
%   \end{quote}
%   To round properly, we must know at which digit the rounding
%   should occur. This requires to know whether the addition
%   produces an overall carry or not. Thus, we do the computation
%   now and check for a carry, then go back and do the rounding.
%   The rounding may cause a carry in very rare cases such as
%   $0.99\cdots 95 \to 1.00\cdots 0$, but this situation always
%   give an exact power of $10$, for which it is easy to correct
%   the result at the end.
%    \begin{macrocode}
\cs_new:Npn \@@_add_significand_o:NnnwnnnnN #1 #2#3 #4; #5#6#7#8
  {
    \exp_after:wN \@@_add_significand_test_o:N
    \int_use:N \__int_eval:w 1#5#6 + #2
      \exp_after:wN \@@_add_significand_pack:NNNNNNN
      \int_use:N \__int_eval:w 1#7#8 + #3 ; #1
  }
\cs_new:Npn \@@_add_significand_pack:NNNNNNN #1 #2#3#4#5#6#7
  {
    \if_meaning:w 2 #1
      + \c_one
    \fi:
    ; #2 #3 #4 #5 #6 #7 ;
  }
\cs_new:Npn \@@_add_significand_test_o:N #1
  {
    \if_meaning:w 2 #1
      \exp_after:wN \@@_add_significand_carry_o:wwwNN
    \else:
      \exp_after:wN \@@_add_significand_no_carry_o:wwwNN
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_add_significand_no_carry_o:wwwNN}
%   \begin{quote}
%     \cs{@@_add_significand_no_carry_o:wwwNN}
%       \meta{8d} |;| \meta{6d} |;| \meta{2d} |;|
%       \meta{rounding digit} \meta{sign}
%   \end{quote}
%   If there's no carry, grab all the digits again and round.  The
%   packing function \cs{@@_basics_pack_high:NNNNNw} takes care of the
%   case where rounding brings a carry.
%    \begin{macrocode}
\cs_new:Npn \@@_add_significand_no_carry_o:wwwNN
    #1; #2; #3#4 ; #5#6
  {
    \exp_after:wN \@@_basics_pack_high:NNNNNw
    \int_use:N \__int_eval:w 1 #1
      \exp_after:wN \@@_basics_pack_low:NNNNNw
      \int_use:N \__int_eval:w 1 #2 #3#4
        + \@@_round:NNN #6 #4 #5
        \exp_after:wN ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_add_significand_carry_o:wwwNN}
%   \begin{quote}
%     \cs{@@_add_significand_carry_o:wwwNN}
%       \meta{8d} |;| \meta{6d} |;| \meta{2d} |;|
%       \meta{rounding digit} \meta{sign}
%   \end{quote}
%   The case where there is a carry is very similar.  Rounding can even
%   raise the first digit from $1$ to $2$, but we don't care.
%    \begin{macrocode}
\cs_new:Npn \@@_add_significand_carry_o:wwwNN
    #1; #2; #3#4; #5#6
  {
    + \c_one
    \exp_after:wN \@@_basics_pack_weird_high:NNNNNNNNw
    \int_use:N \__int_eval:w 1 1 #1
      \exp_after:wN \@@_basics_pack_weird_low:NNNNw
      \int_use:N \__int_eval:w 1 #2#3 +
        \exp_after:wN \@@_round:NNN
        \exp_after:wN #6
        \exp_after:wN #3
        \__int_value:w \@@_round_digit:Nw #4 #5 ;
        \exp_after:wN ;
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute subtraction}
%
% \begin{macro}[aux, EXP]{\@@_sub_npos_o:NnwNnw}
% \begin{macro}[aux, EXP]{\@@_sub_eq_o:Nnwnw, \@@_sub_npos_ii_o:Nnwnw}
%   \begin{quote}
%     \cs{@@_sub_npos_o:NnwNnw}
%       \meta{sign_1} \meta{exp_1} \meta{body_1} |;|
%       \cs{s_@@} \cs{@@_chk:w} |1|
%       \meta{initial sign_2} \meta{exp_2} \meta{body_2} |;|
%   \end{quote}
%   Rounding properly in some modes requires to know what the sign of
%   the result will be.  Thus, we start by comparing the exponents and
%   significands.  If the numbers coincide, return zero.  If the second
%   number is larger, swap the numbers and call
%   \cs{@@_sub_npos_i_o:Nnwnw} with the opposite of \meta{sign_1}.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_npos_o:NnwNnw #1#2#3; \s_@@ \@@_chk:w 1 #4#5#6;
  {
    \if_case:w \@@_compare_npos:nwnw {#2} #3; {#5} #6; \exp_stop_f:
      \exp_after:wN \@@_sub_eq_o:Nnwnw
    \or:
      \exp_after:wN \@@_sub_npos_i_o:Nnwnw
    \else:
      \exp_after:wN \@@_sub_npos_ii_o:Nnwnw
    \fi:
    #1 {#2} #3; {#5} #6;
  }
\cs_new:Npn \@@_sub_eq_o:Nnwnw #1#2; #3; { \exp_after:wN \c_zero_fp }
\cs_new:Npn \@@_sub_npos_ii_o:Nnwnw #1 #2; #3;
  {
    \exp_after:wN \@@_sub_npos_i_o:Nnwnw
      \int_use:N \__int_eval:w \c_two - #1 \__int_eval_end:
      #3; #2;
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_sub_npos_i_o:Nnwnw}
%   After the computation is done, \cs{@@_sanitize:Nw} checks for
%   overflow/underflow.  It expects the \meta{final sign} and the
%   \meta{exponent} (delimited by |;|).  Start an integer expression for
%   the exponent, which starts with the exponent of the largest number,
%   and may be decreased if the two numbers are very close.  If the two
%   numbers have the same exponent, call the \texttt{near} auxiliary.
%   Otherwise, decimate $y$, then call the \texttt{far} auxiliary to
%   evaluate the difference between the two significands.  Note that we
%   decimate by $1$ less than one could expect.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_npos_i_o:Nnwnw #1 #2#3; #4#5;
  {
    \exp_after:wN \@@_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \__int_eval:w
      #2
      \if_int_compare:w #2 = #4 \exp_stop_f:
        \exp_after:wN \@@_sub_back_near_o:nnnnnnnnN
      \else:
        \exp_after:wN \@@_decimate:nNnnnn \exp_after:wN
          { \int_use:N \__int_eval:w #2 - #4 - \c_one \exp_after:wN }
          \exp_after:wN \@@_sub_back_far_o:NnnwnnnnN
      \fi:
        #5
      #3
      #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_sub_back_near_o:nnnnnnnnN}
% \begin{macro}[aux, rEXP]
%   {\@@_sub_back_near_pack:NNNNNNw, \@@_sub_back_near_after:wNNNNw}
%   \begin{quote}
%     \cs{@@_sub_back_near_o:nnnnnnnnN}
%       \Arg{Y_1} \Arg{Y_2} \Arg{Y_3} \Arg{Y_4}
%       \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4}
%       \meta{final sign}
%   \end{quote}
%   In this case, the subtraction is exact, so we discard the
%   \meta{final sign} |#9|.  The very large shifts of $10^{9}$ and
%   $1.1\cdot10^{9}$ are unnecessary here, but allow the auxiliaries to
%   be reused later.  Each integer expression produces a $10$ digit
%   result.  If the resulting $16$ digits start with a $0$, then we need
%   to shift the group, padding with trailing zeros.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_near_o:nnnnnnnnN #1#2#3#4 #5#6#7#8 #9
  {
    \exp_after:wN \@@_sub_back_near_after:wNNNNw
    \int_use:N \__int_eval:w 10#5#6 - #1#2 - \c_eleven
      \exp_after:wN \@@_sub_back_near_pack:NNNNNNw
      \int_use:N \__int_eval:w 11#7#8 - #3#4 \exp_after:wN ;
  }
\cs_new:Npn \@@_sub_back_near_pack:NNNNNNw #1#2#3#4#5#6#7 ;
  { + #1#2 ; {#3#4#5#6} {#7} ; }
\cs_new:Npn \@@_sub_back_near_after:wNNNNw 10 #1#2#3#4 #5 ;
  {
    \if_meaning:w 0 #1
      \exp_after:wN \@@_sub_back_shift:wnnnn
    \fi:
    ; {#1#2#3#4} {#5}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_sub_back_shift:wnnnn}
% \begin{macro}[aux, rEXP]
%   {
%     \@@_sub_back_shift_ii:ww,
%     \@@_sub_back_shift_iii:NNNNNNNNw,
%     \@@_sub_back_shift_iv:nnnnw
%   }
%   \begin{quote}
%     \cs{@@_sub_back_shift:wnnnn} |;|
%       \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} |;|
%   \end{quote}
%   This function is called with $\meta{Z_1}\leq 999$.  Act with
%   \tn{number} to trim leading zeros from \meta{Z_1} \meta{Z_2} (we
%   don't do all four blocks at once, since non-zero blocks would then
%   overflow \TeX{}'s integers).  If the first two blocks are zero, the
%   auxiliary receives an empty |#1| and trims |#2#30| from leading
%   zeros, yielding a total shift between $7$ and~$16$ to the exponent.
%   Otherwise we get the shift from |#1| alone, yielding a result
%   between $1$ and~$6$.  Once the exponent is taken care of, trim
%   leading zeros from |#1#2#3| (when |#1| is empty, the space before
%   |#2#3| is ignored), get four blocks of $4$~digits and finally clean
%   up.  Trailing zeros are added so that digits can be grabbed safely.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_shift:wnnnn ; #1#2
  {
    \exp_after:wN \@@_sub_back_shift_ii:ww
    \__int_value:w #1 #2 0 ;
  }
\cs_new:Npn \@@_sub_back_shift_ii:ww #1 0 ; #2#3 ;
  {
    \if_meaning:w @ #1 @
      - \c_seven
      - \exp_after:wN \use_i:nnn
        \exp_after:wN \@@_sub_back_shift_iii:NNNNNNNNw
        \__int_value:w #2#3 0 ~ 123456789;
    \else:
      - \@@_sub_back_shift_iii:NNNNNNNNw #1 123456789;
    \fi:
    \exp_after:wN \@@_pack_twice_four:wNNNNNNNN
    \exp_after:wN \@@_pack_twice_four:wNNNNNNNN
    \exp_after:wN \@@_sub_back_shift_iv:nnnnw
    \exp_after:wN ;
    \__int_value:w
    #1 ~ #2#3 0 ~ 0000 0000 0000 000 ;
  }
\cs_new:Npn \@@_sub_back_shift_iii:NNNNNNNNw #1#2#3#4#5#6#7#8#9; {#8}
\cs_new:Npn \@@_sub_back_shift_iv:nnnnw #1 ; #2 ; { ; #1 ; }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_sub_back_far_o:NnnwnnnnN}
%   \begin{quote}
%     \cs{@@_sub_back_far_o:NnnwnnnnN}
%       \meta{rounding} \Arg{Y'_1} \Arg{Y'_2} \meta{extra-digits} |;|
%       \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4}
%       \meta{final sign}
%   \end{quote}
%   If the difference is greater than $10^{\meta{expo_x}}$, call the
%   \texttt{very_far} auxiliary.  If the result is less than
%   $10^{\meta{expo_x}}$, call the \texttt{not_far} auxiliary.  If it is
%   too close a call to know yet, namely if $1 \meta{Y'_1} \meta{Y'_2} =
%   \meta{X_1} \meta{X_2} \meta{X_3} \meta{X_4} 0$, then call the
%   \texttt{quite_far} auxiliary.  We use the odd combination of space
%   and semi-colon delimiters to allow the \texttt{not_far} auxiliary to
%   grab each piece individually, the \texttt{very_far} auxiliary to use
%   \cs{@@_pack_eight:wNNNNNNNN}, and the \texttt{quite_far} to ignore
%   the significands easily (using the |;| delimiter).
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_far_o:NnnwnnnnN #1 #2#3 #4; #5#6#7#8
  {
    \if_case:w
      \if_int_compare:w 1 #2 = #5#6 \use_i:nnnn #7 \exp_stop_f:
        \if_int_compare:w #3 = \use_none:n #7#8 0 \exp_stop_f:
          \c_zero
        \else:
          \if_int_compare:w #3 > \use_none:n #7#8 0 - \fi: \c_one
        \fi:
      \else:
        \if_int_compare:w 1 #2 > #5#6 \use_i:nnnn #7 - \fi: \c_one
      \fi:
           \exp_after:wN \@@_sub_back_quite_far_o:wwNN
    \or:   \exp_after:wN \@@_sub_back_very_far_o:wwwwNN
    \else: \exp_after:wN \@@_sub_back_not_far_o:wwwwNN
    \fi:
    #2 ~ #3 ; #5 #6 ~ #7 #8 ; #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_sub_back_quite_far_o:wwNN}
% \begin{macro}[aux, EXP]{\@@_sub_back_quite_far_ii:NN}
%   The easiest case is when $x-y$ is extremely close to a power of
%   $10$, namely the first digit of $x$ is $1$, and all others vanish
%   when subtracting $y$.  Then the \meta{rounding} |#3| and the
%   \meta{final sign} |#4| control whether we get $1$ or $0.9999 9999
%   9999 9999$.  In the usual round-to-nearest mode, we will get $1$
%   whenever the \meta{rounding} digit is less than or equal to $5$
%   (remember that the \meta{rounding} digit is only equal to $5$ if
%   there was no further non-zero digit).
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_quite_far_o:wwNN #1; #2; #3#4
  {
    \exp_after:wN \@@_sub_back_quite_far_ii:NN
    \exp_after:wN #3
    \exp_after:wN #4
  }
\cs_new:Npn \@@_sub_back_quite_far_ii:NN #1#2
  {
    \if_case:w \@@_round_neg:NNN #2 0 #1
      \exp_after:wN \use_i:nn
    \else:
      \exp_after:wN \use_ii:nn
    \fi:
      { ; {1000} {0000} {0000} {0000} ; }
      { - \c_one ; {9999} {9999} {9999} {9999} ; }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_sub_back_not_far_o:wwwwNN}
%   In the present case, $x$ and $y$ have different exponents, but
%   $y$~is large enough that $x-y$ has a smaller exponent than~$x$.
%   Decrement the exponent (with |- \c_one|).  Then proceed in a way
%   similar to the \texttt{near} auxiliaries seen earlier, but
%   multiplying $x$ by~$10$ (|#30| and |#40| below), and with the added
%   quirk that the \meta{rounding} digit has to be taken into account.
%   Namely, we may have to decrease the result by one unit if
%   \cs{@@_round_neg:NNN} returns~$1$.  This function expects the
%   \meta{final sign}~|#6|, the last digit of |1100000000+#40-#2|, and
%   the \meta{rounding} digit.  Instead of redoing the computation for
%   the second argument, we note that \cs{@@_round_neg:NNN} only cares
%   about its parity, which is identical to that of the last digit
%   of~|#2|.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_not_far_o:wwwwNN #1 ~ #2; #3 ~ #4; #5#6
  {
    - \c_one
    \exp_after:wN \@@_sub_back_near_after:wNNNNw
    \int_use:N \__int_eval:w 1#30 - #1 - \c_eleven
      \exp_after:wN \@@_sub_back_near_pack:NNNNNNw
      \int_use:N \__int_eval:w 11 0000 0000 + #40 - #2
        - \exp_after:wN \@@_round_neg:NNN
          \exp_after:wN #6
          \use_none:nnnnnnn #2 #5
        \exp_after:wN ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_sub_back_very_far_o:wwwwNN}
% \begin{macro}[aux, EXP]{\@@_sub_back_very_far_ii_o:nnNwwNN}
%   The case where $x-y$ and $x$ have the same exponent is a bit more
%   tricky, mostly because it cannot reuse the same auxiliaries.  Shift
%   the $y$~significand by adding a leading~$0$.  Then the logic is similar
%   to the \texttt{not_far} functions above.  Rounding is a bit more
%   complicated: we have two \meta{rounding} digits |#3| and |#6| (from
%   the decimation, and from the new shift) to take into account, and
%   getting the parity of the main result requires a computation.  The
%   first \cs{__int_value:w} triggers the second one because the number
%   is unfinished; we can thus not use $0$ in place of $2$ there.
%    \begin{macrocode}
\cs_new:Npn \@@_sub_back_very_far_o:wwwwNN #1#2#3#4#5#6#7
  {
    \@@_pack_eight:wNNNNNNNN
    \@@_sub_back_very_far_ii_o:nnNwwNN
    { 0 #1#2#3 #4#5#6#7 }
    ;
  }
\cs_new:Npn \@@_sub_back_very_far_ii_o:nnNwwNN #1#2 ; #3 ; #4 ~ #5; #6#7
  {
    \exp_after:wN \@@_basics_pack_high:NNNNNw
    \int_use:N \__int_eval:w 1#4 - #1 - \c_one
      \exp_after:wN \@@_basics_pack_low:NNNNNw
      \int_use:N \__int_eval:w 2#5 - #2
        - \exp_after:wN \@@_round_neg:NNN
          \exp_after:wN #7
          \__int_value:w
            \if_int_odd:w \__int_eval:w #5 - #2 \__int_eval_end:
              1 \else: 2 \fi:
          \__int_value:w \@@_round_digit:Nw #3 #6 ;
      \exp_after:wN ;
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Multiplication}
%
% \subsubsection{Signs, and special numbers}
%
% \begin{macro}[int, EXP]{\@@_*_o:ww}
%   We go through an auxiliary, which is common with \cs{@@_/_o:ww}.
%   The first argument is the operation, used for the invalid operation
%   exception.  The second is inserted in a formula to dispatch cases
%   slightly differently between multiplication and division.  The third
%   is the operation for normal floating points.  The fourth is there
%   for extra cases needed in \cs{@@_/_o:ww}.
%    \begin{macrocode}
\cs_new_nopar:cpn { @@_*_o:ww }
  {
    \@@_mul_cases_o:NnNnww
      *
      { - \c_two + }
      \@@_mul_npos_o:Nww
      { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_mul_cases_o:nNnnww}
%   Split into $10$ cases ($12$ for division).
%   If both numbers are normal, go to case $0$
%   (same sign) or case $1$ (opposite signs): in both cases, call
%   \cs{@@_mul_npos_o:Nww} to do the work.  If the first operand is
%   \texttt{nan}, go to case $2$, in which the second operand is
%   discarded; if the second operand is \texttt{nan}, go to case $3$, in
%   which the first operand is discarded (note the weird interaction
%   with the final test on signs).  Then we separate the case where the
%   first number is normal and the second is zero: this goes to cases
%   $4$ and $5$ for multiplication, $10$ and $11$ for division.
%   Otherwise, we do a computation which
%   dispatches the products $0\times 0 = 0\times 1 = 1\times 0 = 0$ to
%   case $4$ or $5$ depending on the combined sign, the products
%   $0\times\infty$ and $\infty\times0$ to case $6$ or $7$ (invalid
%   operation), and the products $1\times\infty = \infty\times1 =
%   \infty\times\infty = \infty$ to cases $8$ and $9$.  Note that the
%   code for these two cases (which return $\pm\infty$) is inserted as
%   argument |#4|, because it differs in the case of divisions.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_cases_o:NnNnww
    #1#2#3#4 \s_@@ \@@_chk:w #5#6#7; \s_@@ \@@_chk:w #8#9
  {
    \if_case:w \__int_eval:w
                 \if_int_compare:w #5 #8 = \c_eleven
                   \c_one
                 \else:
                   \if_meaning:w 3 #8
                     \c_three
                   \else:
                     \if_meaning:w 3 #5
                       \c_two
                     \else:
                       \if_int_compare:w #5 #8 = \c_ten
                         \c_nine #2 - \c_two
                       \else:
                         (#5 #2 #8) / \c_two * \c_two + \c_seven
                       \fi:
                     \fi:
                   \fi:
                 \fi:
                 \if_meaning:w #6 #9 - \c_one \fi:
               \__int_eval_end:
         \@@_case_use:nw { #3 0 }
    \or: \@@_case_use:nw { #3 2 }
    \or: \@@_case_return_i_o:ww
    \or: \@@_case_return_ii_o:ww
    \or: \@@_case_return_o:Nww \c_zero_fp
    \or: \@@_case_return_o:Nww \c_minus_zero_fp
    \or: \@@_case_use:nw { \@@_invalid_operation_o:Nww #1 }
    \or: \@@_case_use:nw { \@@_invalid_operation_o:Nww #1 }
    \or: \@@_case_return_o:Nww \c_inf_fp
    \or: \@@_case_return_o:Nww \c_minus_inf_fp
    #4
    \fi:
    \s_@@ \@@_chk:w #5 #6 #7;
    \s_@@ \@@_chk:w #8 #9
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute multiplication}
%
% In this subsection, we perform the multiplication
% of two positive normal numbers.
%
% \begin{macro}[int, EXP]{\@@_mul_npos_o:Nww}
%   \begin{quote}
%     \cs{@@_mul_npos_o:Nww} \meta{final sign}
%     \cs{s_@@} \cs{@@_chk:w} |1| \meta{sign_1} \Arg{exp_1}  \meta{body_1} |;|
%     \cs{s_@@} \cs{@@_chk:w} |1| \meta{sign_2} \Arg{exp_2}  \meta{body_2} |;|
%   \end{quote}
%   After the computation, \cs{@@_sanitize:Nw} checks for overflow or
%   underflow.  As we did for addition, \cs{__int_eval:w} computes the
%   exponent, catching any shift coming from the computation in the
%   significand.  The \meta{final sign} is needed to do the rounding
%   properly in the significand computation.  We setup the post-expansion
%   here, triggered by \cs{@@_mul_significand_o:nnnnNnnnn}.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_npos_o:Nww
    #1 \s_@@ \@@_chk:w #2 #3 #4 #5 ; \s_@@ \@@_chk:w #6 #7 #8 #9 ;
  {
    \exp_after:wN \@@_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \__int_eval:w
      #4 + #8
      \@@_mul_significand_o:nnnnNnnnn #5 #1 #9
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_mul_significand_o:nnnnNnnnn}
% \begin{macro}[aux, EXP]
%   {\@@_mul_significand_drop:NNNNNw, \@@_mul_significand_keep:NNNNNw}
%   \begin{quote}
%     \cs{@@_mul_significand_o:nnnnNnnnn}
%       \Arg{X_1} \Arg{X_2} \Arg{X_3} \Arg{X_4} \meta{sign}
%       \Arg{Y_1} \Arg{Y_2} \Arg{Y_3} \Arg{Y_4}
%   \end{quote}
%   Note the three semicolons at the end of the definition.  One is for
%   the last \cs{@@_mul_significand_drop:NNNNNw}; one is for
%   \cs{@@_round_digit:Nw} later on; and one, preceded by
%   \cs{exp_after:wN}, which is correctly expanded (within an
%   \cs{__int_eval:w}), is used by \cs{@@_basics_pack_low:NNNNNw}.
%
%   The product of two $16$ digit integers has $31$ or $32$ digits,
%   but it is impossible to know which one before computing. The place
%   where we round depends on that number of digits, and may depend
%   on all digits until the last in some rare cases. The approach is
%   thus to compute the $5$ first blocks of $4$ digits (the first one
%   is between $100$ and $9999$ inclusive), and a compact version of
%   the remaining $3$ blocks. Afterwards, the number of digits is
%   known, and we can do the rounding within yet another set of
%   \cs{__int_eval:w}.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_significand_o:nnnnNnnnn #1#2#3#4 #5 #6#7#8#9
  {
    \exp_after:wN \@@_mul_significand_test_f:NNN
    \exp_after:wN #5
    \int_use:N \__int_eval:w 99990000 + #1*#6 +
      \exp_after:wN \@@_mul_significand_keep:NNNNNw
      \int_use:N \__int_eval:w 99990000 + #1*#7 + #2*#6 +
        \exp_after:wN \@@_mul_significand_keep:NNNNNw
        \int_use:N \__int_eval:w 99990000 + #1*#8 + #2*#7 + #3*#6 +
          \exp_after:wN \@@_mul_significand_drop:NNNNNw
          \int_use:N \__int_eval:w  99990000 + #1*#9 + #2*#8 + #3*#7 + #4*#6 +
            \exp_after:wN \@@_mul_significand_drop:NNNNNw
            \int_use:N \__int_eval:w  99990000 + #2*#9 + #3*#8 + #4*#7 +
              \exp_after:wN \@@_mul_significand_drop:NNNNNw
              \int_use:N \__int_eval:w  99990000 + #3*#9 + #4*#8 +
                \exp_after:wN \@@_mul_significand_drop:NNNNNw
                \int_use:N \__int_eval:w 100000000 + #4*#9 ;
    ; \exp_after:wN ;
  }
\cs_new:Npn \@@_mul_significand_drop:NNNNNw #1#2#3#4#5 #6;
  { #1#2#3#4#5 ; + #6 }
\cs_new:Npn \@@_mul_significand_keep:NNNNNw #1#2#3#4#5 #6;
  { #1#2#3#4#5 ; #6 ; }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_mul_significand_test_f:NNN}
%   \begin{quote}
%     \cs{@@_mul_significand_test_f:NNN} \meta{sign} |1|
%       \meta{digits 1--8} |;| \meta{digits 9--12} |;| \meta{digits 13--16} |;|
%       |+| \meta{digits 17--20} |+| \meta{digits 21--24}
%       |+| \meta{digits 25--28} |+| \meta{digits 29--32} |;|
%       \cs{exp_after:wN} |;|
%   \end{quote}
%   If the \meta{digit 1} is non-zero, then for rounding we only care
%   about the digits $16$ and $17$, and whether further digits are zero
%   or not (check for exact ties). On the other hand, if \meta{digit 1}
%   is zero, we care about digits $17$ and $18$, and whether further
%   digits are zero.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_significand_test_f:NNN #1 #2 #3
  {
    \if_meaning:w 0 #3
      \exp_after:wN \@@_mul_significand_small_f:NNwwwN
    \else:
      \exp_after:wN \@@_mul_significand_large_f:NwwNNNN
    \fi:
    #1 #3
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_mul_significand_large_f:NwwNNNN}
%   In this branch, \meta{digit 1} is non-zero. The result is thus
%   \meta{digits 1--16}, plus some rounding which depends on the digits
%   $16$, $17$, and whether all subsequent digits are zero or not.
%   Here, \cs{@@_round_digit:Nw} takes digits $17$ and further (as an
%   integer expression), and replaces it by a \meta{rounding digit},
%   suitable for \cs{@@_round:NNN}.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_significand_large_f:NwwNNNN #1 #2; #3; #4#5#6#7; +
  {
    \exp_after:wN \@@_basics_pack_high:NNNNNw
    \int_use:N \__int_eval:w 1#2
      \exp_after:wN \@@_basics_pack_low:NNNNNw
      \int_use:N \__int_eval:w 1#3#4#5#6#7
        + \exp_after:wN \@@_round:NNN
          \exp_after:wN #1
          \exp_after:wN #7
          \__int_value:w \@@_round_digit:Nw
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_mul_significand_small_f:NNwwwN}
%   In this branch, \meta{digit 1} is zero. Our result will thus be
%   \meta{digits 2--17}, plus some rounding which depends on the digits
%   $17$, $18$, and whether all subsequent digits are zero or not.
%   The $8$ digits |1#3| are followed, after expansion of the
%   \texttt{small_pack} auxiliary, by the next digit, to form a $9$
%   digit number.
%    \begin{macrocode}
\cs_new:Npn \@@_mul_significand_small_f:NNwwwN #1 #2#3; #4#5; #6; + #7
  {
    - \c_one
    \exp_after:wN \@@_basics_pack_high:NNNNNw
    \int_use:N \__int_eval:w 1#3#4
      \exp_after:wN \@@_basics_pack_low:NNNNNw
      \int_use:N \__int_eval:w 1#5#6#7
        + \exp_after:wN \@@_round:NNN
          \exp_after:wN #1
          \exp_after:wN #7
          \__int_value:w \@@_round_digit:Nw
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Division}
%
% \subsubsection{Signs, and special numbers}
%
% Time is now ripe to tackle the hardest of the four elementary
% operations: division.
%
% \begin{macro}[int, EXP]{\@@_/_o:ww}
%   Filtering special floating point is very similar to what we did for
%   multiplications, with a few variations.  Invalid operation
%   exceptions display |/| rather than |*|.  In the formula for
%   dispatch, we replace |- \c_two +| by |-|.  The case of normal
%   numbers is treated using \cs{@@_div_npos_o:Nww} rather than
%   \cs{@@_mul_npos_o:Nww}.  There are two additional cases: if the
%   first operand is normal and the second is a zero, then the division
%   by zero exception is raised: cases $10$ and $11$ of the
%   \cs{if_case:w} construction in \cs{@@_mul_cases_o:NnNnww} are
%   provided as the fourth argument here.
%    \begin{macrocode}
\cs_new_nopar:cpn { @@_/_o:ww }
  {
    \@@_mul_cases_o:NnNnww
      /
      { - }
      \@@_div_npos_o:Nww
      {
        \or:
          \@@_case_use:nw
            { \@@_division_by_zero_o:NNww \c_inf_fp / }
        \or:
          \@@_case_use:nw
            { \@@_division_by_zero_o:NNww \c_minus_inf_fp / }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_div_npos_o:Nww}
%   \begin{quote}
%     \cs{@@_div_npos_o:Nww} \meta{final sign}
%     \cs{s_@@} \cs{@@_chk:w} |1| \meta{sign_A} \Arg{exp A}
%       \Arg{A_1} \Arg{A_2} \Arg{A_3} \Arg{A_4} |;|
%     \cs{s_@@} \cs{@@_chk:w} |1| \meta{sign_Z} \Arg{exp Z}
%       \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} |;|
%   \end{quote}
%   We want to compute $A/Z$.  As for multiplication,
%   \cs{@@_sanitize:Nw} checks for overflow or underflow; we provide it
%   with the \meta{final sign}, and an integer expression in which we
%   compute the exponent.  We set up the arguments of
%   \cs{@@_div_significand_i_o:wnnw}, namely an integer \meta{y} obtained
%   by adding $1$ to the first $5$ digits of $Z$ (explanation given soon
%   below), then the four \Arg{A_{i}}, then the four \Arg{Z_{i}}, a
%   semi-colon, and the \meta{final sign}, used for rounding at the end.
%    \begin{macrocode}
\cs_new:Npn \@@_div_npos_o:Nww
    #1 \s_@@ \@@_chk:w 1 #2 #3 #4 ; \s_@@ \@@_chk:w 1 #5 #6 #7#8#9;
  {
    \exp_after:wN \@@_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \__int_eval:w
      #3 - #6
      \exp_after:wN \@@_div_significand_i_o:wnnw
        \int_use:N \__int_eval:w #7 \use_i:nnnn #8 + \c_one ;
        #4
        {#7}{#8}#9 ;
        #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Work plan}
%
% In this subsection, we explain how to avoid overflowing \TeX{}'s
% integers when performing the division of two positive normal numbers.
%
% We are given two numbers, $A=0.A_{1}A_{2}A_{3}A_{4}$ and
% $Z=0.Z_{1}Z_{2}Z_{3}Z_{4}$, in blocks of $4$ digits, and we know that
% the first digits of $A_{1}$ and of $Z_{1}$ are non-zero. To compute
% $A/Z$, we proceed as follows.
% \begin{itemize}
%   \item Find an integer $Q_{A} \simeq 10^{4} A / Z$.
%   \item Replace $A$ by $B = 10^{4} A - Q_{A} Z$.
%   \item Find an integer $Q_{B} \simeq 10^{4} B / Z$.
%   \item Replace $B$ by $C = 10^{4} B - Q_{B} Z$.
%   \item Find an integer $Q_{C} \simeq 10^{4} C / Z$.
%   \item Replace $C$ by $D = 10^{4} C - Q_{C} Z$.
%   \item Find an integer $Q_{D} \simeq 10^{4} D / Z$.
%   \item Consider $E = 10^{4} D - Q_{D} Z$, and ensure
%     correct rounding.
% \end{itemize}
% The result is then $Q = 10^{-4} Q_{A} + 10^{-8} Q_{B} + 10^{-12} Q_{C}
% + 10^{-16} Q_{D} + \text{rounding}$.  Since the $Q_{i}$ are integers,
% $B$, $C$, $D$, and~$E$ are all exact multiples of $10^{-16}$, in other
% words, computing with $16$ digits after the decimal separator yields
% exact results.  The problem will be overflow: in general $B$, $C$,
% $D$, and $E$ may be greater than $1$.
%
% Unfortunately, things are not as easy as they seem.  In particular, we
% want all intermediate steps to be positive, since negative results
% would require extra calculations at the end.  This requires that
% $Q_{A} \leq 10^{4} A / Z$ \emph{etc.}  A reasonable attempt would be
% to define $Q_{A}$ as
% \begin{equation*}
%   \cs{int_eval:n} \left\{
%     \frac{ A_{1} A_{2} }{ Z_{1} + 1 } - 1 \right\}
%   \leq 10^{4} \frac{A}{Z}
% \end{equation*}
% Subtracting $1$ at the end takes care of the fact that \eTeX{}'s
% \cs{__int_eval:w} rounds divisions instead of truncating (really,
% $1/2$ would be sufficient, but we work with integers).  We add $1$ to
% $Z_{1}$ because $Z_{1} \leq 10^{4}Z < Z_{1}+1$ and we need $Q_{A}$ to
% be an underestimate.  However, we are now underestimating $Q_{A}$ too
% much: it can be wrong by up to $100$, for instance when $Z = 0.1$ and
% $A \simeq 1$.  Then $B$ could take values up to $10$ (maybe more), and
% a few steps down the line, we would run into arithmetic overflow,
% since \TeX{} can only handle integers less than roughly $2\cdot
% 10^{9}$.
%
% A better formula is to take
% \begin{equation*}
%   Q_{A} = \cs{int_eval:n} \left\{
%     \frac{ 10 \cdot A_{1} A_{2} }
%       { \left\lfloor 10^{-3} \cdot Z_{1} Z_{2} \right\rfloor + 1 }
%     - 1 \right\}.
% \end{equation*}
% This is always less than $10^{9} A / (10^{5} Z)$, as we wanted.  In
% words, we take the $5$ first digits of $Z$ into account, and the $8$
% first digits of $A$, using $0$ as a $9$-th digit rather than the true
% digit for efficiency reasons.  We shall prove that using this formula
% to define all the $Q_{i}$ avoids any overflow.  For convenience, let
% us denote
% \begin{equation*}
%   y = \left\lfloor 10^{-3} \cdot Z_{1} Z_{2} \right\rfloor + 1,
% \end{equation*}
% so that, taking into account the fact that \eTeX{} rounds ties away
% from zero,
% \begin{align*}
%   Q_{A}
%   &= \left\lfloor \frac{A_{1}A_{2}0}{y} - \frac{1}{2} \right\rfloor
%   \\
%   &>\frac{A_{1}A_{2}0}{y} - \frac{3}{2}.
% \end{align*}
% Note that $10^{4}<y\leq 10^{5}$, and $999 \leq Q_{A} \leq 99989$.
% Also note that this formula does not cause an overflow as long as $A <
% (2^{31}-1) / 10^{9} \simeq 2.147\cdots$, since the numerator involves an
% integer slightly smaller than $10^{9} A$.
%
% Let us bound $B$:
% \begin{align*}
%   10^{5} B
%   &=
%   A_{1}A_{2}0 + 10 \cdot 0.A_{3}A_{4}
%   - 10 \cdot Z_{1}.Z_{2}Z_{3}Z_{4} \cdot Q_{A}
%   \\
%   &<
%   A_{1}A_{2}0
%   \cdot \left( 1 - 10 \cdot \frac{Z_{1}.Z_{2}Z_{3}Z_{4}}{y} \right)
%   + \frac{3}{2} \cdot 10 \cdot Z_{1}.Z_{2}Z_{3}Z_{4} + 10
%   \\
%   &\leq
%   \frac{A_{1}A_{2}0 \cdot (y - 10 \cdot Z_{1}.Z_{2}Z_{3}Z_{4})}{y}
%   + \frac{3}{2} y + 10
%   \\
%   &\leq
%   \frac{A_{1}A_{2}0\cdot 1}{y} + \frac{3}{2} y + 10
%   \leq
%   \frac{10^{9} A}{y} + 1.6\cdot y.
% \end{align*}
% At the last step, we hide $10$ into the second term for later
% convenience.  The same reasoning yields
% \begin{align*}
%   10^{5} B &< 10^{9} A/y + 1.6 y, \\
%   10^{5} C &< 10^{9} B/y + 1.6 y, \\
%   10^{5} D &< 10^{9} C/y + 1.6 y, \\
%   10^{5} E &< 10^{9} D/y + 1.6 y. \\
% \end{align*}
% The goal is now to prove that none of $B$, $C$, $D$, and $E$ can go
% beyond $(2^{31}-1) / 10^{9} = 2.147\cdots$.
%
% Combining the various inequalities together with $A<1$, we get
% \begin{align*}
%   10^{5} B &< 10^{9}/y + 1.6 y, \\
%   10^{5} C &< 10^{13}/y^{2} + 1.6 (y + 10^{4}), \\
%   10^{5} D &< 10^{17}/y^{3} + 1.6 (y + 10^{4} + 10^{8}/y), \\
%   10^{5} E &< 10^{21}/y^{4} + 1.6 (y + 10^{4} + 10^{8}/y + 10^{12}/y^{2}). \\
% \end{align*}
% All of those bounds are convex functions of $y$ (since every power of
% $y$ involved is convex, and the coefficients are positive), and thus
% maximal at one of the end-points of the allowed range $10^{4} < y \leq
% 10^{5}$.  Thus,
% \begin{align*}
%   10^{5} B &< \mathrm{max} ( 1.16\cdot 10^{5}, 1.7 \cdot 10^{5}), \\
%   10^{5} C &< \mathrm{max} ( 1.32\cdot 10^{5}, 1.77 \cdot 10^{5}), \\
%   10^{5} D &< \mathrm{max} ( 1.48\cdot 10^{5}, 1.777 \cdot 10^{5}), \\
%   10^{5} E &< \mathrm{max} ( 1.64\cdot 10^{5}, 1.7777 \cdot 10^{5}). \\
% \end{align*}
% All of those bounds are less than $2.147\cdot 10^{5}$, and we are thus
% within \TeX{}'s bounds in all cases!
%
% We will later need to have a bound on the $Q_{i}$. Their definitions
% imply that $Q_{A} < 10^{9} A/y - 1/2 < 10^{5} A$ and similarly for the
% other $Q_{i}$.  Thus, all of them are less than $177770$.
%
% The last step is to ensure correct rounding. We have
% \begin{equation*}
%   A/Z = \sum_{i=1}^{4} \left(10^{-4i} Q_{i}\right) + 10^{-16} E/Z
% \end{equation*}
% exactly.  Furthermore, we know that the result will be in $[0.1,10)$,
% hence will be rounded to a multiple of $10^{-16}$ or of $10^{-15}$, so
% we only need to know the integer part of $E/Z$, and a
% \enquote{rounding} digit encoding the rest.  Equivalently, we need to
% find the integer part of $2E/Z$, and determine whether it was an
% exact integer or not (this serves to detect ties).  Since
% \begin{equation*}
%   \frac{2E}{Z} = 2\frac{10^{5} E}{10^{5} Z}
%   \leq 2\frac{10^{5} E}{10^{4}} < 36,
% \end{equation*}
% this integer part is between $0$ and $35$ inclusive. We let \eTeX{}
% round
% \begin{equation*}
%   P = \cs{int_eval:n} \left\{
%     \frac{2\cdot E_{1}E_{2}}{Z_{1}Z_{2}} \right\},
% \end{equation*}
% which differs from $2E/Z$ by at most
% \begin{equation*}
%   \frac{1}{2}
%   + 2 \left\lvert \frac{E}{Z} - \frac{E}{10^{-8} Z_{1}Z_{2}}\right\rvert
%   + 2 \left\lvert \frac{10^{8} E - E_{1}E_{2}}{Z_{1}Z_{2}}\right\rvert
%   < 1,
% \end{equation*}
% ($1/2$ comes from \eTeX{}'s rounding) because each absolute value is
% less than $10^{-7}$.  Thus $P$ is either the correct integer part, or
% is off by $1$; furthermore, if $2 E / Z$ is an integer, $P = 2 E / Z$.
% We will check the sign of $2 E - P Z$.  If it is negative, then $E / Z
% \in \big((P - 1) / 2, P / 2\big)$.  If it is zero, then $E / Z = P /
% 2$.  If it is positive, then $E / Z \in \big(P / 2, (P - 1) / 2\big)$.
% In each case, we know how to round to an integer, depending on the
% parity of $P$, and the rounding mode.
%
% \subsubsection{Implementing the significand division}
%
% \begin{macro}[aux, rEXP]{\@@_div_significand_i_o:wnnw}
%   \begin{quote}
%     \cs{@@_div_significand_i_o:wnnw} \meta{y} |;|
%       \Arg{A_1} \Arg{A_2} \Arg{A_3} \Arg{A_4}
%       \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} |;| \meta{sign}
%   \end{quote}
%   Compute $10^{6} + Q_{A}$ (a $7$~digit number thanks to the shift),
%   unbrace \meta{A_1} and \meta{A_2}, and prepare the
%   \meta{continuation} arguments for $4$ consecutive calls to
%   \cs{@@_div_significand_calc:wwnnnnnnn}.  Each of these calls will need
%   \meta{y} (|#1|), and it turns out that we need post-expansion there,
%   hence the \cs{__int_value:w}.  Here, |#4| is six brace groups, which
%   give the six first |n|-type arguments of the \texttt{calc} function.
%    \begin{macrocode}
\cs_new:Npn \@@_div_significand_i_o:wnnw #1 ; #2#3 #4 ;
  {
    \exp_after:wN \@@_div_significand_test_o:w
    \int_use:N \__int_eval:w
      \exp_after:wN \@@_div_significand_calc:wwnnnnnnn
      \int_use:N \__int_eval:w 999999 + #2 #3 0 / #1 ;
        #2 #3 ;
        #4
        { \exp_after:wN \@@_div_significand_ii:wwn \__int_value:w #1 }
        { \exp_after:wN \@@_div_significand_ii:wwn \__int_value:w #1 }
        { \exp_after:wN \@@_div_significand_ii:wwn \__int_value:w #1 }
        { \exp_after:wN \@@_div_significand_iii:wwnnnnn \__int_value:w #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, rEXP]{\@@_div_significand_calc:wwnnnnnnn}
% \begin{macro}[aux, rEXP]
%   {
%     \@@_div_significand_calc_i:wwnnnnnnn,
%     \@@_div_significand_calc_ii:wwnnnnnnn,
%   }
%   \begin{quote}
%     \cs{@@_div_significand_calc:wwnnnnnnn} \meta{$10^{6}+{}$Q_{A}} |;|
%       \meta{A_1} \meta{A_2} |;| \Arg{A_3} \Arg{A_4}
%       \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4}
%       \Arg{continuation}
%   \end{quote}
%   expands to
%   \begin{quote}
%     \meta{$10^{6}+{}$Q_{A}} \meta{continuation} |;|
%       \meta{B_1} \meta{B_2} |;| \Arg{B_3} \Arg{B_4}
%       \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4}
%   \end{quote}
%   where $B = 10^{4} A - Q_{A} \cdot Z$.  This function is also used to
%   compute $C$, $D$, $E$ (with the input shifted accordingly), and is
%   used in \pkg{l3fp-expo}.
%
%   We know that $0<Q_{A}<1.8\cdot 10^{5}$, so the product of $Q_{A}$
%   with each $Z_{i}$ is within \TeX{}'s bounds.  However, it is a
%   little bit too large for our purposes: we would not be able to use
%   the usual trick of adding a large power of $10$ to ensure that the
%   number of digits is fixed.
%
%   The bound on $Q_{A}$, implies that $10^{6}+Q_{A}$ starts with the
%   digit $1$, followed by $0$ or $1$.  We test, and call different
%   auxiliaries for the two cases.  An earlier implementation did the
%   tests within the computation, but since we added a
%   \meta{continuation}, this is not possible because the macro has $9$
%   parameters.
%
%   The result we want is then (the overall power of $10$ is arbitrary):
%   \begin{align*}
%     &10^{-4} ( \#2 - \#1 \cdot \#5 - 10 \cdot \meta{i} \cdot \#5\#6 )
%     + 10^{-8} ( \#3 - \#1 \cdot \#6 - 10 \cdot \meta{i} \cdot \#7 ) \\
%     &+ 10^{-12}( \#4 - \#1 \cdot \#7 - 10 \cdot \meta{i} \cdot \#8 )
%     + 10^{-16}(     - \#1 \cdot \#8 ),
%   \end{align*}
%   where \meta{i} stands for the $10^{5}$ digit of $Q_{A}$, which is
%   $0$ or~$1$, and $\#1$, $\#2$, \emph{etc.\@} are the parameters of
%   either auxiliary.  The factors of $10$ come from the fact that
%   $Q_{A} = 10\cdot 10^{4} \cdot \meta{i} + \#1$.  As usual, to combine
%   all the terms, we need to choose some shifts which must ensure that
%   the number of digits of the second, third, and fourth terms are each
%   fixed.  Here, the positive contributions are at most $10^{8}$ and
%   the negative contributions can go up to $10^{9}$.  Indeed, for the
%   auxiliary with $\meta{i}=1$, |#1| is at most $80000$, leading to
%   contributions of at worse $-8\cdot 10^{8}4$, while the other
%   negative term is very small $<10^{6}$ (except in the first
%   expression, where we don't care about the number of digits); for the
%   auxiliary with $\meta{i}=0$, |#1| can go up to $99999$, but there is
%   no other negative term.  Hence, a good choice is $2\cdot 10^{9}$,
%   which produces totals in the range $[10^{9}, 2.1\cdot 10^{9}]$.  We
%   are flirting with \TeX{}'s limits once more.
%    \begin{macrocode}
\cs_new:Npn \@@_div_significand_calc:wwnnnnnnn 1#1
  {
    \if_meaning:w 1 #1
      \exp_after:wN \@@_div_significand_calc_i:wwnnnnnnn
    \else:
      \exp_after:wN \@@_div_significand_calc_ii:wwnnnnnnn
    \fi:
  }
\cs_new:Npn \@@_div_significand_calc_i:wwnnnnnnn #1; #2;#3#4 #5#6#7#8 #9
  {
    1 1 #1
    #9 \exp_after:wN ;
    \int_use:N \__int_eval:w \c_@@_Bigg_leading_shift_int
      + #2 - #1 * #5 - #5#60
      \exp_after:wN \@@_pack_Bigg:NNNNNNw
      \int_use:N \__int_eval:w \c_@@_Bigg_middle_shift_int
        + #3 - #1 * #6 - #70
        \exp_after:wN \@@_pack_Bigg:NNNNNNw
        \int_use:N \__int_eval:w \c_@@_Bigg_middle_shift_int
          + #4 - #1 * #7 - #80
          \exp_after:wN \@@_pack_Bigg:NNNNNNw
          \int_use:N \__int_eval:w \c_@@_Bigg_trailing_shift_int
            - #1 * #8 ;
    {#5}{#6}{#7}{#8}
  }
\cs_new:Npn \@@_div_significand_calc_ii:wwnnnnnnn #1; #2;#3#4 #5#6#7#8 #9
  {
    1 0 #1
    #9 \exp_after:wN ;
    \int_use:N \__int_eval:w \c_@@_Bigg_leading_shift_int
      + #2 - #1 * #5
      \exp_after:wN \@@_pack_Bigg:NNNNNNw
      \int_use:N \__int_eval:w \c_@@_Bigg_middle_shift_int
        + #3 - #1 * #6
        \exp_after:wN \@@_pack_Bigg:NNNNNNw
        \int_use:N \__int_eval:w \c_@@_Bigg_middle_shift_int
          + #4 - #1 * #7
          \exp_after:wN \@@_pack_Bigg:NNNNNNw
          \int_use:N \__int_eval:w \c_@@_Bigg_trailing_shift_int
            - #1 * #8 ;
    {#5}{#6}{#7}{#8}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_div_significand_ii:wwn}
%   \begin{quote}
%     \cs{@@_div_significand_ii:wwn} \meta{y} |;|
%       \meta{B_1} |;| \Arg{B_2} \Arg{B_3} \Arg{B_4}
%       \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4}
%       \meta{continuations} \meta{sign}
%   \end{quote}
%   Compute $Q_{B}$ by evaluating $\meta{B_1}\meta{B_2}0 / y - 1$.  The
%   result will be output to the left, in an \cs{__int_eval:w} which we
%   start now.  Once that is evaluated (and the other $Q_{i}$ also,
%   since later expansions are triggered by this one), a packing
%   auxiliary takes care of placing the digits of $Q_{B}$ in an
%   appropriate way for the final addition to obtain $Q$.  This
%   auxiliary is also used to compute $Q_{C}$ and $Q_{D}$ with the
%   inputs $C$ and $D$ instead of $B$.
%    \begin{macrocode}
\cs_new:Npn \@@_div_significand_ii:wwn #1; #2;#3
  {
    \exp_after:wN \@@_div_significand_pack:NNN
    \int_use:N \__int_eval:w
      \exp_after:wN \@@_div_significand_calc:wwnnnnnnn
      \int_use:N \__int_eval:w 999999 + #2 #3 0 / #1 ; #2 #3 ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_div_significand_iii:wwnnnnn}
%   \begin{quote}
%     \cs{@@_div_significand_iii:wwnnnnn} \meta{y} |;|
%       \meta{E_1} |;| \Arg{E_2} \Arg{E_3} \Arg{E_4}
%       \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   We compute $P \simeq 2E/Z$ by rounding $2 E_{1} E_{2}/Z_{1}Z_{2}$.
%   Note the first $0$, which multiplies $Q_{D}$ by $10$: we will later
%   add (roughly) $5\cdot P$, which amounts to adding $P/2 \simeq E/Z$
%   to $Q_{D}$, the appropriate correction from a hypothetical $Q_{E}$.
%    \begin{macrocode}
\cs_new:Npn \@@_div_significand_iii:wwnnnnn #1; #2;#3#4#5 #6#7
  {
    0
    \exp_after:wN \@@_div_significand_iv:wwnnnnnnn
    \int_use:N \__int_eval:w (\c_two * #2 #3) / #6 #7 ; % <- P
      #2 ; {#3} {#4} {#5}
      {#6} {#7}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]
%   {
%     \@@_div_significand_iv:wwnnnnnnn,
%     \@@_div_significand_v:NNw,
%     \@@_div_significand_vi:Nw
%   }
%   \begin{quote}
%     \cs{@@_div_significand_iv:wwnnnnnnn} \meta{P} |;|
%       \meta{E_1} |;| \Arg{E_2} \Arg{E_3} \Arg{E_4}
%       \Arg{Z_1} \Arg{Z_2} \Arg{Z_3} \Arg{Z_4} \meta{sign}
%   \end{quote}
%   This adds to the current expression ($10^{7} + 10\cdot Q_{D}$) a
%   contribution of $5 \cdot P + \operatorname{sign}(T)$ with $T = 2 E -
%   P Z$.  This amounts to adding $P / 2$ to $Q_{D}$, with an extra
%   \meta{rounding} digit.  This \meta{rounding} digit is $0$ or $5$ if
%   $T$ does not contribute, \emph{i.e.,} if $0 = T = 2 E - P Z$, in
%   other words if $10^{16} A / Z$ is an integer or half-integer.
%   Otherwise it is in the appropriate range, $[1,4]$ or $[6,9]$.  This
%   is precise enough for rounding purposes (in any mode).
%
%   It seems an overkill to compute $T$ exactly as I do here, but I see
%   no faster way right now.
%
%   Once more, we need to be careful and show that the calculation
%   $\#1\cdot\#6\#7$ below does not cause an overflow: naively, $P$ can
%   be up to $35$, and $\#6\#7$ up to $10^{8}$, but both cannot happen
%   simultaneously.  To show that things are fine, we split in two
%   (non-disjoint) cases.
%   \begin{itemize}
%   \item For $P < 10$, the product obeys $P\cdot\#6\#7 < 10^{8} \cdot P
%     < 10^{9} $.
%   \item For large $P\geq 3$, the rounding error on $P$, which is at
%     most $1$, is less than a factor of $2$, hence $P\leq 4E/Z$.  Also,
%     $\#6\#7 \leq 10^{8} \cdot Z$, hence $P\cdot \#6\#7 \leq 4E\cdot
%     10^{8} < 10^{9}$.
%   \end{itemize}
%   Both inequalities could be made tighter if needed.
%
%   Note however that $P\cdot \#8\#9$ may overflow, since the two
%   factors are now independent, and the result may reach $3.5\cdot
%   10^{9}$.  Thus we compute the two lower levels separately.  The rest
%   is standard, except that we use |+| as a separator (ending integer
%   expressions explicitly).  $T$ is negative if the first character is
%   |-|, it is positive if the first character is neither |0| nor |-|.
%   It is also positive if the first character is |0| and second
%   argument of \cs{@@_div_significand_vi:Nw}, a sum of several terms, is
%   also zero.  Otherwise, there was an exact agreement: $T = 0$.
%    \begin{macrocode}
\cs_new:Npn \@@_div_significand_iv:wwnnnnnnn #1; #2;#3#4#5 #6#7#8#9
  {
    + \c_five * #1
    \exp_after:wN \@@_div_significand_vi:Nw
    \int_use:N \__int_eval:w -20 + 2*#2#3 - #1*#6#7 +
      \exp_after:wN \@@_div_significand_v:NN
      \int_use:N \__int_eval:w 199980 + 2*#4 - #1*#8 +
        \exp_after:wN \@@_div_significand_v:NN
        \int_use:N \__int_eval:w 200000 + 2*#5 - #1*#9 ;
  }
\cs_new:Npn \@@_div_significand_v:NN #1#2 { #1#2 \__int_eval_end: + }
\cs_new:Npn \@@_div_significand_vi:Nw #1#2;
  {
    \if_meaning:w 0 #1
      \if_int_compare:w \__int_eval:w #2 > \c_zero + \c_one \fi:
    \else:
      \if_meaning:w - #1 - \else: + \fi: \c_one
    \fi:
    ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_div_significand_pack:NNN}
%   At this stage, we are in the following situation: \TeX{} is in the
%   process of expanding several integer expressions, thus functions at
%   the bottom expand before those above.
%   \begin{quote}
%     \cs{@@_div_significand_test_o:w} $10^{6} + Q_{A}$
%     \cs{@@_div_significand_pack:NNN} $10^{6} + Q_{B}$
%     \cs{@@_div_significand_pack:NNN} $10^{6} + Q_{C}$
%     \cs{@@_div_significand_pack:NNN}
%     $10^{7} + 10\cdot Q_{D} + 5 \cdot P + \varepsilon$ |;| \meta{sign}
%   \end{quote}
%   Here, $\varepsilon = \operatorname{sign}(T)$ is $0$ in case $2E=PZ$,
%   $1$ in case $2E>PZ$, which means that $P$ was the correct value, but
%   not with an exact quotient, and $-1$ if $2E<PZ$, \emph{i.e.}, $P$
%   was an overestimate.  The packing function we define now does
%   nothing special: it removes the $10^{6}$ and carries two digits (for
%   the $10^{5}$'s and the $10^{4}$'s).
%    \begin{macrocode}
\cs_new:Npn \@@_div_significand_pack:NNN 1 #1 #2 { + #1 #2 ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_div_significand_test_o:w}
%   \begin{quote}
%     \cs{@@_div_significand_test_o:w} |1| |0| \meta{5d} |;|
%     ~~\meta{4d} |;| \meta{4d} |;| \meta{5d} |;| \meta{sign}
%   \end{quote}
%   The reason we know that the first two digits are |1| and |0| is that
%   the final result is known to be between $0.1$ (inclusive) and $10$,
%   hence $\widetilde{Q_{A}}$ (the tilde denoting the contribution from
%   the other $Q_{i}$) is at most $99999$, and $10^{6}+\widetilde{Q_{A}}
%   = 10\cdots$.
%
%   It is now time to round. This depends on how many digits the final
%   result will have.
%    \begin{macrocode}
\cs_new:Npn \@@_div_significand_test_o:w 10 #1
  {
    \if_meaning:w 0 #1
      \exp_after:wN \@@_div_significand_small_o:wwwNNNNwN
    \else:
      \exp_after:wN \@@_div_significand_large_o:wwwNNNNwN
    \fi:
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_div_significand_small_o:wwwNNNNwN}
%   \begin{quote}
%     \cs{@@_div_significand_small_o:wwwNNNNwN} |0| \meta{4d} |;|
%     ~~\meta{4d} |;| \meta{4d} |;| \meta{5d} |;| \meta{final sign}
%   \end{quote}
%   Standard use of \cs{@@_basics_pack_low:NNNNNw} and
%   \cs{@@_basics_pack_high:NNNNNw}.  We finally get to use the
%   \meta{final sign} which has been sitting there for a while.
%    \begin{macrocode}
\cs_new:Npn \@@_div_significand_small_o:wwwNNNNwN
    0 #1; #2; #3; #4#5#6#7#8; #9
  {
    \exp_after:wN \@@_basics_pack_high:NNNNNw
    \int_use:N \__int_eval:w 1 #1#2
      \exp_after:wN \@@_basics_pack_low:NNNNNw
      \int_use:N \__int_eval:w 1 #3#4#5#6#7
        + \@@_round:NNN #9 #7 #8
        \exp_after:wN ;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_div_significand_large_o:wwwNNNNwN}
%   \begin{quote}
%     \cs{@@_div_significand_large_o:wwwNNNNwN} \meta{5d} |;|
%     ~~\meta{4d} |;| \meta{4d} |;| \meta{5d} |;| \meta{sign}
%   \end{quote}
%   We know that the final result cannot reach $10$, hence |1#1#2|,
%   together with contributions from the level below, cannot reach
%   $2\cdot 10^{9}$.  For rounding, we build the \meta{rounding digit}
%   from the last two of our $18$ digits.
%    \begin{macrocode}
\cs_new:Npn \@@_div_significand_large_o:wwwNNNNwN
    #1; #2; #3; #4#5#6#7#8; #9
  {
    + \c_one
    \exp_after:wN \@@_basics_pack_weird_high:NNNNNNNNw
    \int_use:N \__int_eval:w 1 #1 #2
      \exp_after:wN \@@_basics_pack_weird_low:NNNNw
      \int_use:N \__int_eval:w 1 #3 #4 #5 #6 +
        \exp_after:wN \@@_round:NNN
        \exp_after:wN #9
        \exp_after:wN #6
        \__int_value:w \@@_round_digit:Nw #7 #8 ;
      \exp_after:wN ;
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Unary operations}
%
% \begin{macro}[int, EXP]{\@@_-_o:w}
%   This function flips the sign of the \meta{floating point} and
%   expands after it in the input stream, just like \cs{@@_+_o:ww}
%   \emph{etc.}  We add a hook used by \pkg{l3fp-expo}: anything before
%   \cs{s_@@} is ignored.
%    \begin{macrocode}
\cs_new:cpn { @@_-_o:w } #1 \s_@@ \@@_chk:w #2 #3
  {
    \exp_after:wN \@@_exp_after_o:w
    \exp_after:wN \s_@@
    \exp_after:wN \@@_chk:w
    \exp_after:wN #2
    \int_use:N \__int_eval:w \c_two - #3 \__int_eval_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_abs_o:w}
%   This function sets the sign of the \meta{floating point} to be
%   positive, and expands after itself in the input stream, just like
%   \cs{@@_-_o:w}.  We must leave the sign of \texttt{nan} invariant.
%    \begin{macrocode}
\cs_new:Npn \@@_abs_o:w \s_@@ \@@_chk:w #1 #2
  {
    \exp_after:wN \@@_exp_after_o:w
    \exp_after:wN \s_@@
    \exp_after:wN \@@_chk:w
    \exp_after:wN #1
    \__int_value:w \if_meaning:w 1 #2 1 \else: 0 \fi: \exp_stop_f:
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex
