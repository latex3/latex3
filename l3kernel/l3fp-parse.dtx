% \iffalse meta-comment
%
%% File: l3fp-parse.dtx Copyright (C) 2011-2013 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3kernel bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver>
\RequirePackage{l3bootstrap}
\GetIdInfo$Id$
  {L3 Floating-point expression parsing}
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-parse} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Floating point expression parsing}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released \filedate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3fp-parse} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=fp>
%    \end{macrocode}
%
% \subsection{Work plan}
%
% The task at hand is non-trivial, and some previous failed attempts
% show that the code leads to unreadable logs, so we had better get it
% (almost) right the first time.  Let us thus first discuss the
% design precisely before writing any code.
%
% \subsubsection{Storing results}
%
% The main question in parsing expressions expandably is to decide where
% to put the intermediate results computed for various subexpressions.
%
% One option is to store the values at the start of the expression, and
% carry them together as the first argument of each macro.  However, we
% want to \texttt{f}-expand tokens one by one in the expression (as
% \cs{int_eval:n} does), and with this approach, expanding the next
% unread token forces us to jump with \cs{exp_after:wN} over every value
% computed earlier in the expression.  With this approach, the run-time
% will grow at least quadratically in the length of the expression, if
% not as its cube (inserting the \cs{exp_after:wN} is tricky and slow).
%
% A second option is to place those values at the end of the expression.
% Then expanding the next unread token is straightforward, but this
% still hits a performance issue: for long expressions we would be
% reaching all the way to the end of the expression at every step of the
% calculation.  The run-time is again quadratic.
%
% A variation of the above attempts to place the intermediate results
% which appear when computing a parenthesized expression near the
% closing parenthesis.  This still lets us expand tokens as we go, and
% avoids performance problems as long as there are enough parentheses.
% However, it would be much better to avoid requiring the closing
% parenthesis to be present as soon as the corresponding opening
% parenthesis is read: the closing parenthesis may still be hidden in a
% macro yet to be expanded.
%
% Hence, we need to go for some fine expansion control: the result is
% stored \emph{before} the start!
%
% Let us illustrate this idea in a simple model: adding positive
% integers which may be resulting from the expansion of macros, or may
% be values of registers.  Assume that one number, say, $12345$, has
% already been found, and that we want to parse the next number. The
% current status of the code may look as follows.
% \begin{quote}\ttfamily
%   \cs{exp_after:wN} \cs{add:ww}
%   \cs{__int_value:w} 12345 \cs{exp_after:wN} ; \newline
%   \cs{tex_romannumeral:D} |\operand:w| \meta{stuff}
% \end{quote}
% One step of expansion expands \cs{exp_after:wN}, which triggers the
% primitive \cs{__int_value:w}, which reads the five digits we have
% already found, |12345|.  This integer is unfinished, causing the
% second \cs{exp_after:wN} to expand, and to trigger the construction
% \cs{tex_romannumeral:D}, which expands |\operand:w|, defined to read
% what follows and make a number out of it, then leave \cs{c_zero}, the
% number, and a semicolon in the input stream.  Once |\operand:w| is
% done expanding, we obtain essentially
% \begin{quote}\ttfamily
%   \cs{exp_after:wN} \cs{add:ww} \cs{__int_value:w} 12345 ; \newline
%   \cs{tex_romannumeral:D} \cs{c_zero} 333444 ;
% \end{quote}
% where in fact \cs{exp_after:wN} has already been expanded,
% \cs{__int_value:w} has already seen |12345|, and
% \cs{tex_romannumeral:D} is still looking for a number.  It finds
% \cs{c_zero}, hence expands to nothing.  Now, \cs{__int_value:w} sees
% the \texttt{;}, which cannot be part of a number.  The expansion
% stops, and we are left with
% \begin{quote}\ttfamily
%   \cs{add:ww} 12345 ; 333444 ;
% \end{quote}
% which can safely perform the addition by grabbing two arguments
% delimited by~|;|.
%
% If we were to continue parsing the expression, then the following
% number should also be cleaned up before the next use of a binary
% operation such as \cs{add:ww}.  Just like \cs{__int_value:w} |12345|
% \cs{exp_after:wN}~|;| expanded what follows once, we need \cs{add:ww}
% to do the calculation, and in the process to expand the following
% once.  This is also true in our real application: all the functions of
% the form \cs{@@_..._o:ww} expand what follows once.  This comes at the
% cost of leaving tokens in the input stack, and we will need to be
% careful not to waste this memory.  All of our discussion above is nice
% but simplistic, as operations should not simply be performed in the
% order they appear.
%
% \subsubsection{Precedence of infix operators}
%
% The various operators we will encounter have different precedences,
% which influence the order of calculations: $1+2\times 3 = 1+(2\times
% 3)$ because $\times$~has a higher precedence than~$+$.  The true
% analog of our macro |\operand:w| must thus take care of that.  When
% looking for an operand, it needs to perform calculations until
% reaching an operator which has lower precedence than the one which
% called |\operand:w|.  This means that |\operand:w| must know what the
% previous binary operator is, or rather, its precedence: we thus rename
% it |\operand:Nw|.  Let us describe as an example how the calculation
% |41-2^3*4+5| will be done.  Here, we abuse notations: the first
% argument of |\operand:Nw| should be an integer constant (\cs{c_three},
% \cs{c_nine}, \ldots{}) equal to the precedence of the given operator,
% not directly the operator itself.
% \begin{itemize}
%   \item Clean up~|41| and find~|-|.  We call |\operand:Nw|~|-| to find
%     the second operand.
%   \item Clean up~|2| and find~|^|.
%   \item Compare the precedences of |-| and~|^|.  Since the latter is
%     higher, we need to compute the exponentiation.  For this, find the
%     second operand with a nested call to |\operand:Nw|~|^|.
%   \item Clean up~|3| and find~|*|.
%   \item Compare the precedences of |^| and~|*|.  Since the former is
%     higher, |\operand:Nw|~|^| has found the second operand of the
%     exponentiation, which is computed: $2^{3} = 8$.
%   \item We now have |41+8*4+5|, and |\operand:Nw|~|-| is still
%     looking for a second operand for the subtraction.  Is it~$8$?
%   \item Compare the precedences of |-| and~|*|.  Since the latter is
%     higher, we are not done with~$8$.  Call |\operand:Nw|~|*| to find
%     the second operand of the multiplication.
%   \item Clean up~|4|, and find~|-|.
%   \item Compare the precedences of |*| and~|-|.  Since the former is
%     higher, |\operand:Nw|~|*| has found the second operand of the
%     multiplication, which is computed: $8*4 = 32$.
%   \item We now have |41+32+5|, and |\operand:Nw|~|-| is still looking
%     for a second operand for the subtraction.  Is it~$32$?
%   \item Compare the precedences of |-| and~|+|.  Since they are equal,
%     |\operand:Nw|~|-| has found the second operand for the
%     subtraction, which is computed: $41-32=9$.
%   \item We now have |9+5|.
% \end{itemize}
% The procedure above stops short of performing all computations, but
% adding a surrounding call to |\operand:Nw| with a very low precedence
% ensures that all computations will be performed before |\operand:Nw|
% is done.  Adding a trailing marker with the same very low precedence
% prevents the surrounding |\operand:Nw| from going beyond the marker.
%
% The pattern above to find an operand for a given operator, is to find
% one number and the next operator, then compare precedences to know if
% the next computation should be done.  If it should, then perform it
% after finding its second operand, and look at the next operator, then
% compare precedences to know if the next computation should be done.
% This continues until we find that the next computation should not be
% done.  Then, we stop.
%
% We are now ready to get a bit more technical and describe which of the
% \pkg{l3fp-parse} functions correspond to each step above.
%
% First, \cs{@@_parse_operand:Nw} is the |\operand:Nw| function above,
% with small modifications due to expansion issues discussed later.  We
% denote by \meta{precedence} the argument of \cs{@@_parse_operand:Nw},
% that is, the precedence of the binary operator whose operand we are
% trying to find.  The basic action is to read numbers from the input
% stream.  This is done by \cs{@@_parse_one:Nw}.  A first approximation
% of this function is that it reads one \meta{number}, performing no
% computation, and finds the following binary \meta{operator}.  Then it
% expands to
% \begin{quote}
%   \meta{number} \newline
%   ~~|\__fp_parse_infix_|\meta{operator}|:N| \meta{precedence}
% \end{quote}
% expanding the \texttt{infix} auxiliary before leaving the above in the
% input stream.
%
% We now explain the \texttt{infix} auxiliaries.  We need some
% flexibility in how we treat the case of equal precedences: most often,
% the first operation encountered should be performed, such as |1-2-3|
% being computed as |(1-2)-3|, but |2^3^4| should be evaluated as
% |2^(3^4)| instead.  For this reason, and to support the equivalence
% between |**| and~|^| more easily, each binary operator is converted to
% a control sequence |\__fp_parse_infix_|\meta{operator}|:N| when it is
% encountered for the first time.  Instead of passing both precedences
% to a test function to do the comparison steps above, we pass the
% \meta{precedence} (of the earlier operator) to the \texttt{infix}
% auxiliary for the following \meta{operator}, to know whether to
% perform the computation of the \meta{operator}.  If it should not be
% performed, the \texttt{infix} auxiliary expands to
% \begin{quote}
%   |@| \cs{use_none:n} |\__fp_parse_infix_|\meta{operator}|:N|
% \end{quote}
% and otherwise it calls \cs{@@_parse_operand:Nw} with the precedence of
% the \meta{operator} to find its second operand \meta{number_2} and the
% next \meta{operator_2}, and expands to
% \begin{quote}
%   |@| \cs{@@_parse_apply_binary:NwNwN} \newline
%   ~~~~\meta{operator} \meta{number_2} \newline
%   |@| |\__fp_parse_infix_|\meta{operator_2}|:N|
% \end{quote}
% The \texttt{infix} function is responsible for comparing precedences,
% but cannot directly call the computation functions, because the first
% operand \meta{number} is before the \texttt{infix} function in the
% input stream.  This is why we stop the expansion here and give control
% to another function to close the loop.
%
% A definition of \cs{@@_parse_operand:Nw} \meta{precedence} with some
% of the expansion control removed is
% \begin{quote}
%   \cs{exp_after:wN} \cs{@@_parse_continue:NwN} \newline
%   \cs{exp_after:wN} \meta{precedence} \newline
%   \cs{tex_romannumeral:D} |-`0| \newline
%   ~~\cs{@@_parse_one:Nw} \meta{precedence}
% \end{quote}
% This expands \cs{@@_parse_one:Nw} \meta{precedence} completely, which
% finds a number, wraps the next \meta{operator} into an \texttt{infix}
% function, feeds this function the \meta{precedence}, and expands it,
% yielding either
% \begin{quote}
%   \cs{@@_parse_continue:NwN} \meta{precedence} \newline
%   \meta{number} |@| \newline
%   \cs{use_none:n} |\__fp_parse_infix_|\meta{operator}|:N|
% \end{quote}
% or
% \begin{quote}
%   \cs{@@_parse_continue:NwN} \meta{precedence} \newline
%   \meta{number} |@| \newline
%   \cs{@@_parse_apply_binary:NwNwN} \newline
%   ~~\meta{operator} \meta{number_2} \newline
%   |@| |\__fp_parse_infix_|\meta{operator_2}|:N|
% \end{quote}
% The definition of \cs{@@_parse_continue:NwN} is then very simple:
% \begin{verbatim}
%   \cs_new:Npn \__fp_parse_continue:NwN #1#2@#3 { #3 #1 #2 @ }
% \end{verbatim}
% In the first case, |#3|~is \cs{use_none:n}, yielding
% \begin{quote}
%   \cs{use_none:n} \meta{precedence} \meta{number} |@| \newline
%   |\__fp_parse_infix_|\meta{operator}|:N|
% \end{quote}
% then \meta{number} |@| |\__fp_parse_infix_|\meta{operator}|:N|.  In
% the second case, |#3|~is \cs{@@_parse_apply_binary:NwNwN}, whose role
% is to compute \meta{number} \meta{operator} \meta{number_2} and to
% prepare for the next comparison of precedences: first we get
% \begin{quote}
%   \cs{@@_parse_apply_binary:NwNwN} \newline
%   ~~\meta{precedence} \meta{number} |@| \newline
%   ~~\meta{operator} \meta{number_2} \newline
%   |@| |\__fp_parse_infix_|\meta{operator_2}|:N|
% \end{quote}
% then
% \begin{quote}
%   \cs{exp_after:wN} \cs{@@_parse_continue:NwN} \newline
%   \cs{exp_after:wN} \meta{precedence} \newline
%   \cs{tex_romannumeral:D} |-`0| \newline
%   |\__fp_|\meta{operator}|_o:ww| \meta{number} \meta{number_2} \newline
%   \cs{tex_romannumeral:D} |-`0| \newline
%   |\__fp_parse_infix_|\meta{operator_2}|:N| \meta{precedence}
% \end{quote}
% where |\__fp_|\meta{operator}|_o:ww| computes \meta{number}
% \meta{operator} \meta{number_2} and expands after the result, thus
% triggers the comparison of the precedence of the \meta{operator_2} and
% the \meta{precedence}, continuing the loop.
%
% We have introduced the most important functions here, and the next few
% paragraphs will describe various subtleties.
%
% \subsubsection{Prefix operators, parentheses, and functions}
%
% Prefix operators (unary |-|, |+|,~|!|) and parentheses are taken care
% of by the same mechanism, and functions (\texttt{sin}, \texttt{exp},
% etc.) as well.  Finding the argument of the unary~|-|, for instance,
% is very similar to grabbing the second operand of a binary infix
% operator, with a subtle precedence explained below.  Once that operand
% is found, the operator can be applied to it (for the unary~|-|, this
% simply flips the sign).  A left parenthesis is just a prefix operator
% with a very low precedence equal to that of the closing parenthesis
% (which is treated as an infix operator, since it normally appears just
% after numbers), so that all computations are performed until the
% closing parenthesis.  The prefix operator associated to the left
% parenthesis does not alter its argument, but it removes the closing
% parenthesis (with some checks).
%
% Prefix operators are the reason why we only summarily described the
% function \cs{@@_parse_one:Nw} earlier.  This function is responsible
% for reading in the input stream the first possible \meta{number} and
% the next infix \meta{operator}.  If what follows \cs{@@_parse_one:Nw}
% \meta{precedence} is a prefix operator, then we must find the operand
% of this prefix operator through a nested call to
% \cs{@@_parse_operand:Nw} with the appropriate precedence, then apply
% the operator to the operand found to yield the result of
% \cs{@@_parse_one:Nw}.  So far, all is simple.
%
% The unary operators |+|, |-|,~|!| complicate things a little bit:
% |-3**2| should be $-(3^2)=-9$, and not $(-3)^2=9$.  This would easily
% be done by giving~|-| a lower precedence, equal to that of the infix
% |+| and~|-|.  Unfortunately, this fails in cases such as |3**-2*4|,
% yielding $3^{-2\times 4}$ instead of the correct $3^{-2}\times 4$.  A
% second attempt would be to call \cs{@@_parse_operand:Nw} with the
% \meta{precedence} of the previous operator, but |0>-2+3| is then
% parsed as |0>-(2+3)|: the addition is performed because it binds more
% tightly than the comparision which precedes~|-|.  The correct approach
% is for a unary~|-| to perform operations whose precedence is greater
% than both that of the previous operation, and that of the unary~|-|
% itself.  The unary~|-| is given a precedence higher than
% multiplication and division.  This does not lead to any surprising
% result, since $-(x/y) = (-x)/y$ and similarly for multiplication, and
% it reduces the number of nested calls to \cs{@@_parse_operand:Nw}.
%
% Functions are implemented as prefix operators with very high
% precedence, so that their argument is the first number that can
% possibly be built, except for juxtaposition.
%
% Note that contrarily to the \texttt{infix} functions discussed
% earlier, the \texttt{prefix} functions do perform tests on the
% previous \meta{precedence} to decide whether to find an argument or
% not, since we know that we need a number, and must never stop there.
%
% ^^A begin[todo]
%
% ^^A todo: discuss how commas are done
%
% \subsubsection{Type detection}
%
% The type of data should be detected by reading the first few tokens,
% before calling a type-specific function to parse it.  Or
% should the type be obtained after the semicolon which indicates the
% end of the thing? And placed there?
%
% \subsection{Description of main functions}
%
% Here is a list of precedences in order of evaluation (some
% distinctions are irrelevant for the order of evaluation, but serve as
% signals).
% \begin{itemize}
% \item[32] Juxtaposition for implicit multiplication.
% \item[16] Function calls with multiple arguments.
% \item[15] Function calls expecting exactly one argument.
% \item[14] Binary |**| and |^| (right to left).
% \item[12] Unary |+|, |-|, |!| (right to left).
% \item[10] Binary |*|, |/| and |%|.
% \item[9] Binary |+| and |-|.
% \item[7] Comparisons.
% \item[5] Logical \texttt{and}, denoted by |&&|.
% \item[4] Logical \texttt{or}, denoted by \verb*+||+.
% \item[3] Ternary operator |?:|, piece |?|.
% \item[2] Ternary operator |?:|, piece |:|.
% \item[1] Commas, and parentheses accepting commas.
% \item[0] Parentheses expecting exactly one argument.
% \item[-1] Start and end of the expression.
% \end{itemize}
%
% \begin{macro}[EXP, int]{\@@_parse:n}
%   \begin{syntax}
%     \cs{@@_parse:n} \Arg{fpexpr}
%   \end{syntax}
%   Evaluates the \meta{floating point expression} and leaves the result
%   in the input stream as an internal floating point number.  This
%   function forms the basis of almost all public \pkg{l3fp} functions.
%   During evaluation, each token is fully \texttt{f}-expanded.
%   \begin{texnote}
%     Registers (integers, toks, etc.) are automatically unpacked,
%     without requiring a function such as \cs{int_use:N}.  Invalid
%     tokens remaining after \texttt{f}-expansion will lead to
%     unrecoverable low-level \TeX{} errors.\footnote{Bruno: describe that $2\cs{c_three} = 6$.}
%   \end{texnote}
% \end{macro}
%
% \begin{macro}[rEXP, aux]{\@@_parse_operand:Nw}
%   \begin{syntax}
%     \cs{tex_romannumeral:D} \cs{@@_parse_operand:Nw} \meta{precedence} \cs{@@_parse_expand:w} \ldots{}
%   \end{syntax}
%   Reads the \enquote{\ttfamily\ldots{}}, performing every computation
%   with a precedence higher than \meta{precedence}, then expands to
%   \begin{syntax}
%     \meta{result} |@| |\__fp_parse_infix_|\meta{operation}|:N| \ldots{}
%   \end{syntax}
%   where the \meta{operation} is the first operation with a lower
%   precedence, possibly \texttt{end}, and the
%   \enquote{\ttfamily\ldots{}} start just after the \meta{operation}.
% \end{macro}
%
% \begin{macro}[EXP, aux]{\@@_parse_infix_+:N}
%   \begin{syntax}
%     \cs{@@_parse_infix_+:N} \meta{precedence} \ldots{}
%   \end{syntax}
%   If |+|~has a precedence higher than the \meta{precedence}, cleans up
%   a second \meta{operand} and finds the \meta{operation_2} which
%   follows, and expands to
%   \begin{syntax}
%     |@| \cs{@@_parse_apply_binary:NwNwN} |+| \meta{operand} |@| \cs{@@_parse_infix_\meta{operation_2}:N} \ldots{}
%   \end{syntax}
%   Otherwise expands to
%   \begin{syntax}
%     |@| \cs{use_none:n} \cs{@@_parse_infix_+:N} \ldots{}
%   \end{syntax}
%   A similar function exists for each infix operator.
% \end{macro}
%
% \begin{macro}[EXP, aux]{\@@_parse_one:Nw}
%   \begin{syntax}
%     \cs{@@_parse_one:Nw} \meta{precedence} \ldots{}
%   \end{syntax}
%   Cleans up one or two operands depending on how the precedence of the
%   next operation compares to the \meta{precedence}.  If the following
%   \meta{operation} has a precedence higher than \meta{precedence},
%   expands to
%   \begin{syntax}
%     \meta{operand_1} |@| \cs{@@_parse_apply_binary:NwNwN} \meta{operation} \meta{operand_2} |@| |\__fp_parse_infix_|\meta{operation_2}|:N| \ldots{}
%   \end{syntax}
%   and otherwise expands to
%   \begin{syntax}
%     \meta{operand} |@| \cs{use_none:n} |\__fp_parse_infix_|\meta{operation}|:N| \ldots{}
%   \end{syntax}
% \end{macro}
%
% ^^A end[todo]
%
% \subsubsection{Expansion control}
%
% At each step in reading a floating point expression, we wish to
% perform \texttt{f}-expansion.  Normally, spaces stop this
% \texttt{f}-expansion.  This can be problematic: for instance, the
% macro |\X| below will not be expanded if we simply do
% \texttt{f}-expansion.
% \begin{verbatim}
%   \DeclareDocumentCommand {\test} {m} { \fp_eval:n {#1} }
%   \ExplSyntaxOff
%   \test { 1 + \X }
% \end{verbatim}
% To avoid this problem, at every step, we do essentially what
% \cs{use:f} would do: take an argument, put it back in the input
% stream, then \texttt{f}-expand it.  This is not a complete solution,
% since a macro's expansion could contain leading spaces which will stop
% the \texttt{f}-expansion before further macro calls are performed.
% However, in practice it should be enough: in particular, floating
% point numbers will correctly be expanded to the underlying \cs{s_@@}
% \ldots{} structure.
%
%^^A begin[todo]
% Floating point expressions should behave as much as possible like
% \eTeX{}-based integer expressions and dimension expressions.  In
% particular, full-expansion should be performed as the expression is
% read, token by token, forcing the expansion of protected macros, and
% ignoring spaces.
%
% Full expansion can be done with \cs{tex_romannumeral:D} |-`0|.
% Unfortunately, this expansion is stopped by spaces.  Thus using simply
% this will fail on |\fp_eval:n { 1 + ~ \l_tmpa_fp }| since the floating
% point variable will not be expanded.  Of course, spaces will not
% appear in a code setting, but may very easily come in document-level
% input, from which some expressions may come.  We can avoid being
% stopped by such explicit space characters (and by some braces) if we
% add \cs{use:n} after~|-`0|.
%
% Testing if a character token |#1| is a digit can be done using
% \begin{verbatim}
% \if_int_compare:w \c_nine < 1 \token_to_str:N #1 \exp_stop_f:
%   true code
% \else:
%   false code
% \fi:
% \end{verbatim}
% To exclude |0|, replace \cs{c_nine} by \cs{c_ten}. The use of
% \cs{token_to_str:N} ensures that a digit with any catcode is detected.
%
%^^A end[todo]
%
% \begin{macro}[aux, rEXP]{\@@_parse_expand:w}
%   \begin{syntax}
%     \cs{tex_romannumeral:D} \cs{@@_parse_expand:w} \meta{tokens}
%   \end{syntax}
%   This function must always come within a \tn{romannumeral} expansion.
%   The \meta{tokens} should be the part of the expression that we have
%   not yet read.  This requires in particular closing all conditionals
%   properly before expanding.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_expand:w #1 { -`0 #1 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_return_semicolon:w}
%   This very odd function swaps its position with the following
%   \cs{fi:} and removes \cs{@@_parse_expand:w} normally responsible for
%   expansion.  That turns out to be useful.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_return_semicolon:w
    #1 \fi: \@@_parse_expand:w { \fi: ; #1 }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Fp object type}
%
% \begin{macro}[aux, EXP]{\@@_type_from_scan:N, \@@_type_from_scan:w}
%   \begin{syntax}
%     \cs{@@_type_from_scan:N} \meta{token}
%   \end{syntax}
%   Grabs the pieces of the stringified \meta{token} which lies after
%   the first |s__fp|.  If the \meta{token} does not contain that
%   string, the result is |_?|.
%    \begin{macrocode}
\group_begin:
\char_set_catcode_other:N \S
\char_set_catcode_other:N \F
\char_set_catcode_other:N \P
\char_set_lccode:nn { `\- } { `\_ }
\tl_to_lowercase:n
  {
    \group_end:
    \cs_new:Npn \@@_type_from_scan:N #1
      {
        \exp_after:wN \@@_type_from_scan:w
        \token_to_str:N #1 \q_mark S--FP-? \q_mark \q_stop
      }
    \cs_new:Npn \@@_type_from_scan:w #1 S--FP #2 \q_mark #3 \q_stop {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Reading digits}
%
% \begin{macro}[rEXP, aux]
%   {
%     \@@_parse_digits_vii:N  ,
%     \@@_parse_digits_vi:N   ,
%     \@@_parse_digits_v:N    ,
%     \@@_parse_digits_iv:N   ,
%     \@@_parse_digits_iii:N  ,
%     \@@_parse_digits_ii:N   ,
%     \@@_parse_digits_i:N
%   }
%   These functions must be called within an \cs{__int_value:w} or
%   \cs{__int_eval:w} construction.  The first token which follows must be
%   \texttt{f}-expanded prior to calling those functions.  The functions
%   read tokens one by one, and output digits into the input stream,
%   until meeting a non-digit, or up to a number of digits equal to
%   their index.  The full expansion is
%   \begin{quote}
%     \meta{digits} |;| \meta{filling 0} |;| \meta{length}
%   \end{quote}
%   where \meta{filling 0} is a string of zeros such that \meta{digits}
%   \meta{filling 0} has the length given by the index of the function,
%   and \meta{length} is the number of zeros in the \meta{filling 0}
%   string.  Each function puts a digit into the input stream and calls
%   the next function, until we find a non-digit.  We are careful to
%   pass the tested tokens through \cs{token_to_str:N} to normalize
%   their category code.
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1 #2 #3
  {
    \cs_new:cpn { @@_parse_digits_ #1 :N } ##1
      {
        \if_int_compare:w \c_nine < 1 \token_to_str:N ##1 \exp_stop_f:
          \token_to_str:N ##1 \exp_after:wN #2 \tex_romannumeral:D
        \else:
          \@@_parse_return_semicolon:w #3 ##1
        \fi:
        \@@_parse_expand:w
      }
  }
\@@_tmp:w {vii}  \@@_parse_digits_vi:N   { 0000000 ; 7 }
\@@_tmp:w {vi}   \@@_parse_digits_v:N    { 000000 ; 6 }
\@@_tmp:w {v}    \@@_parse_digits_iv:N   { 00000 ; 5 }
\@@_tmp:w {iv}   \@@_parse_digits_iii:N  { 0000 ; 4 }
\@@_tmp:w {iii}  \@@_parse_digits_ii:N   { 000 ; 3 }
\@@_tmp:w {ii}   \@@_parse_digits_i:N    { 00 ; 2 }
\@@_tmp:w {i}    \@@_parse_digits_:N     { 0 ; 1 }
\cs_new_nopar:Npn \@@_parse_digits_:N { ; ; 0 }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Parsing one operand}
%
% At the start of an expression, or just following a binary operation or
% a function call, we are looking for an operand.  This can be an
% explicit floating point number, a floating point variable, a \TeX{}
% register, a function call such as \texttt{sin(3)}, a parenthesized
% expression, \emph{etc.}  We distinguish the various cases by their
% first token after \texttt{f}-expansion:
% \begin{itemize}
% \item \cs{tex_relax:D} in some form.  That can be an internal
%   floating point, a premature end, or an uninitialized register.
% \item A register.  We interpret this as the significand of a floating
%   point number.  This is subtly different from unpacking it, for
%   instance, \texttt{\cs{c_minus_one}**2} gives $1$, while
%   \texttt{-1**2} gives $-1$.
% \item A digit, or a dot.  That marks the start of the significand for
%   a floating point number.
% \item A letter (lower or upper-case), which starts an identifier,
%   either a constant or a function (possibly unknown).
% \item |+|, |-|, or |!|, unary operators, which resume looking for a
%   floating point number before acting on it.
% \item |(|, which makes us parse a subexpression until the
%   matching~|)|.
% \item Other characters such as |'| or |"| may be given a meaning
%   later.  Characters such as |*| or |/| have a meaning as infix
%   operators but are not valid when we are looking for an operand: for
%   instance, |3+*4| is not valid.
% \end{itemize}
% A category code test separates the first two cases from the others,
% and they are further distinguished with a meaning test.  We then
% single out digits.  Letters are detected using their character code.
% All other characters are taken care of by building a csname from that
% character and using it to continue parsing.  Unknown characters lead
% to an error.
%
% ^^A todo: this is now mostly robust against \noexpand\expandable,
% ^^A but many other places not.
% ^^A todo: \noexpand\if... or \noexpand\fi kills the parser.
% \begin{macro}[int, EXP]{\@@_parse_one:Nw}
%   Function called \cs{one} at other places. It grabs one operand, and
%   packs the symbol that follows in an \cs{infix_} csname.  |#1| is the
%   previous \meta{precedence}, and |#2|~the first token of the operand.
%   Since |#2|~has already been \texttt{f}-expanded, it should not be
%   expandable, but it may be expandable if we started with
%   \cs{exp_not:N} \meta{token}, as happens when a \LaTeXe{} command
%   using \tn{protect} appears within expressions.  Hence, we include
%   \cs{exp_not:N} when testing if |#2|~is a control sequence.
%   Expandable and non-expandable control sequences other than those
%   equal to \cs{scan_stop:} are taken care of by the \texttt{register}
%   auxiliary.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_one:Nw #1 #2
  {
    \if_catcode:w \tex_relax:D \exp_not:N #2
      \if_meaning:w \tex_relax:D #2
        \exp_after:wN \exp_after:wN
        \exp_after:wN \@@_parse_one_relax:NN
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \@@_parse_one_register:NN
      \fi:
    \else:
      \if_int_compare:w \c_nine < 1 \token_to_str:N #2 \exp_stop_f:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \@@_parse_one_digit:NN
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \@@_parse_one_other:NN
      \fi:
    \fi:
    #1 #2
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: rounding of negative dimensions is probably wrong.
% \begin{macro}[aux, EXP]
%   {\@@_parse_one_register:NN, \@@_parse_one_register_aux:www}
%   Find the exponent following the register |#2|, then combine the
%   value of |#2| (mapping |1pt| to $1$) with the exponent to produce a
%   floating point number.  If |#2| is a register, the right thing
%   happens, and otherwise, a relatively benign \TeX{} error occurs,
%   leaving~|0| in place of the token.  It would be best to replace by
%   \texttt{nan}, but this cannot be done.
%    \begin{macrocode}
\group_begin:
\char_set_catcode_other:N \P
\char_set_catcode_other:N \T
\tl_to_lowercase:n
  {
    \group_end:
    \cs_new:Npn \@@_parse_one_register:NN #1#2
      {
        \exp_after:wN \@@_parse_infix_after_operand:NwN
        \exp_after:wN #1
        \tex_romannumeral:D -`0
          \exp_after:wN \@@_parse_one_register_aux:www
          \tex_the:D
            \exp_after:wN \exp_not:N
            \exp_after:wN #2
            \exp_after:wN P
            \exp_after:wN T
            \exp_after:wN !
            \__int_value:w
              \exp_after:wN \@@_parse_exponent:N
              \tex_romannumeral:D \@@_parse_expand:w
      }
    \cs_new:Npn \@@_parse_one_register_aux:www #1 PT #2! #3;
      { \@@_parse:n { #1 e #3 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {
%     \@@_parse_one_relax:NN,
%     \@@_parse_exp_after_f:nw,
%     \@@_parse_exp_after_mark_f:nw,
%     \@@_parse_exp_after_?_f:nw
%   }
%   The second argument is a control sequence equal to \cs{tex_relax:D}.
%   There are three cases, dispatched using \cs{@@_type_from_scan:N}.
%   \begin{itemize}
%     \item \cs{s_@@} starts a floating point number, and we call
%       \cs{@@_parse_exp_after_f:nw}, which |f|-expands after the
%       floating point.
%     \item \cs{s_@@_mark} is a premature end, we call
%       \cs{@@_parse_exp_after_mark_f:nw}, which triggers the
%       appropriate error.
%     \item For a control sequence not containing |\s__fp|, we call
%       \cs{@@_parse_exp_after_?_f:nw}, causing a |bad-variable| error.
%   \end{itemize}
%   This scheme is extensible: additional types can be added by starting
%   the variables with a scan mark of the form |\s__fp_|\meta{type} and
%   defining |\__fp_parse_exp_after_|\meta{type}|_f:nw|.  In all cases, we
%   make sure that the last argument of \cs{@@_parse_infix:NN} is
%   correctly expanded.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_one_relax:NN #1#2
  {
    \cs:w @@_parse_exp_after \@@_type_from_scan:N #2 _f:nw \cs_end:
      {
        \exp_after:wN \@@_parse_infix:NN
        \exp_after:wN #1 \tex_romannumeral:D \@@_parse_expand:w
      }
    #2
  }
\cs_new_eq:NN \@@_parse_exp_after_f:nw \@@_exp_after_f:nw
\cs_new:Npn \@@_parse_exp_after_mark_f:nw #1
  {
    \__msg_kernel_expandable_error:nn { kernel } { fp-early-end }
    \exp_after:wN \c_nan_fp
    \tex_romannumeral:D -`0 #1
  }
\cs_new:cpn { @@_parse_exp_after_?_f:nw } #1#2
  {
    \__msg_kernel_expandable_error:nnn
      { kernel } { bad-variable } {#2}
    \exp_after:wN \c_nan_fp
    \tex_romannumeral:D -`0 #1
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A begin[todo]
%
% \begin{macro}[aux, EXP]{\@@_parse_one_other:NN}
%   The interesting bit is \cs{@@_parse_one_other:NN}. It separates
%   letters from non-letters and builds the appropriate \cs{prefix}
%   function. If it is not defined (is \cs{tex_relax:D}), make it
%   a signalling \texttt{nan}. We don't look for an argument, as the
%   unknown \enquote{prefix} can also be a (mistyped) constant such
%   as \texttt{Inf}.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_one_other:NN #1 #2
  {
    \if_int_compare:w
        \__int_eval:w \tex_uccode:D `#2 / 26 = \c_three
      \exp_after:wN \@@_parse_one_other_word_aux:Nw
      \exp_after:wN #1
      \tex_romannumeral:D
        \exp_after:wN \@@_parse_letters:NN
        \exp_after:wN #2
        \tex_romannumeral:D
    \else:
      \exp_after:wN \@@_parse_one_other_prefix_aux:NNN
      \exp_after:wN #1
      \exp_after:wN #2
      \cs:w @@_parse_prefix_#2:Nw \exp_after:wN \cs_end:
      \tex_romannumeral:D
    \fi:
    \@@_parse_expand:w
  }

\cs_new:Npn \@@_parse_letters:NN #1#2
  {
    \exp_after:wN \c_zero
    \exp_after:wN #1
    \tex_romannumeral:D
      \if_int_compare:w
          \if_catcode:w \tex_relax:D #2
            \c_zero
          \else:
            \__int_eval:w \tex_uccode:D `#2 / 26
          \fi:
          = \c_three
        \exp_after:wN \@@_parse_letters:NN
        \exp_after:wN #2
        \tex_romannumeral:D
        \exp_after:wN \@@_parse_expand:w
      \else:
        \exp_after:wN \c_zero
        \exp_after:wN ;
        \exp_after:wN #2
      \fi:
  }
\cs_new:Npn \@@_parse_one_other_word_aux:Nw #1 #2;
  {
    \cs_if_exist_use:cF { @@_parse_word_#2:N }
      {
        \__msg_kernel_expandable_error:nnn
          { kernel } { unknown-fp-word } {#2}
        \exp_after:wN \c_nan_fp
        \tex_romannumeral:D -`0
          \@@_parse_infix:NN
      }
      #1
  }
\cs_new_eq:NN \s_@@_unknown \tex_relax:D
\cs_new:Npn \@@_parse_one_other_prefix_aux:NNN #1#2#3
  {
    \if_meaning:w \tex_relax:D #3
      \exp_after:wN \@@_parse_one_other_prefix_unknown:NNN
      \exp_after:wN #2
    \fi:
    #3 #1
  }
\cs_new:Npn \@@_parse_one_other_prefix_unknown:NNN #1#2#3
  {
    \cs_if_exist:cTF { @@_parse_infix_#1:N }
      {
        \__msg_kernel_expandable_error:nnn
          { kernel } { fp-missing-number } {#1}
        \exp_after:wN \c_nan_fp
        \tex_romannumeral:D -`0
          \@@_parse_infix:NN #3 #1
      }
      {
        \__msg_kernel_expandable_error:nnn
          { kernel } { fp-unknown-symbol } {#1}
        \@@_parse_one:Nw #3
      }
  }
%    \end{macrocode}
% \end{macro}
%
% The following forms are accepted:
% \begin{itemize}
% \item
% \item \meta{floating point}
% \item \meta{integer} |.| \meta{decimal} |e| \meta{exponent}
% \end{itemize}
% In both cases, \meta{signs} is a (possibly empty) string of
% |+| and |-| (with any category code\footnote{Bruno: except
%   1, 2, 4, 10, 13, and those which cannot be tokens (0, 5, 9),
%   so really, just 3, 6, 7, 8, 11, 12.}).\footnote{Bruno:
%   test (and implement) non-other digits.}
%
% In the second form, the \meta{integer} is a sequence of digits,
% whose length is not limited by constraints \TeX{}'s integer
% registers. It stops at the first non-digit character. The
% \meta{decimal} part is formed by all digits from the dot
% (if it exists) until the first non-digit character. The
% \meta{exponent} part has the form \meta{exponent sign}
% \meta{exponent body}, where \meta{exponent sign} is any string
% of |+| or |-|, and \meta{exponent body} is a string of digits,
% stopping, as usual, at the first non-digit.
%
% Any missing part will take the appropriate default value.
% \begin{itemize}
% \item A missing \meta{exponent} is considered to be zero.
% \item A number with no dot has zero decimal part.
% \item An empty \meta{integer} part or decimal part is zero.
% \end{itemize}
%
% Border cases:
% \begin{itemize}
% \item \texttt{e1} is considered as invalid input, and gives
%   \texttt{qnan}.\footnote{Bruno: now just gives an error.}
%   This will be important once parsing expressions is
%   implemented, since \texttt{e-1} would be ambiguous otherwise.
% \item \texttt{.e3} and \texttt{.} are zero.
% \end{itemize}
%
% Bruno: expansion, not yet. Only \texttt{f}-expansion at the start, and
% unpacking of registers after signs.
%
%
% Work-plan.  The sign is already taken care of by expression parsing.
% \begin{itemize}
% \item Drop leading zeros.
% \item If the next character is a dot, drop some more zeros,
%   keeping track of how many were dropped after the dot.
%   Counting those gives $\meta{exp_1}<0$. Then read the decimal part
%   with the functions whose name contains~|small|.
% \item Otherwise, $\meta{exp_1}=0$, and first read the integer part,
%   then the decimal part. This is implemented through the more
%   elaborate |large| functions.
% \item Continuing in the same line of expansion, read the exponent
%   \meta{exp_2}.  Combine everything.
% \end{itemize}
%
% \begin{macro}[aux, EXP]{\@@_parse_one_digit:NN}
%    \begin{macrocode}
\cs_new:Npn \@@_parse_one_digit:NN #1
  {
    \exp_after:wN \@@_parse_infix_after_operand:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0
      \exp_after:wN \@@_sanitize:wN
      \int_use:N \__int_eval:w \c_zero \@@_parse_trim_zeros:N
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A end[todo]
%
% \paragraph{Trimming leading zeros}
%
% \begin{macro}[aux, rEXP]{\@@_parse_trim_zeros:N, \@@_parse_trim_end:w}
%   This function expects an already expanded token.  It removes any
%   leading zero, then distinguishes three cases: if the first non-zero
%   token is a digit, then call \cs{@@_parse_large:N} (the significand
%   is $\geq 1$); if it is |.|, then continue trimming zeros with
%   \cs{@@_parse_strim_zeros:N}; otherwise, our number is exactly zero,
%   and we call \cs{@@_parse_zero:} to take care of that case.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_trim_zeros:N #1
  {
    \if:w 0 #1
      \exp_after:wN \@@_parse_trim_zeros:N
      \tex_romannumeral:D
    \else:
      \if:w . #1
        \exp_after:wN \@@_parse_strim_zeros:N
        \tex_romannumeral:D
      \else:
        \@@_parse_trim_end:w #1
      \fi:
    \fi:
    \@@_parse_expand:w
  }
\cs_new:Npn \@@_parse_trim_end:w #1 \fi: \fi: \@@_parse_expand:w
  {
      \fi:
    \fi:
    \if_int_compare:w \c_nine < 1 \token_to_str:N #1 \exp_stop_f:
      \exp_after:wN \@@_parse_large:N
    \else:
      \exp_after:wN \@@_parse_zero:
    \fi:
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_strim_zeros:N, \@@_parse_strim_end:w}
%   If we have removed all digits until a period (or if the body started
%   with a period), then enter the \enquote{\texttt{small_trim}} loop
%   which outputs $-1$ for each removed $0$.  Those $-1$ are added to an
%   integer expression waiting for the exponent.  If the first non-zero
%   token is a digit, call \cs{@@_parse_small:N} (our significand is
%   smaller than~$1$), and otherwise, the number is an exact zero.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_strim_zeros:N #1
  {
    \if:w 0 #1
      - \c_one
      \exp_after:wN \@@_parse_strim_zeros:N
      \tex_romannumeral:D
    \else:
      \@@_parse_strim_end:w #1
    \fi:
    \@@_parse_expand:w
  }
\cs_new:Npn \@@_parse_strim_end:w #1 \fi: \@@_parse_expand:w
  {
    \fi:
    \if_int_compare:w \c_nine < 1 \token_to_str:N #1 \exp_stop_f:
      \exp_after:wN \@@_parse_small:N
    \else:
      \exp_after:wN \@@_parse_zero:
    \fi:
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Exact zero}
%
% \begin{macro}[aux, EXP]{\@@_parse_zero:}
%   After reading a significand of $0$, we need to remove any exponent,
%   then put a sign of |1| for \cs{@@_sanitize:wN}, denoting an
%   exact zero.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_zero:
  {
    \exp_after:wN ; \exp_after:wN 1
    \__int_value:w \@@_parse_exponent:N
  }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Small significand}
%
% \begin{macro}[aux, rEXP]{\@@_parse_small:N}
%   This function is called after we have passed the decimal separator
%   and removed all leading zeros from the significand.  It is followed
%   by a non-zero digit (with any catcode).  The goal is to read up to
%   $16$ digits.  But we can't do that all at once, because
%   \cs{__int_value:w} (which allows us to collect digits and continue
%   expanding) can only go up to $9$ digits.  Hence we grab digits in
%   two steps of $8$ digits.  Since |#1| is a digit, read seven more
%   digits using \cs{@@_parse_digits_vii:N}.  The \texttt{small_leading}
%   auxiliary will leave those digits in the \cs{__int_value:w}, and grab
%   some more, or stop if there are no more digits.  Then the
%   \texttt{pack_leading} auxiliary puts the various parts in the
%   appropriate order for the processing further up.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_small:N #1
  {
    \exp_after:wN \@@_parse_pack_leading:NNNNNww
    \int_use:N \__int_eval:w 1 \token_to_str:N #1
      \exp_after:wN \@@_parse_small_leading:wwNN
      \__int_value:w 1
        \exp_after:wN \@@_parse_digits_vii:N
        \tex_romannumeral:D \@@_parse_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_small_leading:wwNN}
%   \begin{syntax}
%     \cs{@@_parse_small_leading:wwNN} |1| \meta{digits} |;| \meta{zeros} |;| \meta{number~of~zeros}
%   \end{syntax}
%   We leave \meta{digits} \meta{zeros} in the input stream: the
%   functions used to grab digits are such that this constitutes digits
%   $1$ through $8$ of the significand.  Then prepare to pack $8$ more
%   digits, with an exponent shift of \cs{c_zero} (this shift is used in
%   the case of a large significand).  If |#4| is a digit, leave it
%   behind for the packing function, and read $6$ more digits to reach a
%   total of $15$ digits: further digits are involved in the rounding.
%   Otherwise put $8$ zeros in to complete the significand, then look
%   for an exponent.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_small_leading:wwNN 1 #1 ; #2; #3 #4
  {
    #1 #2
    \exp_after:wN \@@_parse_pack_trailing:NNNNNNww
    \exp_after:wN \c_zero
    \int_use:N \__int_eval:w 1
      \if_int_compare:w \c_nine < 1 \token_to_str:N #4 \exp_stop_f:
        \token_to_str:N #4
        \exp_after:wN \@@_parse_small_trailing:wwNN
        \__int_value:w 1
          \exp_after:wN \@@_parse_digits_vi:N
          \tex_romannumeral:D
      \else:
        0000 0000 \@@_parse_exponent:Nw #4
      \fi:
      \@@_parse_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_small_trailing:wwNN}
%   \begin{syntax}
%     \cs{@@_parse_small_trailing:wwNN} |1| \meta{digits} |;| \meta{zeros} |;| \meta{number~of~zeros} \meta{next~token}
%   \end{syntax}
%   Leave digits $10$ to $15$ (arguments |#1| and |#2|) in the input
%   stream.  If the \meta{next~token} is a digit, it is the $16$th
%   digit, we keep it, then the \texttt{small_round} auxiliary considers
%   this digit and all further digits to perform the rounding: the
%   function expands to nothing or to |+1|.  Otherwise, there is no
%   $16$-th digit, so we put a $0$, and look for an exponent.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_small_trailing:wwNN 1 #1 ; #2; #3 #4
  {
    #1 #2
    \if_int_compare:w \c_nine < 1 \token_to_str:N #4 \exp_stop_f:
      \token_to_str:N #4
      \exp_after:wN \@@_parse_small_round:NN
      \exp_after:wN #4
      \tex_romannumeral:D
    \else:
      0 \@@_parse_exponent:Nw #4
    \fi:
    \@@_parse_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]
%   {
%     \@@_parse_pack_trailing:NNNNNNww ,
%     \@@_parse_pack_leading:NNNNNww   ,
%     \@@_parse_pack_carry:w
%   }
%   Those functions are expanded after all the digits are found, we took
%   care of the rounding, as well as the exponent.  The last argument is
%   the exponent.  The previous five arguments are $8$ digits which we
%   pack in groups of $4$, and the argument before that is $1$, except
%   in the rare case where rounding lead to a carry, in which case the
%   argument is $2$.  The \texttt{trailing} function has an exponent
%   shift as its first argument, which we add to the exponent found in
%   the |e...| syntax.  If the trailing digits cause a carry, the
%   integer expression for the leading digits is incremented (|+ \c_one|
%   in the code below).  If the leading digits propagate this carry all
%   the way up, the function \cs{@@_parse_pack_carry:w} increments the
%   exponent, and changes the significand from |0000...| to |1000...|: this
%   is simple because such a carry can only occur to give rise to a
%   power of $10$.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_pack_trailing:NNNNNNww #1 #2 #3#4#5#6 #7; #8 ;
  {
    \if_meaning:w 2 #2 + \c_one \fi:
    ; #8 + #1 ; {#3#4#5#6} {#7};
  }
\cs_new:Npn \@@_parse_pack_leading:NNNNNww #1 #2#3#4#5 #6; #7;
  {
    + #7
    \if_meaning:w 2 #1 \@@_parse_pack_carry:w \fi:
    ; 0 {#2#3#4#5} {#6}
  }
\cs_new:Npn \@@_parse_pack_carry:w \fi: ; 0 #1
  { \fi: + \c_one ; 0 {1000} }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Large significand}
%
% Parsing a significand larger than $1$ is a little bit more difficult
% than parsing small significands.  We need to count the number of
% digits before the decimal separator, and add that to the final
% exponent.  We also need to test for the presence of a dot each time we
% run out of digits, and branch to the appropriate \texttt{parse_small}
% function in those cases.
%
% \begin{macro}[aux, EXP]{\@@_parse_large:N}
%   This function is followed by the first non-zero digit of a
%   \enquote{large} significand ($\geq 1$).  It is called within an
%   integer expression for the exponent.  Grab up to $7$ more digits,
%   for a total of $8$ digits.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_large:N #1
  {
    \exp_after:wN \@@_parse_large_leading:wwNN
    \__int_value:w 1 \token_to_str:N #1
      \exp_after:wN \@@_parse_digits_vii:N
      \tex_romannumeral:D \@@_parse_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_large_leading:wwNN}
%   \begin{syntax}
%     \cs{@@_parse_large_leading:wwNN} |1| \meta{digits} |;| \meta{zeros} |;| \meta{number~of~zeros} \meta{next~token}
%   \end{syntax}
%   We shift the exponent by the number of digits in |#1|, namely the
%   target number, $8$, minus the \meta{number of zeros} (number of
%   digits missing).  Then prepare to pack the $8$ first digits.  If the
%   \meta{next token} is a digit, read up to $6$ more digits (digits
%   $10$ to $15$).  If it is a period, try to grab the end of our $8$
%   first digits, branching to the \texttt{small} functions since the
%   number of digit does not affect the exponent anymore.  Finally, if
%   this is the end of the significand, insert the \meta{zeros} to
%   complete the $8$ first digits, insert $8$ more, and look for an
%   exponent.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_large_leading:wwNN 1 #1 ; #2; #3 #4
  {
    + \c_eight - #3
    \exp_after:wN \@@_parse_pack_leading:NNNNNww
    \int_use:N \__int_eval:w 1 #1
      \if_int_compare:w \c_nine < 1 \token_to_str:N #4 \exp_stop_f:
        \exp_after:wN \@@_parse_large_trailing:wwNN
        \__int_value:w 1 \token_to_str:N #4
          \exp_after:wN \@@_parse_digits_vi:N
          \tex_romannumeral:D
      \else:
        \if:w . #4
          \exp_after:wN \@@_parse_small_leading:wwNN
          \__int_value:w 1
            \cs:w
              @@_parse_digits_
              \tex_romannumeral:D #3
              :N \exp_after:wN
            \cs_end:
            \tex_romannumeral:D
        \else:
          #2
          \exp_after:wN \@@_parse_pack_trailing:NNNNNNww
          \exp_after:wN \c_zero
          \__int_value:w 1 0000 0000
          \@@_parse_exponent:Nw #4
        \fi:
      \fi:
      \@@_parse_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_large_trailing:wwNN}
%   \begin{syntax}
%     \cs{@@_parse_large_trailing:wwNN} |1| \meta{digits} |;| \meta{zeros} |;| \meta{number~of~zeros} \meta{next~token}
%   \end{syntax}
%   We have just read $15$ digits.  If the \meta{next token} is a digit,
%   then the exponent shift caused by this block of $8$ digits is $8$,
%   first argument to the \texttt{pack_trailing} function.  We keep the
%   \meta{digits} and this $16$-th digit, and find how this should be
%   rounded using \cs{@@_parse_large_round:NN}.  Otherwise, the exponent
%   shift is the number of \meta{digits}, $7$ minus the \meta{number of
%     zeros}, and we test for a decimal point.  This case happens in
%   |123451234512345.67| with exactly $15$ digits before the decimal
%   separator.  Then branch to the appropriate \texttt{small} auxiliary,
%   grabbing a few more digits to complement the digits we already
%   grabbed.  Finally, if this is truly the end of the significand, look
%   for an exponent after using the \meta{zeros} and providing a $16$-th
%   digit of $0$.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_large_trailing:wwNN 1 #1 ; #2; #3 #4
  {
    \if_int_compare:w \c_nine < 1 \token_to_str:N #4 \exp_stop_f:
      \exp_after:wN \@@_parse_pack_trailing:NNNNNNww
      \exp_after:wN \c_eight
      \int_use:N \__int_eval:w 1 #1 \token_to_str:N #4
        \exp_after:wN \@@_parse_large_round:NN
        \exp_after:wN #4
        \tex_romannumeral:D
    \else:
      \exp_after:wN \@@_parse_pack_trailing:NNNNNNww
      \int_use:N \__int_eval:w \c_seven - #3 \exp_stop_f:
      \int_use:N \__int_eval:w 1 #1
        \if:w . #4
          \exp_after:wN \@@_parse_small_trailing:wwNN
          \__int_value:w 1
            \cs:w
              @@_parse_digits_
              \tex_romannumeral:D #3
              :N \exp_after:wN
            \cs_end:
            \tex_romannumeral:D
        \else:
          #2 0 \@@_parse_exponent:Nw #4
        \fi:
    \fi:
    \@@_parse_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Finding the exponent}
%
% Expansion is a little bit tricky here, in part because we accept input
% where multiplication is implicit.
% \begin{verbatim}
%   \@@_parse:n { 3.2 erf(0.1) }
%   \@@_parse:n { 3.2 e\l_my_int }
%   \@@_parse:n { 3.2 \c_pi_fp }
% \end{verbatim}
% The first case indicates that just looking one character ahead for an
% \enquote{\texttt{e}} is not enough, since we would mistake the
% function \texttt{erf} for an exponent of \enquote{\texttt{rf}}.  An
% alternative would be to look two tokens ahead and check if what
% follows is a sign or a digit, considering in that case that we must be
% finding an exponent.  But taking care of the second case requires that
% we unpack registers after \texttt{e}.  However, blindly expanding the
% two tokens ahead completely would break the third example (unpacking
% is even worse).  Indeed, in the course of reading $3.2$, \cs{c_pi_fp}
% is expanded to \cs{s_@@} \cs{@@_chk:w} |1| |0| |{-1}| |{3141}|
% $\cdots$ |;| and \cs{s_@@} stops the expansion.  Expanding two tokens
% ahead would then force the expansion of \cs{@@_chk:w} (despite it
% being protected), and that function tries to produce an error.
%
% What can we do?  Really, the reason why this last case breaks is that
% just as \TeX{} does, we should read ahead as little as possible.
% Here, the only case where there may be an exponent is if the first
% token ahead is |e|.  Then we expand (and possibly unpack) the second
% token --- and hopefully that is safe.
%
% \begin{macro}[aux, rEXP]{\@@_parse_exponent:Nw}
%   This auxiliary is convenient to smuggle some material through
%   \cs{fi:} ending conditional processing.  We place those \cs{fi:}
%   (argument |#2|) at a very odd place because this allows us to insert
%   \cs{__int_eval:w} \ldots{} there if needed.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_exponent:Nw #1 #2 \@@_parse_expand:w
  {
    \exp_after:wN ;
    \__int_value:w #2 \@@_parse_exponent:N #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_exponent:N, \@@_parse_exponent_aux:N}
%   This function should be called within an \cs{__int_value:w} expansion
%   (or within an integer expression.  It leaves digits of the exponent
%   behind it in the input stream, and terminates the expansion with a
%   semicolon.  If there is no \texttt{e}, leave an exponent of $0$.  If
%   there is an \texttt{e}, expand the next token to run some tests on
%   it.  Namely, if the character code of |#1| is greater than that of
%   |9| (largest code valid for an exponent, less than any code valid
%   for an identifier), there was in fact no exponent; otherwise, we
%   search for the sign of the exponent.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_exponent:N #1
  {
    \if:w e #1
      \exp_after:wN \@@_parse_exponent_aux:N
      \tex_romannumeral:D
    \else:
      0 \@@_parse_return_semicolon:w #1
    \fi:
    \@@_parse_expand:w
  }
\cs_new:Npn \@@_parse_exponent_aux:N #1
  {
    \if_int_compare:w \if_catcode:w \tex_relax:D #1
                \c_zero \else: `#1 \fi: > `9 \exp_stop_f:
      0 \exp_after:wN ; \exp_after:wN e
    \else:
      \exp_after:wN \@@_parse_exponent_sign:N
    \fi:
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_exponent_sign:N}
%   Read signs one by one (if there is any).
%    \begin{macrocode}
\cs_new:Npn \@@_parse_exponent_sign:N #1
  {
    \if:w + \if:w - #1 + \fi: \token_to_str:N #1
      \exp_after:wN \@@_parse_exponent_sign:N
      \tex_romannumeral:D \exp_after:wN \@@_parse_expand:w
    \else:
      \exp_after:wN \@@_parse_exponent_body:N
      \exp_after:wN #1
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_exponent_body:N}
%   An exponent can be an explicit integer (most common case), or
%   various other things (most of which are invalid).
%    \begin{macrocode}
\cs_new:Npn \@@_parse_exponent_body:N #1
  {
    \if_int_compare:w \c_nine < 1 \token_to_str:N #1 \exp_stop_f:
      \token_to_str:N #1
      \exp_after:wN \@@_parse_exponent_digits:N
      \tex_romannumeral:D
    \else:
      \@@_parse_exponent_keep:NTF #1
        { \@@_parse_return_semicolon:w #1 }
        {
          \exp_after:wN ;
          \tex_romannumeral:D
        }
    \fi:
    \@@_parse_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_exponent_digits:N}
%   Read digits one by one, and leave them behind in the input stream.
%   When finding a non-digit, stop, and insert a semicolon.  Note that
%   we don't check for overflow of the exponent, hence there can be a
%   TeX error.  It is mostly harmless, except when parsing
%   |0e9876543210|, which should be a valid representation of $0$, but
%   is not.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_exponent_digits:N #1
  {
    \if_int_compare:w \c_nine < 1 \token_to_str:N #1 \exp_stop_f:
      \token_to_str:N #1
      \exp_after:wN \@@_parse_exponent_digits:N
      \tex_romannumeral:D
    \else:
      \@@_parse_return_semicolon:w #1
    \fi:
    \@@_parse_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\@@_parse_exponent_keep:NTF}
%   This is the last building block for parsing exponents.  The argument
%   |#1| is already fully expanded, and neither |+| nor |-| nor a digit.
%   It can be:
%   \begin{itemize}
%   \item \cs{s_@@}, marking the start of an internal floating point,
%     invalid here;
%   \item another control sequence equal to \tn{relax}, probably a bad
%     variable;
%   \item a register: in this case we make sure that it is an integer
%     register, not a dimension;
%   \item a character other than |+|, |-| or digits, again, an error.
%   \end{itemize}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_parse_exponent_keep:N #1 { TF }
  {
    \if_catcode:w \tex_relax:D #1
      \if_meaning:w \tex_relax:D #1
        \if_int_compare:w \pdftex_strcmp:D { \s_@@ } { #1 } = \c_zero
          0
          \__msg_kernel_expandable_error:nnn
            { kernel } { fp-after-e } { floating~point~ }
          \prg_return_true:
        \else:
          0
          \__msg_kernel_expandable_error:nnn
            { kernel } { bad-variable } {#1}
          \prg_return_false:
        \fi:
      \else:
        \if_int_compare:w
            \pdftex_strcmp:D { \__int_value:w #1 } { \tex_the:D #1 }
            = \c_zero
          \__int_value:w #1
        \else:
          0
          \__msg_kernel_expandable_error:nnn
            { kernel } { fp-after-e } { dimension~#1 }
        \fi:
        \prg_return_false:
      \fi:
    \else:
      0
      \__msg_kernel_expandable_error:nnn
        { kernel } { fp-missing } { exponent }
      \prg_return_true:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% ^^A begin[todo]
% ^^A todo: word 'e' == 'invalid syntax', word 'E' == "use 'e' instead"
%
% \paragraph{Beyond 16 digits: rounding}
%
% \begin{macro}[int]{\@@_cfs_round_loop:N}
%   Used both for \cs{@@_parse_small_round:NN} and
%   \cs{@@_parse_large_round:NN}.
%   Should appear after a \cs{__int_eval:w} |0|. Reads digits one by one,
%   until reaching a non-digit. Adds |+1| for each digit. If all digits
%   found are |0|, ends the \cs{__int_eval:w} by |;\c_zero|, otherwise
%   by |;\c_one|. This is done by switching the loop to |round_up|
%   at the first non-zero digit.
%
%    \begin{macrocode}
\cs_new:Npn \@@_cfs_round_loop:N #1
  {
    \if_int_compare:w \c_nine < 1 \token_to_str:N #1 \exp_stop_f:
      + \c_one
      \if:w 0 #1
        \exp_after:wN \@@_cfs_round_loop:N
        \tex_romannumeral:D
      \else:
        \exp_after:wN \@@_cfs_round_up:N
        \tex_romannumeral:D
      \fi:
    \else:
      \@@_parse_return_semicolon:w \c_zero #1
    \fi:
    \@@_parse_expand:w
  }
\cs_new:Npn \@@_cfs_round_up:N #1
  {
    \if_int_compare:w \c_nine < 1 \token_to_str:N #1 \exp_stop_f:
      + 1
      \exp_after:wN \@@_cfs_round_up:N
      \tex_romannumeral:D
    \else:
      \@@_parse_return_semicolon:w \c_one #1
    \fi:
    \@@_parse_expand:w
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[int]{\@@_parse_large_round:NN}
%   \begin{syntax}
%     \cs{@@_parse_large_round:NN} \meta{digit} \meta{more digits}
%   \end{syntax}
%   \meta{digit} is the digit that we are currently rounding (we only
%   care whether it is even or odd).
%
%   The goal is to get \cs{c_zero} or \cs{c_one}, check for an exponent
%   afterwards, and combine it to the number of digits before the decimal
%   point (which we thus need to keep track of).
%    \begin{macrocode}
\cs_new:Npn \@@_parse_large_round:NN #1#2
  {
    \if_int_compare:w \c_nine < 1 \token_to_str:N #2 \exp_stop_f:
      +
      \exp_after:wN \@@_round_s:NNNw
      \exp_after:wN 0
      \exp_after:wN #1
      \exp_after:wN #2
      \int_use:N \__int_eval:w
        \exp_after:wN \@@_parse_large_round_after:wNN
        \int_use:N \__int_eval:w \c_one
          \exp_after:wN \@@_cfs_round_loop:N
    \else: %^^A could be dot, or e, or other
      \exp_after:wN \@@_parse_large_round_dot_test:NNw
      \exp_after:wN #1
      \exp_after:wN #2
    \fi:
  }
\cs_new:Npn \@@_parse_large_round_dot_test:NNw #1#2
  {
    \if:w . #2
      \exp_after:wN \@@_parse_small_round:NN
      \exp_after:wN #1
      \tex_romannumeral:D
    \else:
      \@@_parse_exponent:Nw #2
    \fi:
    \@@_parse_expand:w
  }
%    \end{macrocode}
%   \begin{syntax}
%     \cs{@@_parse_large_round_after:wNN} \meta{exp} |;|
%     ~~\meta{0 or 1} \meta{next~token}
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \@@_parse_large_round_after:wNN #1 ; #2 #3
  {
    \if:w . #3
      \exp_after:wN \@@_parse_large_round_after_aux:wN
      \int_use:N \__int_eval:w #1 +
        \c_zero * \__int_eval:w \c_zero
          \exp_after:wN \@@_cfs_round_loop:N
          \tex_romannumeral:D \exp_after:wN \@@_parse_expand:w
    \else:
      + #2
      \exp_after:wN ;
      \int_use:N \__int_eval:w #1 +
        \exp_after:wN \@@_parse_exponent:N
        \exp_after:wN #3
    \fi:
  }
\cs_new:Npn \@@_parse_large_round_after_aux:wN #1 ; #2
  {
    + #2
    \exp_after:wN ;
    \int_use:N \__int_eval:w #1 +
      \@@_parse_exponent:N
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}[int]{\@@_parse_small_round:NN}
%   \begin{syntax}
%     \cs{@@_parse_small_round:NN} \meta{digit} \meta{more digits}
%   \end{syntax}
%   \meta{digit} is the digit that we are currently rounding (we only
%   care whether it is even or odd).
%
%   The goal is to get \cs{c_zero} or \cs{c_one}
%    \begin{macrocode}
\cs_new:Npn \@@_parse_small_round:NN #1#2
  {
    \if_int_compare:w \c_nine < 1 \token_to_str:N #2 \exp_stop_f:
      +
      \exp_after:wN \@@_round_s:NNNw
      \exp_after:wN 0
      \exp_after:wN #1
      \exp_after:wN #2
      \int_use:N \__int_eval:w
        \exp_after:wN \@@_parse_small_round_after:wN
        \int_use:N \__int_eval:w \c_zero
          \exp_after:wN \@@_cfs_round_loop:N
          \tex_romannumeral:D
    \else:
      \@@_parse_exponent:Nw #2
    \fi:
    \@@_parse_expand:w
  }
\cs_new:Npn \@@_parse_small_round_after:wN #1; #2
  {
    + #2 \exp_after:wN ;
    \__int_value:w \@@_parse_exponent:N
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Main functions}
%
% \begin{macro}[int, EXP]{\@@_parse:n}
% \begin{macro}[aux, EXP]{\@@_parse_after:ww}
%   Start a \tn{romannumeral} expansion so that \cs{@@_parse:n} expands
%   in two steps.  The \cs{@@_parse_operand:Nw} function will perform
%   computations until reaching an operation with precedence
%   \cs{c_minus_one} or less.  Then check that there was indeed nothing
%   left (this cannot happen), and stop the initial expansion with
%   \cs{c_zero}.%^^A todo: simplify a bit.
%    \begin{macrocode}
\cs_new:Npn \@@_parse:n #1
  {
    \tex_romannumeral:D
      \exp_after:wN \@@_parse_after:ww
      \tex_romannumeral:D
        \@@_parse_operand:Nw \c_minus_one
        \@@_parse_expand:w #1 \s_@@_mark
      \s_@@_stop
  }
\cs_new:Npn \@@_parse_after:ww #1@ #2 \s_@@_stop
  {
%<assert>    \assert_str_eq:nn { #2 } { \@@_parse_infix_end:N \s_@@_mark }
    \c_zero #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_parse_operand:Nw}
% \begin{macro}[aux, EXP]{\@@_parse_continue:NwN}
%   The \cs{@@_parse_operand}
%   This is just a shorthand which sets up both \cs{@@_parse_continue}
%   and \cs{@@_parse_one} with the same precedence. Note the
%   trailing \cs{tex_romannumeral:D}. This function should be
%   used with much care.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_operand:Nw #1
  {
    -`0
    \exp_after:wN \@@_parse_continue:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0
    \exp_after:wN \@@_parse_one:Nw
    \exp_after:wN #1
    \tex_romannumeral:D
  }
\cs_new:Npn \@@_parse_continue:NwN #1 #2 @ #3 { #3 #1 #2 @ }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Main functions}
%
% \begin{macro}[aux, EXP]{\@@_parse_infix_after_operand:NwN}
%    \begin{macrocode}
\cs_new:Npn \@@_parse_infix_after_operand:NwN #1 #2;
  {
    \@@_exp_after_f:nw { \@@_parse_infix:NN #1 }
    #2;
  }
\group_begin:
  \char_set_catcode_letter:N \*
  \cs_new:Npn \@@_parse_infix:NN #1 #2
    {
      \if_catcode:w \tex_relax:D #2
        \if_int_compare:w
            \pdftex_strcmp:D { \s_@@_mark } { #2 }
            = \c_zero
          \exp_after:wN \exp_after:wN
          \exp_after:wN \@@_parse_infix_end:N
        \else:
          \exp_after:wN \exp_after:wN
          \exp_after:wN \@@_parse_infix_juxtapose:N
        \fi:
      \else:
        \if_int_compare:w
            \__int_eval:w \tex_uccode:D `#2 / 26
            = \c_three
          \exp_after:wN \exp_after:wN
          \exp_after:wN \@@_parse_infix_juxtapose:N
        \else:
          \exp_after:wN \@@_parse_infix_check:NNN
          \cs:w
            @@_parse_infix_#2:N
            \exp_after:wN \exp_after:wN \exp_after:wN
          \cs_end:
        \fi:
      \fi:
      #1
      #2
    }
  \cs_new:Npn \@@_parse_infix_check:NNN #1#2#3
    {
      \if_meaning:w \tex_relax:D #1
        \__msg_kernel_expandable_error:nnn { kernel } { fp-missing } { * }
        \exp_after:wN \@@_parse_infix_*:N
        \exp_after:wN #2
        \exp_after:wN #3
      \else:
        \exp_after:wN #1
        \exp_after:wN #2
        \tex_romannumeral:D \exp_after:wN \@@_parse_expand:w
      \fi:
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_parse_apply_binary:NwNwN}
%   Receives \meta{precedence} \meta{operand_1} |@| \meta{operation}
%   \meta{operand_2} |@| \meta{infix command}.  Builds the appropriate
%   call to the \meta{operation} |#4|, given the types of the two
%   \meta{operands}.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_apply_binary:NwNwN #1 #2#3@ #4 #5#6@ #7
  {
    \exp_after:wN \@@_parse_continue:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0
      \cs:w
        @@
        \@@_type_from_scan:N #2
        _ #4
        \@@_type_from_scan:N #5
        _o:ww
      \cs_end:
      #2#3 #5#6
    \tex_romannumeral:D -`0 #7 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_unary_type:N}
%   Expects \cs{s_@@} or similar as~|#1|.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_unary_type:N #1
  { \@@_type_from_scan:N #1 _o:w \cs_end: #1 }
%    \end{macrocode}
% \end{macro}
%
% ^^A todo: remove the \@@_parse_apply_unary...:NNwN functions?
% \begin{macro}[int, EXP]
%   {\@@_parse_apply_unary_array:NNwN, \@@_parse_apply_unary:NNwN}
%   Here, |#1| is a precedence, |#2| is \emph{e.g.}, \cs{@@_sin_o:w},
%   and expands once after the calculation, |#3| is the operand, and
%   |#4| is a |\__fp_parse_infix_...:N| function.  The argument |#3| may
%   be an array, so either we map through all its items, or we feed all
%   items at once to the custom function.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_apply_unary_array:NNwN #1#2#3@#4
  {
    #2 #3 @
    \tex_romannumeral:D -`0 #4 #1
  }
\cs_new:Npn \@@_parse_apply_unary:NNwN #1#2#3@#4
  {
    #2 #3
    \tex_romannumeral:D -`0 #4 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {\@@_parse_apply_unary_array:NNNwN, \@@_parse_apply_unary:NNNwN}
%   Here, |#1| is a precedence, |#2| is some extra data used by some
%   functions, |#3| is \emph{e.g.}, \cs{@@_sin_o:w}, and expands once
%   after the calculation, |#4| is the operand, and |#5| is a
%   |\__fp_parse_infix_...:N| function.  The argument |#4| may be an
%   array, so either we map through all its items, or we feed all items
%   at once to the custom function.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_apply_unary_array:NNNwN #1#2#3#4@#5
  {
    #3 #2 #4 @
    \tex_romannumeral:D -`0 #5 #1
  }
\cs_new:Npn \@@_parse_apply_unary:NNNwN #1#2#3#4@#5
  {
    #3 #2 #4
    \tex_romannumeral:D -`0 #5 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Prefix operators}
%
% \begin{macro}[aux, EXP]
%   {
%     \@@_parse_word_inf:N, \@@_parse_word_nan:N, \@@_parse_word_pi:N ,
%     \@@_parse_word_deg:N, \@@_parse_word_em:N ,
%     \@@_parse_word_ex:N , \@@_parse_word_in:N , \@@_parse_word_pt:N ,
%     \@@_parse_word_pc:N , \@@_parse_word_cm:N , \@@_parse_word_mm:N ,
%     \@@_parse_word_dd:N , \@@_parse_word_cc:N , \@@_parse_word_nd:N ,
%     \@@_parse_word_nc:N , \@@_parse_word_bp:N , \@@_parse_word_sp:N ,
%     \@@_parse_word_true:N , \@@_parse_word_false:N ,
%   }
%   A whole bunch of floating point numbers.
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1 #2
  {
    \cs_new_nopar:cpn { @@_parse_word_#1:N }
      { \exp_after:wN #2 \tex_romannumeral:D -`0 \@@_parse_infix:NN }
  }
\@@_tmp:w { inf } \c_inf_fp
\@@_tmp:w { nan } \c_nan_fp
\@@_tmp:w { pi  } \c_pi_fp
\@@_tmp:w { deg } \c_one_degree_fp
\@@_tmp:w { true } \c_one_fp
\@@_tmp:w { false } \c_zero_fp
\@@_tmp:w { pt } \c_one_fp
\cs_set_protected:Npn \@@_tmp:w #1 #2
  {
    \cs_new_nopar:cpn { @@_parse_word_#1:N }
      {
        \@@_exp_after_f:nw { \@@_parse_infix:NN }
        \s_@@ \@@_chk:w 10 #2 ;
      }
  }
\@@_tmp:w {in} { {2} {7227} {0000} {0000} {0000} }
\@@_tmp:w {pc} { {2} {1200} {0000} {0000} {0000} }
\@@_tmp:w {cm} { {2} {2845} {2755} {9055} {1181} }
\@@_tmp:w {mm} { {1} {2845} {2755} {9055} {1181} }
\@@_tmp:w {dd} { {1} {1070} {0085} {6496} {0630} }
\@@_tmp:w {cc} { {2} {1284} {0102} {7795} {2756} }
\@@_tmp:w {nd} { {1} {1066} {9783} {4645} {6693} }
\@@_tmp:w {nc} { {2} {1280} {3740} {1574} {8031} }
\@@_tmp:w {bp} { {1} {1003} {7500} {0000} {0000} }
\@@_tmp:w {sp} { {-4} {1525} {8789} {0625} {0000} }
\tl_map_inline:nn { {em} {ex} }
  {
    \cs_new_nopar:cpn { @@_parse_word_#1:N }
      {
        \exp_after:wN \dim_to_fp:n \exp_after:wN
          { \dim_use:N \__dim_eval:w 1 #1 \exp_after:wN }
        \tex_romannumeral:D -`0 \@@_parse_infix:NN
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, EXP]
%   {
%     \@@_parse_word_abs:N   ,
%     \@@_parse_word_exp:N   ,
%     \@@_parse_word_ln:N    ,
%   }
%   Unary functions.
%    \begin{macrocode}
\tl_map_inline:nn
  { {abs} {exp} {ln} }
  {
    \cs_new:cpn { @@_parse_word_#1:N } ##1
      {
        \exp_after:wN \@@_parse_apply_unary:NNwN
        \exp_after:wN ##1
        \cs:w @@_ #1 \exp_after:wN \@@_parse_unary_type:N
        \tex_romannumeral:D
        \@@_parse_operand:Nw \c_fifteen
        \@@_parse_expand:w
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]
%   {
%     \@@_parse_word_acos:N  ,
%     \@@_parse_word_acosd:N ,
%     \@@_parse_word_acsc:N  ,
%     \@@_parse_word_acscd:N ,
%     \@@_parse_word_asec:N  ,
%     \@@_parse_word_asecd:N ,
%     \@@_parse_word_asin:N  ,
%     \@@_parse_word_asind:N ,
%     \@@_parse_word_cos:N   ,
%     \@@_parse_word_cosd:N  ,
%     \@@_parse_word_cot:N   ,
%     \@@_parse_word_cotd:N  ,
%     \@@_parse_word_csc:N   ,
%     \@@_parse_word_cscd:N  ,
%     \@@_parse_word_sec:N   ,
%     \@@_parse_word_secd:N  ,
%     \@@_parse_word_sin:N   ,
%     \@@_parse_word_sind:N  ,
%     \@@_parse_word_tan:N   ,
%     \@@_parse_word_tand:N  ,
%   }
%   Unary functions.
%    \begin{macrocode}
\tl_map_inline:nn
  {
    {acos} {acsc} {asec} {asin}
    {cos} {cot} {csc} {sec} {sin} {tan}
  }
  {
    \cs_new:cpn { @@_parse_word_#1:N } ##1
      {
        \exp_after:wN \@@_parse_apply_unary:NNNwN
        \exp_after:wN ##1
        \exp_after:wN \use_i:nn
        \cs:w @@_ #1 \exp_after:wN \@@_parse_unary_type:N
        \tex_romannumeral:D
        \@@_parse_operand:Nw \c_fifteen
        \@@_parse_expand:w
      }
    \cs_new:cpn { @@_parse_word_#1d:N } ##1
      {
        \exp_after:wN \@@_parse_apply_unary:NNNwN
        \exp_after:wN ##1
        \exp_after:wN \use_ii:nn
        \cs:w @@_ #1 \exp_after:wN \@@_parse_unary_type:N
        \tex_romannumeral:D
        \@@_parse_operand:Nw \c_fifteen
        \@@_parse_expand:w
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]
%   {
%     \@@_parse_word_acot:N , \@@_parse_word_acotd:N,
%     \@@_parse_word_atan:N , \@@_parse_word_atand:N,
%   }
%   Those functions are also unary (not binary), but may receive a
%   variable number of arguments.
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1#2#3
  {
    \cs_new:Npn #1 ##1
      {
        \exp_after:wN \@@_parse_apply_unary_array:NNNwN
        \exp_after:wN ##1
        \exp_after:wN #3
        \exp_after:wN #2
        \tex_romannumeral:D
        \@@_parse_operand:Nw \c_sixteen \@@_parse_expand:w
      }
  }
\@@_tmp:w \@@_parse_word_acot:N  \@@_acot_o:w \use_i:nn
\@@_tmp:w \@@_parse_word_acotd:N \@@_acot_o:w \use_ii:nn
\@@_tmp:w \@@_parse_word_atan:N  \@@_atan_o:w \use_i:nn
\@@_tmp:w \@@_parse_word_atand:N \@@_atan_o:w \use_ii:nn
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_parse_word_max:N, \@@_parse_word_min:N}
%   Those functions are also unary, but receive an arbitrary number of
%   arguments.
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1#2
  {
    \cs_new:Npn #1 ##1
      {
        \exp_after:wN \@@_parse_apply_unary_array:NNwN
        \exp_after:wN ##1
        \exp_after:wN #2
        \tex_romannumeral:D
        \@@_parse_operand:Nw \c_sixteen \@@_parse_expand:w
      }
  }
\@@_tmp:w \@@_parse_word_max:N \@@_max_o:w
\@@_tmp:w \@@_parse_word_min:N \@@_min_o:w
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_parse_word_round:N}
%   This function expects one or two arguments.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_word_round:N #1#2
  {
    \if_meaning:w + #2
      \@@_parse_round:Nw \@@_round_to_pinf:NNN
    \else:
      \if_meaning:w 0 #2
        \@@_parse_round:Nw \@@_round_to_zero:NNN
      \else:
        \if_meaning:w - #2
          \@@_parse_round:Nw \@@_round_to_ninf:NNN
        \fi:
      \fi:
    \fi:
    \exp_after:wN \@@_parse_apply_round:NNwN
    \exp_after:wN #1
    \exp_after:wN \@@_round_to_nearest:NNN
    \tex_romannumeral:D
    \@@_parse_operand:Nw \c_sixteen \@@_parse_expand:w #2
  }
\cs_new:Npn \@@_parse_round:Nw
    #1 #2 \@@_round_to_nearest:NNN #3 \@@_parse_expand:w #4
  { #2 #1 #3 \@@_parse_expand:w }
\cs_new:Npn \@@_parse_apply_round:NNwN #1#2#3@#4
  {
    \if_case:w \__int_eval:w \@@_array_count:n {#3} - \c_one \__int_eval_end:
         \@@_round:Nwn #2 #3 {0} \tex_romannumeral:D
    \or: \@@_round:Nww #2 #3 \tex_romannumeral:D
    \else:
      \__msg_kernel_expandable_error:nnnnn
        { kernel } { fp-num-args } { round() } { 1 } { 2 }
      \exp_after:wN \c_nan_fp \tex_romannumeral:D
    \fi:
    -`0 #4 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, aux]{\@@_parse_prefix_+:Nw}
%   A unary |+| does nothing.
%    \begin{macrocode}
\cs_new_eq:cN { @@_parse_prefix_+:Nw } \@@_parse_one:Nw
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, aux]{\@@_parse_prefix_-:Nw, \@@_parse_prefix_!:Nw}
%   Unary |-| is harder.
%   Boolean not.
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1#2
  {
    \cs_new:cpn { @@_parse_prefix_#1:Nw } ##1
      {
        \exp_after:wN \@@_parse_apply_unary:NNwN
        \exp_after:wN ##1
        \cs:w @@_ #2 \exp_after:wN \@@_parse_unary_type:N
        \tex_romannumeral:D
        \if_int_compare:w \c_twelve < ##1
          \@@_parse_operand:Nw ##1
        \else:
          \@@_parse_operand:Nw \c_twelve
        \fi:
        \@@_parse_expand:w
      }
  }
\@@_tmp:w - { - }
\@@_tmp:w ! { ! }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_prefix_(:Nw}
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_letter:N \)
  \cs_new:cpn { @@_parse_prefix_(:Nw } #1
    {
      \exp_after:wN \@@_parse_lparen_after:NwN
      \exp_after:wN #1
      \tex_romannumeral:D
      \if_int_compare:w #1 = \c_sixteen
        \@@_parse_operand:Nw \c_one
      \else:
        \@@_parse_operand:Nw \c_zero
      \fi:
      \@@_parse_expand:w
    }
  \cs_new:Npn \@@_parse_lparen_after:NwN #1#2@#3
    {
      \token_if_eq_meaning:NNTF #3 \@@_parse_infix_):N
        {
          \@@_exp_after_array_f:w #2 \s_@@_stop
          \exp_after:wN \@@_parse_infix:NN
          \exp_after:wN #1
          \tex_romannumeral:D \@@_parse_expand:w
        }
        {
          \__msg_kernel_expandable_error:nnn { kernel } { fp-missing } { ) }
          #2 @ \use_none:n #3
        }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_prefix_.:Nw}
%   This function is called when a number starts with a dot.
%    \begin{macrocode}
\cs_new:cpn {@@_parse_prefix_.:Nw} #1
  {
    \exp_after:wN \@@_parse_infix_after_operand:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0
      \exp_after:wN \@@_sanitize:wN
      \int_use:N \__int_eval:w \c_zero \@@_parse_strim_zeros:N
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Infix operators}
%
%   As described in the \enquote{work plan}, each infix operator has an
%   associated \cs{infix} function, a computing function, and
%   precedence, given as arguments to \cs{@@_tmp:w}.  The
%   latter two are only needed when defining the \cs{infix} function.
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1#2#3#4
  {
    \cs_new:Npn #1 ##1
      {
        \if_int_compare:w ##1 < #3
          \exp_after:wN @
          \exp_after:wN \@@_parse_apply_binary:NwNwN
          \exp_after:wN #2
          \tex_romannumeral:D
          \@@_parse_operand:Nw #4
          \exp_after:wN \@@_parse_expand:w
        \else:
          \exp_after:wN @
          \exp_after:wN \use_none:n
          \exp_after:wN #1
        \fi:
      }
  }
%    \end{macrocode}
%
% \begin{macro}[int, EXP]
%   {
%     \@@_parse_infix_+:N, \@@_parse_infix_-:N,
%     \@@_parse_infix_/:N, \@@_parse_infix_mul:N,
%     \@@_parse_infix_and:N, \@@_parse_infix_or:N,
%   }
%   Using the general mechanism for arithmetic operations.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:N \&
  \@@_tmp:w \@@_parse_infix_juxtapose:N * \c_thirty_two \c_thirty_two
  \exp_args:Nc \@@_tmp:w { @@_parse_infix_ / :N } / \c_ten \c_ten
  \exp_args:Nc \@@_tmp:w { @@_parse_infix_mul:N } * \c_ten \c_ten
  \exp_args:Nc \@@_tmp:w { @@_parse_infix_ - :N } - \c_nine \c_nine
  \exp_args:Nc \@@_tmp:w { @@_parse_infix_ + :N } + \c_nine \c_nine
  \exp_args:Nc \@@_tmp:w { @@_parse_infix_and:N } & \c_five \c_five
  \exp_args:Nc \@@_tmp:w { @@_parse_infix_ or:N } | \c_four \c_four
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_parse_infix_*:N}
% \begin{macro}[int, EXP]+\@@_parse_infix_^:N+
%   The power operation must be associative in the opposite order from
%   all others.  For this, we reverse the test, hence treating a
%   \enquote{previous precedence} of \cs{c_fourteen} as less binding
%   than |^|.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_letter:N ^
  \@@_tmp:w \@@_parse_infix_^:N ^ \c_fifteen \c_fourteen
  \cs_new:cpn { @@_parse_infix_*:N } #1#2
    {
      \if:w * #2
        \exp_after:wN \@@_parse_infix_^:N
        \exp_after:wN #1
      \else:
        \exp_after:wN \@@_parse_infix_mul:N
        \exp_after:wN #1
        \exp_after:wN #2
      \fi:
    }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, EXP]+\@@_parse_infix_|:Nw+
% \begin{macro}[int, EXP]+\@@_parse_infix_&:Nw+
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_letter:N \|
  \char_set_catcode_letter:N \&
  \cs_new:Npn \@@_parse_infix_|:N #1#2
    {
      \if:w | #2
        \exp_after:wN \@@_parse_infix_|:N
        \exp_after:wN #1
        \tex_romannumeral:D \exp_after:wN \@@_parse_expand:w
      \else:
        \exp_after:wN \@@_parse_infix_or:N
        \exp_after:wN #1
        \exp_after:wN #2
      \fi:
    }
  \cs_new:Npn \@@_parse_infix_&:N #1#2
    {
      \if:w & #2
        \exp_after:wN \@@_parse_infix_&:N
        \exp_after:wN #1
        \tex_romannumeral:D \exp_after:wN \@@_parse_expand:w
      \else:
        \exp_after:wN \@@_parse_infix_and:N
        \exp_after:wN #1
        \exp_after:wN #2
      \fi:
    }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, EXP]
%   {
%     \@@_parse_infix_<:N, \@@_parse_infix_=:N,
%     \@@_parse_infix_>:N, \@@_parse_infix_!:N
%   }
% \begin{macro}[aux, EXP]
%   {
%     \@@_parse_infix_excl_aux:NN,
%     \@@_parse_infix_excl_error:,
%     \@@_infix_compare:N,
%     \@@_parse_compare:NNNNNNw,
%     \@@_parse_compare_expand:NNNNNw,
%     \@@_parse_compare_end:NNNN,
%     \@@_compare:wNNNNw,
%   }
%    \begin{macrocode}
\cs_new:cpn { @@_parse_infix_<:N } #1
  {
    \@@_infix_compare:N #1 \c_one_fp
      \c_zero_fp  \c_zero_fp \c_zero_fp \c_zero_fp <
  }
\cs_new:cpn { @@_parse_infix_=:N } #1
  {
    \@@_infix_compare:N #1 \c_one_fp
      \c_zero_fp \c_zero_fp \c_zero_fp \c_zero_fp =
  }
\cs_new:cpn { @@_parse_infix_>:N } #1
  {
    \@@_infix_compare:N #1 \c_one_fp
      \c_zero_fp \c_zero_fp \c_zero_fp \c_zero_fp >
  }
\cs_new:cpn { @@_parse_infix_!:N } #1
  {
    \exp_after:wN \@@_parse_infix_excl_aux:NN
    \exp_after:wN #1 \tex_romannumeral:D \@@_parse_expand:w
  }
\cs_new:Npn \@@_parse_infix_excl_aux:NN #1#2
  {
    \@@_infix_compare:N #1 \c_zero_fp
      \c_one_fp \c_one_fp \c_one_fp \c_one_fp #2
  }
\cs_new:Npn \@@_parse_infix_excl_error:
  {
    \__msg_kernel_expandable_error:nnnn
      { kernel } { fp-missing } { = } { ~after~!. }
  }
\cs_new:Npn \@@_infix_compare:N #1
  {
    \if_int_compare:w #1 < \c_seven
      \exp_after:wN \@@_parse_compare:NNNNNNw
      \exp_after:wN \@@_parse_infix_excl_error:
    \else:
      \exp_after:wN @
      \exp_after:wN \use_none:n
      \exp_after:wN \@@_infix_compare:N
    \fi:
  }
\cs_new:Npn \@@_parse_compare:NNNNNNw #1#2#3#4#5#6#7
  {
    \if_case:w
          \if_catcode:w \tex_relax:D #7
            \c_minus_one
          \else:
            \__int_eval:w `#7 - `< \__int_eval_end:
          \fi:
         \@@_parse_compare_expand:NNNNNw #2#2#4#5#6
    \or: \@@_parse_compare_expand:NNNNNw #2#3#2#5#6
    \or: \@@_parse_compare_expand:NNNNNw #2#3#4#2#6
    \or: \@@_parse_compare_expand:NNNNNw #2#3#4#5#2
    \else: #1 \@@_parse_compare_end:NNNN #3#4#5#6#7
    \fi:
  }
\cs_new:Npn \@@_parse_compare_expand:NNNNNw #1#2#3#4#5
  {
    \exp_after:wN \@@_parse_compare:NNNNNNw
    \exp_after:wN \prg_do_nothing:
    \exp_after:wN #1
    \exp_after:wN #2
    \exp_after:wN #3
    \exp_after:wN #4
    \exp_after:wN #5
    \tex_romannumeral:D \exp_after:wN \@@_parse_expand:w
  }
\cs_new:Npn \@@_parse_compare_end:NNNN #1#2#3#4#5 \fi:
  {
    \fi:
    \exp_after:wN @
    \exp_after:wN \@@_parse_apply_compare:NwNNNNwN
    \exp_after:wN #1
    \exp_after:wN #2
    \exp_after:wN #3
    \exp_after:wN #4
    \tex_romannumeral:D
    \@@_parse_operand:Nw \c_seven \@@_parse_expand:w #5
  }
\cs_new:Npn \@@_parse_apply_compare:NwNNNNwN #1 #2@ #3#4#5#6 #7@ #8
  {
    \exp_after:wN \@@_parse_continue:NwN
    \exp_after:wN #1
    \tex_romannumeral:D -`0
      \exp_after:wN \exp_after:wN
      \exp_after:wN \exp_after:wN
      \exp_after:wN \exp_after:wN
      \if_case:w \@@_compare_back:ww #7 #2 \exp_stop_f:
             #4
      \or:   #5
      \or:   #6
      \else: #3
      \fi:
    \tex_romannumeral:D -`0 #8 #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, EXP]{\@@_parse_infix_?:N, \@@_parse_infix_::N}
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_letter:N \?
  \cs_new:Npn \@@_parse_infix_?:N #1
    {
      \if_int_compare:w #1 < \c_three
        \exp_after:wN @
        \exp_after:wN \@@_ternary:NwwN
        \tex_romannumeral:D
        \@@_parse_operand:Nw \c_three
        \exp_after:wN \@@_parse_expand:w
      \else:
        \exp_after:wN @
        \exp_after:wN \use_none:n
        \exp_after:wN \@@_parse_infix_?:N
      \fi:
    }
  \cs_new:Npn \@@_parse_infix_::N #1
    {
      \if_int_compare:w #1 < \c_three
        \__msg_kernel_expandable_error:nnnn
          { kernel } { fp-missing } { ? } { ~for~?: }
        \exp_after:wN @
        \exp_after:wN \@@_ternary_auxii:NwwN
        \tex_romannumeral:D
        \@@_parse_operand:Nw \c_two
        \exp_after:wN \@@_parse_expand:w
      \else:
        \exp_after:wN @
        \exp_after:wN \use_none:n
        \exp_after:wN \@@_parse_infix_::N
      \fi:
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]+\@@_parse_infix_):N+
%   This one is a little bit odd: force every previous operator to end,
%   regardless of the precedence.  This is very similar to
%   \cs{@@_parse_infix_end:N}.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_letter:N \)
  \cs_new:Npn \@@_parse_infix_):N #1
    {
      \if_int_compare:w #1 < \c_zero
        \__msg_kernel_expandable_error:nnn { kernel } { fp-extra } { ) }
        \exp_after:wN \@@_parse_infix:NN
        \exp_after:wN #1
        \tex_romannumeral:D \exp_after:wN \@@_parse_expand:w
      \else:
        \exp_after:wN @
        \exp_after:wN \use_none:n
        \exp_after:wN \@@_parse_infix_):N
      \fi:
    }
\group_end:
\cs_new:Npn \@@_parse_infix_end:N #1
  { @ \use_none:n \@@_parse_infix_end:N }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int, EXP]+\@@_parse_infix_,:N+
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_letter:N \,
  \cs_new:Npn \@@_parse_infix_,:N #1
    {
      \if_int_compare:w #1 > \c_one
        \exp_after:wN @
        \exp_after:wN \use_none:n
        \exp_after:wN \@@_parse_infix_,:N
      \else:
        \if_int_compare:w #1 = \c_one
          \exp_after:wN \@@_parse_infix_comma:w
          \tex_romannumeral:D
        \else:
          \exp_after:wN \@@_parse_infix_comma_gobble:w
          \tex_romannumeral:D
        \fi:
        \@@_parse_operand:Nw \c_one
        \exp_after:wN \@@_parse_expand:w
      \fi:
    }
  \cs_new:Npn \@@_parse_infix_comma:w #1 @
    { #1 @ \use_none:n }
  \cs_new:Npn \@@_parse_infix_comma_gobble:w #1 @
    {
      \__msg_kernel_expandable_error:nn { kernel } { fp-extra-comma }
      @ \use_none:n
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\__msg_kernel_new:nnn { kernel } { unknown-fp-word }
  { Unknown~fp~word~#1. }
\__msg_kernel_new:nnn { kernel } { fp-missing }
  { Missing~#1~inserted #2. }
\__msg_kernel_new:nnn { kernel } { fp-extra }
  { Extra~#1~ignored. }
\__msg_kernel_new:nnn { kernel } { fp-early-end }
  { Premature~end~in~fp~expression. }
\__msg_kernel_new:nnn { kernel } { fp-after-e }
  { Cannot~use~#1 after~'e'. }
\__msg_kernel_new:nnn { kernel } { fp-missing-number }
  { Missing~number~before~'#1'. }
\__msg_kernel_new:nnn { kernel } { fp-unknown-symbol }
  { Unknown~symbol~#1~ignored. }
\__msg_kernel_new:nnn { kernel } { fp-extra-comma }
  { Unexpected~comma:~extra~arguments~ignored. }
\__msg_kernel_new:nnn { kernel } { fp-num-args }
  { #1~expects~between~#2~and~#3~arguments. }
%    \end{macrocode}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex
