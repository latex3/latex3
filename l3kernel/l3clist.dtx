% \iffalse meta-comment
%
%% File: l3clist.dtx Copyright (C) 2004-2011 Frank Mittelbach,
%%                                 The LaTeX3 project
%%                             (C) 2012,2013 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3kernel bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{l3bootstrap}
\GetIdInfo$Id$
  {L3 Comma separated lists}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3clist} package\\ Comma separated lists^^A
%   \thanks{This file describes v\ExplFileVersion,
%      last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% Comma lists contain ordered data where items can be added to the left
% or right end of the list. The resulting ordered list can then
% be mapped over using \cs{clist_map_function:NN}. Several items can
% be added at once, and spaces are removed from both sides of each item
% on input. Hence,
% \begin{verbatim}
%   \clist_new:N \l_my_clist
%   \clist_put_left:Nn \l_my_clist { ~ a ~ , ~ {b} ~ }
%   \clist_put_right:Nn \l_my_clist { ~ { c ~ } , d }
% \end{verbatim}
% results in \cs{l_my_clist} containing |a,{b},{c~},d|.
% Comma lists cannot contain empty items, thus
% \begin{verbatim}
%   \clist_clear_new:N \l_my_clist
%   \clist_put_right:Nn \l_my_clist { , ~ , , }
%   \clist_if_empty:NTF \l_my_clist { true } { false }
% \end{verbatim}
% will leave \texttt{true} in the input stream. To include an item
% which contains a comma, or starts or ends with a space,
% surround it with braces.  The sequence data type should be preferred
% to comma lists if items are to contain |{|, |}|, or |#| (assuming the
% usual \TeX{} category codes apply).
%
% \section{Creating and initialising comma lists}
%
% \begin{function}{\clist_new:N, \clist_new:c}
%   \begin{syntax}
%     \cs{clist_new:N} \meta{comma list}
%   \end{syntax}
%   Creates a new \meta{comma list} or raises an error if the name is
%   already taken. The declaration is global. The \meta{comma list} will
%   initially contain no items.
% \end{function}
%
% \begin{function}
%   {\clist_clear:N, \clist_clear:c, \clist_gclear:N, \clist_gclear:c}
%   \begin{syntax}
%     \cs{clist_clear:N} \meta{comma list}
%   \end{syntax}
%   Clears all items from the \meta{comma list}.
% \end{function}
%
% \begin{function}
%   {
%     \clist_clear_new:N,  \clist_clear_new:c,
%     \clist_gclear_new:N, \clist_gclear_new:c
%   }
%   \begin{syntax}
%     \cs{clist_clear_new:N} \meta{comma list}
%   \end{syntax}
%   Ensures that the \meta{comma list} exists globally by applying
%   \cs{clist_new:N} if necessary, then applies \cs{clist_(g)clear:N} to leave
%   the list empty.
% \end{function}
%
% \begin{function}
%   {
%     \clist_set_eq:NN,  \clist_set_eq:cN,
%     \clist_set_eq:Nc,  \clist_set_eq:cc,
%     \clist_gset_eq:NN, \clist_gset_eq:cN,
%     \clist_gset_eq:Nc, \clist_gset_eq:cc
%   }
%   \begin{syntax}
%     \cs{clist_set_eq:NN} \meta{comma list_1} \meta{comma list_2}
%   \end{syntax}
%   Sets the content of \meta{comma list_1} equal to that of
%   \meta{comma list_2}.
% \end{function}
%
% \begin{function}
%   {
%     \clist_concat:NNN,  \clist_concat:ccc,
%     \clist_gconcat:NNN, \clist_gconcat:ccc
%   }
%   \begin{syntax}
%     \cs{clist_concat:NNN} \meta{comma list_1} \meta{comma list_2} \meta{comma list_3}
%   \end{syntax}
%   Concatenates the content of \meta{comma list_2} and \meta{comma list_3}
%   together and saves the result in \meta{comma list_1}. The items in
%   \meta{comma list_2} will be placed at the left side of the new comma list.
% \end{function}
%
% \begin{function}[EXP, pTF, added=2012-03-03]
%   {\clist_if_exist:N, \clist_if_exist:c}
%   \begin{syntax}
%     \cs{clist_if_exist_p:N} \meta{comma list}
%     \cs{clist_if_exist:NTF} \meta{comma list} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{comma list} is currently defined.  This does
%   not check that the \meta{comma list} really is a comma list.
% \end{function}
%
% \section{Adding data to comma lists}
%
% \begin{function}[added = 2011-09-06]
%   {
%     \clist_set:Nn,  \clist_set:NV,
%     \clist_set:No,  \clist_set:Nx,
%     \clist_set:cn,  \clist_set:cV,
%     \clist_set:co,  \clist_set:cx,
%     \clist_gset:Nn, \clist_gset:NV,
%     \clist_gset:No, \clist_gset:Nx,
%     \clist_gset:cn, \clist_gset:cV,
%     \clist_gset:co, \clist_gset:cx
%   }
%   \begin{syntax}
%     \cs{clist_set:Nn} \meta{comma list} |{|\meta{item_1},\ldots{},\meta{item_n}|}|
%   \end{syntax}
%   Sets \meta{comma list} to contain the \meta{items},
%   removing any previous content from the variable.
%   Spaces are removed from both sides of each item.
% \end{function}
%
% \begin{function}[updated = 2011-09-05]
%   {
%     \clist_put_left:Nn,  \clist_put_left:NV,
%     \clist_put_left:No,  \clist_put_left:Nx,
%     \clist_put_left:cn,  \clist_put_left:cV,
%     \clist_put_left:co,  \clist_put_left:cx,
%     \clist_gput_left:Nn, \clist_gput_left:NV,
%     \clist_gput_left:No, \clist_gput_left:Nx,
%     \clist_gput_left:cn, \clist_gput_left:cV,
%     \clist_gput_left:co, \clist_gput_left:cx
%   }
%   \begin{syntax}
%     \cs{clist_put_left:Nn} \meta{comma list} |{|\meta{item_1},\ldots{},\meta{item_n}|}|
%   \end{syntax}
%   Appends the \meta{items} to the left of the \meta{comma list}.
%   Spaces are removed from both sides of each item.
% \end{function}
%
% \begin{function}[updated = 2011-09-05]
%   {
%     \clist_put_right:Nn,  \clist_put_right:NV,
%     \clist_put_right:No,  \clist_put_right:Nx,
%     \clist_put_right:cn,  \clist_put_right:cV,
%     \clist_put_right:co,  \clist_put_right:cx,
%     \clist_gput_right:Nn, \clist_gput_right:NV,
%     \clist_gput_right:No, \clist_gput_right:Nx,
%     \clist_gput_right:cn, \clist_gput_right:cV,
%     \clist_gput_right:co, \clist_gput_right:cx
%   }
%   \begin{syntax}
%     \cs{clist_put_right:Nn} \meta{comma list} |{|\meta{item_1},\ldots{},\meta{item_n}|}|
%   \end{syntax}
%   Appends the \meta{items} to the right of the \meta{comma list}.
%   Spaces are removed from both sides of each item.
% \end{function}
%
% \section{Modifying comma lists}
%
% While comma lists are normally used as ordered lists, it may be
% necessary to modify the content. The functions here may be used
% to update comma lists, while retaining the order of the unaffected
% entries.
%
% \begin{function}
%   {
%     \clist_remove_duplicates:N,  \clist_remove_duplicates:c,
%     \clist_gremove_duplicates:N, \clist_gremove_duplicates:c
%   }
%   \begin{syntax}
%     \cs{clist_remove_duplicates:N} \meta{comma list}
%   \end{syntax}
%   Removes duplicate items from the \meta{comma list}, leaving the
%   left most copy of each item in the \meta{comma list}.  The \meta{item}
%   comparison takes place on a token basis, as for \cs{tl_if_eq:nn(TF)}.
%   \begin{texnote}
%     This function iterates through every item in the \meta{comma list} and
%     does a comparison with the \meta{items} already checked. It is therefore
%     relatively slow with large comma lists.
%     Furthermore, it will not work if any of the items in the
%     \meta{comma list} contains |{|, |}|, or |#|
%     (assuming the usual \TeX{} category codes apply).
%   \end{texnote}
% \end{function}
%
% \begin{function}[updated = 2011-09-06]
%   {
%     \clist_remove_all:Nn,  \clist_remove_all:cn,
%     \clist_gremove_all:Nn, \clist_gremove_all:cn
%   }
%   \begin{syntax}
%     \cs{clist_remove_all:Nn} \meta{comma list} \Arg{item}
%   \end{syntax}
%   Removes every occurrence of \meta{item} from the \meta{comma list}.
%   The \meta{item} comparison takes place on a token basis, as for
%   \cs{tl_if_eq:nn(TF)}.
%   \begin{texnote}
%     The \meta{item} may not contain |{|, |}|, or |#|
%     (assuming the usual \TeX{} category codes apply).
%   \end{texnote}
% \end{function}
%
% \section{Comma list conditionals}
%
% \begin{function}[EXP,pTF]{\clist_if_empty:N, \clist_if_empty:c}
%   \begin{syntax}
%     \cs{clist_if_empty_p:N} \meta{comma list}
%     \cs{clist_if_empty:NTF} \meta{comma list} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the \meta{comma list} is empty (containing no items).
% \end{function}
%
% \begin{function}[updated = 2011-09-06, TF]
%   {
%      \clist_if_in:Nn, \clist_if_in:NV, \clist_if_in:No,
%      \clist_if_in:cn, \clist_if_in:cV, \clist_if_in:co,
%      \clist_if_in:nn, \clist_if_in:nV, \clist_if_in:no
%   }
%   \begin{syntax}
%     \cs{clist_if_in:NnTF} \meta{comma list} \Arg{item} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the \meta{item} is present in the \meta{comma list}.
%   In the case of an \texttt{n}-type \meta{comma list},
%   spaces are stripped from each item, but braces are not removed.
%   Hence,
%   \begin{verbatim}
%     \clist_if_in:nnTF { a , {b}~ , {b} , c } { b } {true} {false}
%   \end{verbatim}
%   yields \texttt{false}.
%   \begin{texnote}
%     The \meta{item} may not contain |{|, |}|, or |#|
%     (assuming the usual \TeX{} category codes apply),
%     and should not contain |,| nor start or end with a space.
%   \end{texnote}
% \end{function}
%
% \section{Mapping to comma lists}
%
% The functions described in this section apply a specified function
% to each item of a comma list.
%
% When the comma list is given explicitly, as an \texttt{n}-type argument,
% spaces are trimmed around each item.
% If the result of trimming spaces is empty, the item is ignored.
% Otherwise, if the item is surrounded by braces, one set is removed,
% and the result is passed to the mapped function. Thus, if your
% comma list that is being mapped is \verb*|{a , {{b} }, ,{}, {c},}|
% then the arguments passed to the mapped function are
% `\verb*|a|', `\verb*|{b} |', an empty argument, and `\verb*|c|'.
%
% When the comma list is given as an \texttt{N}-type argument, spaces
% have already been trimmed on input, and items are simply stripped
% of one set of braces if any. This case is more efficient than using
% \texttt{n}-type comma lists.
%
% \begin{function}[rEXP, updated = 2012-06-29]
%   {\clist_map_function:NN, \clist_map_function:cN, \clist_map_function:nN}
%   \begin{syntax}
%     \cs{clist_map_function:NN} \meta{comma list} \meta{function}
%   \end{syntax}
%   Applies \meta{function} to every \meta{item} stored in the
%   \meta{comma list}. The \meta{function} will receive one argument for
%   each iteration. The \meta{items} are returned from left to right.
%   The function \cs{clist_map_inline:Nn} is in general more efficient
%   than \cs{clist_map_function:NN}.
%   One mapping may be nested inside another.
% \end{function}
%
% \begin{function}[updated = 2012-06-29]
%   {\clist_map_inline:Nn, \clist_map_inline:cn, \clist_map_inline:nn}
%   \begin{syntax}
%     \cs{clist_map_inline:Nn} \meta{comma list} \Arg{inline function}
%   \end{syntax}
%   Applies \meta{inline function} to every \meta{item} stored
%   within the \meta{comma list}. The \meta{inline function} should
%   consist of code which will receive the \meta{item} as |#1|.
%   One in line mapping can be nested inside another. The \meta{items}
%   are returned from left to right.
% \end{function}
%
% \begin{function}[updated = 2012-06-29]
%   {\clist_map_variable:NNn, \clist_map_variable:cNn, \clist_map_variable:nNn}
%   \begin{syntax}
%     \cs{clist_map_variable:NNn} \meta{comma list} \meta{tl~var.} \Arg{function using tl~var.}
%   \end{syntax}
%   Stores each entry in the \meta{comma list} in turn in the
%   \meta{tl~var.}\ and applies the \meta{function using tl~var.}
%   The \meta{function} will usually consist of code making use of
%   the \meta{tl~var.}, but this is not enforced.  One variable
%   mapping can be nested inside another. The \meta{items}
%   are returned from left to right.
% \end{function}
%
% \begin{function}[rEXP, updated = 2012-06-29]{\clist_map_break:}
%   \begin{syntax}
%     \cs{clist_map_break:}
%   \end{syntax}
%   Used to terminate a \cs{clist_map_\ldots} function before all
%   entries in the \meta{comma list} have been processed. This will
%   normally take place within a conditional statement, for example
%   \begin{verbatim}
%     \clist_map_inline:Nn \l_my_clist
%       {
%         \str_if_eq:nnTF { #1 } { bingo }
%           { \clist_map_break: }
%           {
%             % Do something useful
%           }
%       }
%   \end{verbatim}
%   Use outside of a \cs{clist_map_\ldots} scenario will lead to low
%   level \TeX{} errors.
%   \begin{texnote}
%     When the mapping is broken, additional tokens may be inserted by the
%     internal macro \cs{__prg_break_point:Nn} before further items are taken
%     from the input stream. This will depend on the design of the mapping
%     function.
%   \end{texnote}
% \end{function}
%
% \begin{function}[updated = 2012-06-29, rEXP]{\clist_map_break:n}
%   \begin{syntax}
%     \cs{clist_map_break:n} \Arg{tokens}
%   \end{syntax}
%   Used to terminate a \cs{clist_map_\ldots} function before all
%   entries in the \meta{comma list} have been processed, inserting
%   the \meta{tokens} after the mapping has ended. This will
%   normally take place within a conditional statement, for example
%   \begin{verbatim}
%     \clist_map_inline:Nn \l_my_clist
%       {
%         \str_if_eq:nnTF { #1 } { bingo }
%           { \clist_map_break:n { <tokens> } }
%           {
%             % Do something useful
%           }
%       }
%   \end{verbatim}
%   Use outside of a \cs{clist_map_\ldots} scenario will lead to low
%   level \TeX{} errors.
%   \begin{texnote}
%     When the mapping is broken, additional tokens may be inserted by the
%     internal macro \cs{__prg_break_point:Nn} before the \meta{tokens} are
%     inserted into the input stream.
%     This will depend on the design of the mapping function.
%   \end{texnote}
% \end{function}
%
% \begin{function}[EXP, added = 2012-07-13]
%   {\clist_count:N, \clist_count:c, \clist_count:n}
%   \begin{syntax}
%     \cs{clist_count:N} \meta{comma list}
%   \end{syntax}
%   Leaves the number of items in the \meta{comma list} in the input
%   stream as an \meta{integer denotation}. The total number of items
%   in a \meta{comma list} will include those which are duplicates,
%   \emph{i.e.}~every item in a \meta{comma list} is unique.
% \end{function}
%
% \section{Using the content of comma lists directly}
%
% \begin{function}[EXP, added = 2013-05-26]{\clist_use:Nnnn, \clist_use:cnnn}
%   \begin{syntax}
%     \cs{clist_use:Nnnn} \meta{clist~var} \Arg{separator~between~two} \Arg{separator~between~more~than~two} \Arg{separator~between~final~two}
%   \end{syntax}
%   Places the contents of the \meta{clist~var} in the input stream,
%   with the appropriate \meta{separator} between the items.  Namely, if
%   the comma list has more than two items, the \meta{separator between
%     more than two} is placed between each pair of items except the
%   last, for which the \meta{separator between final two} is used.  If
%   the comma list has exactly two items, then they are placed in the input
%   stream separated by the \meta{separator between two}.  If the comma
%   list has a single item, it is placed in the input stream, and a comma
%   list with no items produces no output.  An error will be raised if
%   the variable does not exist or if it is invalid.
%
%   For example,
%   \begin{verbatim}
%     \clist_set:Nn \l_tmpa_clist { a , b , , c , {de} , f }
%     \clist_use:Nnnn \l_tmpa_clist { ~and~ } { ,~ } { ,~and~ }
%   \end{verbatim}
%   will insert \enquote{\texttt{a, b, c, de, and f}} in the input
%   stream.  The first separator argument is not used in this case
%   because the comma list has more than $2$ items.
%   \begin{texnote}
%     The result is returned within the \tn{unexpanded}
%     primitive (\cs{exp_not:n}), which means that the \meta{items}
%     will not expand further when appearing in an \texttt{x}-type
%     argument expansion.
%   \end{texnote}
% \end{function}
%
% \begin{function}[EXP, added = 2013-05-26]{\clist_use:Nn, \clist_use:cn}
%   \begin{syntax}
%     \cs{clist_use:Nn} \meta{clist~var} \Arg{separator}
%   \end{syntax}
%   Places the contents of the \meta{clist~var} in the input stream,
%   with the \meta{separator} between the items. If the comma
%   list has a single item, it is placed in the input stream, and a comma
%   list with no items produces no output.  An error will be raised if
%   the variable does not exist or if it is invalid.
%
%   For example,
%   \begin{verbatim}
%     \clist_set:Nn \l_tmpa_clist { a , b , , c , {de} , f }
%     \clist_use:Nn \l_tmpa_clist { ~and~ } 
%   \end{verbatim}
%   will insert \enquote{\texttt{a and b and c and de and f}} in the input
%   stream. 
%   \begin{texnote}
%     The result is returned within the \tn{unexpanded}
%     primitive (\cs{exp_not:n}), which means that the \meta{items}
%     will not expand further when appearing in an \texttt{x}-type
%     argument expansion.
%   \end{texnote}
% \end{function}
%
% \section{Comma lists as stacks}
%
% Comma lists can be used as stacks, where data is pushed to and popped
% from the top of the comma list. (The left of a comma list is the top, for
% performance reasons.) The stack functions for comma lists are not
% intended to be mixed with the general ordered data functions detailed
% in the previous section: a comma list should either be used as an
% ordered data type or as a stack, but not in both ways.
%
% \begin{function}[updated = 2012-05-14]{\clist_get:NN, \clist_get:cN}
%   \begin{syntax}
%     \cs{clist_get:NN} \meta{comma list} \meta{token list variable}
%   \end{syntax}
%   Stores the left-most item from a \meta{comma list} in the
%   \meta{token list variable} without removing it from the
%   \meta{comma list}. The \meta{token list variable} is assigned locally.
%   If the \meta{comma list} is empty the \meta{token list variable} will
%   contain the marker value \cs{q_no_value}.
% \end{function}
%
% \begin{function}[TF, added = 2012-05-14]{\clist_get:NN, \clist_get:cN}
%   \begin{syntax}
%     \cs{clist_get:NNTF} \meta{comma list} \meta{token list variable} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   If the \meta{comma list} is empty, leaves the \meta{false code} in the
%   input stream.  The value of the \meta{token list variable} is
%   not defined in this case and should not be relied upon.  If the
%   \meta{comma list} is non-empty, stores the top item from the
%   \meta{comma list} in the \meta{token list variable} without removing it
%   from the \meta{comma list}. The \meta{token list variable} is assigned
%   locally.
% \end{function}
%
% \begin{function}[updated = 2011-09-06]{\clist_pop:NN, \clist_pop:cN}
%   \begin{syntax}
%     \cs{clist_pop:NN} \meta{comma list} \meta{token list variable}
%   \end{syntax}
%   Pops the left-most item from a \meta{comma list} into the
%   \meta{token list variable}, \emph{i.e.}~removes the item from the
%   comma list and stores it in the \meta{token list variable}.
%   Both of the variables are assigned locally.
% \end{function}
%
% \begin{function}{\clist_gpop:NN, \clist_gpop:cN}
%   \begin{syntax}
%     \cs{clist_gpop:NN} \meta{comma list} \meta{token list variable}
%   \end{syntax}
%   Pops the left-most item from a \meta{comma list} into the
%   \meta{token list variable}, \emph{i.e.}~removes the item from the
%   comma list and stores it in the \meta{token list variable}.
%   The \meta{comma list} is modified globally, while the assignment of
%   the \meta{token list variable} is local.
% \end{function}
%
% \begin{function}[TF, added = 2012-05-14]{\clist_pop:NN, \clist_pop:cN}
%   \begin{syntax}
%     \cs{clist_pop:NNTF} \meta{sequence} \meta{token list variable} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   If the \meta{comma list} is empty, leaves the \meta{false code} in the
%   input stream.  The value of the \meta{token list variable} is
%   not defined in this case and should not be relied upon.  If the
%   \meta{comma list} is non-empty, pops the top item from the
%   \meta{comma list} in the \meta{token list variable}, \emph{i.e.}~removes
%   the item from the \meta{comma list}. Both the \meta{comma list} and the
%   \meta{token list variable} are assigned locally.
% \end{function}
%
% \begin{function}[TF, added = 2012-05-14]{\clist_gpop:NN, \clist_gpop:cN}
%   \begin{syntax}
%     \cs{clist_gpop:NNTF} \meta{comma list} \meta{token list variable} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   If the \meta{comma list} is empty, leaves the \meta{false code} in the
%   input stream.  The value of the \meta{token list variable} is
%   not defined in this case and should not be relied upon.  If the
%   \meta{comma list} is non-empty, pops the top item from the
%   \meta{comma list} in the \meta{token list variable}, \emph{i.e.}~removes
%   the item from the \meta{comma list}. The \meta{comma list} is modified
%   globally, while the \meta{token list variable} is assigned locally.
% \end{function}
%
% \begin{function}
%   {
%     \clist_push:Nn,  \clist_push:NV,  \clist_push:No,  \clist_push:Nx,
%     \clist_push:cn,  \clist_push:cV,  \clist_push:co,  \clist_push:cx,
%     \clist_gpush:Nn, \clist_gpush:NV, \clist_gpush:No, \clist_gpush:Nx,
%     \clist_gpush:cn, \clist_gpush:cV, \clist_gpush:co, \clist_gpush:cx
%   }
%   \begin{syntax}
%     \cs{clist_push:Nn} \meta{comma list} \Arg{items}
%   \end{syntax}
%   Adds the \Arg{items} to the top of the \meta{comma list}.
%   Spaces are removed from both sides of each item.
% \end{function}
%
% \section{Viewing comma lists}
%
% \begin{function}[updated = 2012-09-09]{\clist_show:N, \clist_show:c}
%   \begin{syntax}
%     \cs{clist_show:N} \meta{comma list}
%   \end{syntax}
%   Displays the entries in the \meta{comma list} in the terminal.
% \end{function}
%
% \begin{function}[updated = 2012-09-09]{\clist_show:n}
%   \begin{syntax}
%     \cs{clist_show:n} \Arg{tokens}
%   \end{syntax}
%   Displays the entries in the comma list in the terminal.
% \end{function}
%
% \section{Constant and scratch comma lists}
%
% \begin{variable}[added = 2012-07-02]{\c_empty_clist}
%   Constant that is always empty.
% \end{variable}
%
% \begin{variable}[added = 2011-09-06]{\l_tmpa_clist, \l_tmpb_clist}
%   Scratch comma lists for local assignment. These are never used by
%   the kernel code, and so are safe for use with any \LaTeX3-defined
%   function. However, they may be overwritten by other non-kernel
%   code and so should only be used for short-term storage.
% \end{variable}
%
% \begin{variable}[added = 2011-09-06]{\g_tmpa_clist, \g_tmpb_clist}
%   Scratch comma lists for global assignment. These are never used by
%   the kernel code, and so are safe for use with any \LaTeX3-defined
%   function. However, they may be overwritten by other non-kernel
%   code and so should only be used for short-term storage.
% \end{variable}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3clist} implementation}
%
% \TestFiles{m3clist002}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=clist>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\__expl_package_check:
%</package>
%    \end{macrocode}
%
% \begin{variable}{\c_empty_clist}
%   An empty comma list is simply an empty token list.
%    \begin{macrocode}
\cs_new_eq:NN \c_empty_clist \c_empty_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_internal_clist}
%   Scratch space for various internal uses. This comma list variable
%   cannot be declared as such because it comes before \cs{clist_new:N}
%    \begin{macrocode}
\tl_new:N \l_@@_internal_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[aux]{\@@_tmp:w}
%   A temporary function for various purposes.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tmp:w { }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Allocation and initialisation}
%
% \begin{macro}{\clist_new:N,\clist_new:c}
% \UnitTested
%   Internally, comma lists are just token lists.
%    \begin{macrocode}
\cs_new_eq:NN \clist_new:N \tl_new:N
\cs_new_eq:NN \clist_new:c \tl_new:c
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\clist_clear:N, \clist_clear:c}
% \UnitTested
% \begin{macro}{\clist_gclear:N, \clist_gclear:c}
% \UnitTested
%   Clearing comma lists is just the same as clearing token lists.
%    \begin{macrocode}
\cs_new_eq:NN \clist_clear:N  \tl_clear:N
\cs_new_eq:NN \clist_clear:c  \tl_clear:c
\cs_new_eq:NN \clist_gclear:N \tl_gclear:N
\cs_new_eq:NN \clist_gclear:c \tl_gclear:c
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\clist_clear_new:N, \clist_clear_new:c}
% \UnitTested
% \begin{macro}{\clist_gclear_new:N, \clist_gclear_new:c}
% \UnitTested
%   Once again a copy from the token list functions.
%    \begin{macrocode}
\cs_new_eq:NN \clist_clear_new:N  \tl_clear_new:N
\cs_new_eq:NN \clist_clear_new:c  \tl_clear_new:c
\cs_new_eq:NN \clist_gclear_new:N \tl_gclear_new:N
\cs_new_eq:NN \clist_gclear_new:c \tl_gclear_new:c
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {\clist_set_eq:NN, \clist_set_eq:cN, \clist_set_eq:Nc, \clist_set_eq:cc}
% \UnitTested
% \begin{macro}
%   {
%     \clist_gset_eq:NN, \clist_gset_eq:cN,
%     \clist_gset_eq:Nc, \clist_gset_eq:cc
%   }
% \UnitTested
%   Once again, these are simple copies from the token list functions.
%    \begin{macrocode}
\cs_new_eq:NN \clist_set_eq:NN  \tl_set_eq:NN
\cs_new_eq:NN \clist_set_eq:Nc  \tl_set_eq:Nc
\cs_new_eq:NN \clist_set_eq:cN  \tl_set_eq:cN
\cs_new_eq:NN \clist_set_eq:cc  \tl_set_eq:cc
\cs_new_eq:NN \clist_gset_eq:NN \tl_gset_eq:NN
\cs_new_eq:NN \clist_gset_eq:Nc \tl_gset_eq:Nc
\cs_new_eq:NN \clist_gset_eq:cN \tl_gset_eq:cN
\cs_new_eq:NN \clist_gset_eq:cc \tl_gset_eq:cc
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\clist_concat:NNN, \clist_concat:ccc}
% \UnitTested
% \begin{macro}{\clist_gconcat:NNN, \clist_gconcat:ccc}
% \UnitTested
% \begin{macro}[aux]{\@@_concat:NNNN}
%   Concatenating comma lists is not quite as easy as it seems, as
%   there needs to be the correct addition of a comma to the output. So
%   a little work to do.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \clist_concat:NNN
  { \@@_concat:NNNN \tl_set:Nx }
\cs_new_protected_nopar:Npn \clist_gconcat:NNN
  { \@@_concat:NNNN \tl_gset:Nx }
\cs_new_protected:Npn \@@_concat:NNNN #1#2#3#4
  {
    #1 #2
      {
        \exp_not:o #3
        \clist_if_empty:NF #3 { \clist_if_empty:NF #4 { , } }
        \exp_not:o #4
      }
  }
\cs_generate_variant:Nn \clist_concat:NNN  { ccc }
\cs_generate_variant:Nn \clist_gconcat:NNN { ccc }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF]{\clist_if_exist:N, \clist_if_exist:c}
%   Copies of the \texttt{cs} functions defined in \pkg{l3basics}.
%    \begin{macrocode}
\prg_new_eq_conditional:NNn \clist_if_exist:N \cs_if_exist:N { TF , T , F , p }
\prg_new_eq_conditional:NNn \clist_if_exist:c \cs_if_exist:c { TF , T , F , p }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Removing spaces around items}
%
% \begin{macro}[int,EXP]{\@@_trim_spaces_generic:nw}
% \begin{macro}[aux]{\@@_trim_spaces_generic:nn}
%   \begin{syntax}
%     \cs{@@_trim_spaces_generic:nw} \Arg{code} \cs{q_mark} \meta{item} |,|
%   \end{syntax}
%   This expands to the \meta{code}, followed by a brace group
%   containing the \meta{item}, with leading and trailing spaces
%   removed.  The calling function is responsible for inserting
%   \cs{q_mark} in front of the \meta{item}, as well as testing for the
%   end of the list.  We reuse a \pkg{l3tl} internal function, whose
%   first argument must start with \cs{q_mark}.  That trims the item
%   |#2|, then feeds the result (after having to do an \texttt{o}-type
%   expansion) to \cs{@@_trim_spaces_generic:nn} which places the
%   \meta{code} in front of the \meta{trimmed item}.
%    \begin{macrocode}
\cs_new:Npn \@@_trim_spaces_generic:nw #1#2 ,
  {
    \__tl_trim_spaces:nn {#2}
      { \exp_args:No \@@_trim_spaces_generic:nn } {#1}
  }
\cs_new:Npn \@@_trim_spaces_generic:nn #1#2 { #2 {#1} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int,rEXP]{\@@_trim_spaces:n}
% \begin{macro}[aux]{\@@_trim_spaces:nn}
%   The first argument of \cs{@@_trim_spaces:nn} is initially empty,
%   and later a comma, namely, as soon as we have added an item to the
%   resulting list. The auxiliary tests for the end of the list,
%   and also prevents empty arguments from finding their way into the
%   output.
%    \begin{macrocode}
\cs_new:Npn \@@_trim_spaces:n #1
  {
    \@@_trim_spaces_generic:nw
      { \@@_trim_spaces:nn { } }
      \q_mark #1 ,
    \q_recursion_tail, \q_recursion_stop
  }
\cs_new:Npn \@@_trim_spaces:nn #1 #2
  {
    \quark_if_recursion_tail_stop:n {#2}
    \tl_if_empty:nTF {#2}
      {
        \@@_trim_spaces_generic:nw
          { \@@_trim_spaces:nn {#1} } \q_mark
      }
      {
        #1 \exp_not:n {#2}
        \@@_trim_spaces_generic:nw
          { \@@_trim_spaces:nn { , } } \q_mark
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Adding data to comma lists}
%
% \begin{macro}
%   {
%     \clist_set:Nn, \clist_set:NV,
%     \clist_set:No, \clist_set:Nx,
%     \clist_set:cn, \clist_set:cV,
%     \clist_set:co, \clist_set:cx
%   }
% \begin{macro}
%   {
%     \clist_gset:Nn, \clist_gset:NV,
%     \clist_gset:No, \clist_gset:Nx,
%     \clist_gset:cn, \clist_gset:cV,
%     \clist_gset:co, \clist_gset:cx
%   }
%    \begin{macrocode}
\cs_new_protected:Npn \clist_set:Nn #1#2
  { \tl_set:Nx #1 { \@@_trim_spaces:n {#2} } }
\cs_new_protected:Npn \clist_gset:Nn #1#2
  { \tl_gset:Nx #1 { \@@_trim_spaces:n {#2} } }
\cs_generate_variant:Nn \clist_set:Nn  { NV , No , Nx , c , cV , co , cx }
\cs_generate_variant:Nn \clist_gset:Nn { NV , No , Nx , c , cV , co , cx }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {
%     \clist_put_left:Nn, \clist_put_left:NV,
%     \clist_put_left:No, \clist_put_left:Nx,
%     \clist_put_left:cn, \clist_put_left:cV,
%     \clist_put_left:co, \clist_put_left:cx
%   }
% \UnitTested
% \begin{macro}
%   {
%     \clist_gput_left:Nn, \clist_gput_left:NV,
%     \clist_gput_left:No, \clist_gput_left:Nx,
%     \clist_gput_left:cn, \clist_gput_left:cV,
%     \clist_gput_left:co, \clist_gput_left:cx
%   }
% \UnitTested
% \begin{macro}[aux]{\@@_put_left:NNNn}
%   Comma lists cannot hold empty values: there are therefore a couple
%   of sanity checks to avoid accumulating commas.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \clist_put_left:Nn
  { \@@_put_left:NNNn \clist_concat:NNN \clist_set:Nn }
\cs_new_protected_nopar:Npn \clist_gput_left:Nn
  { \@@_put_left:NNNn \clist_gconcat:NNN \clist_set:Nn }
\cs_new_protected:Npn \@@_put_left:NNNn #1#2#3#4
  {
    #2 \l_@@_internal_clist {#4}
    #1 #3 \l_@@_internal_clist #3
  }
\cs_generate_variant:Nn \clist_put_left:Nn  {     NV , No , Nx }
\cs_generate_variant:Nn \clist_put_left:Nn  { c , cV , co , cx }
\cs_generate_variant:Nn \clist_gput_left:Nn {     NV , No , Nx }
\cs_generate_variant:Nn \clist_gput_left:Nn { c , cV , co , cx }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {
%     \clist_put_right:Nn, \clist_put_right:NV,
%     \clist_put_right:No, \clist_put_right:Nx,
%     \clist_put_right:cn, \clist_put_right:cV,
%     \clist_put_right:co, \clist_put_right:cx
%   }
% \UnitTested
% \begin{macro}
%   {
%     \clist_gput_right:Nn, \clist_gput_right:NV,
%     \clist_gput_right:No, \clist_gput_right:Nx,
%     \clist_gput_right:cn, \clist_gput_right:cV,
%     \clist_gput_right:co, \clist_gput_right:cx
%   }
% \UnitTested
% \begin{macro}[aux]{\@@_put_right:NNNn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \clist_put_right:Nn
  { \@@_put_right:NNNn \clist_concat:NNN \clist_set:Nn }
\cs_new_protected_nopar:Npn \clist_gput_right:Nn
  { \@@_put_right:NNNn \clist_gconcat:NNN \clist_set:Nn }
\cs_new_protected:Npn \@@_put_right:NNNn #1#2#3#4
  {
    #2 \l_@@_internal_clist {#4}
    #1 #3 #3 \l_@@_internal_clist
  }
\cs_generate_variant:Nn \clist_put_right:Nn  {     NV , No , Nx }
\cs_generate_variant:Nn \clist_put_right:Nn  { c , cV , co , cx }
\cs_generate_variant:Nn \clist_gput_right:Nn {     NV , No , Nx }
\cs_generate_variant:Nn \clist_gput_right:Nn { c , cV , co , cx }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Comma lists as stacks}
%
% \begin{macro}{\clist_get:NN, \clist_get:cN}
% \UnitTested
% \begin{macro}[aux]{\@@_get:wN}
%   Getting an item from the left of a comma list is pretty easy: just
%   trim off the first item using the comma.
%    \begin{macrocode}
\cs_new_protected:Npn \clist_get:NN #1#2
  {
    \if_meaning:w #1 \c_empty_clist
      \tl_set:Nn #2 { \q_no_value }
    \else:
      \exp_after:wN \@@_get:wN #1 , \q_stop #2
    \fi:
  }
\cs_new_protected:Npn \@@_get:wN #1 , #2 \q_stop #3
  { \tl_set:Nn #3 {#1} }
\cs_generate_variant:Nn \clist_get:NN { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\clist_pop:NN, \clist_pop:cN}
% \UnitTested
% \begin{macro}{\clist_gpop:NN, \clist_gpop:cN}
% \UnitTested
% \begin{macro}[aux]
%   {\@@_pop:NNN, \@@_pop:wwNNN, \@@_pop:wN}
%   An empty clist leads to \cs{q_no_value}, otherwise grab until the
%   first comma and assign to the variable.  The second argument of
%   \cs{@@_pop:wwNNN} is a comma list ending in a comma and
%   \cs{q_mark}, unless the original clist contained exactly one item:
%   then the argument is just \cs{q_mark}.  The next auxiliary picks
%   either \cs{exp_not:n} or \cs{use_none:n} as |#2|, ensuring that the
%   result can safely be an empty comma list.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \clist_pop:NN
  { \@@_pop:NNN \tl_set:Nx }
\cs_new_protected_nopar:Npn \clist_gpop:NN
  { \@@_pop:NNN \tl_gset:Nx }
\cs_new_protected:Npn \@@_pop:NNN #1#2#3
  {
    \if_meaning:w #2 \c_empty_clist
      \tl_set:Nn #3 { \q_no_value }
    \else:
      \exp_after:wN \@@_pop:wwNNN #2 , \q_mark \q_stop #1#2#3
    \fi:
  }
\cs_new_protected:Npn \@@_pop:wwNNN #1 , #2 \q_stop #3#4#5
  {
    \tl_set:Nn #5 {#1}
    #3 #4
      {
        \@@_pop:wN \prg_do_nothing:
          #2 \exp_not:o
          , \q_mark \use_none:n
        \q_stop
      }
  }
\cs_new:Npn \@@_pop:wN #1 , \q_mark #2 #3 \q_stop { #2 {#1} }
\cs_generate_variant:Nn \clist_pop:NN  { c }
\cs_generate_variant:Nn \clist_gpop:NN { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[TF]{\clist_get:NN, \clist_get:cN}
% \begin{macro}[TF]{\clist_pop:NN, \clist_pop:cN}
% \begin{macro}[TF]{\clist_gpop:NN, \clist_gpop:cN}
% \begin{macro}[aux]{\@@_pop_TF:NNN}
%   The same, as branching code: very similar to the above.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \clist_get:NN #1#2 { T , F , TF }
  {
    \if_meaning:w #1 \c_empty_clist
      \prg_return_false:
    \else:
      \exp_after:wN \@@_get:wN #1 , \q_stop #2
      \prg_return_true:
    \fi:
  }
\cs_generate_variant:Nn \clist_get:NNT  { c }
\cs_generate_variant:Nn \clist_get:NNF  { c }
\cs_generate_variant:Nn \clist_get:NNTF { c }
\prg_new_protected_conditional:Npnn \clist_pop:NN #1#2 { T , F , TF }
  { \@@_pop_TF:NNN \tl_set:Nx #1 #2 }
\prg_new_protected_conditional:Npnn \clist_gpop:NN #1#2 { T , F , TF }
  { \@@_pop_TF:NNN \tl_gset:Nx #1 #2 }
\cs_new_protected:Npn \@@_pop_TF:NNN #1#2#3
  {
    \if_meaning:w #2 \c_empty_clist
      \prg_return_false:
    \else:
      \exp_after:wN \@@_pop:wwNNN #2 , \q_mark \q_stop #1#2#3
      \prg_return_true:
    \fi:
  }
\cs_generate_variant:Nn \clist_pop:NNT   { c }
\cs_generate_variant:Nn \clist_pop:NNF   { c }
\cs_generate_variant:Nn \clist_pop:NNTF  { c }
\cs_generate_variant:Nn \clist_gpop:NNT  { c }
\cs_generate_variant:Nn \clist_gpop:NNF  { c }
\cs_generate_variant:Nn \clist_gpop:NNTF { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{
%   \clist_push:Nn, \clist_push:NV, \clist_push:No, \clist_push:Nx,
%   \clist_push:cn, \clist_push:cV, \clist_push:co, \clist_push:cx
% }
% \UnitTested
% \begin{macro}{
%   \clist_gpush:Nn, \clist_gpush:NV, \clist_gpush:No, \clist_gpush:Nx,
%   \clist_gpush:cn, \clist_gpush:cV, \clist_gpush:co, \clist_gpush:cx
% }
% \UnitTested
%   Pushing to a comma list is the same as adding on the left.
%    \begin{macrocode}
\cs_new_eq:NN \clist_push:Nn  \clist_put_left:Nn
\cs_new_eq:NN \clist_push:NV  \clist_put_left:NV
\cs_new_eq:NN \clist_push:No  \clist_put_left:No
\cs_new_eq:NN \clist_push:Nx  \clist_put_left:Nx
\cs_new_eq:NN \clist_push:cn  \clist_put_left:cn
\cs_new_eq:NN \clist_push:cV  \clist_put_left:cV
\cs_new_eq:NN \clist_push:co  \clist_put_left:co
\cs_new_eq:NN \clist_push:cx  \clist_put_left:cx
\cs_new_eq:NN \clist_gpush:Nn \clist_gput_left:Nn
\cs_new_eq:NN \clist_gpush:NV \clist_gput_left:NV
\cs_new_eq:NN \clist_gpush:No \clist_gput_left:No
\cs_new_eq:NN \clist_gpush:Nx \clist_gput_left:Nx
\cs_new_eq:NN \clist_gpush:cn \clist_gput_left:cn
\cs_new_eq:NN \clist_gpush:cV \clist_gput_left:cV
\cs_new_eq:NN \clist_gpush:co \clist_gput_left:co
\cs_new_eq:NN \clist_gpush:cx \clist_gput_left:cx
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Modifying comma lists}
%
% \begin{variable}{\l_@@_internal_remove_clist}
%   An internal comma list for the removal routines.
%    \begin{macrocode}
\clist_new:N \l_@@_internal_remove_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\clist_remove_duplicates:N, \clist_remove_duplicates:c}
% \UnitTested
% \begin{macro}{\clist_gremove_duplicates:N, \clist_gremove_duplicates:c}
% \UnitTested
% \begin{macro}[aux]{\@@_remove_duplicates:NN}
%   Removing duplicates means making a new list then copying it.
%    \begin{macrocode}
\cs_new_protected:Npn \clist_remove_duplicates:N
  { \@@_remove_duplicates:NN \clist_set_eq:NN }
\cs_new_protected:Npn \clist_gremove_duplicates:N
  { \@@_remove_duplicates:NN \clist_gset_eq:NN }
\cs_new_protected:Npn \@@_remove_duplicates:NN #1#2
  {
    \clist_clear:N \l_@@_internal_remove_clist
    \clist_map_inline:Nn #2
      {
        \clist_if_in:NnF \l_@@_internal_remove_clist {##1}
          { \clist_put_right:Nn \l_@@_internal_remove_clist {##1} }
      }
    #1 #2 \l_@@_internal_remove_clist
  }
\cs_generate_variant:Nn \clist_remove_duplicates:N  { c }
\cs_generate_variant:Nn \clist_gremove_duplicates:N { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\clist_remove_all:Nn, \clist_remove_all:cn}
% \UnitTested
% \begin{macro}{\clist_gremove_all:Nn, \clist_gremove_all:cn}
% \UnitTested
% \begin{macro}[aux]{\@@_remove_all:NNn}
% \begin{macro}[aux]{\@@_remove_all:w}
% \begin{macro}[aux]{\@@_remove_all:}
%   The method used here is very similar to \cs{tl_replace_all:Nnn}.
%   Build a function delimited by the \meta{item} that should be removed,
%   surrounded with commas, and call that function followed by
%   the expanded comma list, and another copy of the \meta{item}.
%   The loop is controlled by the argument grabbed by
%   \cs{@@_remove_all:w}: when the item was found,
%   the \cs{q_mark} delimiter used is the one inserted by
%   \cs{@@_tmp:w}, and \cs{use_none_delimit_by_q_stop:w}
%   is deleted. At the end, the final \meta{item} is
%   grabbed, and the argument of \cs{@@_tmp:w} contains
%   \cs{q_mark}: in that case, \cs{@@_remove_all:w}
%   removes the second \cs{q_mark} (inserted by \cs{@@_tmp:w}),
%   and lets \cs{use_none_delimit_by_q_stop:w} act.
%
%   No brace is lost because items are always grabbed with a leading comma.
%   The result of the first assignment has an extra leading comma,
%   which we remove in a second assignment.
%   Two exceptions: if the clist lost all of its elements, the result
%   is empty, and we shouldn't remove anything; if the clist started up
%   empty, the first step happens to turn it into a single comma, and
%   the second step removes it.
%    \begin{macrocode}
\cs_new_protected:Npn \clist_remove_all:Nn
  { \@@_remove_all:NNn \tl_set:Nx }
\cs_new_protected:Npn \clist_gremove_all:Nn
  { \@@_remove_all:NNn \tl_gset:Nx }
\cs_new_protected:Npn \@@_remove_all:NNn #1#2#3
  {
    \cs_set:Npn \@@_tmp:w ##1 , #3 ,
      {
        ##1
        , \q_mark , \use_none_delimit_by_q_stop:w ,
        \@@_remove_all:
      }
    #1 #2
      {
        \exp_after:wN \@@_remove_all:
        #2 , \q_mark , #3 , \q_stop
      }
    \clist_if_empty:NF #2
      {
        #1 #2
          {
            \exp_args:No \exp_not:o
              { \exp_after:wN \use_none:n #2 }
          }
      }
  }
\cs_new:Npn \@@_remove_all:
  { \exp_after:wN \@@_remove_all:w \@@_tmp:w , }
\cs_new:Npn \@@_remove_all:w #1 , \q_mark , #2 , { \exp_not:n {#1} }
\cs_generate_variant:Nn \clist_remove_all:Nn  { c }
\cs_generate_variant:Nn \clist_gremove_all:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Comma list conditionals}
%
% \begin{macro}[pTF]{\clist_if_empty:N, \clist_if_empty:c}
% \UnitTested
%   Simple copies from the token list variable material.
%    \begin{macrocode}
\prg_new_eq_conditional:NNn \clist_if_empty:N \tl_if_empty:N { p , T , F , TF }
\prg_new_eq_conditional:NNn \clist_if_empty:c \tl_if_empty:c { p , T , F , TF }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]
%   {
%     \clist_if_in:Nn, \clist_if_in:NV, \clist_if_in:No,
%     \clist_if_in:cn, \clist_if_in:cV, \clist_if_in:co,
%     \clist_if_in:nn, \clist_if_in:nV, \clist_if_in:no
%   }
% \begin{macro}[aux]{\@@_if_in_return:nn}
% \UnitTested
%   See description of the \cs{tl_if_in:Nn} function for details.
%   We simply surround the comma list, and the item, with commas.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \clist_if_in:Nn #1#2 { T  , F , TF }
  {
    \exp_args:No \@@_if_in_return:nn #1 {#2}
  }
\prg_new_protected_conditional:Npnn \clist_if_in:nn #1#2 { T  , F , TF }
  {
    \clist_set:Nn \l_@@_internal_clist {#1}
    \exp_args:No \@@_if_in_return:nn \l_@@_internal_clist {#2}
  }
\cs_new_protected:Npn \@@_if_in_return:nn #1#2
  {
    \cs_set:Npn \@@_tmp:w ##1 ,#2, { }
    \tl_if_empty:oTF
      { \@@_tmp:w ,#1, {} {} ,#2, }
      { \prg_return_false: } { \prg_return_true: }
  }
\cs_generate_variant:Nn \clist_if_in:NnT  {     NV , No }
\cs_generate_variant:Nn \clist_if_in:NnT  { c , cV , co }
\cs_generate_variant:Nn \clist_if_in:NnF  {     NV , No }
\cs_generate_variant:Nn \clist_if_in:NnF  { c , cV , co }
\cs_generate_variant:Nn \clist_if_in:NnTF {     NV , No }
\cs_generate_variant:Nn \clist_if_in:NnTF { c , cV , co }
\cs_generate_variant:Nn \clist_if_in:nnT  {     nV , no }
\cs_generate_variant:Nn \clist_if_in:nnF  {     nV , no }
\cs_generate_variant:Nn \clist_if_in:nnTF {     nV , no }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Mapping to comma lists}
%
% \begin{macro}{\clist_map_function:NN, \clist_map_function:cN}
% \UnitTested
% \begin{macro}[aux]{\@@_map_function:Nw}
%   If the variable is empty, the mapping is skipped (otherwise,
%   that comma-list would be seen as consisting of one empty item).
%   Then loop over the comma-list, grabbing one comma-delimited
%   item at a time. The end is marked by \cs{q_recursion_tail}.
%   The auxiliary function \cs{@@_map_function:Nw} is used
%   directly in \cs{clist_map_inline:Nn}. Change with care.
%    \begin{macrocode}
\cs_new:Npn \clist_map_function:NN #1#2
  {
    \clist_if_empty:NF #1
      {
        \exp_last_unbraced:NNo \@@_map_function:Nw #2 #1
          , \q_recursion_tail ,
        \__prg_break_point:Nn \clist_map_break: { }
      }
  }
\cs_new:Npn \@@_map_function:Nw #1#2 ,
  {
    \__quark_if_recursion_tail_break:nN {#2} \clist_map_break:
    #1 {#2}
    \@@_map_function:Nw #1
  }
\cs_generate_variant:Nn \clist_map_function:NN { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\clist_map_function:nN}
% \UnitTested
% \begin{macro}[aux]{\@@_map_function_n:Nn}
% \begin{macro}[aux]{\@@_map_unbrace:Nw}
%   The \texttt{n}-type mapping function is a bit more awkward,
%   since spaces must be trimmed from each item.
%   Space trimming is again based on \cs{@@_trim_spaces_generic:nw}.
%   The auxiliary \cs{@@_map_function_n:Nn} receives
%   as arguments the function, and the result of removing leading
%   and trailing spaces from the item which lies until the next comma.
%   Empty items are ignored, then one level of braces is removed
%   by \cs{@@_map_unbrace:Nw}.
%    \begin{macrocode}
\cs_new:Npn \clist_map_function:nN #1#2
  {
    \@@_trim_spaces_generic:nw { \@@_map_function_n:Nn #2 }
    \q_mark #1, \q_recursion_tail,
    \__prg_break_point:Nn \clist_map_break: { }
  }
\cs_new:Npn \@@_map_function_n:Nn #1 #2
  {
    \__quark_if_recursion_tail_break:nN {#2} \clist_map_break:
    \tl_if_empty:nF {#2} { \@@_map_unbrace:Nw #1 #2, }
    \@@_trim_spaces_generic:nw { \@@_map_function_n:Nn #1 }
    \q_mark
  }
\cs_new:Npn \@@_map_unbrace:Nw #1 #2, { #1 {#2} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\clist_map_inline:Nn, \clist_map_inline:cn}
% \UnitTested
% \begin{macro}{\clist_map_inline:nn}
% \UnitTested
%   Inline mapping is done by creating a suitable function
%   \enquote{on the fly}: this is done globally to avoid
%   any issues with \TeX{}'s groups.  We use a different
%   function for each level of nesting.
%
%   Since the mapping is non-expandable,  we can perform
%   the space-trimming  needed by the \texttt{n} version
%   simply  by storing the comma-list in a variable.  We
%   don't need  a different comma-list  for each nesting
%   level: the comma-list is expanded before the mapping
%   starts.
%    \begin{macrocode}
\cs_new_protected:Npn \clist_map_inline:Nn #1#2
  {
    \clist_if_empty:NF #1
      {
        \int_gincr:N \g__prg_map_int
        \cs_gset:cpn { __prg_map_ \int_use:N \g__prg_map_int :w } ##1 {#2}
        \exp_last_unbraced:Nco \@@_map_function:Nw
          { __prg_map_ \int_use:N \g__prg_map_int :w }
          #1 , \q_recursion_tail ,
        \__prg_break_point:Nn \clist_map_break:
          { \int_gdecr:N \g__prg_map_int }
      }
  }
\cs_new_protected:Npn \clist_map_inline:nn #1
  {
    \clist_set:Nn \l_@@_internal_clist {#1}
    \clist_map_inline:Nn \l_@@_internal_clist
  }
\cs_generate_variant:Nn \clist_map_inline:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\clist_map_variable:NNn, \clist_map_variable:cNn}
% \UnitTested
% \begin{macro}{\clist_map_variable:nNn}
% \begin{macro}[aux]{\@@_map_variable:Nnw}
%   As for other comma-list mappings, filter out the case of
%   an empty list. Same approach as \cs{clist_map_function:Nn},
%   additionally we store each item in the given variable.
%   As for inline mappings, space trimming for the \texttt{n}
%   variant is done by storing the comma list in a variable.
%    \begin{macrocode}
\cs_new_protected:Npn \clist_map_variable:NNn #1#2#3
  {
    \clist_if_empty:NF #1
      {
        \exp_args:Nno \use:nn
          { \@@_map_variable:Nnw #2 {#3} }
          #1
          , \q_recursion_tail , \q_recursion_stop
        \__prg_break_point:Nn \clist_map_break: { }
      }
  }
\cs_new_protected:Npn \clist_map_variable:nNn #1
  {
    \clist_set:Nn \l_@@_internal_clist {#1}
    \clist_map_variable:NNn \l_@@_internal_clist
  }
\cs_new_protected:Npn \@@_map_variable:Nnw #1#2#3,
  {
    \tl_set:Nn #1 {#3}
    \quark_if_recursion_tail_stop:N #1
    \use:n {#2}
    \@@_map_variable:Nnw #1 {#2}
  }
\cs_generate_variant:Nn \clist_map_variable:NNn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\clist_map_break:, \clist_map_break:n}
%   The break statements use the general \cs{__prg_map_break:Nn} mechanism.
%    \begin{macrocode}
\cs_new_nopar:Npn \clist_map_break:
  { \__prg_map_break:Nn \clist_map_break: { } }
\cs_new_nopar:Npn \clist_map_break:n
  { \__prg_map_break:Nn \clist_map_break: }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\clist_count:N, \clist_count:c, \clist_count:n}
% \begin{macro}[aux]{\@@_count:n}
% \begin{macro}[aux]{\@@_count:w}
%   Counting the items in a comma list is done using the same approach as for
%   other token count functions: turn each entry into a \texttt{+1} then use
%   integer evaluation to actually do the mathematics.
%   In the case of an \texttt{n}-type comma-list, we could of course use
%   \cs{clist_map_function:nN}, but that is very slow, because it carefully
%   removes spaces. Instead, we loop manually, and skip blank items
%   (but not |{}|, hence the extra spaces).
%    \begin{macrocode}
\cs_new:Npn \clist_count:N #1
  {
    \int_eval:n
      {
        0
        \clist_map_function:NN #1 \@@_count:n
      }
  }
\cs_generate_variant:Nn \clist_count:N { c }
\cs_new:Npx \clist_count:n #1
  {
    \exp_not:N \int_eval:n
      {
        0
        \exp_not:N \@@_count:w \c_space_tl
        #1 \exp_not:n { , \q_recursion_tail , \q_recursion_stop }
      }
  }
\cs_new:Npn \@@_count:n #1 { + \c_one }
\cs_new:Npx \@@_count:w #1 ,
  {
    \exp_not:n { \exp_args:Nf \quark_if_recursion_tail_stop:n } {#1}
    \exp_not:N \tl_if_blank:nF {#1} { + \c_one }
    \exp_not:N \@@_count:w \c_space_tl
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Using comma lists}
%
% \begin{macro}[EXP]{\clist_use:Nnnn, \clist_use:cnnn}
% \begin{macro}[EXP, aux]
%   {\@@_use:wwn, \@@_use:nwwwwnwn, \@@_use:nwwn}
% \begin{macro}[EXP]{\clist_use:Nn, \clist_use:cn}
%   First check that the variable exists.  Then count the items in the
%   comma list.  If it has none, output nothing.  If it has one item,
%   output that item, brace stripped (note that space-trimming has
%   already been done when the comma list was assigned).  If it has two,
%   place the \meta{separator~between~two} in the middle.
%
%   Otherwise, \cs{@@_use:nwwwwnwn} takes the following arguments; 1:
%   a \meta{separator}, 2, 3, 4: three items from the comma list (or
%   quarks), 5: the rest of the comma list, 6: a \meta{continuation}
%   function (\texttt{use_ii} or \texttt{use_iii} with its
%   \meta{separator} argument), 7: junk, and 8: the temporary result,
%   which is built in a brace group following \cs{q_stop}.  The
%   \meta{separator} and the first of the three items are placed in the
%   result, then we use the \meta{continuation}, placing the remaining
%   two items after it.  When we begin this loop, the three items really
%   belong to the comma list, the first \cs{q_mark} is taken as a
%   delimiter to the \texttt{use_ii} function, and the continuation is
%   \texttt{use_ii} itself.  When we reach the last two items of the
%   original token list, \cs{q_mark} is taken as a third item, and now
%   the second \cs{q_mark} serves as a delimiter to \texttt{use_ii},
%   switching to the other \meta{continuation}, \texttt{use_iii}, which
%   uses the \meta{separator between final two}.
%    \begin{macrocode}
\cs_new:Npn \clist_use:Nnnn #1#2#3#4
  {
    \clist_if_exist:NTF #1
      {
        \int_case:nnn { \clist_count:N #1 }
          {
            { 0 } { }
            { 1 } { \exp_after:wN \@@_use:wwn #1 , , { } }
            { 2 } { \exp_after:wN \@@_use:wwn #1 , {#2} }
          }
          {
            \exp_after:wN \@@_use:nwwwwnwn
            \exp_after:wN { \exp_after:wN } #1 ,
            \q_mark , { \@@_use:nwwwwnwn {#3} }
            \q_mark , { \@@_use:nwwn {#4} }
            \q_stop { }
          }
      }
      { \__msg_kernel_expandable_error:nnn { kernel } { bad-variable } {#1} }
  }
\cs_generate_variant:Nn \clist_use:Nnnn { c }
\cs_new:Npn \@@_use:wwn #1 , #2 , #3 { \exp_not:n { #1 #3 #2 } }
\cs_new:Npn \@@_use:nwwwwnwn
    #1#2 , #3 , #4 , #5 \q_mark , #6#7 \q_stop #8
  { #6 {#3} , {#4} , #5 \q_mark , {#6} #7 \q_stop { #8 #1 #2 } }
\cs_new:Npn \@@_use:nwwn #1#2 , #3 \q_stop #4
  { \exp_not:n { #4 #1 #2 } }
\cs_new:Npn \clist_use:Nn #1#2
  { \clist_use:Nnnn #1 {#2} {#2} {#2} }
\cs_generate_variant:Nn \clist_use:Nn { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Viewing comma lists}
%
% \begin{macro}{\clist_show:N, \clist_show:c}
% \begin{macro}{\clist_show:n}
%   Apply the general \cs{__msg_show_variable:Nnn}. In the case
%   of an \texttt{n}-type comma-list, first store it
%   in a scratch variable, then show that variable:
%   The message takes care of omitting its name.
%    \begin{macrocode}
\cs_new_protected:Npn \clist_show:N #1
  {
    \__msg_show_variable:Nnn #1 { clist }
      { \clist_map_function:NN #1 \__msg_show_item:n }
  }
\cs_new_protected:Npn \clist_show:n #1
  {
    \clist_set:Nn \l_@@_internal_clist {#1}
    \clist_show:N \l_@@_internal_clist
  }
\cs_generate_variant:Nn \clist_show:N { c }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Scratch comma lists}
%
% \begin{variable}{\l_tmpa_clist, \l_tmpb_clist}
% \begin{variable}{\g_tmpa_clist, \g_tmpb_clist}
%   Temporary comma list variables.
%    \begin{macrocode}
\clist_new:N \l_tmpa_clist
\clist_new:N \l_tmpb_clist
\clist_new:N \g_tmpa_clist
\clist_new:N \g_tmpb_clist
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \subsection{Deprecated interfaces}
%
% Deprecated on 2011-05-27, for removal by 2011-08-31.
%
% \begin{macro}{\clist_top:NN, \clist_top:cN}
% \UnitTested
%   These are old stack functions.
%    \begin{macrocode}
%<*deprecated>
\cs_new_eq:NN \clist_top:NN \clist_get:NN
\cs_new_eq:NN \clist_top:cN \clist_get:cN
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\clist_remove_element:Nn,\clist_gremove_element:Nn}
% \UnitTested
%   An older name for \cs{clist_remove_all:Nn}.
%    \begin{macrocode}
%<*deprecated>
\cs_new_eq:NN \clist_remove_element:Nn  \clist_remove_all:Nn
\cs_new_eq:NN \clist_gremove_element:Nn \clist_gremove_all:Nn
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\clist_display:N, \clist_display:c}
%   An older name for \cs{clist_show:N}.
%    \begin{macrocode}
%<*deprecated>
\cs_new_eq:NN \clist_display:N \clist_show:N
\cs_new_eq:NN \clist_display:c \clist_show:c
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% Deprecated on 2011-09-05, for removal by 2011-12-31.
%
% \begin{macro}
%   {
%     \clist_trim_spaces:N, \clist_trim_spaces:c,
%     \clist_gtrim_spaces:N, \clist_gtrim_spaces:c
%   }
%   Since clist items are now always stripped from their surrounding
%   spaces, it is redundant to provide these functions.
%   The \cs{@@_trim_spaces:n} function is now internal,
%   deprecated for use outside the kernel.
%    \begin{macrocode}
%<*deprecated>
\cs_new_protected:Npn \clist_trim_spaces:N  #1 { \clist_set:No  #1 {#1} }
\cs_new_protected:Npn \clist_gtrim_spaces:N #1 { \clist_gset:No #1 {#1} }
\cs_generate_variant:Nn \clist_trim_spaces:N  { c }
\cs_generate_variant:Nn \clist_gtrim_spaces:N { c }
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% Deprecated on 2012-05-10, for removal by 2012-08-31.
%
% \begin{macro}[pTF]
%   {\clist_if_eq:NN, \clist_if_eq:Nc, \clist_if_eq:cN, \clist_if_eq:cc}
%   Simple copies from the token list variable material.
%    \begin{macrocode}
%<*deprecated>
\prg_new_eq_conditional:NNn \clist_if_eq:NN \tl_if_eq:NN { p , T , F , TF }
\prg_new_eq_conditional:NNn \clist_if_eq:Nc \tl_if_eq:Nc { p , T , F , TF }
\prg_new_eq_conditional:NNn \clist_if_eq:cN \tl_if_eq:cN { p , T , F , TF }
\prg_new_eq_conditional:NNn \clist_if_eq:cc \tl_if_eq:cc { p , T , F , TF }
%</deprecated>
%    \end{macrocode}
% \end{macro}
% 
% Deprecated 2012-05-13 for removal by 2012-11-31.
%  
% \begin{macro}{\clist_length:N, \clist_length:c, \clist_length:n}
%    \begin{macrocode}
%<*deprecated>
\cs_new_eq:NN \clist_length:N \clist_count:N
\cs_new_eq:NN \clist_length:n \clist_count:c
\cs_new_eq:NN \clist_length:c \clist_count:n
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% Deprecated 2012-05-19 for removal by 2012-11-31.
%
% \begin{macro}{\clist_use:N, \clist_use:c}
%    \begin{macrocode}
%<*deprecated>
\cs_new_eq:NN \clist_use:N \tl_use:N
\cs_new_eq:NN \clist_use:c \tl_use:c
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
