% \iffalse
%% File xfm.dtx
%% (C) Copyright 2001, 2004, 2007-2009 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xfrontm bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%<*driver|package>
\RequirePackage{expl3}
%</driver|package>
%\fi
\GetIdInfo$Id$
          {xfm}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
%
% ^^A still to clean up:
%
% ^^A \null
% ^^A \footins
% ^^A \vskip
% ^^A \relax
% ^^A \AtEndDocument
% ^^A \insert
% ^^A \protected@xdef
%
 \documentclass{l3doc}
%
 \begin{document}
 \catcode`\_=11
 \catcode`\:=11
 \DocInput{xfm.dtx}
 \end{document}
%</driver>
%
% \fi
%
%
% \title{The \textsf{xfm} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
%
% \begin{abstract}
%    This document describes a front matter model and implementation
%    for \LaTeX.
%
%    As of today a large portion of the documentation is incorrect,
%    sorry folks, for example the original \verb=\author= command was
%    generalised to allow any kind of front matter structures of this
%    type, but the documentation still talks about \verb=\author= and
%    |address| keyword instead of ``some keyword'' of ``a front matter
%    structure'' \ldots\ one day
% \end{abstract}
%
% \section{Introduction}
%
%
% \subsection{Layout Areas}
%
% Conceptually the front matter consists of so called ``layout areas''
% or ``layout block'' which receive textual data from the syntax
% elements such as the |\title| command or the author declarations
% (i.e., the |\author| command).
%
% A ``layout area'' is vertically oriented, which means that it starts
% out in vertical mode and finishes of in vertical mode by pre- and
% appending a |\par| command. Textual data which is put into it will
% not contain direct formatting information at that point but instead
% will be surrounded by functions with one argument responsible for the
% formatting. For example, an address will appear as
%\begin{verbatim}
%    \xfm_format_key_address:n {Zedernweg 62, 55128 Mainz, Germany}
%\end{verbatim}
% in such a ``layout area''.
%
%
% \subsubsection{Area Declaration}
%
%\DescribeMacro\DeclareFMArea
% Areas are declared by |\DeclareFMArea| as follows:
%\begin{verbatim}
%    \DeclareFMArea{<name>}
%     {
%       area-required-boolean    = <true or false>,
%       area-measure-setup       = <horizontal galley parameters>,
%       area-bb-skip             = <vertical separation to prev block>,
%
%       head-text                = <fixed heading text>,
%       head-font                = <font for heading>,
%       head-format              = <format of heading>,
%       head-justification-setup = <how to justify heading>,
%
%       head-text-bb-skip        = <vertical separation between head/text>,
%       head-text-h-skip         = <horizontal separation between head/text>,
%
%       text-font                = <font for text>,
%       text-pshape-setup        = <special parshape if necessary>,
%       text-justification-setup = <how to justify text>,
%       text-firstindent-boolean = <indent first paragraph?>,
% }
%\end{verbatim}
% The |basebase-skip| key defines the distance between the first baseline in
% the area and the last baseline of an earlier area (if there is
% one).\footnote{For very complex layouts where the areas are not
% essentially following each other that key seems slightly odd, but
% for most type of layouts the placement within the area setup is
% appropriate (and it is easier to implement this way).} By default it
% is the value of |fontbaseline| so that areas follow each other
% without any special space.
%
% The |fontsize| and the |fontbaseline| keys define some important
% properties of the body font. There need to be others and all those
% should probably be combined somehow and offered as |font-setup|.
%
% The |justification-setup| defines the paragraph justification used
% for area. If we go with the galley2 type of templates (without
% actually using them) then we probably also need something like
% |pshape-setup|.
%
% Finally |required-boolean| defines whether or not that area needs
% filling. An unfilled area is ignored including the whitespace
% preceding it, but if the area is required we will get an error
% message.
%
%
%
% \subsubsection{Element Separation}\label{sec:eltsep}
%
% The ``textual elements'' in the areas will be internally separated
% from each other by functions taking three arguments:
%\begin{verbatim}
%    \xfm_area_sep:nnn {addresses}{key!address}{marker!addresses}
%\end{verbatim}
% The first argument is the name of the area itself, the second
% describes the nature of the previous element (an address in the
% example), and the third describes the nature of the following
% element (a marker with the name |addresses| in the example).
% If there is no previous element the second argument contains the
% string |START| and if there is no further element the third argument
% contains the string |END|.
%
% Having these separator functions it is possible to describe in
% detail the formatting that should happen between two elements in an
% area as well as allowing special actions to be taken before the
% first element and after the last element.
%
% \DescribeMacro\DeclareFMObjectSep
% The actions of the separator functions are declared using a number
% of |\DeclareFMObjectSep| each taking four arguments: the area to
% which they apply, the ``descriptive name'' of the previous element,
% the ``descriptive name'' of the following element, and the action to
% take if we are between two such elements (i.e., if the three
% arguments of |\xfm_area_sep:nnn| match the first three arguments in
% the |\DeclareFMObjectSep| declaration. Instead of a ``descriptive
% name'' one can use a |*| which means any element.
%
% As a simple example consider the author names appearing in such a
% list being denoted by |key!name|\footnote{How to determine which
% elements have what name we cover later.} then separating them by
% comma could be done as follows:
%\begin{verbatim}
%  \DeclareFMObjectSep{authors}{START}{key!name}   {}
%  \DeclareFMObjectSep{authors}{*}    {key!name}   {, }
%  \DeclareFMObjectSep{authors}{*}    {END}        {}
%\end{verbatim}
% This is admittedly a simple example; especially in this case we
% typically have the need to handle the situation of two elements
% specially, e.g., adding \verb*= and = in that case but
% \verb*=, and =  between the last two authors if there are more
% than two.\footnote{It remains to be seen if this kind of extra
% complication asks for a  even more generic solution or if it can be
% suitably handled with the current concepts.}
%
% As a second example consider markers being added after author names
% to refer to email address, thanks, and the like. The following
% specification will put a small space before the first marker,
% separate the markers by a raised comma (the marker itself is better
% be raised as well in that case :-) and finishes the set of markers
% for one author by a raised close parenthesis.
%\begin{verbatim}
%  \DeclareFMObjectSep{authors}
%                    {*}            {marker!thanks}{\,}
%  \DeclareFMObjectSep{authors}
%                    {marker!thanks}{marker!thanks}{\textsuperscript{,}}
%  \DeclareFMObjectSep{authors}
%                    {marker!thanks}{*}            {\textsuperscript{)}}
%\end{verbatim}
%
% The use of the |*| in the |\DeclareFMObjectSep| declaration needs
% some further explanation. Consider the following three declarations:
%\begin{verbatim}
%  \DeclareFMObjectSep{authors}{A}{*}{do-A}
%  \DeclareFMObjectSep{authors}{*}{B}{do-B}
%  \DeclareFMObjectSep{authors}{A}{C}{do-C}
%  \DeclareFMObjectSep{authors}{*}{*}{do-D}
%\end{verbatim}
% If we are between two elements then it is first checked if there is
% a declaration for this exact combination (thus not involving stars).
% If this is the case then the corresponding action is executed and
% nothing else. Therefore if we are between |A| and |C| the algorithm
% executes |do-C| and ignores that the first and the last of the above
% rules would match the situation as well.
%
% However, if the exact match is not found, the algorithm first tries
% to finds a rule with the second element replaced by a star (and if
% found executes its action) and then regardless of the result for
% that search also looks for a rule with the first element being
% replaced by a star.
%
% If there was at least one match involving one star processing stops
% otherwise the algorithm makes a final attempt and looks for a rule
% with both elements replaced by stars.
%
% Thus for |A| followed by |B| we execute |do-A| and then |do-B|,
% while for |A| followed by |D| we execute only |do-A|, for |C|
% followed by |B| we would execute |do-B|, and for |C| followed by |C|
% we would execute |do-D| (assuming that the above are the only rules
% involving |A|, |B|, and |C|).
%
%
% \subsubsection{Processing and Formatting}
%
% \DescribeMacro\xfm_add_element:nnn
% \DescribeMacro\xfm_add_element:nno
% To add an element to some area the command |\xfm_add_element:nnn|
% can be used as follows:
%\begin{verbatim}
%  \xfm_add_element:nnn {authors} {key!name}{Frank Mittelbach}
%\end{verbatim}
% where the first argument specifies the target area, the second the
% ``descriptive name'' for the element, and the third the actual
% data. This command and its companion (which is the same except that
% last argument is expanded once) are intended for internal use, so
% the argument would usually contain |#1| and the like rather than
% fixed data.
%
% The target area should have been declared; the ``descriptive name''
% can in be any string, though to be useful there should be a sensible
% convention (the one used by this setup is explained below).
%
% The commands append at the right by first adding an element
% separation command (as explained in the previous section) followed
% by contents of the third argument. Thus formatting commands such as
% |\xfm_format_key_address:n| need to be part of that third argument
% if necessary.
%
%
% The areas are formatted by executing an instance of type |textarea|
% and the name of that area, e.g.,
%\begin{verbatim}
%  \UseInstance{textarea}{thanks}
%\end{verbatim}
% would typeset the contents of an area named |thanks| at the current
% point.
%
% \DescribeMacro\xfm_typeset_area_list:n
% This command expects a comma separated list of areas and formats one
% after each other by calling |\UseInstance{textarea}{...}| if they
% exist, otherwise it ignores the area(s).
%
% \DescribeMacro\xfm_typeset_insertion_area_list:nN
% This command expects a comma separated list of areas and an
% insertion class (such as footins) and formats one
% after each other into that class by calling
% |\UseInstance{textarea}{...}| if they
% exist, otherwise it ignores the area(s).
%
% Should perhaps combined with the previous command for normal areas.
%
%
% As mentioned above the elements are formatted using commands with
% one argument. The definition for these commands are part of the
% declarations that set up the data sources from which the text comes,
% e.g., keys of the |\author| commands gets distributed to areas and
% the formatting for the key value is described with the key declaration.
%
%
%
%
%
%
% \subsection{Markers}
%
% Some of the information distributed to different areas need to be
% linked to other areas, e.g., you might want to link an author name
% appearing in the |authors| area with its address (appearing, for
% example, in the |addresses| area) as well as with its email address
% and homepage information (both appearing, say, as footnotes on the
% bottom of the page).
%
% \DescribeMacro\DeclareFMMarker
% This is done by linking this data via ``markers'' which are declared
% using the |\DeclareFMMarker| declaration as follows:
%\begin{verbatim}
%  \DeclareFMMarker{<name>}
%   {
%     marker-type   = <display-type-of-marker>,
%     source-format = <presentation-in-sourcearea>,
%     target-format = <presentation-in-target-area>,
%   }
%\end{verbatim}
% Markers are internally represented as counters, with the
% |marker-type| we define the general display properties of the
% marker, e.g., as arabic numbers or as footnote symbols , etc.
% The |source-format| describes for formatting in the source area
% (link start) while the |target-format| describes the formatting in
% the target area (if different from the formatting in the source
% area).\footnote{not used below ... FIX}
%
% For example, we might have |\textsuperscript{\normalfont#1}| as
% formatting  in the source area, but perhaps |#1)| in the target
% area. Both |-format| keys apply to a single reference to a marker,
% if several such marker reference appear in succession in an area,
% they are separated by element separator functions and thus the
% formatting between them can be specified via this concept.
%
%
%
%
% \subsection{Author Data}
%
% Author data is perhaps the most complicated information in the front
% matter because it contains several items that need special treatment
% in most layout styles. This package provides a single input syntax
% while supporting the various layout conventions required by
% different journals.
%
%
% \subsubsection{Author Data Input Specification}
%
% \DescribeMacro\author
% Author data is entered in the source document using the |\author|
% command:
% \begin{verbatim}
% \author{<name>}{
%   address    = <author address> ,
%   altaddress = <alternate author address> ,
%   homepage   = <author home page> ,
%   email      = <author email address> ,
%   thanks     = <thanks and attributions> ,
%   ...
% }
% \end{verbatim}
%
% The keywords in the second argument to the |\author| command are an
% extensible set; they are declared by document class (or in the
% preamble). For the sake of portability, a suitable default set
% should be provided.
%
% Keywords used but not declared result in an error. Declaring
% keywords on the other hand does not necessarily mean that the value
% is going to be used by the class.
%
%
% \subsubsection{Declaring keywords for the author command}
%
% \DescribeMacro\DeclareAuthorKeyword
% Keywords available within the second argument of the |\author|
% command are declared using |\DeclareAuthorKeyword| as follows:
% \begin{verbatim}
% \DeclareAuthorKeyword{<keyword>}
%   {
%    value-required-boolean = <true-or-false>,
%    value-targetarea-id    = <area-name>,
%    value-combine-boolean  = <true-or-false>,
%    marker-id                = <marker-name>,
%    marker-sourcearea-id    = <area-name>,
%   }
% \end{verbatim}
% Not every keyword within the |\author| command represents a required
% value. We might require that every author has an address but
% probably not every author has an email address. By specifying that
% |value-required-boolean| is |false| for a keyword we instruct the front
% matter algorithm that it is permissible when this particular keyword
% is missing in an author declaration. If this is set to |true| the
% algorithm checks if that keyword is present for every author and if
% not will issue an error message. (The default is |true|.)
%
% To get a keyword formatted at some point it needs a target area in
% which it gets typeset; this area is specified by
% |value-targetarea-id |. If this contains no value the declared keyword
% will be accepted but ignored.
%
% If the value of the author keyword has to be linked with some other
% data we need a marker which can be specified by the |marker-id|. If
% a |marker-id| is given the corresponding marker will be used in two
% places:
% \begin{itemize}
% \item in the |value-targetarea-id | before the author keyword value is
%   inserted there
% \item in the |marker-sourcearea-id| at the current point in that area.
% \end{itemize}
% The formatting used for the marker depends on the declarations for
% this marker. The |marker-id| has no effect if the whole author
% keyword is ignored (i.e., if the |value-targetarea-id | is empty).
%
% The default for the |marker-sourcearea-id| is the area named |authors|
% which by convention holds the author names.
%
% In some cases identical data in certain areas (for certain keys)
% should be combined. This can be requested on the author keyword
% level by setting the flag |value-combine-boolean| to |true|. In this case
% all data flagged with the same marker is searched to find an already
% existing entry with the same value. If this value is found then the
% corresponding marker label is used instead of generating a new
% one. Note that if a marker is used for linking data in different
% target areas (which is probably a bad idea in the first place) then
% the identical string might be found in any of these target areas!
%
% There is the interesting question where to put a flag like
% |value-combine-boolean|. Putting it onto an area sounds interesting but
% consider the following scenario: both thanks and address go to the
% footnote area at the bottom of the page and two authors thank their
% wives named Lisa. To conserve space we want to combine identical
% addresses, do we also want to have the line ``With thanks to Lisa''
% be combined into a single line?
%
%
% \subsubsection{Processing data for one author}
%
% General processing of individual author data is identical for all
% styles. Its purpose is to collect referencing information that link
% the author name author data not formatted and ``close by'', e.g.,
% url information later formatted as a footnote, and prepare for this
% data to be processable in a later stage.
%
% \begin{itemize}
% \item Clear the temporary marker reference list.
% \item Process the author data in a specified keyword order (this order
%   is stored in the template value \texttt{keyword-order}).
% \item For each keyword determine if it has a value and if so
%   \begin{itemize}
%   \item append an appropriate marker reference to the marker reference
%     list
%   \item postprocess the keyword value by appending it together with
%     its marker reference to an area list for later formatting (if
%     necessary---the data might already be present).
%   \end{itemize}
% \end{itemize}
%
% After this process the temporary marker reference list can (and
% should) be used to format marker information that should be attached
% to the author name. The area lists are global to this processing,
% ie., their contents will not be cleared.
%
%
%
%
% \section{Question, Issues, and Ideas}
%
% This is a set of comments on the concepts and the implementation in
% random order.
%
% \begin{itemize}
%
% \item The more I work with templates the more I (mis)use the
%    template interface to provide key/value parsing, e.g., define a
%    declaration command such as |\DeclareFMMarker| which does
%    nothing else than declaring a template instance and immediately
%    executing it. After that this instance is never going to be
%    used again. This really calls for providing an interface for such
%    action which internally generates some anonymous instance which
%    is removed from storage immediately afterwards.
%
% \item Just realised that the fake templates would get much simpler
%    if I pass the name as a template argument rather than as a
%    key. Should probably update them all but not tonight.
%
% \item Perhaps it is a good idea to provide the interface to markers
%   in a more general way as a generic interface to counters since
%   there as well something like |source-format| and |target-format|
%   would make sense for many of them as well.
%
% \item The current use of markers needs one more layer of
%    abstraction, i.e., rather than passing around the display value
%    of the marker it would be better to pass around a reference to it
%    and determine the real value at the very last moment. This would
%    allow to get independent usages of the same marker, e.g., via
%    direct |\thanks| commands in sync with those produced when author
%    key values are distributed to areas.
% \end{itemize}
%
%
%
%
% \section{Implementation}
%
%    To implement the front matter code we need the |template| code as
%    well as some general purpose stuff implementing property lists
%    and the like which is coming from |expl3|.
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\RequirePackage{expl3}
\RequirePackage{ldcsetup}
\RequirePackage{xtemplate}
\RequirePackage{xfmgalley,xparse}
\RequirePackage{l3stuff}
%    \end{macrocode}
%
%
% \subsection{Layout Areas}
%
%
% \subsubsection{Area declaration}
%
% \DescribeMacro\g_xfm_FOO_list_tl
%    For an area named |FOO| the tl var.~|\g_xfm_FOO_list_tl| holds all
%    formatting instructions to be used when the corresponding area
%    instance is executed. (After execution this list is cleared so an
%    area can be used un a loop, if in the loop filling and using is
%    alternated.)
%
% \DescribeMacro\g_xfm_FOO_last_tl
%    For an area |FOO| the tl var.~|\g_xfm_FOO_last_tl| holds the
%    descriptive name of the last element that was added. This is used
%    when computing the separator function that is placed between two
%    such elements.
%
% \DescribeMacro\XFMShowAreas
%    The |\XFMShowAreas| is indented as a debugging aid and shows the
%    current contents of each area.
%
%
% \begin{macro}{textarea (template/type)}
%    Areas are internally implemented as instances of templates so we
%    start by declaring a template type for this. As a typical
%    ``setup'' type this type has no arguments.
%    \begin{macrocode}
\DeclareObjectType{textarea}{0}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\DeclareFMArea}
%    The |\DeclareFMArea| is the designer interface to area
%    declaration, the first argument is the area name and the second
%    is a list of key/values. This hides the fact that we use template
%    instances for areas but it is also here because we do want to do
%    some code execution when the area is declared and some when it is
%    used.
%
%    \begin{macrocode}
\cs_set_nopar:Npn \DeclareFMArea #1#2{
%    \end{macrocode}
%    Each area has a tl var.~which holds the contents of the area. It is
%    initially empty.
%    \begin{macrocode}
  \tl_gclear:c{g_xfm_ #1 _list_tl}
%    \end{macrocode}
%    As a primitive form of debugging during development we provide a
%    |\show| of the area tl var.~contents so we add the new area to the
%    |\XFMShowAreas| macro (this is clearly code which will vanish one
%    day).
%    \begin{macrocode}
%<*trace>
  \tl_gput_right:No
     \XFMShowAreas
     {\cs_show:c {g_xfm_ #1 _list_tl} }
%</trace>
%    \end{macrocode}
%    To be able to add proper element separator commands into the area
%    we need to initialise the tl var.~that keeps track of the last
%    element seen:
%    \begin{macrocode}
  \tl_gset:cn{g_xfm_ #1 _last_tl}{START}
%    \end{macrocode}
%    And finally we declare a template instance, passing area name
%    under the key |area-id| and the second argument as the remaining
%    key/values.
%    \begin{macrocode}
  \DeclareInstance{textarea}{#1}{std}{ area-id = #1,  #2 }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \begin{macro}{\XFMShowAreas}
%    The debugging command |\XFMShowAreas| shows the current contents
%    of all areas, the output is rather unreadable---need something
%    better in the end. We have to initialise this or else the
%    |\tl_gput_right:No| in |\DeclareFMArea| will fail.
%    \begin{macrocode}
%<*trace>
\tl_new:N \XFMShowAreas
%</trace>
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{textarea/std (template)}
%    The purpose of this instance is to format the contents of an area
%    and prepare for its reuse (if necessary).
%
%    Keys and their names for this template need further thought, they
%    are neither complete nor good.
%    \begin{macrocode}
\DeclareTemplateInterface{textarea}{std}{0}{
   area-id                  : tokenlist             ,
   area-required-boolean    : choice {true, false } ,
   area-measure-setup       : instance {measure}    ,

   area-bb-skip             : skip                 ,
   head-text                : tokenlist            ,
   head-font                : tokenlist            ,
   head-format              : function 1           ,
   head-justification-setup : instance {justification} = center ,
   head-text-h-skip         : tokenlist             , % should be skip
   head-text-bb-skip        : tokenlist             , % should be skip

   text-font                : function 0           ,
   text-justification-setup : instance {justification} = centerfirst-adjust ,
   text-pshape-setup        : instance {pshape}    ,
   text-firstindent-boolean : choice {true, false} ,
 }

\tl_new:N   \l_textarea_id_tl
\skip_new:N \l_textarea_BB_skip
\tl_new:N   \l_textarea_head_text_tl
\tl_new:N   \l_textarea_head_font_tl
\cs_new:Npn \textarea_head_format:n #1 {}
\cs_new:Npn \textarea_head_justification_setup: {}
\cs_new:Npn \textarea_measure_setup:n #1 {}

\tl_new:N \l_textarea_text_hskip_tl
\tl_new:N \l_textarea_text_BBskip_tl
\tl_new:N \l_textarea_text_font_tl

\cs_new:Npn \textarea_text_justification_setup: {}
\cs_new:Npn \textarea_text_pshape_setup: {}


\DeclareTemplateCode{textarea}{std}{0}{
   area-id               = \l_textarea_id_tl      ,
   area-required-boolean = {
     true  = ,
     false = \cs_set_eq:NN \textarea_missing_value:\relax
   },
   area-measure-setup    = \textarea_measure_setup:n,

   area-bb-skip          = \l_textarea_BB_skip,
   head-text             = \l_textarea_head_text_tl,
   head-font             = \l_textarea_head_font_tl,
   head-format           = \textarea_head_format:n,
   head-justification-setup= \textarea_head_justification_setup:,
   head-text-h-skip         =  \l_textarea_text_hskip_tl,
   head-text-bb-skip        =  \l_textarea_text_BBskip_tl,

   text-font                = \l_textarea_text_font_tl,
   text-justification-setup = \textarea_text_justification_setup:,
   text-pshape-setup        = \textarea_text_pshape_setup:,
   text-firstindent-boolean = {
     true = ,
     false = \cs_set_eq:NN \textarea_text_handle_indent:
                           \gal_remove_next_parindent:
   },
 }
 {
%    \end{macrocode}
%
%    \begin{macrocode}
  \cs_set_eq:NN \textarea_measure_setup:n \use_none:n
  \skip_set:Nn  \l_textarea_BB_skip    \baselineskip
%    \end{macrocode}
%    The default for |\textarea_missing_value:| is to call an error
%    routine which tells the user that contents for this area is
%    required but not provided by the document.
%    \begin{macrocode}
  \cs_set_nopar:Npn \textarea_missing_value:
           { \xfm_error_decl:nn {area} \l_textarea_id_tl }

  \cs_set_eq:NN \textarea_text_pshape_setup: \scan_stop:

  \tl_set:Nn    \l_textarea_text_BBskip_tl \baselineskip
  \tl_set_eq:NN \l_textarea_text_hskip_tl  \NoValue
  \tl_clear:N   \l_textarea_text_font_tl

  \tl_set_eq:NN \l_textarea_head_text_tl \NoValue
  \tl_clear:N   \l_textarea_head_font_tl

  \cs_set_eq:NN \textarea_head_format:n \use:n
  \cs_set_eq:NN \textarea_text_handle_indent: \scan_stop:
%    \end{macrocode}
%
%    \begin{macrocode}
  \AssignTemplateKeys
%    \end{macrocode}
%
%    If the area contents is empty we execute
%    |\textarea_missing_value:| which, by default, will generate an
%    error message, but if the declaration set |required-boolean| to
%    |false| it will do nothing.
%    \begin{macrocode}
  \tl_if_empty:cTF {g_xfm_ \l_textarea_id_tl _list_tl}
  { \textarea_missing_value: }
%    \end{macrocode}
%    If it is non-empty we have to typeset it:
%    \begin{macrocode}
  {
%    \end{macrocode}
%    First thing to do is to append the final separator command since
%    this is still missing.
%    \begin{macrocode}
    \xfm_add_element_sep:nn \l_textarea_id_tl {END}
%    \end{macrocode}
%    The actual typesetting is done in a group so that font changes
%    etc are kept local to the area.
%    \begin{macrocode}
    \group_begin:
      \par
      \textarea_measure_setup:n \NoValue

      \tl_if_eq:NNTF \l_textarea_head_text_tl \NoValue
        {
         \skip_set:Nn
            \l_textarea_text_BBskip_tl \l_textarea_BB_skip
         \textarea_text_handle_indent:
        }
        {
         \group_begin:
     \l_textarea_head_font_tl
     \UseBBskip\l_textarea_BB_skip
     \tl_if_eq:NNF \l_textarea_text_hskip_tl \NoValue
                       \textarea_text_handle_indent:
     \textarea_head_format:n
        \l_textarea_head_text_tl
         \group_end:
         \textarea_head_justification_setup:
        }
%    \end{macrocode}
%    We need to set up the body font for the area \emph{before} we
%    call |\UseBBskip| since the latter needs to know the upcoming
%    baselineskip value to make the right calculations.
%    \begin{macrocode}
      \tl_if_eq:NNF \l_textarea_text_hskip_tl \NoValue
                  { \hskip \l_textarea_text_hskip_tl }
      \l_textarea_text_font_tl
      \tl_if_eq:NNT \l_textarea_text_hskip_tl \NoValue
         { \par
            \UseBBskip\l_textarea_text_BBskip_tl
         }
%    \end{macrocode}
%    Then we set up justification and finally typeset the area
%    contents followed by a |\par| to ensure that we return to
%    vertical mode.
%    \begin{macrocode}
      \textarea_text_pshape_setup:
      \textarea_text_justification_setup:
    % \cs_show:c{ g_xfm_ \l_textarea_id_tl _list_tl }
      \use:c { g_xfm_ \l_textarea_id_tl _list_tl }
      \par
    \group_end:
%    \end{macrocode}
%
%    After that we have to reinitialise the area to allow reuse (as
%    well as to save space). We can do this within the |\else| part
%    since we can assume that an empty contents means that we are
%    still having an initialised version (if not something will break :-).
%    \begin{macrocode}
    \tl_gclear:c{g_xfm_ \l_textarea_id_tl _list_tl}
    \tl_gset:cn {g_xfm_ \l_textarea_id_tl _last_tl}
                 {START} % provide restart
   }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xfm_error_decl:nn}
%    The current error handling is BAD and the texts are wrong, so
%    there\ldots
%    \begin{macrocode}
\cs_set_nopar:Npn  \xfm_error_decl:nn #1#2
    {\PackageError{xfm}{No~ contents~ in~ #1~ `#2'~ missing}
                       \@eha % needs real help message
    }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsubsection{Element Formatting and Separation}
%
% \DescribeMacro{\xfm_AREA-A-B}
%    The action to be taken between two elements |A| and |B| in an
%    area named |AREA| is stored in |\xfm_AREA-A-B|. |AREA|, |A| and |B| are
%    either descriptive names or |*|s denoting ``any name''.
%
% \DescribeMacro{\xfm_AREA-A}
%    The formatting for element |A| in an
%    area named |AREA| is stored in |\xfm_AREA-A|. |AREA| and |A|  are
%    either descriptive names or |*|s denoting ``any name''.
%
% \begin{macro}{\DeclareFMObjectSep}
%    The |\DeclareFMObjectSep| stores away the information in the
%    appropriate tl var.
%    \begin{macrocode}
\cs_set_nopar:Npn \DeclareFMObjectSep #1#2#3#4 { \tl_gset:cn{xfm_#1-#2-#3}{#4} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareFMObjectFormat}
%    |\DeclareFMObjectFormat| declares the formatting for element |#2|
%    in area |#1|. The formatting code has one argument and we pick it
%    up implicitly so that we can use `|#1|' in the third argument.
%    \begin{macrocode}
\cs_set_nopar:Npn \DeclareFMObjectFormat #1#2 { \cs_gset_nopar:cpn {xfm_#1-#2} ##1 }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\xfm_add_element:nnn}
% \begin{macro}{\xfm_add_element:nno}
%    |\xfm_add_element:nnn| takes an area name as first argument, an
%    (descriptive) element name as second argument, and the element
%    value as third and updates the area tl var.~with this information by
%    adding an appropriate element separator function followed by the
%    third argument with its formatter function.
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_add_element:nnn #1#2#3 {
%    \end{macrocode}
%    Add the separator function first\ldots
%    \begin{macrocode}
  \xfm_add_element_sep:nn {#1}{#2}
%    \end{macrocode}
%    \ldots then add the third argument to the area tl var.
%    \begin{macrocode}
  \tl_gput_right:cn
     { g_xfm_#1_list_tl }
     { \xfm_area_value:nnn{#1}{#2}{#3} }
}
%    \end{macrocode}
%    |\xfm_add_element:nno| is the more common variant which expands
%    the third argument once before adding it.
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_add_element:nno #1#2#3 {
  \xfm_add_element_sep:nn {#1}{#2}
%    \end{macrocode}
%    Because we don't know the length of the first two arguments to
%    |\xfm_area_value:nnn| we add the expanded third argument in a
%    separate step.
%    \begin{macrocode}
  \tl_gput_right:cn
     { g_xfm_#1_list_tl }
     { \xfm_area_value:nnn {#1}{#2} }
  \tl_gput_right:co
     { g_xfm_#1_list_tl }
     { \exp_after:wN { #3 } }
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
% \begin{macro}{\xfm_add_element_sep:nn}
%    |\xfm_add_element_sep:nn| takes an area name as first argument
%    and an element name as second argument and appends the line
%\begin{verbatim}
%   \xfm_area_sep:nnn {<area>} {<last-element>} {<upcoming-element>}
%\end{verbatim}
%    to the area tl var.
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_add_element_sep:nn #1#2 {
%    \end{macrocode}
%    We have to get the contents of |\g_xfm_|\meta{area}|_last_tl|
%    into the area tl var.~and the easiest way to do this is via full
%    expansion.
%    \begin{macrocode}
  \tl_set:Nx \l_tmpa_tl
     { \exp_not:N \xfm_area_sep:nnn
                 { #1 }
                 { \use:c {g_xfm_ #1 _last_tl} }
                 { #2 }
     }
%    \end{macrocode}
%    After that we can update |\g_xfm_|\meta{area}|_last_tl| to point
%    to the new name.
%    \begin{macrocode}
  \tl_gset:cn{g_xfm_ #1 _last_tl}{#2}
%    \end{macrocode}
%    Finally we add the contents of |\l_tmpa_tl| to the area tl var.
%    \begin{macrocode}
  \tl_gput_right:co
     {g_xfm_ #1 _list_tl}
     \l_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xfm_area_value:nnn}
%    |\xfm_area_value:nnn| picks up an area name and a descriptive
%    element name and finds the formatting for it. Then it applies
%    that to the third argument which is the element's value.
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_area_value:nnn #1#2 {
%<*trace>
  \typeout{XFM:~ Element~ formatting:~ #1-#2}
%</trace>
  \cs_if_free:cTF{xfm_#1-#2}
    {
     \cs_if_free:cTF{xfm_*-#2}
        {
%<*trace>
         \typeout{\@spaces nothing~ found}
%</trace>
   \use:n
        }
  {
%<*trace>
         \typeout{\@spaces\space xfm_*-#2~=~
                  \cs_meaning:c {xfm_*-#2} }
%</trace>
         \use:c {xfm_*-#2}
        }
    }
    {
%<*trace>
     \typeout{\@spaces\space xfm_#1-#2~=~
                  \cs_meaning:c {xfm_#1-#2} }
%</trace>
     \use:c {xfm_#1-#2}
    }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfm_area_sep:nnn}
%    The |\xfm_area_sep:nnn| is the area separator function appearing
%    between elements in the area. It is a huge bunch of tests to find
%    out which combinations of element names and stars is defined and
%    which of them needs execution. See section \ref{sec:eltsep} for
%    an explanation of the logic.
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_area_sep:nnn #1#2#3 {
%<*trace>
  \typeout{XFM:~ Element~ separation:~ #1-#2-#3}
%</trace>
  \cs_if_free:cTF{xfm_#1-#2-#3}
    {
      \cs_if_free:cTF{xfm_#1-#2-*}
        {
          \cs_if_free:cTF{xfm_#1-*-#3}
            {
              \cs_if_free:cTF{xfm_#1-*-*}
                {
%<*trace>
                 \typeout{\@spaces nothing~ found}
%</trace>
                }
                {
%<*trace>
                 \typeout{\@spaces\space xfm_#1-*-*~=~
                          \cs_meaning:c {xfm_#1-*-*} }
%</trace>
                 \use:c {xfm_#1-*-*}
                }
            }
            {
%<*trace>
             \typeout{\@spaces\space xfm_#1-*-#3~=~
                      \cs_meaning:c {xfm_#1-*-#3} }
%</trace>
             \use:c {xfm_#1-*-#3}
            }
        }
        {
%<*trace>
          \typeout{\@spaces\space xfm_#1-#2-*~=~
                   \cs_meaning:c {xfm_#1-#2-*} }
%</trace>
          \use:c {xfm_#1-#2-*}
          \cs_if_free:cF{xfm_#1-*-#3}
            {
%<*trace>
             \typeout{\@spaces\space xfm_#1-*-#3~=~
                      \cs_meaning:c {xfm_#1-*-#3} }
%</trace>
             \use:c {xfm_#1-*-#3}
            }
        }
    }
    {
%<*trace>
     \typeout{\@spaces\space xfm_#1-#2-#3~=~
              \cs_meaning:c {xfm_#1-#2-#3} }
%</trace>
     \use:c {xfm_#1-#2-#3}
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsection{Markers}
%
% As mentioned above markers are essentially \LaTeX{} counters with a
% few additions. Here is a list of internals structures set up when a
% marker named |FOO| is declared.
%
% \DescribeMacro\c@FOO
%    The current value of the marker is stored in the count register
%    |\c@FOO|.
%
% \DescribeMacro\theFOO
%    The basic display representation of the marker is given by
%    |\theFOO|.
%
% \DescribeMacro\g_xfm_FOO_prop
%    For each marker |FOO| we maintain a property list
%    |\g_xfm_FOO_prop| in which we put under the key
%    |\mark-|\meta{marker-num} the following data
%\begin{verbatim}
%  { <display-value> }{ <target-text> }
%\end{verbatim}
%    which is needed if we want combine reference to identical text.
%
%    This property list will change with a different implementation,
%    see ``Questions, Issues'' section!
%
% \DescribeMacro\xfm_format_source_marker_FOO:n
%    A command with one argument which describes the formatting to be
%    applied to the marker value if used in the source area.
%
% \DescribeMacro\xfm_format_target_marker_FOO:n
%    A command with one argument which describes the formatting to be
%    applied to the marker value if used in a target area.
%
%
% \begin{macro}{\DeclareFMMarker}
%    The |\DeclareFMMarker| simply hides the fact that the
%    key/value parsing is done via a template. It declares an instance
%    and immediately executes it.
%    \begin{macrocode}
\cs_set_nopar:Npn \DeclareFMMarker #1#2{
  \UseTemplate{FMmarkersetup}{std}{#2}{#1}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{FMmarkersetup (template type)}
%    Here is the template type declaration.
%    \begin{macrocode}
\DeclareObjectType{FMmarkersetup}{1}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{FMmarkersetup/std (template)}
%    The purpose of this template is to set up the marker data
%    structures.
%    \begin{macrocode}
\DeclareTemplateInterface{FMmarkersetup}{std}{1}{
   marker-type    : tokenlist  ,
   default-format : function 1 ,
   target-format  : function 1 ,
 }

\tl_new:N  \l_FMmarker_type_tl
\cs_new:Npn \FMmarker_default_format:n #1 {}
\cs_new:Npn \FMmarker_target_format:n  #1 {}

\DeclareTemplateCode{FMmarkersetup}{std}{1}{
   marker-type    = \l_FMmarker_type_tl,
   default-format = \FMmarker_default_format:n,
   target-format  = \FMmarker_target_format:n,
 }
 {
%    \end{macrocode}
%    As defaults we use |\arabic| for the |marker-type|, |#1| for the
%    |default-format| |\@firstofone|.
%    \begin{macrocode}
   \tl_set:Nn \l_FMmarker_type_tl           {\arabic}
   \cs_set_eq:NN  \FMmarker_default_format:n \use:n
%    \end{macrocode}
%
%    \begin{macrocode}
   \AssignTemplateKeys
%    \end{macrocode}
%    Make a new \LaTeX{}  counter with the name of the marker; due to
%    this the declaration is currently not modifiable once it is
%    given!
%    \begin{macrocode}
   \newcounter {#1}
   \cs_gset_nopar:cpx {the#1} { \exp_not:o \l_FMmarker_type_tl {#1} }
%    \end{macrocode}
%    Provide the special property list that we need for combining
%    references.
%    \begin{macrocode}
   \prop_new:c {g_xfm_ #1 _prop}
%    \end{macrocode}
%    We store the source format in the appropriate command:
%    \begin{macrocode}
   \cs_gset_eq:cN
      {xfm_ *-marker!#1}
      \FMmarker_default_format:n
 }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \subsection{Front Matter Structure Data}
%
%
% \subsubsection{Structure Input Specification}
%
%
% \begin{macro}{\author}
%    The |\author| command stores the key/values as properties in a
%    property list which is named |\g_xfm_structure_|\meta{num}|_prop| where
%    \meta{num} is a sequence number which we get from incrementing
%    the counter |\g_xfm_structure_int|. Thus that counter will tell us the
%    number of authors seen in total.

%    In addition we store the current value of that counter in the
%    sequence |\g_xfm_authors_seq| so that this sequence will initially hold
%    the value $1,\ldots,n$ if we have $n$ authors in total.
%
%    Thus we can loop through this sequence if we want to process the
%    authors. Also, if authors need to be sorted by address, we can
%    remove values from this sequence once they are processed and thus
%    keep track of the authors still unprocessed.
%
%    The key names are of the form |\xfm_key_|\meta{name-of-key}.
%    \begin{macrocode}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xfm_structure_int}
%    We count the |\author| commands seen in the counter
%    |\g_xfm_structure_int|. At a later stage the counter is used to denote
%    the number of authors during processing, e.g., when sorting by
%    address it denotes the number of authors found for the current
%    address.
%    \begin{macrocode}
\int_new:N \g_xfm_structure_int
%    \end{macrocode}
% \end{macro}
%
% Some variants of the \texttt{prop} functions which have been moved
% from \textsf{l3prop}. TO CLEAN UP.
%    \begin{macrocode}
\cs_generate_variant:Nn \prop_gput:Nnn {ccn,cco}
\cs_generate_variant:Nn \prop_get:NnN {NcN}
%    \end{macrocode}
%
%
% \begin{macro}{\xfm_structure_parse_keyword_code:n}
%    |\xfm_structure_parse_keyword_code:n| is the code used to evaluate a key
%    using |\setkeys{xfm}|, i.e., for each keyword \meta{key} we want
%    to allow in the second argument of |\authors| we need to |\cs_set_eq:NN|
%    the macro name |\KV@xfm-|\meta{structure}|@|\meta{key} to this
%    macro (this is done in the declaration of keys for the |\author|
%    command below).
%
%    We could have used |\define@key| in that declaration but since
%    the code is the same for all keys using a direct |\cs_set_eq:NN| saves a
%    lot of space.
%
%    The purpose of the code is to store the key value as a property
%    in the property list for the current author using the property
%    key |\xfm_key_|\meta{key}.
%
%    The macro has an argument but we can make it implicit and have
%    |\prop_gput:ccn| to pick it up as its third argument.
%
%    If anybody wonders what the |\@tempa| is doing\marginpar{DANGER:
%    bad dependency to keyval package} in the second argument to
%    |\prop_gput:ccn| \ldots : it holds the value of the parsed key (so
%    this is totally dependent on the implementation of |\setkeys|,
%    urg, which should offer a proper interface to the currently
%    parsed key name but doesn't).
%
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_structure_parse_keyword_code:n {
  \prop_gput:ccn
     {g_xfm_structure_ \int_use:N\g_xfm_structure_int _prop}
     {xfm_key_\@tempa}
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsubsection{Declaring keywords for a structure command}
%
% To declare a keyword |FOO| for the front matter structure BAR we have to set
%    up a number of internal data structures.
%
% \DescribeMacro{\KV@xfm-BAR@FOO}
%    The |\KV@xfm-BAR@FOO| command is the parsing routine for
%    \texttt{keyval} to capture the keyword |FOO| within the structure |BAR|.
%
%
% \DescribeMacro\xfm_format_key_FOO:n
%    The macro |\xfm_format_key_FOO:n| holds the formatting
%    instructions for the key value when it is passed into the target
%    area.
%
% \DescribeMacro\xfm_find_marker_BAZ-FOO:Nn
%    The macro |\xfm_find_marker_BAZ-FOO:Nn| executed if we try to find an
%    already existing value to combine marker information, |BAZ| is
%    the target area for |FOO| (recall that there can be more than one
%    such area per keyword). It will be
%    either |\cs_set_eq:NN| to |\xfm_find_marker:Nn| (in which case we try to
%    combine) or to |\use_none:n| (in which case we  loop but only through
%    data away --- not very efficient)
%
% \DescribeMacro{\xfm_process_key_author-FOO:N}
%    The macro |\xfm_process_key_author-FOO:N| stores the code that is
%    executed when we try to distribute this particular key value to
%    some target area. It is either a call to
%    |\xfm_append_keyval:nnN| or to
%    |\xfm_linkappend_keyval_nnnnN| with all but the last
%    arguments fixed. Which of the two is used depends on the
%    value for the |marker-id|: if we don't have markers we
%
%
%
% \begin{macro}{\DeclareFMKeyword}
%    |\DeclareFMKeyword| takes the name of a structure (without
%    backslash) as first argument, the name of a keyword for this
%    structure as second argument and the specification what to do for
%    this keyword as a third argument.
%    \begin{macrocode}
\cs_set_nopar:Npn \DeclareFMKeyword #1#2#3{
 \UseTemplate{keywordsetup}{std}{#3}{#1}{#2}
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{keywordsetup (template type)}
%    Arguments are structure and keyword names.
%    \begin{macrocode}
\DeclareObjectType{keywordsetup}{2}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{keywordsetup/std (template)}
%    The purpose of this template is to register a keyword for a front
%    matter structure command and set up the necessary data
%    structures.
%    \begin{macrocode}
\DeclareTemplateInterface{keywordsetup}{std}{2}{
   value-targetarea-id    : tokenlist ,
   value-required-boolean : choice {true, false} ,
   value-combine-boolean  : choice {true, false} ,
   value-format           : function 1 ,
   marker-id              : tokenlist  ,
   marker-sourcearea-id   : tokenlist  ,

   value-targetarea-id2   : tokenlist  ,
   value-format2          : function 1 ,
   value-combine-boolean2 : choice {true, false} ,
   marker-sourcearea-id2  : tokenlist  ,
   marker-id2             : tokenlist  ,

   value-targetarea-id3   : tokenlist  ,
   value-combine-boolean3 : choice {true, false} ,
   value-format3          : function 1 ,
   marker-sourcearea-id3  : tokenlist  ,
   marker-id3             : tokenlist  ,

 }

\cs_new:Npn \keysetup_keyword_format:n #1 {}
\cs_new:Npn \keysetupii_keyword_format:n #1 {}
\cs_new:Npn \keysetupiii_keyword_format:n #1 {}

\tl_new:N \l_keysetup_target_area_id_tl
\tl_new:N \l_keysetup_marker_id_tl
\tl_new:N \l_keysetup_source_area_id_tl
\tl_new:N \l_keysetupii_target_area_id_tl
\tl_new:N \l_keysetupii_source_area_id_tl
\tl_new:N \l_keysetupii_marker_id_tl
\tl_new:N \l_keysetupiii_target_area_id_tl
\tl_new:N \l_keysetupiii_source_area_id_tl
\tl_new:N \l_keysetupiii_marker_id_tl

\DeclareTemplateCode{keywordsetup}{std}{2}{
   value-targetarea-id    =  \l_keysetup_target_area_id_tl,
   value-required-boolean = {
     true  = ,
     false = \cs_set_eq:NN \keysetup_missing_key: \scan_stop:
   } ,
   value-combine-boolean  = {
     true  = \cs_set_eq:NN \keysetup_combine_boolean:Nn
                           \xfm_find_marker:Nn              ,
     false =
   },
   value-format           = \keysetup_keyword_format:n,
   marker-id              = \l_keysetup_marker_id_tl,
   marker-sourcearea-id   = \l_keysetup_source_area_id_tl,

   value-targetarea-id2   = \l_keysetupii_target_area_id_tl,
   value-format2          = \keysetupii_keyword_format:n,
   value-combine-boolean2 = {
     true  = \cs_set_eq:NN \keysetupii_combine_boolean:Nn
                           \xfm_find_marker:Nn               ,
     false =
   },
   marker-sourcearea-id2  = \l_keysetupii_source_area_id_tl,
   marker-id2             = \l_keysetupii_marker_id_tl,

   value-targetarea-id3   = \l_keysetupiii_target_area_id_tl,
   value-combine-boolean3 = {
     true  = \cs_set_eq:NN \keysetupiii_combine_boolean:Nn
                           \xfm_find_marker:Nn               ,
     false =
   },
   value-format3          = \keysetupiii_keyword_format:n,
   marker-sourcearea-id3  = \l_keysetupiii_source_area_id_tl,
   marker-id3             = \l_keysetupiii_marker_id_tl,

 }
 {
%    \end{macrocode}
%    Start by setting up (sensible?) defaults: by default we don't
%    have a marker and we format the key value by simply passing it on
%    unchanged --- easy.
%    \begin{macrocode}
   \tl_clear:N \l_keysetup_marker_id_tl
   \tl_clear:N \l_keysetupii_marker_id_tl
   \tl_clear:N \l_keysetupiii_marker_id_tl
   \cs_set_eq:NN \keysetup_keyword_format:n    \use:n
   \cs_set_eq:NN \keysetupii_keyword_format:n  \use:n
   \cs_set_eq:NN \keysetupiii_keyword_format:n \use:n
%    \end{macrocode}
%    If no |marker-sourcearea-id| for the marker is given we assume that the
%    author name will go to the area |authors| and that the marker
%    reference therefore should be there too --- less clear.
%    \begin{macrocode}
   \tl_set:Nn  \l_keysetup_source_area_id_tl {authors}
   \tl_clear:N \l_keysetupii_source_area_id_tl
   \tl_clear:N \l_keysetupii_target_area_id_tl
   \tl_clear:N \l_keysetupiii_source_area_id_tl
   \tl_clear:N \l_keysetupiii_target_area_id_tl
%    \end{macrocode}
%    By default declared front matter structure keys are required,
%    which may be the wrong way round.
%    \begin{macrocode}
   \cs_set_nopar:Npn \keysetup_missing_key: {\xfm_error_key:nn{#1}{#2}}
%    \end{macrocode}
%    By default we do not combine entries.
%    \begin{macrocode}
   \cs_set_eq:NN \keysetup_combine_boolean:Nn\use_none:nn
   \cs_set_eq:NN \keysetupii_combine_boolean:Nn\use_none:nn
   \cs_set_eq:NN \keysetupiii_combine_boolean:Nn\use_none:nn
%    \end{macrocode}
%
%    \begin{macrocode}
   \AssignTemplateKeys
%    \end{macrocode}
%    Registering the keyword means linking the \texttt{keyval} parsing
%    routine to the default parsing routine for front matter structure
%    keywords.
%    \begin{macrocode}
   \cs_gset_eq:cN
      {KV@xfm-#1@ #2}
      \xfm_structure_parse_keyword_code:n
%    \end{macrocode}
%    We stored the main target area externally since we need it for
%    sorting.\footnote{Rethink general mechanism!}
%    \begin{macrocode}
   \tl_gset_eq:cN
      {xfm_target_area_ #1-#2 _tl}
      \l_keysetup_target_area_id_tl
%    \end{macrocode}
%
%    \begin{macrocode}
   \cs_gset_eq:cN
      {xfm_find_marker_ \l_keysetup_target_area_id_tl - #2 :Nn}
      \keysetup_combine_boolean:Nn
%    \end{macrocode}
%
%    \begin{macrocode}
   \cs_gset_eq:cN
      {xfm_ \l_keysetup_target_area_id_tl -key! #2}
      \keysetup_keyword_format:n
%    \end{macrocode}
%
%    \begin{macrocode}
   \tl_if_eq:NNF \l_keysetupii_target_area_id_tl \c_empty_tl
     {
      \cs_gset_eq:cN
  {xfm_ \l_keysetupii_target_area_id_tl -key! #2}
  \keysetupii_keyword_format:n
      \cs_gset_eq:cN
  {xfm_find_marker_ \l_keysetupii_target_area_id_tl - #2 :Nn}
  \keysetupii_combine_boolean:Nn
     }

   \tl_if_eq:NNF \l_keysetupiii_target_area_id_tl \c_empty_tl
     {
      \cs_gset_eq:cN
  {xfm_ \l_keysetupiii_target_area_id_tl -key! #2}
  \keysetupiii_keyword_format:n
      \cs_gset_eq:cN
  {xfm_find_marker_ \l_keysetupiii_target_area_id_tl - #2 :Nn}
  \keysetupiii_combine_boolean:Nn
     }
%    \end{macrocode}
%
%    \begin{macrocode}
  \cs_gset_nopar:cpx {xfm_process_key_ #1-#2 :N} ##1
  {
    \tl_if_empty:NTF \l_keysetup_marker_id_tl
    {
      \exp_not:N\xfm_append_keyval:nnN
      {#2}
    }
    {
      \exp_not:N\xfm_linkappend_keyval:nnnnN
        {#2}
        {\l_keysetup_marker_id_tl}
        {\l_keysetup_source_area_id_tl}
    }
    {\l_keysetup_target_area_id_tl}
    ##1

    \tl_if_empty:NF \l_keysetupii_target_area_id_tl
    {
      \tl_if_empty:NTF \l_keysetupii_marker_id_tl
      {
        \exp_not:N\xfm_append_keyval:nnN
        {#2}
      }
      {
        \exp_not:N\xfm_linkappend_keyval:nnnnN
          {#2}
          {\l_keysetupii_marker_id_tl}
          {\l_keysetupii_source_area_id_tl}
      }
        {\l_keysetupii_target_area_id_tl}
        ##1
    }

      \tl_if_empty:NF \l_keysetupiii_target_area_id_tl
      {
        \tl_if_empty:NTF \l_keysetupiii_marker_id_tl
        {
          \exp_not:N\xfm_append_keyval:nnN
          {#2}
        }
        {
          \exp_not:N\xfm_linkappend_keyval:nnnnN
          {#2}
          {\l_keysetupiii_marker_id_tl}
          {\l_keysetupiii_source_area_id_tl}
        }
          {\l_keysetupiii_target_area_id_tl}
          ##1
      }
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xfm_error_key:nn}
%    Raise an error when a required keyword (|#2|) in the front matter
%    structure |#1| is missing. Could and should give better help one
%    day.
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_error_key:nn #1#2 {
  \PackageError{xfm}{Required~ keyword~`#2'~missing~ in~
     front~ matter~ structure~ `#1'}\@eha}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsubsection{Processing data of one author}
%
%
% \begin{macro}{\xfm_distribute_structure_data:nn}
%    This macro takes the reference to one author as an argument and
%    processes for this author all keywords specified in
%    |\g_xfm_author_keyword_order_tl|, i.e., distributes their values
%    to appropriate title areas as specified by the keyword instance
%    (including references if requested).
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_distribute_structure_data:nn #1#2 {
%    \end{macrocode}
%    Loop over the keyword names in |#1|
%    and\ldots
%    \begin{macrocode}
  \clist_map_inline:cn
  {g_xfm_ #1 _keyword_order_tl}
  {
%    \end{macrocode}
%    \ldots call for each keyword the command that holds the code to
%    distribute and manipulate the keyword value is present. This
%    command requires the authors property list so we construct it as
%    well.
%    \begin{macrocode}
    \tl_if_eq:cNTF {xfm_process_key_ #1-##1 :N} \relax
%    \end{macrocode}
%    Runtime checking like this bad, should be checked in the template
%    code!\footnote{FIX!}
%    \begin{macrocode}
    { \PackageError{xfm}{Undeclared~ keyword:~ ##1}\@eha }
    {
        \exp_args:cc {xfm_process_key_ #1-##1 :N}
                     {g_xfm_structure_ #2 _prop}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% The macro
% |\xfm_process_key_|\meta{structure-name}|-|\meta{key-name}|:N| in
% the above loop is supposed to distribute the key value to a target
% area according to the specification given in the declaration for
% this key. This is done in one of two ways: the simple form simply
% adds the value as an element to an area and makes sure that it is
% properly separated by a separator function (as explained in the
% section on areas) --- this is done by calling
% |\xfm_append_keyval:nnN| with appropriate arguments.
%
% The more complicated form also
% handles linking the information with some other area by putting
% marker elements into both --- this is done by calling
% |\xfm_linkappend_keyval:nnnnN| with appropriate arguments.
%
% Some attempt was made to make these two macros independent of the
% particular |\author| key data structure. However, this isn't fully
% done so more work is needed if the macros should be usable on
% non-author property lists.
%
%
% \begin{macro}{\xfm_append_keyval:nnN}
%    The |\xfm_append_keyval:nnN| command takes three arguments: a key
%    name, a target area name, and a property list in which we look up
%    the key.
%    \begin{macrocode}
\tl_new:N \l_xfm_tmp_tl
\cs_set_nopar:Npn \xfm_append_keyval:nnN #1#2#3 {
%    \end{macrocode}
%    As a first step look up the key in the property list assuming
%    that the property list key is constructed from the key name by
%    prepending |\xfm_key_|. The result is stored in
%    |\g_xfm_result_tl|.
%    \begin{macrocode}
  \prop_get:NcN
     #3
     {xfm_key_#1}
     \l_xfm_tmp_tl
  \tl_gset_eq:NN \g_xfm_result_tl \l_xfm_tmp_tl
%    \end{macrocode}
%    Check if we have found this key at all (otherwise we now have the
%    quark |\q_no_value| in |\g_xfm_result_tl|):
%    \begin{macrocode}
  \quark_if_no_value:NTF \g_xfm_result_tl
%    \end{macrocode}
%    If the key was not found we execute the code that was set up when
%    the key was registered. It will either be |\relax| or generate an
%    error if the key is required.
%    \begin{macrocode}
     { \use:c {xfm_missing_key_#1:} }
%    \end{macrocode}
%    If the key was found we add its value to the target area.
%    \begin{macrocode}
     { \xfm_add_element:nno {#2} {key!#1} \g_xfm_result_tl }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm_linkappend_keyval:nnnnN}
%    \begin{macrocode}
% key-name, marker-name, sourcearea-name, target-area-name, author-prop
% #1      , #2         , #3                #4                #5


\cs_set_nopar:Npn \xfm_linkappend_keyval:nnnnN #1#2#3#4#5 {
  \prop_get:NcN
     #5
     {xfm_key_#1}
     \l_xfm_tmp_tl
  \tl_gset_eq:NN \g_xfm_result_tl \l_xfm_tmp_tl
%    \end{macrocode}
%    If the key was specified we have a value in |\g_xfm_result_tl|,
%    otherwise the key is missing and we may or may not have to do
%    something about that.
%    \begin{macrocode}
  \quark_if_no_value:NTF \g_xfm_result_tl
%    \end{macrocode}
%    Do whatever is required if the key is missing token at this point
%    (the code is in the macro being constructed):
%    \begin{macrocode}
     { \use:c {xfm_missing_key_#1:} }
%    \end{macrocode}
%
%    \begin{macrocode}
     {
      \tl_set_eq:NN \l_xfm_result_tl \q_no_value

      \prop_map_function:cc
          {g_xfm_ #2 _prop}
          {xfm_find_marker_#4-#1:Nn}

      \quark_if_no_value:NT \l_xfm_result_tl
%    \end{macrocode}
%
%    Value does not exist, so make new mark:
%    \begin{macrocode}
        {
          \stepcounter{#2}
          \protected@xdef
             \g_xfm_resultiii_tl { \use:c{the#2} }

%    \end{macrocode}
%    Next bit of code adds an entry to the property list
%    |#2|, this could be done manually which would be faster but less
%    understandable.
%
%    First start the value of the marker number and the text as two
%    brace groups in |\g_xfm_resultii_tl|
%    \begin{macrocode}
          \tl_gset:No
             \g_xfm_resultii_tl
             { \exp_after:wN { \g_xfm_resultiii_tl } }
          \tl_gput_right:No
             \g_xfm_resultii_tl
             { \exp_after:wN { \g_xfm_result_tl } }
%    \end{macrocode}
%    Then put all of that into the property list:
%    \begin{macrocode}
          \prop_gput:cco
             {g_xfm_ #2 _prop}
             {mark-\the\value{#2}}
             \g_xfm_resultii_tl

%    \end{macrocode}
%
%    \begin{macrocode}
          \xfm_add_element:nno {#4} {marker!#2} \g_xfm_resultiii_tl

          \xfm_add_element:nno {#4} {key!#1} \g_xfm_result_tl

        }
%    \end{macrocode}
%    At this point the mark reference is definitely in
%    |\l_xfm_result_tl| so we can append it to the
%    to the source area.
%    \begin{macrocode}

      \xfm_add_element:nno {#3} {marker!#2} \g_xfm_resultiii_tl

     }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\g_xfm_result_tl}
% \begin{macro}{\g_xfm_resultii_tl}
% \begin{macro}{\g_xfm_resultiii_tl}
% \begin{macro}{\l_xfm_result_tl}
%    Some temporary storage bins three globally used one locally (but
%    this is mainly a historical fact.
%    \begin{macrocode}
\tl_new:N \g_xfm_result_tl
\tl_new:N \g_xfm_resultii_tl
\tl_new:N \g_xfm_resultiii_tl
\tl_new:N \l_xfm_result_tl
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm_find_marker:Nn}
%    \begin{macrocode}
%    This bit of code finds an already existing marker with a value
%    equal to the text stored in |\g_xfm_result_tl|.
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_find_marker:Nn #1 #2 {
  \tl_gset:No \g_xfm_resultii_tl  { \use_ii:nn #2 }
  \tl_gset:No \g_xfm_resultiii_tl { \use_i:nn  #2 }
  \tl_if_eq:NNT \g_xfm_result_tl \g_xfm_resultii_tl
    { \tl_set:Nn \l_xfm_result_tl {#1}
      \cs_set_eq:NN \prop_map_funct:Nn \use_none:nn
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \subsection{Remaining Document Commands}
%
%
%
% \begin{macro}{\xfm_structure_loop:n}
% \begin{macro}{\xfm_structure_loop:nN}
%    |\xfm_structure_loop:n| loops through an structure sequence (i.e.,
%    |\g_xfm_#1_seq|) and applies
%    |\xfm_distribute_structure_data:nn{#1}| to each structure element
%    in the sequence.
%
%    |\xfm_structure_loop:nN| is the variant that needs to be used if
%    the sequence name is not standard (i.e., not the one corresponding
%    to the structure), for example, during sorting.
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_structure_loop:n #1 {
  \xfm_structure_loop:cn
     {g_xfm_ #1 _seq}
     {#1}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_structure_loop:Nn #1#2 {
  \seq_map_inline:Nn
    #1
    { \xfm_distribute_structure_data:nn{#2}{##1} }
%    \end{macrocode}
%    A bit of debugging (at the moment):
%    \begin{macrocode}
  \XFMShowAreas
}
\cs_generate_variant:Nn \xfm_structure_loop:Nn {cn}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
% \subsection{Algorithm for sorting by address}
%
% The author numbers are stored in a sequence which at the start simply
% contains the numbers $1$ to $n$ if we have $n$ authors in the preamble
% specified.
%
% The algorithm works on this sequence in the following way:
% \begin{itemize}
% \item Check if the |authors| sequence is empty; if so processing stops.
% \item Otherwise remove the first element from the |authors| sequence and
%   retrieve its address and store its value in |curr-address|.
% \item Store the element as the first element of the sequence
%   |curr-seq|.
% \item Clear the sequence |remaining-authors|.
% \item Set the counter |author-cnt| to 1.
% \item Now loop through the remainder of the sequence |authors| and do the
%   following:
%   \begin{itemize}
%   \item If for the current element the address is the same as
%     |cur-address| append the current element to |curr-seq| and
%     advance |author-cnt| by one.
%   \item Otherwise append the current element to the sequence
%     |remaining-authors|.
%   \end{itemize}
% \item Replace the contents of the |authors| sequence by the contents of
%   the |remaining-authors| sequence.
% \end{itemize}
% At this point in time we have the following situation:
% \begin{itemize}
% \item Queue |curr-address| contains the current address.
% \item Tlp |curr-seq| contains the authors having this address.
% \item |author-cnt| contains the number of authors in this sequence.
% \item Queue |authors| contains the remaining authors having addresses
%   not yet processed.
% \end{itemize}
% This means that we can now format the authors in |curr-seq| and then
% restart the algorithm processing any remaining authors started in the
% |authors| sequence.
%
% \subsubsection{Processing the \texttt{curr-seq}}
%
% The authors in |curr-seq| will be processed in the normal way, i.e.,
% by looping through all keywords of interest (with the exception of
% |address| since that is the same for all authors in the sequence) and
% appending their values to appropriate areas.
%
% As a result we will get:
% \begin{itemize}
% \item The authors names followed by any labels in
%   |\g_xfm_authors_list_tl|.
% \item The address still in |curr-address|.
% \item Any other keyword values the desired area lists, e.g., if
%   |thanks| is moved to the |footnote-area| its value will be appended
%   there in the form
% \begin{verbatim}
%   \xfm_format_key_thanks:nn{<label-number>}{<text>}
% \end{verbatim}
%   allowing further formatting at this point as desired.
% \end{itemize}
%
% By default we only append data to the areas. This means that if an
% area is to be intended to belong solemnly to the group of authors
% currently processed (i.e., those in |curr-seq|) then it is the
% responsibility the processing code to clear those areas.
%
% For example, if the layout is to be something like this:
% \begin{verbatim}
%    <Author1>, <Author2>, and <Author3>
%
%    <Main address for all authors above>
%    <data special to individual authors referenced via labels>
%
%    <Author4>, ...
% \end{verbatim}
% then the area receiving the ``special data'' needs to be cleared after
% processing to avoid that its contents shows up again below
% |<Author4>|. On the other hand, data going into the footnote area does
% not need this treatments since the latter area is processed only once
% at the very end.
%
%
%
%
% \begin{macro}{\g_xfm_curr_sort_seq}
% \begin{macro}{\g_xfm_remaining_sort_seq}
%    Two sequences are used when sorting some sequence by a key:
%    |\g_xfm_curr_sort_seq| receives elements matching the current
%    key value while |\g_xfm_remaining_sort_seq| receives those
%    which do not match and need further processing at a later
%    stage.
%    \begin{macrocode}
\seq_new:N \g_xfm_curr_sort_seq
\seq_new:N\g_xfm_remaining_sort_seq
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\g_xfm_curr_sort_value_tl}
%    In |\g_xfm_curr_sort_value_tl| we store the value of a key when
%    doing sorting by this key.
%    \begin{macrocode}
\tl_new:N \g_xfm_curr_sort_value_tl
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm_structure_sorted_by:nnn}
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_stucture_sorted_by:nnn #1#2 {
   \xfm_structure_sorted_by:ccnnn
     {g_xfm_ #1 _seq}
     {xfm_key_ #2}
     {#1}
     {#2}
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xfm_structure_sorted_by:NNnnn}
%    The |\xfm_structure_sorted_by:NNnnn| macro takes formatting
%    instructions as its argument: those which should be processed
%    when all authors with a certain address have been found.
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_structure_sorted_by:NNnnn #1#2#3#4#5 {
%    \end{macrocode}
%    We start by looking if the sequence |#1| is empty,
%    if so we have done all that is needed and return immediately
%    (this ends the recursive call below).
%    \begin{macrocode}
  \seq_if_empty:NTF #1
    {}
%    \end{macrocode}
%    Otherwise we prepare for finding the next batch of authors with
%    the same address. For this we clear the sequence
%    |\g_xfm_curr_sort_seq| which will receive all authors found.
%    The sequence |\g_xfm_remaining_sort_seq| doesn't need clearing
%    since it is empty at this point (see below).
%    \begin{macrocode}
    {
     \seq_gclear:N \g_xfm_curr_sort_seq
%    \end{macrocode}
%    Then we pop the top element from |#1| and store
%    the result in |\g_xfm_result_tl| and also put it into the sequence
%    |\g_xfm_curr_sort_seq|.
%    \begin{macrocode}
     \seq_gpop:NN
       #1
       \g_xfm_result_tl
     \seq_gput_right:No
       \g_xfm_curr_sort_seq
       \g_xfm_result_tl
%    \end{macrocode}
%    Next step is to retrieve the keyword value for this structure and
%    store it in |\g_xfm_curr_sort_value_tl|.
%    \begin{macrocode}
     \prop_get:cnN
       {g_xfm_structure_ \g_xfm_result_tl _prop}
       {#2}
       \l_xfm_tmp_tl
     \tl_gset_eq:NN \g_xfm_curr_sort_value_tl \l_xfm_tmp_tl

%    \end{macrocode}
%    If the key was not in we have a problem (perhaps the solution is
%    to make this key required if you want to sort by it :-) --- have
%    to think it through, for the moment we just balk.
%    \begin{macrocode}
     \quark_if_no_value:NT
        \g_xfm_curr_sort_value_tl
        {
         \PackageError{xfm}{Keyword~ `#4'~ for~ sorting~ missing~ in~
           structure~ `#3'}\@eha
         \tl_gset:Nn \g_xfm_curr_sort_value_tl {<MISSING~KEY>}
        }
%    \end{macrocode}
%    Since we have found the first author for this address we set the
%    |\g_xfm_structure_int| to 1.
%    \begin{macrocode}
     \int_gset:Nn \g_xfm_structure_int \c_one
%    \end{macrocode}
%    Now we loop through the remaining elements in the sequence
%    |#1| each time determining whether or not the
%    element under inspection has the same address as stored in
%    |\g_xfm_curr_sort_value_tl| and if so add it to
%    |\g_xfm_curr_sort_seq|. Otherwise we add it to the sequence
%    |\g_xfm_remaining_sort_seq|. This is done by mapping
%    |\xfm_find_key_value:Nn#2| over the sequence |#1|.
%    \begin{macrocode}
     \seq_map_inline:Nn
       #1
       { \xfm_find_key_value:Nn #2 {##1} }
%    \end{macrocode}
%    Once we are finished with this we can move the authors from the
%    |\g_xfm_remaining_sort_seq| back to |#1|
%    for the next iteration. After that this temporary sequence can be
%    cleared.
%    \begin{macrocode}
     \cs_gset_eq:NN #1 \g_xfm_remaining_sort_seq
     \seq_gclear:N \g_xfm_remaining_sort_seq
%    \end{macrocode}
%    A bit debugging stuff at this point:
%    \begin{macrocode}
%<*trace>
     \cs_show:N \g_xfm_curr_sort_seq
     \cs_show:N #1
%</trace>
%    \end{macrocode}
%    Now we loop through all the elements in |\g_xfm_curr_sort_seq|
%    and distribute their key values into the appropriate areas.
%    \begin{macrocode}
     \xfm_structure_loop:Nn
       \g_xfm_curr_sort_seq
       {#3}
%    \end{macrocode}
%
%    The\marginpar{WRONG: this is still done correctly only for
%    addresses area and address keyword!!! FIXME}
%    next bit of code isn't really as it should be (I guess) but
%    we have a problem here: if |value-combine-boolean| was set to |false|
%    for the |address| key we end up with the current address several
%    times in the |\g_xfm_addresses_list_tl| which makes the |address|
%    area basically unusable.
%
%    But why use this area in the first place and not
%    |\g_xfm_curr_sort_value_tl| which contains the current address?
%    Well, for one we can have the situation that alternate addresses
%    should also go into that area, perhaps mixed with emails etc. But
%    this only makes sense if the |address| key is set up in a way
%    that it appears only once, i.e., if |value-combine-boolean| for it is
%    set to |true|.
%
%    So the current logic is as follows:
%    \begin{itemize}
%    \item
%      If |value-combine-boolean| is |false| for the key used in
%      sorting then the
%      current key value will be the only text appearing the
%      corresponding target area; if any other keys contribute to that
%      area ---
%      tough, their values get overwritten.
%    \item
%      Otherwise keys are distributed into any area in the normal
%      fashion.
%    \end{itemize}
%    First we store the target-area of the sort key in
%    |\g_xfm_curr_target_area_tl| since it is needed several times below.
%    \begin{macrocode}
    \tl_gset:Nx \g_xfm_curr_target_area_tl
         { \use:c {xfm_target_area_ #3-#4 _tl} }
%    \end{macrocode}
%
%    The status of the |value-combine-boolean| key for current sort
%    key can be found by looking at
%    |\xfm_find_marker_|\meta{target-area}|-|\meta{sort-key}|:Nn|. If
%    it equals |\use_none:nn|, then we haven't
%    been asked to combine values for this key.
%    \begin{macrocode}
    \cs_if_eq:cNT {xfm_find_marker_ \g_xfm_curr_target_area_tl -#4 :Nn}
               \use_none:nn
%    \end{macrocode}
%    So this is the case when we overwrite whatever was added to
%    |\g_xfm_|\meta{target-area}|_list_tl| and replace it by a single
%    value and its separator function:
%    \begin{macrocode}
      {
       \tl_gset:cx {g_xfm_ \g_xfm_curr_target_area_tl _list_tl}
         {
           \exp_not:N
           \xfm_area_sep:nnn   {\g_xfm_curr_target_area_tl} {START}{key!#4}
           \exp_not:N
           \xfm_area_value:nnn {\g_xfm_curr_target_area_tl} {key!#4}
         }
%    \end{macrocode}
%    Adding the actual value is done in a separate step since we can't
%    use |\xdef| with unknown data.
%    \begin{macrocode}
       \tl_gput_right:co
         { g_xfm_ \g_xfm_curr_target_area_tl _list_tl }
         { \exp_after:wN { \g_xfm_curr_sort_value_tl } }
      }
%    \end{macrocode}
%
%    So finally we are ready to do some formatting:
%    \begin{macrocode}
     #5
%    \end{macrocode}
%    And then recourse if necessary:
%    \begin{macrocode}
     \xfm_structure_sorted_by:NNnnn #1 #2 {#3} {#4} {#5}
    }
}
\cs_generate_variant:Nn \xfm_structure_sorted_by:NNnnn {ccnnn}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm_find_key_value:Nn}
%    The |\xfm_find_key_value:Nn| is the code that tries to find elements
%    with the same key value as the one given in
%    |\g_xfm_curr_sort_value_tl|. The first argument is the internal
%    key and the second is a pointer to a
%    structure property list name as we store it in the structure sequences.
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_find_key_value:Nn #1#2 {
%    \end{macrocode}
%    First we retrieve the key value for the current element and
%    store it in |\g_xfm_result_tl|.
%    \begin{macrocode}
  \prop_get:cnN
    {g_xfm_structure_ #2 _prop}
    {#1}
    \l_xfm_tmp_tl
  \tl_gset_eq:NN \g_xfm_result_tl \l_xfm_tmp_tl
%    \end{macrocode}
%    If this value corresponds to what is stored in
%    |\g_xfm_curr_sort_value_tl| we add the current element to the
%    |\g_xfm_curr_sort_seq| sequence and increment the counter
%    counting the number of elements found.
%    \begin{macrocode}
  \tl_if_eq:NNTF \g_xfm_result_tl \g_xfm_curr_sort_value_tl
    {
     \int_gincr:N \g_xfm_structure_int
     \seq_gput_right:Nn \g_xfm_curr_sort_seq {#2}
    }
%    \end{macrocode}
%    Otherwise we add the current element to the sequence of remaining
%    elements, i.e., |\g_xfm_remaining_sort_seq|.
%    \begin{macrocode}
    {
     \seq_gput_right:Nn \g_xfm_remaining_sort_seq {#2}
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \section{Stuff}
%
%
%
%
%
%    \begin{macrocode}
\DeclareObjectType{titlesetup}{0}

\DeclareTemplateInterface{titlesetup}{authorbyaddress}{0}{
   authorinfo-keyword-list   : tokenlist ,
   articleinfo-keyword-list  : tokenlist ,
   top-areas-list            : tokenlist ,
   author-areas-list         : tokenlist ,
   bottom-areas-list         : tokenlist ,
   footins-areas-list        : tokenlist ,
   end-areas-list            : tokenlist ,
   title-post-v-skip         : skip ,
 }


\tl_new:N \g_xfm_authorinfo_keyword_order_tl
\tl_new:N \g_xfm_articleinfo_keyword_order_tl
\tl_new:N \g_xfm_top_areas_tl
\tl_new:N \g_xfm_authors_areas_tl
\tl_new:N \g_xfm_bottom_areas_tl
\tl_new:N \g_xfm_footins_areas_tl
\tl_new:N \g_xfm_end_areas_tl

\skip_new:N \g_xfm_title_post_v_skip

\DeclareTemplateCode{titlesetup}{authorbyaddress}{0}{
   authorinfo-keyword-list  = global \g_xfm_authorinfo_keyword_order_tl,
   articleinfo-keyword-list = global \g_xfm_articleinfo_keyword_order_tl,
   top-areas-list           = global \g_xfm_top_areas_tl,
   author-areas-list        = global \g_xfm_authors_areas_tl,
   bottom-areas-list        = global \g_xfm_bottom_areas_tl,
   footins-areas-list       = global \g_xfm_footins_areas_tl,
   end-areas-list           = global \g_xfm_end_areas_tl,
   title-post-v-skip        = global \g_xfm_title_post_v_skip,
 }
 {

   \tl_gset:Nn \g_xfm_authorinfo_keyword_order_tl {name,address,thanks}
   \tl_gset:Nn \g_xfm_articleinfo_keyword_order_tl{title,subtitle,thanks}

   \tl_gclear:N \g_xfm_footins_areas_tl
   \tl_gclear:N \g_xfm_end_areas_tl

   \skip_gzero:N \g_xfm_title_post_v_skip

   \AssignTemplateKeys

   \xfm_structure_loop:n {articleinfo}

   \null % right start?

   \xfm_typeset_area_list:N \g_xfm_top_areas_tl

   \xfm_stucture_sorted_by:nnn
     {authorinfo}
     {address}
     { \xfm_typeset_area_list:N \g_xfm_authors_areas_tl  }

   \xfm_typeset_area_list:N \g_xfm_bottom_areas_tl

   \xfm_typeset_insertion_area_list:oN
     \g_xfm_footins_areas_tl
     \footins

   \vskip \g_xfm_title_post_v_skip \scan_stop:

   \AtEndDocument{ \xfm_typeset_area_list:N\g_xfm_end_areas_tl }
 }




\DeclareTemplateInterface{titlesetup}{std}{0}{
   authorinfo-keyword-list  : tokenlist ,
   articleinfo-keyword-list : tokenlist ,
   top-areas-list           : tokenlist ,
   footins-areas-list       : tokenlist ,
   end-areas-list           : tokenlist ,
   lhead-areas-list         : tokenlist ,
   rhead-areas-list         : tokenlist ,
   title-post-v-skip        : skip ,
 }


\tl_new:N \g_xfm_lhead_areas_tl
\tl_new:N \g_xfm_rhead_areas_tl

\DeclareTemplateCode{titlesetup}{std}{0}{
   authorinfo-keyword-list  = global \g_xfm_authorinfo_keyword_order_tl,
   articleinfo-keyword-list = global \g_xfm_articleinfo_keyword_order_tl,
   top-areas-list           = global \g_xfm_top_areas_tl,
   footins-areas-list       = global \g_xfm_footins_areas_tl,
   end-areas-list           = global \g_xfm_end_areas_tl,
   lhead-areas-list         = global \g_xfm_lhead_areas_tl,
   rhead-areas-list         = global \g_xfm_rhead_areas_tl,
   title-post-v-skip        = global \g_xfm_title_post_v_skip,
 }
 {

   \tl_gset:Nn\g_xfm_authorinfo_keyword_order_tl{name,address,thanks}
   \tl_gset:Nn\g_xfm_articleinfo_keyword_order_tl{title,subtitle,thanks}

   \tl_gclear:N \g_xfm_top_areas_tl
   \tl_gclear:N \g_xfm_footins_areas_tl
   \tl_gclear:N \g_xfm_end_areas_tl
   \tl_gclear:N \g_xfm_lhead_areas_tl
   \tl_gclear:N \g_xfm_rhead_areas_tl

   \skip_gzero:N \g_xfm_title_post_v_skip


   \AssignTemplateKeys

   \xfm_structure_loop:n {articleinfo}
   \xfm_structure_loop:n {authorinfo}

   \null % right start?

   \xfm_typeset_area_list:N \g_xfm_top_areas_tl

   \xfm_typeset_insertion_area_list:oN
     \g_xfm_footins_areas_tl
     \footins

   \vskip \g_xfm_title_post_v_skip \scan_stop:

   \AtEndDocument{ \xfm_typeset_area_list:N \g_xfm_end_areas_tl }
 }

%    \end{macrocode}
%
%
%    \begin{macrocode}
\cs_set_nopar:Npn \maketitle{
  \UseInstance{titlesetup}{maketitle}
}
%    \end{macrocode}
%
%
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_typeset_area_list:N #1 {
  \clist_map_inline:Nn #1 {
    \IfInstanceExistTF{textarea}{##1}
      { \UseInstance{textarea}{##1} }
      \scan_stop:
  }
}
%    \end{macrocode}
%
%
%    \begin{macrocode}
\cs_set_nopar:Npn \xfm_typeset_insertion_area_list:oN #1#2 {
  \clist_map_inline:Nn #1 {
    \IfInstanceExistTF{textarea}{##1}
    {
      \tl_if_eq:cNF {g_xfm_ ##1 _list_tl}
      \c_empty_tl
% actually here we would need to test for required area perhaps???
      {
        \insert #2 { \UseInstance{textarea}{##1} }
      }
    }
    \relax
  }
}
%    \end{macrocode}
%
%    now where is this used? (document)
%    \begin{macrocode}
%--------START-----------
\cs_set_nopar:Npn \XFMSplitOnComma #1#2#3 {
  \cs_gset_eq:NN \xfm_split_code \c_empty_tl
  \clist_map_inline:nn {#1}{
    \exp_after:wN \xfm_split_code
    \exp_after:wN #3\exp_after:wN {\exp_after:wN \ignorespaces ##1}
    \cs_gset_nopar:Npn \xfm_split_code{#2}
  }
}

%    \end{macrocode}
%
%
%    \begin{macrocode}

\newcommand*\UseBBskip[1]{
    \mode_if_horizontal:T { \par }
    \setlength\@tempskipa{#1 - \parskip - \baselineskip}
    \vskip\@tempskipa
}
%    \end{macrocode}
%
%    \begin{macrocode}


% #1 value-target-area
% #2 text-type (keyword)
% #3 marker-name
% #4 value picked up

\cs_set_nopar:Npn \dothanks #1#2#3#4 {
  \stepcounter{#3}
  \protected@xdef
    \g_xfm_resultiii_tl { \cs:w the#3 \cs_end: }

  \xfm_add_element:nno {#1} {marker!#3} \g_xfm_resultiii_tl

  \xfm_add_element:nnn {#1} {key!#2} {#4}

  \xfm_area_sep:nnn   \l_textarea_id_tl {SUB} {marker!#3}
  \xfm_area_value:nnn \l_textarea_id_tl {marker!#3} \g_xfm_resultiii_tl
  \xfm_area_sep:nnn   \l_textarea_id_tl {marker!#3} {SUB}
}

%    \end{macrocode}
%
% \begin{macro}{\DeclareFMStructure}
%    \begin{macrocode}
\cs_set_nopar:Npn \DeclareFMStructure #1#2{
 \UseTemplate{structuresetup}{std}
   {#2}{#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{structuresetup (template type)}
%    \begin{macrocode}
\DeclareObjectType{structuresetup}{1}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{structuresetup/std (template)}
%    \begin{macrocode}
\DeclareTemplateInterface{structuresetup}{std}{1}{
  accepted-keyword-list : tokenlist ,
 }


\tl_new:N \l_structuresetup_accepted_list_tl


\DeclareTemplateCode{structuresetup}{std}{1}{
  accepted-keyword-list = \l_structuresetup_accepted_list_tl,
 }
 {
  \tl_clear:N \l_structuresetup_accepted_list_tl

  \AssignTemplateKeys

  \cs_set_nopar:cpn {#1} ##1 {
    \int_gincr:N \g_xfm_structure_int
    \prop_new:c
       {g_xfm_structure_ \int_use:N\g_xfm_structure_int _prop}
    \seq_gput_right:co
       {g_xfm_ #1 _seq}
       {\int_use:N\g_xfm_structure_int}
    \setkeys{xfm-#1}{##1}
  }
  \seq_new:c {g_xfm_ #1 _seq}

%    \end{macrocode}
%    The way it is now the contents of |\l_structuresetup_accepted_list_tl|
%    needs to be a comma separated list \emph{without} blanks. In
%    practise this probably needs to be allowed since normally blanks
%    are ignored in templates.\footnote{FIX}
%    \begin{macrocode}
  \cs_set_nopar:Npn \xfm_structuresetup_accepted_std_template_aux:n ##1 {
    \cs_gset_eq:cN
      { KV@xfm-#1@ ##1 }
      \xfm_structure_parse_keyword_code:n
%    \end{macrocode}
%    The above ensures that the keyword will get parsed properly and
%    the one below ensures that by default we do nothing with it
%    during processing.
%    \begin{macrocode}
    \cs_gset_eq:cN
      { xfm_process_key_ #1-##1 :N }
      \use_none:n
  }
  \clist_map_function:NN
    \l_structuresetup_accepted_list_tl
    \xfm_structuresetup_accepted_std_template_aux:n
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}



% use: \xfm_gget_object_count:nN {name}\g_xfm_author_cnt_tl

\cs_set_nopar:Npn \xfm_gget_object_count:nnN #1#2#3 {
  \group_begin:
    \int_zero:N \l_tmpa_int
    \cs_set_nopar:Npn \l_tmpa_tl {key!#2}
    \cs_set_eq:NN  \xfm_area_sep:nnn\use_none:nnn
    \cs_set_nopar:Npn \xfm_area_value:nnn ##1##2##3 {
      \cs_set_nopar:Npn \l_tmpb_tl {##2}
      \tl_if_eq:NNT \l_tmpa_tl \l_tmpb_tl
                  { \int_incr:N \l_tmpa_int }
    }
    \tl_use:c {g_xfm_ #1 _list_tl}
    \tl_gset:Nx #3 {\int_use:N \l_tmpa_int}
  \group_end:
}

\int_new:N \g_xfm_author_int

\int_new:N  \l_xfm_typeset_objects_int

\cs_set_nopar:Npn \FMAuthorSeparation {
  \int_compare:nNnTF \g_xfm_author_int = \c_zero
  {
    \xfm_gget_object_count:nnN{authors}{name}\g_xfm_author_int
    \int_set:Nn \l_xfm_typeset_objects_int \c_one
  }
  {
    \int_incr:N \l_xfm_typeset_objects_int
  }
  \int_compare:nNnTF \l_xfm_typeset_objects_int = \g_xfm_author_int
  {
    \tex_ifcase:D \l_xfm_typeset_objects_int
    \tex_or:D
    \tex_or:D   % =2
       \space and~
    \else:
       ,~ and~
    \fi:
    \int_gzero:N \g_xfm_author_int
  }
  { ,~ }
}


% note that spaces at the arguments' edges will vanish unless
% explicitly given as |\space| not |~| this is due to the template
% getting rid of them on either side (i think, not checked)

\DeclareObjectType{XFMobjectsep}{0}

\DeclareTemplateInterface{XFMobjectsep}{std}{0}{
  area-id            : tokenlist ,
  keyword-id         : tokenlist ,
  first-action       : tokenlist ,
  medial-action      : tokenlist ,
  last-of-two-action : tokenlist ,
  last-action        : tokenlist ,
 }


\tl_new:N \objectsep_area_tl
\tl_new:N \objectsep_keyword_tl
\tl_new:N \objectsep_first_action
\tl_new:N \objectsep_medial_action
\tl_new:N \objectsep_lastoftwo_action
\tl_new:N \objectsep_last_action

\DeclareTemplateCode{XFMobjectsep}{std}{0}{
  area-id            = \objectsep_area_tl,
  keyword-id         = \objectsep_keyword_tl,
  first-action       = \objectsep_first_action,
  medial-action      = \objectsep_medial_action,
  last-of-two-action = \objectsep_lastoftwo_action,
  last-action        = \objectsep_last_action,
 }
 {

  \AssignTemplateKeys

%\traceon

  \int_compare:nNnTF \g_xfm_author_int = \c_zero
  {
    \exp_args:NNo
      \xfm_gget_object_count:nnN
      \objectsep_area_tl
      {\objectsep_keyword_tl}
      \g_xfm_author_int
    \int_set:Nn \l_xfm_typeset_objects_int \c_one
    \objectsep_first_action
  }
  {
    \int_incr:N \l_xfm_typeset_objects_int

    \int_compare:nNnTF \l_xfm_typeset_objects_int = \g_xfm_author_int
    {
      \tex_ifcase:D \l_xfm_typeset_objects_int
      \tex_or:D
      \tex_or:D   % =2
        \objectsep_lastoftwo_action
      \else:
        \objectsep_last_action
      \fi:
      \int_gzero:N \g_xfm_author_int
    }
    {
      \objectsep_medial_action
    }
  }
 }
%    \end{macrocode}

%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \endinput
\endinput
