% \iffalse
%%
%% (C) Copyright 1999, 2009 Frank Mittelbach, LaTeX3 Project
%%
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xlists bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%%
%
%<*driver|package>
\RequirePackage{expl3}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {Generic lists}
%\iffalse
%<*driver>
%\fi
%\iffalse
 \documentclass{ltxdoc}
 \usepackage{textcomp}
 \usepackage{ldcdoc}
 \EnableCrossrefs \CodelineIndex

\DeclareDocumentEnvironment{inlineenumerate}
   { }
   { \UseInstance{list}{inlineenumerate} \NoValue \NoValue \BooleanFalse }
   { \EndThisList }

\DeclareInstance{list}{inlineenumerate}{inline}{
  pre-hmaterial-setup  = \UseTemplate{hmaterial}{std}
                             {penalty=0,space=1em},
 item-hmaterial-setup  = \UseTemplate{hmaterial}{std}
                             {penalty=-300,space=.5em},
 item-post-hmaterial-setup  = \UseTemplate{hmaterial}{std}
                             {penalty=10000,space=5pt},
 post-hmaterial-setup  = \UseTemplate{hmaterial}{std}
                             {penalty=0,space=1em},
  item-label-text    = \alph{enumi}.\@,
  item-label-format  = \textbf{#1},
  counter-id    = enumi,
}
 \begin{document}
 \DocInput{xlists.dtx}
 \end{document}
%</driver>
% \fi
%
%
% \GetFileInfo{xlists.dtx}
%
% \title{The \textsf{xlists} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
% \section{Interfaces}
%
% \begin{TemplateInterfaceDescription}{list}
%
%   \TemplateArgument{1}
%       {String to calculate the value for left margin indentation
%       (using the normal item-label formatting information) or
%       \NoValue{} in which case
%        the default from the list instance is used --- in case of
%        inline lists this value is always ignored.}
%
%   \TemplateArgument{2}
%       {Symbol/string to be used as item label or \NoValue{} in
%        which the default from the list is used.}
%
%   \TemplateArgument{3}
%       {If \BooleanFalse, a list using a counting mechanism will start
%        counting with 1. If \BooleanTrue it continues with the
%        current value of the respective counter --- with non-counting
%        lists the argument is always ignored.}
%
%   \TemplateSemantics
%
% Outer shell for a list-like environment. It is supposed to set up
% |\ListItem| as the starting point for ``item''s within the list, and
% is supposed to be finished of with |\EndThisList| (so it better
% adjusts that one as well).
%
% \end{TemplateInterfaceDescription}
%
%
% \begin{TemplateInterfaceDescription}{labelposition}
%
%   \TemplateArgument{0}{---}
%
%   \TemplateSemantics
%
%    Sets up certain parameters that define the position of the item
%    label. Can make use of the following internal parameter to do
%    this: |\leftmargin|.
%
% \end{TemplateInterfaceDescription}
%
%
% \section{Examples}
%
% Setting up a standard enumerate environment using the `list'
% template type, i.e., no optional arguments which means all three
% arguments of the template receive a |\NoValue| or |\BooleanFalse| value.
% The list is
% ended via |\EndThisList|.
%\begin{verbatim}
%\DeclareDocumentEnvironment{enumerate}
%   {  }
%   { \UseInstance{list}{enumerate} \NoValue \NoValue \BooleanFalse }
%   { \EndThisList }
%\end{verbatim}
%
% Items within the list template type are started using |\ListItem| an
% interface to this with one optional argument is the following:
%\begin{verbatim}
%\DeclareDocumentCommand \item
%   { o }
%   { \ListItem {#1} }
%\end{verbatim}
%
% Next environment continues a previous `enumerate' by specifying
% |\BooleanTrue| as the third argument:
%\begin{verbatim}
%\DeclareDocumentEnvironment{enumerate*}
%   {  }
%   { \UseInstance{list}{enumerate} \NoValue \NoValue \BooleanTrue }
%   { \EndThisList }
%\end{verbatim}
%
% A slightly non-standard itemize environment where the optional arg
% specifies an alternate label:
%\begin{verbatim}
%\DeclareDocumentEnvironment{itemize}
%   { o }
%   { \UseInstance{list}{itemize} \NoValue {#1} \BooleanFalse }
%   { \EndThisList }
%\end{verbatim}
%
% And finally a non-standard description environment where the
% optional argument specifies the size of left
% indentation.\footnote{One probably does want to specify a string to
% be measured instead but not now\ldots}
%\begin{verbatim}
%\DeclareDocumentEnvironment{description}
%   { o }
%   { \UseInstance{list}{description} {#1} \NoValue \BooleanFalse }
%   { \EndThisList }
%\end{verbatim}
%
%
% \StopEventually{}
%
% \section{Implementation}
%
% Set up certain defaults including to ignore white space
% within the body of this package.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\RequirePackage{galley2,xmaterial}
%    \end{macrocode}
%
% \begin{macro}{\trace}
%    A command for tracing under e\TeX{}
%    (useful stuff those extra debug flags).
%    \begin{macrocode}
\cs_new:Npn\trace{\tracingassigns=1\tracingall}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{ListItem implementation}
%
%
% \begin{macro}{\ListItem}
%    The |\ListItem| command is the class file interface for starting
%    the next item within an instance of type `list', e.g., calling it
%    within |\item| on the document level. Since it should only work
%    within such a list its definition on top level is to produce an
%    error message.
%    \begin{macrocode}
\cs_new:Npn\ListItem #1{
  \msg_error:nn { xlist }{ lonely-item }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xlist_format_item:n}
%    The |\xlist_format_item:n| is the real code for |\ListItem| when within a
%    list environment. It uses the following hooks which have to be
%    set up by any list template: |\xlist_item_initial_action:| (initialisation at
%    start), |\xlist_item_measure_and_format:| (measuring and outputting
%    or preparing for output of label), and
%    |\xlist_item_between_action:| (code to run at start of any inner
%    item, i.e., between two items).
%
%    Perhaps should get a * argument
%    as well, that kills off label formatting (?).
%    \begin{macrocode}
\cs_new:Npn \xlist_format_item:n #1 {
  \GAL_typeout:n{Item~ seen \on@line}
%
%    \end{macrocode}
%
%    First we look at the mandatory argument. If it is not |\NoValue|
%    we overwrite the |\l_xlist_item_label_text_tl| declaration from the list
%    template. At the same time we record whether or not we've seen a
%    user overwrite.
%    \begin{macrocode}
  \IfNoValueTF{#1}  { \bool_set_true:N  \l_xlist_no_item_bool }
                    { \bool_set_false:N \l_xlist_no_item_bool
                      \tl_set:Nn \l_xlist_item_label_text_tl {#1} }
%
%    \end{macrocode}
%
%    We then set up initial stuff if specified by the list environment
%    \begin{macrocode}
  \xlist_item_initial_action:
%    \end{macrocode}
%
%    The rest of the code depends on the state we are in: if we are at
%    the top of the list, i.e., seeing the first item we have two
%    cases to consider. A) an outer item label is not yet set in which
%    case we either have to output it first or do some item
%    accumulation and B) there is no such dangling item and we have to
%    set the first item of the current list which is not supposed to
%    get any extra space on top.
%    \begin{macrocode}
  \bool_if:NTF \g_new_list_bool
    {
%    \end{macrocode}
%    Now the list isn't any longer `new' since we have seen a first
%    item. So look at the |\g_in_labellist_bool| flag and if true run code the
%    potentially outputs the dangling item.
%    \begin{macrocode}
    \bool_gset_false:N \g_new_list_bool
    \bool_if:NT \g_in_labellist_bool
      {
       \GAL_typeout:n{in_labellist~ case \on@line}
       \list_process_accumulated_items:
      }
%    \end{macrocode}
%    Whatever happened above we now have to deal with the first item
%    in the current list, i.e., with the one that isn't supposed to
%    add inter-item space etc.
%    \begin{macrocode}
    \xlist_item_base_code:
%    \end{macrocode}
%    If not at the beginning of the list we output an ``inner'' item.
%    \begin{macrocode}
  }{
    \xlist_process_inner_item:
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\l_xlist_no_item_bool}
%    \begin{macrocode}
\bool_new:N \l_xlist_no_item_bool
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\l_xlist_numbered_bool}
%    \begin{macrocode}
\bool_new:N \l_xlist_numbered_bool
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xlist_item_base_code:}
%    The |\xlist_item_base_code:| code is not only used for the first item of
%    a list but is part of all item code.
%    \begin{macrocode}
\cs_new:Npn\xlist_item_base_code: {
  \GAL_typeout:n{xlist_item_base_code: \on@line}
%    \end{macrocode}
%     Depending on the fact that the |\ListItem| argument was user
%    specified or not we might have to step the list-counter is there
%    is any.
%    \begin{macrocode}
  \bool_if:NT \l_xlist_no_item_bool
    {
      \bool_set_false:N \l_xlist_no_item_bool
      \bool_if:NT \l_xlist_numbered_bool
                  { \refstepcounter \l_xlists_counter_name_tl }
    }
%    \end{macrocode}
%    Then we prepare to format and measure the item label.
%    \begin{macrocode}
  \xlist_item_measure_and_format:
%    \end{macrocode}
%    And that's about it, except for ignoring any spaces and |\par|s
%    that may follow.
%    \begin{macrocode}
  \GAL_ignore_pars:n
     {Something's~ wrong--perhaps~ a~ missing~
      end of list?}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xlist_process_inner_item:}
%    This code is run by any item other than the first one.
%    \begin{macrocode}
\cs_new:Npn \xlist_process_inner_item: {
  \GAL_typeout:n{xlist_process_inner_item \on@line}
%    \end{macrocode}
%    First we run |\xlist_item_between_action:| to handle spacing etc
%    and then invoke |\xlist_item_base_code:| to do the rest.
%    \begin{macrocode}
  \xlist_item_between_action:
  \xlist_item_base_code:
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{EndThisList implementation}
%
%
% \begin{macro}{\EndThisList}
%    The |\EndThisList| command is the common ending for all instances
%    of type list. It has two hooks which need to be set up by any
%    list template: |\xlist_end_finish_item_action:| and
%    |\xlist_end_finish_list_action:|.
%    \begin{macrocode}
\cs_new:Npn \EndThisList {
%    \end{macrocode}
%    If we are still in a new list then we have an error condition:
%    \begin{macrocode}
  \bool_if:NT \g_new_list_bool
             {
               \msg_error:nn { xlist } { missing-item }
               \ListItem \NoValue }
%    \end{macrocode}
%
%    Next we run code that finishes the previous item if necessary.
%    \begin{macrocode}
  \xlist_end_finish_item_action:
%    \end{macrocode}
%
%    Then restore the galley state.
%    \begin{macrocode}
  \GAL_restore_galley_state:
%    \end{macrocode}
%
%    Finally we run code that finishes the list, e.g., puts out spaces
%    and penalties or whatever.
%    \begin{macrocode}
  \xlist_end_finish_list_action:
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Low-level code}
%
% \begin{macro}{\xlist_item_accumulate_action:}
%    The |\xlist_item_accumulate_action:| macro either does nothing (default)
%    in which case items are accumulated on the same line if an item
%    of some list immediately starts with a sub-list, or it starts and
%    ends a paragraph in which case the unset outer item is placed on
%    the page.
%    \begin{macrocode}
\cs_new_eq:NN \xlist_item_accumulate_action: \prg_do_nothing:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xlist_item_output_dangling:}
%    The |\xlist_item_output_dangling:| macro makes sure a dangling label is
%    set. At this point one could add additional code that sets up the
%    galley structure so that the distance to the next item (which
%    immediately follows) is flexible via parameters. For now we just
%    ensure that we don't separate the two items.
%    \begin{macrocode}
\cs_new:Npn\xlist_item_output_dangling: {
       \noindent \par
       \GAL_set_break:n 1  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_in_label_bool}
%    The |\g_in_label_bool| switch is set to true for the time an item label
%    has be set up but is still waiting to be placed. It is tested at
%    various places to ensure that this item label is not lost by
%    mistake.
%    Since the switch is always being set globally we code this within
%    the mutator commands.
%    \begin{macrocode}
\bool_new:N \g_in_label_bool
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_in_labellist_bool}
%    If a list starts directly after an item of a super-list the flag
%    |\g_in_labellist_bool| is set to true.\footnote{This replaces the
%    \texttt{@noparlist} and \texttt{@noparitem} flags in 2e lists.}
%    \begin{macrocode}
\bool_new:N \g_in_labellist_bool
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_new_list_bool}
%    The |\g_new_list_bool| switch is set to true for the time a new list is
%    started until the first item is seen. It is used to check for
%    error conditions, e.g., a paragraph start without an |\ListItem|
%    first, or the end of the list without ever setting anything. It
%    is also used to distinguish the first item of a list from the
%    others.
%    Since the switch is always being set globally we code this within
%    the mutator commands.
%    \begin{macrocode}
\bool_new:N \g_new_list_bool
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\ListDepth}
%    The counter |\ListDepth| holds the current
%    list depth, it gets updated in |\xlist_initialize:NNNNN| before the list
%    parameters are assigned.
%    \begin{macrocode}
\int_new:N \ListDepth
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{List template implementation}
%
%    The template `labelposition' is used within the declaration for
%    the list template so we have to declare its type up front (or get
%    a nasty internal error message! --- something that could perhaps
%    be improved.)
%
%    \begin{macrocode}
\DeclareObjectType{labelposition}{0}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareObjectType{list}{3}
%    \end{macrocode}
%    \begin{macrocode}
\DeclareTemplateInterface{list}{vertical}{3}{
%    \end{macrocode}
%    The right hand sides of the keys currently use commands and
%    registers already available in \LaTeX{} as far as possible. This
%    makes the code looks in parts a bit inconsistent and should
%    (perhaps) change!
%    \begin{macrocode}
  left-margin-width      : length   ,
  right-margin-width     : length   ,
  pre-penalty            : integer  ,
  pre-sep                : skip     ,
  item-penalty           : integer  ,
  item-sep               : skip     ,
  post-penalty           : integer  ,
  post-sep               : skip     ,
%    \end{macrocode}
%    next three instance setups fully specify internal para stuff.
%    alternatively one could of a single hj-setup (if we stay with
%    that template type) or ...?
%    \begin{macrocode}
  justification-setup    : instance {justification} ,
  linebreak-setup        : instance {linebreak}     ,
  hyphenation-setup      : instance {hyphenation}   ,
%    \end{macrocode}
%    \begin{macrocode}
  par-sep                : skip            ,
  item-label-text        : tokenlist       ,
  item-label-format      : function 1 = #1 ,
  label-position-setup   : instance {labelposition} = right ,
%    \end{macrocode}
%    The key for dealing with wide labels is inconsistent compared to
%    the previous one: both should probably have the same type one
%    day.
%    \begin{macrocode}
  widelabel-action       : function 0 = \runinwidelabel ,
%    \end{macrocode}
%    We support the notion that a list starts with an implicit item
%    (perhaps this is a rubbish idea (it doesn't save space
%    either)). In the current implementation setting this switch to
%    true means that the first item \emph{is} truly implicit not that
%    it is optional, i.e., if the list nevertheless starts with a
%    |\ListItem| on document level it will result in two list
%    labels. One could implement this differently so that one as an
%    ``optional first item'' switch.
%    \begin{macrocode}
  item-implicit-boolean         : choice {true, false} ,
%    \end{macrocode}
%    Two switches control whether the current list allows to
%    accumulate item labels on its left and/or right. The default is
%    to allow accumulation.
%    \begin{macrocode}
  item-accumulate-right-boolean  : choice {true, false} ,
  item-accumulate-left-boolean   : choice {true, false} ,
%    \end{macrocode}
%    If the list should have ``numbered'' labels we specify a counter
%    name at this point.
%    \begin{macrocode}
  counter-id                     : tokenlist ,
 }


\skip_new:N \botsep

\tl_new:N   \l_xlist_item_label_text_tl
\tl_new:N   \l_xlists_counter_name_tl
\cs_new:Npn \xlist_item_label_format:n #1 {}
\cs_new:Npn \xlist_item_label_position_setup: {}
\cs_new:Npn \xlist_item_wide_label_action: {}
\cs_new:Npn \xlist_justification_setup: {}
\cs_new:Npn \xlist_linebreak_setup: {}
\cs_new:Npn \xlist_hyphenation_setup: {}


\DeclareTemplateCode{list}{vertical}{3}{
%    \end{macrocode}
%    The right hand sides of the keys currently use commands and
%    registers already available in \LaTeX{} as far as possible. This
%    makes the code looks in parts a bit inconsistent and should
%    (perhaps) change!
%    \begin{macrocode}
  left-margin-width      =  \leftmargin,
  right-margin-width     =  \rightmargin,
  pre-penalty            =  \@beginparpenalty,   % we use these 2e names for now
  pre-sep                =  \topsep,
  item-penalty           =  \@itempenalty,
  item-sep               =  \itemsep,
  post-penalty           =  \@endparpenalty,
  post-sep               =  \botsep,
%    \end{macrocode}
%    next three instance setups fully specify internal para stuff.
%    alternatively one could of a single hj-setup (if we stay with
%    that template type) or ...?
%    \begin{macrocode}
  justification-setup =  \xlist_justification_setup:     ,
  linebreak-setup     =  \xlist_linebreak_setup:         ,
  hyphenation-setup   =  \xlist_hyphenation_setup:       ,
%    \end{macrocode}
%    \begin{macrocode}
  par-sep                =  \parsep,
  item-label-text        =  \l_xlist_item_label_text_tl       ,
  item-label-format      =  \xlist_item_label_format:n        ,
  label-position-setup   =  \xlist_item_label_position_setup: ,
%    \end{macrocode}
%    The key for dealing with wide labels is inconsistent compared to
%    the previous one: both should probably have the same type one
%    day.
%    \begin{macrocode}
  widelabel-action       = \xlist_item_wide_label_action:     ,
%    \end{macrocode}
%    We support the notion that a list starts with an implicit item
%    (perhaps this is a rubbish idea (it doesn't save space
%    either)). In the current implementation setting this switch to
%    true means that the first item \emph{is} truly implicit not that
%    it is optional, i.e., if the list nevertheless starts with a
%    |\ListItem| on document level it will result in two list
%    labels. One could implement this differently so that one as an
%    ``optional first item'' switch.
%    \begin{macrocode}
  item-implicit-boolean   = {
    true  =  {\cs_set:Npn\xlist_item_implicit_code:{\item\relax}} ,
    false =
  },
%    \end{macrocode}
%    Two switches control whether the current list allows to
%    accumulate item labels on its left and/or right. The default is
%    to allow accumulation.
%    \begin{macrocode}
  item-accumulate-right-boolean = {
    true  =          ,
    false = {\cs_set:Npn \xlist_item_accumulate_action:
                         {\xlist_item_output_dangling:}}
  } ,
  item-accumulate-left-boolean  = {
    true  =          ,
    false = {\cs_set:Npn \list_process_accumulated_items:
                         {\xlist_item_output_dangling:}}
  } ,
%    \end{macrocode}
%    If the list should have ``numbered'' labels we specify a counter
%    name at this point.
%    \begin{macrocode}
  counter-id      = \l_xlists_counter_name_tl,
 }
 {
%    \end{macrocode}
%    The list init code was/is intended to hold the common setup stuff
%    for different list template implementations (this is right now a
%    little muddled so once we have additional templates we might want
%    to revise this and either merge this and part of the following
%    code or run everything inline or \ldots).
%    \begin{macrocode}
  \xlist_initialize:NNNNN
     \xlist_item_label_position_setup:
     \xlist_item_measure_and_format_vertical:
     \xlist_item_inner_pre_code_vertical:
     \xlist_end_finish_item_vertical:
     \xlist_end_finish_list_vertical:
%    \end{macrocode}
%
%    In case we are still in hmode from a previous para we issue a
%    |\par|. This may have to come earlier, i.e., before saving the
%    galley state, but i think not.
%    \begin{macrocode}
  \par
%    \end{macrocode}
%
%    At this point we are ready to do the key parameter assignments.
%    \begin{macrocode}
  \AssignTemplateKeys
%    \end{macrocode}
%
%    Next task is to look at the mandatory arguments of the
%    template. If the first arg is not |\NoValue| it is supposed to be
%    an overwrite for the |\leftmargin| value which is set by the
%    \key{left-margin-width} key:
%    \begin{macrocode}
  \IfNoValueF{#1} { \settowidth \leftmargin {\xlist_item_label_format:n{#1}} }
%    \end{macrocode}
%
%    Second argument is an overwrite for the \key{item-label-text} key
%    if it is not |\NoValue|.
%    \begin{macrocode}
  \IfNoValueF{#2} { \tl_set:Nn\l_xlist_item_label_text_tl {#2} }
%    \end{macrocode}
%
%    If there was no \key{counter-id} key we set the |\l_xlist_numbered_bool| flag
%    to false. Otherwise we have to look at argument three and if this
%    is |\BooleanFalse| we reset the counter to zero .
%    \begin{macrocode}
  \tl_if_empty:NTF \l_xlists_counter_name_tl
     { \bool_set_false:N \l_xlist_numbered_bool }
     { \bool_set_true:N  \l_xlist_numbered_bool
       \IfBooleanF{#3} { \setcounter \l_xlists_counter_name_tl \c_zero }
     }
%    \end{macrocode}
%
%    Setting up the measure is happening next\ldots
%    \begin{macrocode}
  \GAL_add_SGPV_measure:nn \leftmargin { -\leftmargin -\rightmargin }
%    \end{macrocode}
%    \ldots followed by setting up a h\&j (if so specified).
%    \begin{macrocode}
  \GAL_set_SGPV_dimension:nn v \parsep
  \xlist_justification_setup:
  \xlist_linebreak_setup:
  \xlist_hyphenation_setup:
%    \end{macrocode}
%
%    If we have an item label from an outer list still to be set we
%    have to adjust its position within the |\g_xlist_labels_box| box since we
%    are going to output that box further to the right (by
%    |\leftmargin|) than was assumed when this label was put in.
%    \begin{macrocode}
  \bool_if:NTF \g_in_label_bool
   {
    \hbox_gset:Nn \g_xlist_labels_box
                  {\hskip -\leftmargin
                   \hbox_unpack_clear:N \g_xlist_labels_box
                   \hskip \leftmargin}
%    \end{macrocode}
%    If not we are at the beginning of an ordinary list and we prepare
%    for putting some vertical space and some penalty on top of
%    it.\footnote{Current implementation makes no difference between a
%    list on its own and a list within a paragraph.}
%    \begin{macrocode}
   }{
    \GAL_max_DGPV_dimension:nn v \topsep
    \GAL_set_penalty:n       \@beginparpenalty
   }
%    \end{macrocode}
%    Finally output code for an implicit first item if requested and
%    ignore spaces and |\par|s for a while. And that means let
%    |\ListItem| take over.
%    \begin{macrocode}
  \xlist_item_implicit_code:
  \GAL_ignore_pars:n
     {Something's~ wrong--perhaps~ a~ missing~
      \protect\item}
 }
%    \end{macrocode}
%

%
% \begin{macro}{\g_xlist_labels_box}
%
%    \begin{macrocode}
\box_new:N \g_xlist_labels_box
%    \end{macrocode}
% \end{macro}

%
% \begin{macro}{\xlist_initialize:NNNNN}
%    This |\xlist_initialize:NNNNN| is the core for setting up any list structure
%    whether vertical or horizontal. It takes the following five
%    arguments all of which should be macro code:
%    \begin{enumerate}
%    \item initial code to be run at start of each item
%    \item code to measure and format a current item
%    \item code to run at start of every inner item (ie other than the
%      first)
%    \item code to finish off last item of the list
%    \item code to finish off list itself
%    \end{enumerate}
%    \begin{macrocode}
\cs_new:Npn \xlist_initialize:NNNNN #1#2#3#4#5{
%    \end{macrocode}
%    First we initialise |\ListItem| (this is really only necessary on
%    the first level but test for it would take more time than doing
%    the assignment).
%    \begin{macrocode}
  \cs_set_eq:NN \ListItem \xlist_format_item:n
%    \end{macrocode}
%    In addition we initialize the hooks into
%    |\ListItem| and |\EndThisList| from the supplied arguments. Here
%    |\cs_set:Npn| is used to \begin{inlineenumerate} \item allow to pass
%    arguments which are from the keyword parameters (ie not yet set
%    up) and \item to allow one day for inline definitions rather than passing
%    external macro names as arguments (though in other places the code
%    states that this is not supported). \end{inlineenumerate}
%    \begin{macrocode}
  \cs_set:Npn \xlist_item_initial_action:     {#1}
  \cs_set:Npn \xlist_item_measure_and_format: {#2}
  \cs_set:Npn \xlist_item_between_action:     {#3}
  \cs_set:Npn \xlist_end_finish_item_action:  {#4}
  \cs_set:Npn \xlist_end_finish_list_action:  {#5}
%    \end{macrocode}
%
%    Then we test to see if we got nested lists without an item
%    in between. If so try a crude error recovery by issuing |\ListItem|
%    (though that is called at a different grouping level)
%    \begin{macrocode}
  \bool_if:NT \g_new_list_bool
    { \msg_error:nn { xlist } { missing-item }
      \ListItem \NoValue }
%    \end{macrocode}
%
%    If there is a dangling item from an outer list we have to set the
%    |\g_in_labellist_bool|. Instead of testing |\g_in_label_bool| we use its status
%    directly:
%    \begin{macrocode}
  \bool_set_eq:NN \g_in_labellist_bool \g_in_label_bool
%    \end{macrocode}
%
%    Then save the current galley state to be able to
%    restore it after the list.\footnote{Checking for hmode at this
%    point would allow to distinguish between a list that lives on its
%    own and a list that is part of a paragraph---not done.}
%    \begin{macrocode}
  \GAL_save_galley_state:
%    \end{macrocode}
%    We also record the list level we are in (though not used) and set
%    a collection name for list so that inner lists can have their own
%    declarations.\footnote{The more i think about that the more i
%    think this is rubbish. probably better is to have the instance
%    name within the document-environment declaration already  use
%    different names depending on the level (and the font size?) ---
%    think!}
%    \begin{macrocode}
  \int_incr:N \ListDepth
%<*trace>
  \typeout{On~list~level:~\the\ListDepth}
%</trace>
%  \UseCollection{list}{L\the\ListDepth}
%    \end{macrocode}
%
%    We now set the |\g_new_list_bool| flag (to be reset within the next item)
%    and add code to the galley so that a paragraph start without an
%    item first will signal an error. However recovery in that case is
%    trickier, we can't just add |\ListItem| as it would come in the
%    middle of executing the galley interface.\footnote{Needs some
%    thought.}
%    \begin{macrocode}
  \bool_gset_true:N \g_new_list_bool
  \GAL_appendto_DGPV_thing:nn q { \bool_if:NT \g_new_list_bool
                                    { \msg_error:nn { xlist } { missing-item-II }
                                      \bool_gset_false:N \g_new_list_bool }
                                }
%    \end{macrocode}
%
%    Some defaults: a) implicit items are not allowed by default and
%    b) list do not have numbers unless explicitly asked for.
%    \begin{macrocode}
  \cs_set_eq:NN \xlist_item_implicit_code: \prg_do_nothing:
  \tl_clear:N \l_xlists_counter_name_tl
%    \end{macrocode}
%
%    Some further defaults: Item label accumulation is decided in
%    parts by the outer list
%    type, eg a description list might decide to forbid accumulation
%    at its right, so we have to pick up the value before running
%    |\AssignTemplateKeys|. So if the outer list decides that
%    accumulation is allowed the current list might still turn it off
%    and when the outer list has already turned it off it will stay
%    turned off.
%    \begin{macrocode}
  \cs_set_eq:NN \list_process_accumulated_items: \xlist_item_accumulate_action:
%    \end{macrocode}
%    Thus the default for |\xlist_item_accumulate_action:| has to be:
%    \begin{macrocode}
  \cs_set_eq:NN \xlist_item_accumulate_action: \prg_do_nothing:
%    \end{macrocode}
%    Actually, the last assignment is only necessary for vertically
%    oriented lists but it doesn't do harm to set it up always.
%
%    The default for setting up a h\&j is to use whatever is
%    currently in effect.
%    \begin{macrocode}
  \cs_set_eq:NN \xlist_justification_setup: \prg_do_nothing:
  \cs_set_eq:NN \xlist_linebreak_setup:     \prg_do_nothing:
  \cs_set_eq:NN \xlist_hyphenation_setup:   \prg_do_nothing:
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xlist_item_measure_and_format_vertical:}
%    \begin{macrocode}
\cs_new:Npn \xlist_item_measure_and_format_vertical: {
  \sbox \l_xlist_tmp_box
        {\xlist_item_left_action:
         \xlist_item_label_format:n \l_xlist_item_label_text_tl
         \xlist_item_right_action:
        }
%    \end{macrocode}
%    The item label (now stored in |\l_xlist_tmp_box|) is combined with any
%    dangling label already in |\g_xlist_labels_box|. Depending on the width of
%    the box and the desired |\labelwidth| we either invoke
%    |\xlist_item_wide_label_action:| or set the item into a box of width
%    |\labelwidth| followed by the separation to the text (which is
%    thus part of the box).
%    \begin{macrocode}
  \hbox_gset:Nn \g_xlist_labels_box {
    \hbox_unpack_clear:N \g_xlist_labels_box
    \hskip \itemindent
    \hskip -\labelwidth
    \hskip -\labelsep
    \dim_compare:nNnTF { \box_wd:N \l_xlist_tmp_box } > \labelwidth
       \xlist_item_wide_label_action:  % has to use \l_xlist_tmp_box
       { \hbox_to_wd:nn \labelwidth {\hbox_unpack_clear:N \l_xlist_tmp_box} }
    \hskip \labelsep}
%    \end{macrocode}
%    So now the item label is waiting to be set inside \g_xlist_labels_box. To
%    get this onto the page we put this box into the appropriate
%    galley datastructure and also set |\g_in_label_bool| to true to signal
%    that a label is waiting.
%    \begin{macrocode}
  \bool_gset_true:N\g_in_label_bool
  \GAL_set_object:n {\box\g_xlist_labels_box
                     \penalty \c_zero  % parametrize penalty?
                     \bool_gset_false:N \g_in_label_bool}
%    \end{macrocode}
%    We also cancel any indentation for the next paragraph by setting
%    a switch.
%    \begin{macrocode}
  \GAL_set_DGPV_thing:nn i \c_one
}
%    \end{macrocode}
% \end{macro}
%
%


% \begin{macro}{\xlist_item_inner_pre_code_vertical:}
%    \begin{macrocode}
\cs_new:Npn \xlist_item_inner_pre_code_vertical: {
%    \end{macrocode}
%    Since we are now somewhere down in the list we first have to make
%    sure that the previous item was already placed onto the page
%    since if there was an item without any text we don't want to end
%    up with having it combined with the next one. So if necessary
%    let's start a paragraph (it is completely irrelevant how we do
%    this. Using |\noindent| might be a bit faster than |\leavevmode|.
%    \begin{macrocode}
  \bool_if:NT \g_in_label_bool
              { \noindent }
%    \end{macrocode}
%    The other check we have to make is finishing a previous paragraph
%    if there is any (and there might be one, for example from the
%    code above or from the |\ListItem| being placed directly below a
%    paragraph text as is often the case. (The |\unskip| is \LaTeXe{}
%    code and at this time of the day I'm not sure it is necessary at
%    this point. If not one could just always issue a |\par| though
%    this code below is a little faster as |\par| has a quite complex
%    definition these days.)
%    \begin{macrocode}
  \mode_if_horizontal:T { \unskip\unskip \par }
%    \end{macrocode}
%    Having dealt with the prelims we now update the galley structure
%    to get the inter-item penalty and skip added.
%    \begin{macrocode}
  \GAL_max_DGPV_dimension:nn v \itemsep
  \GAL_set_penalty:n       \@itempenalty
}
%    \end{macrocode}
% \end{macro}
%
%


% \begin{macro}{\xlist_end_finish_item_vertical:}

%    \begin{macrocode}
\cs_new:Npn \xlist_end_finish_item_vertical: {
%    \end{macrocode}
%    If we are still within |\g_in_label_bool| then the last |\ListItem| did
%    not contain any horizontal material. Thus we start a paragraph to
%    get the label onto the page.
%    In any case we then finish any still unset paragraph.
%    \begin{macrocode}
  \bool_if:NT \g_in_label_bool  { \noindent }
  \mode_if_horizontal:T \par
}
%    \end{macrocode}
% \end{macro}
%
%

% \begin{macro}{\xlist_end_finish_list_vertical:}

%    \begin{macrocode}
\cs_new:Npn  \xlist_end_finish_list_vertical: {
%    \end{macrocode}
%
%    Don't add extra vertical spacing after an |\g_in_labellist_bool|.
%    However, this should probably be parametrised instead of being
%    fixed.
%    \begin{macrocode}
  \bool_if:NF \g_in_labellist_bool
   {
    \GAL_max_DGPV_dimension:nn v \botsep
    \GAL_set_penalty:n       \@endparpenalty
   }
}
%    \end{macrocode}
% \end{macro}
%
%
% \section{An alternative template setup (different keys)}
%
% This is a setup which might appeal to some people, eg with much more
% OO in it :-). But then it might obscure the things --- provide both
% styles?
%
%
% \subsection{A second vertical list template implementation}
%
% We need some text here or else we get a strange toc (see bug reports
% in NOTES)
%
% There  are no comments in the code but changes to the other
% implementation are marked using |% <---|.
%
%    \begin{macrocode}
\DeclareTemplateInterface{list}{vertical2}{3}{
  measure-setup        : instance {measure}        ,
  pre-vmaterial-setup  : instance {vmaterial}      ,
 item-vmaterial-setup  : instance {vmaterial}      ,
 post-vmaterial-setup  : instance {vmaterial}      ,
  justification-setup  : instance {justification}  ,
  linebreak-setup      : instance {linebreak}      ,
  hyphenation-setup    : instance {hyphenation}    ,
  par-sep              : skip                      ,
  item-label-text      : tokenlist = \textbullet]  ,
  item-label-format    : function 1 =  #1          ,
  label-position-setup : instance {labelposition} = right ,
%    \end{macrocode}
%    The key for dealing with wide labels is inconsistent compared to
%    the previous one: both should probably have the same type one day.
%    \begin{macrocode}
  widelabel-action     : function 0 = \runinwidelabel ,
  item-implicit-boolean          : choice {true, false} ,
  item-accumulate-right-boolean  : choice {true, false} ,
  item-accumulate-left-boolean   : choice {true, false} ,
  counter-id           : tokenlist ,
 }

\cs_new:Npn \xlist_measure_setup:n #1 {}
\cs_new:Npn \xlist_top_vmaterial_setup:n #1 {}
\cs_new:Npn \xlist_item_vmaterial_setup: {}
\cs_new:Npn \xlist_bot_vmaterial_setup: {}

\DeclareTemplateCode{list}{vertical2}{3}{
  measure-setup        = \xlist_measure_setup:n            ,
  pre-vmaterial-setup  = \xlist_top_vmaterial_setup:n      ,
 item-vmaterial-setup  = \xlist_item_vmaterial_setup:      ,
 post-vmaterial-setup  = \xlist_bot_vmaterial_setup:       ,
  justification-setup  = \xlist_justification_setup:       ,
  linebreak-setup      = \xlist_linebreak_setup:           ,
  hyphenation-setup    = \xlist_hyphenation_setup:         ,
  par-sep              = \parsep                           ,
  item-label-text      = \l_xlist_item_label_text_tl       ,
  item-label-format    = \xlist_item_label_format:n        ,
  label-position-setup = \xlist_item_label_position_setup: ,
%    \end{macrocode}
%    The key for dealing with wide labels is inconsistent compared to
%    the previous one: both should probably have the same type one day.
%    \begin{macrocode}
  widelabel-action        = \xlist_item_wide_label_action: ,
  item-implicit-boolean   = {
    true  =  {\cs_set:Npn \xlist_item_implicit_code:{\item\relax}} ,
    false =
  },
  item-accumulate-right-boolean = {
    true  =          ,
    false = { \cs_set_eq:NN \xlist_item_accumulate_action:
                            \xlist_item_output_dangling: }
  } ,
  item-accumulate-left-boolean  = {
    true  =          ,
    false = { \cs_set_eq:NN \xlist_item_accumulate_action:
                            \xlist_item_output_dangling: }
  } ,
  counter-id      = \l_xlists_counter_name_tl,
 }
 {
  \xlist_initialize:NNNNN
     \xlist_item_label_position_setup:
     \xlist_item_measure_and_format_vertical:
     \xlist_item_inner_pre_code_vertical_II:
     \xlist_end_finish_item_vertical:
     \xlist_end_finish_list_vertical_II:
  \AssignTemplateKeys
  \IfNoValueF{#2} { \tl_set:Nn \l_xlist_item_label_text_tl {#2} }
  \tl_if_empty:NTF \l_xlists_counter_name_tl
     { \bool_set_false:N \l_xlist_numbered_bool }
     { \bool_set_true:N \l_xlist_numbered_bool
       \IfBooleanF{#3} { \setcounter \l_xlists_counter_name_tl \c_zero }
     }
  \xlist_measure_setup:n {#1}                           % <-----
  \setSGPVdimension:nn v \parsep
  \xlist_justification_setup:
  \xlist_linebreak_setup:
  \xlist_hyphenation_setup:
  \bool_if:NTF \g_in_label_bool
    {
     \hbox_gset:Nn \g_xlist_labels_box {
          \hskip -\leftmargin
          \hbox_unpack_clear:N \g_xlist_labels_box
          \hskip \leftmargin
          }
    }
    { \xlist_top_vmaterial_setup:n                        % <-----
    }
  \xlist_item_implicit_code:
  \GAL_ignore_pars:n
     {Something's~ wrong--perhaps~ a~ missing~
      \protect\item}
 }

\cs_new:Npn  \xlist_end_finish_list_vertical_II: {   % <-----
  \bool_if:NF \g_in_labellist_bool
   {
    \xlist_bot_vmaterial_setup:                        % <-----
   }
}

\cs_new:Npn\xlist_item_inner_pre_code_vertical_II: {         % <-----
  \bool_if:NTF \g_in_label_bool
               {  \noindent    }
  \mode_if_horizontal:T { \unskip\unskip \par }
  \xlist_item_vmaterial_setup:                         % <-----
}
%    \end{macrocode}
%
% \subsection{Wide item implementation}
%
% Using commands for the next bits and pieces is inconsistent. should
% be handled similarly to the template `labelposition' but i haven't
% made up my mind on how exactly yet and i needed something to run
%
% \begin{macro}{\l_xlist_tmp_box}
%
%    \begin{macrocode}
\box_new:N \l_xlist_tmp_box
%    \end{macrocode}
%  \end{macro}

% \begin{macro}{\flushrightwidelabel}
%    \begin{macrocode}
\cs_new:Npn \flushrightwidelabel
            { \hbox_to_wd:nn \labelwidth
                             {\hss \box_use_clear:N \l_xlist_tmp_box }
            }
\cs_new:Npn \runinwidelabel
            { \box_use_clear:N \l_xlist_tmp_box }
\cs_new:Npn \newlinewidelabel
            {\parbox[b]{\labelwidth}{{\rlap{\box_use_clear:N \l_xlist_tmp_box}\mbox{}}}}
\cs_new:Npn \topdownwidelabel
            {\raisebox{0pt}[1ex][0pt]{\makebox[\labelwidth][l]
              {\parbox[t]{\labelwidth}{\hspace{0pt}\hbox_unpack_clear:N \l_xlist_tmp_box}}}}
\cs_new:Npn \bottomupwidelabel
            {\parbox[b]{\labelwidth}{\hspace{0pt}\hbox_unpack_clear:N \l_xlist_tmp_box}}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Labelposition template implementation}
%
% Again have some text here or else the toc will get the heading
% several times.
%    \begin{macrocode}
\DeclareTemplateInterface{labelposition}{std}{0}
{
  label-sep      : skip       = 5pt  ,
  label-width    : length     = \leftmargin - \labelsep ,
  label-indent   : length     = 0pt  ,
  label-l-action : function 0 = \hss ,
  label-r-action : function 0 =      ,
}

\cs_new:Npn \xlist_item_left_action:  {}
\cs_new:Npn \xlist_item_right_action: {}

\DeclareTemplateCode{labelposition}{std}{0}
{
  label-sep     = \labelsep       ,
  label-width   = \labelwidth     ,
  label-indent  = \itemindent     ,
  label-l-action= \xlist_item_left_action:  ,
  label-r-action= \xlist_item_right_action:  ,
}
{
  \AssignTemplateKeys
}
%    \end{macrocode}
%
%
% \section{Inline lists}
%
%
%    \begin{macrocode}
\DeclareTemplateInterface{list}{inline}{3}{
  pre-hmaterial-setup      : instance {hmaterial} ,
 item-hmaterial-setup      : instance {hmaterial} ,
 item-post-hmaterial-setup : instance {hmaterial} ,
 post-hmaterial-setup      : instance {hmaterial} ,
  item-label-text          : tokenlist            ,
  item-label-format        : function 1 = #1      ,
  item-implicit-boolean    : choice {true, false} ,
  counter-id               : tokenlist           ,
 }

\cs_new:Npn \xlist_pre_hmaterial_setup: {}
\cs_new:Npn \xlist_item_pre_hmaterial_setup:  {}
\cs_new:Npn \xlist_item_post_hmaterial_setup:  {}
\cs_new:Npn \xlist_post_hmaterial_setup: {}


\DeclareTemplateCode{list}{inline}{3}{
  pre-hmaterial-setup      = \xlist_pre_hmaterial_setup:       ,
 item-hmaterial-setup      = \xlist_item_pre_hmaterial_setup:  ,
 item-post-hmaterial-setup = \xlist_item_post_hmaterial_setup: ,
 post-hmaterial-setup      = \xlist_post_hmaterial_setup:      ,
  item-label-text          = \l_xlist_item_label_text_tl       ,
  item-label-format        = \xlist_item_label_format:n        ,
  item-implicit-boolean    = {
    true  =  {\cs_set:Npn \xlist_item_implicit_code: {\item\relax}} ,
    false =
  },
  counter-id              = \l_xlists_counter_name_tl,
 }
 {
  \xlist_initialize:NNNNN
      \prg_do_nothing:
      \xlist_item_measure_and_format_inline:
      \xlist_item_pre_hmaterial_setup:
      \prg_do_nothing:
      \xlist_post_hmaterial_setup:
  \AssignTemplateKeys
  \IfNoValueF{#2} { \tl_set:Nn \l_xlist_item_label_text_tl {#2} }
  \tl_if_empty:NTF \l_xlists_counter_name_tl
     { \bool_set_false:N \l_xlist_numbered_bool }
     { \bool_set_true:N  \l_xlist_numbered_bool
       \IfBooleanF{#3} { \setcounter \l_xlists_counter_name_tl \c_zero }
     }
  \xlist_pre_hmaterial_setup:                          % <-----
  \xlist_item_implicit_code:
  \GAL_ignore_pars:n
     {Something's~ wrong--perhaps~ a~ missing~
      \protect\item}
 }


\cs_new:Npn\xlist_item_measure_and_format_inline: {
  \xlist_item_label_format:n \l_xlist_item_label_text_tl
  \xlist_item_post_hmaterial_setup:
}


%    \end{macrocode}
%
% \section{Error handling}
%
%    \begin{macrocode}
\msg_new:nnn { xlist } { lonely-item }
  {Lonely~\token_to_str:N\ListItem--perhaps~a~missing~
        list~environment}
\msg_new:nnnn { xlist } { missing-item }
   {An~\token_to_str:N \item\space command~was~expected~at~this~point}
   {As~a~recovery~action~a~\token_to_str:N \ListItem\space command~
    will~be~added.}
\msg_new:nnnn { xlist } { missing-item-II }
   {An~\token_to_str:N \item\space command~was~expected~at~this~point}
   {We~try~to~continue~without~it.}
%    \end{macrocode}
%
%
%    \begin{macrocode}
\endinput
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \Finale
%
% \endinput

% vertical spacing case that \item has to handle:
%
% 1) first item of list
% 1.1) no outer label pending
% 1.1.1) text before is normal
% 1.1.2) text before was a heading
%
% 1.2) outer label not yet set
% 1.2.1) both labels go on same line
% 1.2.2) inner label should go on next line
%
% 2) middle item of list
%
% the following is (should be?) output in the various cases (only leaves):
%
% 1.1.1)
%        \addpenalty\@beginparpenalty
%        \addvspace{\@topsep - \parskip}
%
% 1.1.2)
%        \addpenalty10000    ????? missing
%        \addvspace{\@outerparskip  - \parskip}
%
% 1.2.1)
%        \vspace{\@outerparskip  - \parskip}
%   note: this is actually done as
%     \@tempskipa\lastskip
%     \vskip -\lastskip
%     \advance\@tempskipa\@outerparskip
%     \advance\@tempskipa -\parskip
%     \vskip\@tempskipa
%   so that any following \addvspace sees the full vertical space (i
%   guess) only that i don't understand how such an \addvspace could
%   be generated in that case. cany clues anybody?
%
% 1.2.2)
%  note: this case is not supported by std list envs
%        \addpenalty10000    ????? missing
%        \addvspace{\@outerparskip  - \parskip}


