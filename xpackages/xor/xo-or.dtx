% \iffalse meta-comment
%
%% File xo-or.dtx Copyright (C) 1999-2000 Frank Mittelbach, David Carlisle, Chris Rowley
%%                          (C) 2001,2004-2009 Frank Mittelbach, The LaTeX3 Project
%%                          (C) 2010-2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "xor bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 experimental OR (part of xor)}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{xo-or} package\\ OR^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% Things that seem likely to require documentation,
% \emph{i.e.}~\enquote{exposed} items. These will probably be manipulated
% largely through templates.
%
% \begin{variable}{\g_xor_cols_int}
%   The total number of columns to be filled for the current page. (?)
%   This one seems to need revision in favour of a function which sets the
%   value and ensures that the appropriate structures are available.
% \end{variable}
%
% \begin{variable}{\g_xor_float_area_skip}
%   The separation to use between two adjacent float areas.
% \end{variable}
%
% \begin{variable}{\g_xor_float_text_skip}
%   The separation to use between column text and adjacent float areas.
% \end{variable}
%
% \begin{variable}{\g_xor_float_float_skip}
%   The separation to use between two floats in the same float area.
% \end{variable}
%
% \begin{variable}{\g_xor_float_text_shrink_dim}
%   The allowed shrinkability of \cs{g_xor_float_text_skip}. This is used if we
%   are doing grid typesetting and have to adjust the vertical size of the
%   column.
% \end{variable}
%
% \begin{variable}{\g_xor_float_inline_skip}
%   The separation to use between two floats in the same float area.
% \end{variable}
%
% \begin{variable}{\g_xor_float_inline_shrink_dim}
%   The allowed shrinkability of \cs{g_xor_float_inline_skip}. This is used if
%   we are doing grid typesetting and have to adjust the vertical size of
%   object to be added, e.g., an inline float with its caption.
% \end{variable}
% 
% \begin{function}
%   {
%     \xor_calculate_float_col:,
%     \xor_calculate_float_col_flexible:,
%     \xor_calculate_float_col_strict:
%   }
%   \begin{syntax}
%     \cs{xor_calculate_float_col:}
%   \end{syntax}
%   \cs{xor_calculate_float_col:} returns the column number into which
%   the current float under trial (that has been just placed into some
%   area). For single column floats this is always the column of the
%   area, but if the float was placed into an area spanning several
%   columns then there are two possibilities: we can return the first
%   or the last of the spanned columns.
%
%   The choice influences the behavior of the algorithms that
%   determine call-out restrictions and influences the code that
%   closes out areas.
%
%   If we return the first column then we claim that the float was
%   placed in the first of the spanned columns (strict setting). If we
%   return the last column (flexible setting) then a float could, for
%   example, be placed into |t12| even if its call-out is in the
%   second column and the |column| call-out possibility is in force.
%
%   Note: the current interface is to assign
%   \cs{xor_calculate_float_col:} different code depending on which
%   calculation should be carried out. This should not be the finally
%   exposed interface on the designer level! 
%
%   Note2: the name of this function is rather bad too.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{xo-or} Implementation}
%
% To check
% \begin{itemize}
%   \item Badly guarded penalties: how does this interact with collection?
%   \item Is there are \tn{topskip} issue with marker penalties?
%   \item What is a \enquote{block} in a column?
%   \item Is allocation of storage for columns and blocks \enquote{dynamic}?
%     What happens if we run out of blocks, for example?
%   \item Should be use a nested mapping approach when setting up for
%     columns, to map over all float areas and block numbers?
%   \item The way that float areas are defined means that a maximum of nine
%     columns are supported. This does not seem like a real limitation, but
%     should be documented. We should also check the number of columns
%     requested to ensure this stays working. Combined with the need for
%     allocation for column data, this suggests that \cs{g_xor_cols_int} should
%     not be set directly, with instead a \enquote{set up columns} function.
%   \item Columns and blocks are indexed from one, not from zero. This
%     makes sense in the OR but should be noted in the documentation.
%   \item We have no mechanism for page layout (\textsf{geometry}),
%     which means some dimensions are not defined in format mode!
%     That includes rather important things such as \cs{textheight}.
%   \item There are a number of comma lists which seem at first glance to
%     be suitable for conversion to sequences. This needs checking once
%     the first pass is completed (and so proper access methods are in use).
%   \item What is the difference between a float type and a float class?
%   \item In package mode, the old \cs{@topnum}, \emph{etc.}, are reused, but
%     in format mode everything is dynamic. Should we allocate a few
%     \enquote{common} areas in all cases? On the other hand, should we test
%     in package mode without this short cut?
%   \item Some things here need \cs{label} mechanisms, which need to be
%     set up elsewhere!
%   \item There are some comments about the \LaTeXe{} OR and how it handles
%     \cs{topskip}. Is this relevant as we completely take over how stuff
%     is done?
%   \item Some parts of the OR interact with the galley (and \emph{vice
%     versa}). The only way to properly deal with this is to always both,
%     and to tie the code together. Of course, this increases complexity:
%     do we want to do this?
%   \item If we end up with \cs{vsize} smaller than \cs{baselineskip}
%     then \cs{c_xor_output_nospace_penalty} is inserted and a break is
%     forced. The notes say that this is a temporary solution, but what is the
%     alternative? Should we simply warn that there is an issue: it's extremely
%     unlikely to come up, and if it does is there a better solution than
%     asking for user intervention?
%
%     [Frank] The situation is not necessarily unlikely, and I think
%     the right approach is that the algorithm changes behavior in
%     that case, but I need to look at that again.
%    \item In the notes for \cs{xor_handle_premature_ending:} there is mention
%      of needing a rethink, but it's not clear if that applies to the current
%      code or a previous version when read along with the other notes there.
% \end{itemize}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%</package>
%    \end{macrocode}
%    
% \begin{variable}{\l_xor_loop_int}
%   Used for tracking loops: set up separately from the scratch counter
%   so there is no danger of a clash.
%    \begin{macrocode}
\int_new:N \l_xor_loop_int
%    \end{macrocode}
% \end{variable}
%    
% \begin{variable}{\l_xor_tmp_box}
% \begin{variable}{\l_xor_tmp_dim}
% \begin{variable}{\l_xor_tmp_int}
% \begin{variable}{\l_xor_tmp_tl}
%   Scratch space.
%    \begin{macrocode}
\box_new:N \l_xor_tmp_box
\dim_new:N \l_xor_tmp_dim
\int_new:N \l_xor_tmp_int
\tl_new:N  \l_xor_tmp_tl
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \subsection{To be moved elsewhere beyond the OR}
% 
% \begin{macro}{\clist_gconcat:NNc}
%   Add to \pkg{l3clist} perhaps: that seems to be the official approach.
%    \begin{macrocode}
\cs_generate_variant:Nn \clist_gconcat:NNN { NNc }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_nointerlineskip:}
%   This is \LaTeXe{}'s \cs{nointerlineskip}, which should go somewhere but
%   probably not in the output routine.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_nointerlineskip:
  { \tex_prevdepth:D -1000 pt }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_bsphack:, \xor_esphack:}
% \begin{variable}{\l_xor_saved_lastskip_dim}
% \begin{variable}{\l_xor_saved_spacefactor_int}
%   \cs{@bsphack} and \cs{esphack}.
%    \begin{macrocode}
\dim_new:N \l_xor_saved_lastskip_dim
\int_new:N \l_xor_saved_spacefactor_int
\cs_new_protected_nopar:Npn \xor_bsphack:
  {
    \scan_stop:
    \mode_if_horizontal:T
      {
        \int_set_eq:NN \l_xor_saved_spacefactor_int \tex_spacefactor:D
        \dim_set:Nn \l_xor_saved_lastskip_dim { \tex_lastskip:D }
      }
  }
\cs_new_protected_nopar:Npn \xor_esphack:
  {
    \scan_stop:
    \mode_if_horizontal:T
      {
        \int_set_eq:NN \tex_spacefactor:D \l_xor_saved_spacefactor_int
        \dim_compare:nNnT \l_xor_saved_lastskip_dim > \c_zero_dim
          { \tex_ignorespaces:D }
      }
  }
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{macro}
%
% \begin{variable}{\l_box_max_depth_dim}
%   \cs{@maxdepth}: only needed in format mode.
%    \begin{macrocode}
%<*initex>
\dim_new:N \l_box_max_depth_dim
%</initex>
%    \end{macrocode}
% \end{variable}
%
% \subsection{Special marker penalties}
%
% As the output routine needs to be run a number of times, a set of marker
% penalty values are needed. Remember that there are also two in \pkg{xmarks},
% which must be different from all of these.
%
% \begin{variable}{\c_xor_output_endgame_penalty}
%    Special penalty added by \TeX{}'s primitive \tn{end}. We will
%    need this eventually so we set it up as a symbolic constant here.
%    \begin{macrocode}
%<*unused>
\int_const:Nn \c_xor_output_endgame_penalty { - 1 073 741 824 }
%</unused>
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_xor_output_collect_penalty}
%   Special penalty marking the point at which the collection OR ended.
%    \begin{macrocode}
\int_const:Nn \c_xor_output_collect_penalty { -20202 }
%    \end{macrocode}
% \end{variable}
% 
% \begin{variable}{\c_xor_output_nospace_penalty}
%    Penalty marker if during trials the \tn{vsize} ended up smaller
%    than \tn{baselineskip}.
%    \begin{macrocode}
\int_const:Nn \c_xor_output_nospace_penalty { -10003 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_xor_output_columnbreak_penalty}
%    Special penalty marking the point a forced column break was
%    requested by the user.
%    \begin{macrocode}
\int_const:Nn \c_xor_output_columnbreak_penalty { -10005 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_xor_output_flush_float_penalty}
%   Special penalty to trigger float flushing for one or more types.
%    \begin{macrocode}
\int_const:Nn \c_xor_output_flush_float_penalty { -10006 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_xor_output_here_float_penalty}
%   Special penalty for floats that should stay with their callout.
%    \begin{macrocode}
\int_const:Nn \c_xor_output_here_float_penalty { -10007 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_xor_output_grid_align_penalty}
%    Special penalty for places that should fall on the page grid.
%    \begin{macrocode}
\int_const:Nn \c_xor_output_grid_align_penalty { -10008 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_xor_output_balance_penalty}
%    Special penalty marking the point at which balancing should happen.
%    \begin{macrocode}
\int_const:Nn \c_xor_output_balance_penalty { -10009 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_xor_output_action_penalty}
%    Special penalty marking the point at which some action affecting the output
%    routine should happen (probably not needed as this is really a
%    here point).
%    We keep this for now, as we might want to distinguish between
%    different actions, \ldots{} let's see
%    \begin{macrocode}
%<*unused>
\int_const:Nn \c_xor_output_action_penalty { -10010 }
%</unused>
%    \end{macrocode}
% \end{variable}
%
% \subsection{Column data structures}
%
% Supporting multiple columns requires two forms of data structure: some
% to track the overall situation, and some on a per-column basis. The
% overall situation is easy to track.
%
% \begin{variable}{\g_xor_cols_int}
%   The total number of columns available at the moment, as defined by the
%   \enquote{user} (probably the designer).
%    \begin{macrocode}
\int_new:N \g_xor_cols_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_curr_col_int}
%   The current column: a global variable as it may be modified within the
%   output routine.
%    \begin{macrocode}
\int_new:N \g_xor_curr_col_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_curr_col_block_int}
%   Register denoting the current block within the current column.
%    \begin{macrocode}
\int_new:N \g_xor_curr_col_block_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[EXP]{\xor_curr_col_block:}
%   A short cut for inserting the current column and block number when
%   referring to a data structure by name.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_curr_col_block:
  { \int_use:N \g_xor_curr_col_int _ \int_use:N \g_xor_curr_col_block_int }
%    \end{macrocode}
% \end{macro}
%
% The data structures needed for each column independently are rather more
% numerous, as many are also separated out for each block.
% \begin{description}
%   \item[\cs{g_xor_col_\meta{column}_\meta{block}_box}]
%     The text of a column during trials and page make up.
%
%   \item[\cs{g_xor_ht_col_\meta{column}_\meta{block}_dim}]
%     The vertical target size for the column block during the trials.
%
%   \item[\cs{g_xor_best_ht_col_\meta{column}_\meta{block}_dim}]
%     ? FRANK ?
%
%   \item[\cs{g_xor_col_\meta{column}_balance_box}]
%     ? FRANK ?
%
%   \item[\cs{g_xor_ht_col_\meta{column}_block_int}]
%     The maximum number of blocks in use for the column. Initially there is
%     one block per column; this will increase when there are middle floats
%     and (one day) for balancing.
%
%   \item[\cs{g_xor_t_floats_col_\meta{column}_int}]
%     The number of top floats we have seen so far in this column, used to
%     implement \cs{g_xor_float_area_skip} handling.
%
%   \item[\cs{g_xor_b_floats_col_\meta{column}_int}]
%     The number of bottom floats we have seen so far in this column, used to
%     implement \cs{g_xor_float_area_skip} handling.
%
%   \item[\cs{g_xor_m_floats_col_\meta{column}_int}]
%     The number of middle floats we have seen so far in this column, used to
%     implement \cs{g_xor_float_area_skip} handling.
%
%   \item[\cs{g_xor_\meta{float area}_delta_col_\meta{column}_dim}]
%     The difference between the real size of all floats in the
%     appropriate area (including their separation spaces) and the nominal
%     size which is used to determine the vertical size of the remaining text
%     column. The two may differ if we do grid typesetting.
%
%   \item[\cs{g_xor_saved_\meta{float area}_delta_col_\meta{column}_dim}]
%     ? FRANK ?
%
%   \item[\cs{g_xor_flseq_type_\meta{float}_col_\meta{column}_int}]
%     The highest float sequence number for floats of type \meta{float}
%     allocated to the column: zero if no float has been allocated so far.
%
%   \item[\cs{g_xor_flseq_type_\meta{float}_col_0_int}]
%     The highest float sequence number for floats of type \meta{float}
%     allocated to the columns on the previous page.
%
%   \item[\cs{g_xor_flseq_areas_top_type_\meta{float}_col_\meta{column}_int}]
%     The highest float sequence number for floats of type \meta{float}
%     allocated to top area of the column: zero if no float has been allocated
%     so far.
%
%   \item[\cs{g_xor_bottom_ht_col_\meta{column}_dim}]
%     The vertical size already taken up by bottom floats during the trials.
%     This is used during balancing.
%
%   \item[\cs{g_xor_balance_ht_col_\meta{column}_dim}]
%     ? FRANK ?
%
%   \item[\cs{g_xor_saved_bottom_ht_col_\meta{column}_dim}]
%     ? FRANK ?
% \end{description}
%
% The above structures are now set up for six columns: this should be enough
% for anyone. On the other hand, the number of blocks available is limited.
%    \begin{macrocode}
\int_step_inline:nnnn { 1 } { 1 } { 6 }
  {
%<*unused>
% ? FRANK ? not sure at the moment
    \box_new:c { g_xor_col_ #1 _box }
%</unused>
    \box_new:c { g_xor_col_ #1 _1_box }
    \box_new:c { g_xor_col_ #1 _2_box }
%<*unused>
% ? FRANK ? not sure at the moment
    \dim_new:c { g_xor_ht_col_ #1 _dim }
%</unused>
    \dim_new:c { g_xor_ht_col_ #1 _1_dim }
    \dim_new:c { g_xor_ht_col_ #1 _2_dim }
%<*unused>
% ? FRANK ? not sure at the moment
    \dim_new:c { g_xor_best_ht_col_ #1 _dim }
%</unused>
    \dim_new:c { g_xor_best_ht_col_ #1 _1_dim }
    \dim_new:c { g_xor_best_ht_col_ #1 _2_dim }
    \box_new:c { g_xor_col_ #1 _balance_box }
    \int_new:c { g_xor_col_ #1 _block_int }
    \int_new:c { g_xor_t_floats_col_ #1 _int }
    \int_new:c { g_xor_b_floats_col_ #1 _int }
    \int_new:c { g_xor_m_floats_col_ #1 _int }
%<*unused>
% ? FRANK ? not sure at the moment
    \int_new:c { g_xor_c_floats_col_ #1 _int }
%</unused>
    \dim_new:c { g_xor_t_delta_col_ #1 _dim }
    \dim_new:c { g_xor_b_delta_col_ #1 _dim }
    \dim_new:c { g_xor_m_delta_col_ #1 _dim }
%<*unused>
% ? FRANK ? not sure at the moment
    \dim_new:c { g_xor_c_delta_col_ #1 _dim }
%</unused>
    \dim_new:c { g_xor_saved_t_delta_col_ #1 _dim }
    \dim_new:c { g_xor_saved_b_delta_col_ #1 _dim }
    \dim_new:c { g_xor_saved_m_delta_col_ #1 _dim }
%<*unused>
% ? FRANK ? not sure at the moment
    \dim_new:c { g_xor_saved_c_delta_col_ #1 _dim }
%</unused>
    \dim_new:c { g_xor_bottom_ht_col_ #1 _dim }
    \dim_new:c { g_xor_saved_bottom_ht_col_ #1 _dim }
    \dim_new:c { g_xor_balance_ht_col_ #1 _dim }
  }
%    \end{macrocode}
%
% \subsection{Utilities for column structures}
%
% \begin{macro}{\xor_forall_columns:n}
% \begin{macro}{\xor_forall_column_block:n}
% \begin{variable}{\g_xor_saved_curr_col_int, \g_xor_saved_curr_col_block_int}
%   Applies the code in |#1| for each column current active. Within the code,
%   \cs{g_xor_curr_col_int} is the column current being processed. The
%   value of \cs{g_xor_curr_col_int} is saved and restored using a global
%   approach, but there is no nesting support here.
%    \begin{macrocode}
\cs_new_protected:Npn \xor_forall_columns:n #1
  {
    \int_gset_eq:NN \g_xor_saved_curr_col_int \g_xor_curr_col_int
    \int_gzero:N \g_xor_curr_col_int
    \int_while_do:nNnn \g_xor_curr_col_int < \g_xor_cols_int
      {
        \int_gincr:N \g_xor_curr_col_int
         #1
      }
    \int_gset_eq:NN \g_xor_curr_col_int \g_xor_saved_curr_col_int
  }
%    \end{macrocode}
%   Mapping to every block of every column follows the same pattern, with
%   \cs{g_xor_curr_col_block_int} available for the block number.
%    \begin{macrocode}
\cs_new_protected:Npn \xor_forall_column_blocks:n #1
  {
    \int_gset_eq:NN \g_xor_saved_curr_col_block_int \g_xor_curr_col_block_int
    \xor_forall_columns:n
      {
        \int_gzero:N \g_xor_curr_col_block_int
        \int_while_do:nNnn \g_xor_curr_col_block_int <
         {
           \int_use:c { g_xor_col_ \int_use:N \g_xor_curr_col_int _block_int }
         }
         {
           \int_gincr:N \g_xor_curr_col_block_int
           #1
         }
      }
    \int_gset_eq:NN \g_xor_curr_col_block_int \g_xor_saved_curr_col_block_int
  }
\int_new:N \g_xor_saved_curr_col_int
\int_new:N \g_xor_saved_curr_col_block_int
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xor_save_col_hts:N}
%   Saves information about the current column setup in a tl var.~passed as its
%   argument. Calling this tl var.~(e.g., |\g_xor_best_trial_col_hts_tl|) can
%   then be used to restore those settings. As with most of the rest of the
%   OR, the assignment here is global and the tl var.~should be a \cs{g_\ldots}
%
%   This is for example used to remember the current best trial.  Calling the
%   tl var.~doesn't change the current \tn{vsize} but sets for each column
%   block \cs{g_xor_ht_col_\meta{column}_\meta{block}_dim} to hold a new height
%   which can then be assigned to \tn{vsize} when cutting the galley for the
%   \meta{column} (or column block).
%    \begin{macrocode}
\cs_new_protected:Npn \xor_save_col_hts:N #1
  {
%<*trace>
    \trace_push:n { xor_save_col_hts:N~( \token_to_str:N #1 ) }
%</trace>
    \tl_gclear:N #1
    \xor_forall_columns:n
      {
        \tl_gput_right:Nx #1
          {
            \int_gset:Nn
              \exp_not:c
                { g_xor_col_ \int_use:N \g_xor_curr_col_int _block_int }
              {
                \int_use:c
                  { g_xor_col_ \int_use:N \g_xor_curr_col_int _block_int }
              }
          }
      }
    \xor_forall_column_blocks:n
      {
%<*trace>
        \trace:n
          { \token_to_str:N \xor_curr_col_block: ~:=~ \xor_curr_col_block: }
%</trace>
        \tl_gput_right:Nx #1
          {
            \dim_gset:Nn
              \exp_not:c { g_xor_ht_col_ \xor_curr_col_block: _dim }
              { \dim_use:c { g_xor_ht_col_ \xor_curr_col_block: _dim} }
          }
      }
%<*trace>
    \trace:n { Saving~column~(height)~information: }
    \trace:n { \token_to_str:N #1 ~:=~ \tl_to_str:N #1}
    \trace_pop:n { xor_save_col_hts:N }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_cols_setup:}
%   This command sets up the column data structures when we are about to
%   start a new page.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_cols_setup:
  {
%<*trace>
    \trace_push:n { xor_cols_setup: }
%</trace>
    \int_gset_eq:NN \g_xor_curr_col_int \c_one
    \int_gset_eq:NN \g_xor_curr_col_block_int \c_one
%    \end{macrocode}
%    We haven't seen any balance points yet, thus clearly none are
%    already handled.\footnote{FIX: not needed here?}
%    \begin{macrocode}
%<*unused>
    \int_gzero:N \g_xor_best_balance_done_int
%</unused>
%    \end{macrocode}
%   The initial target size for all columns is the height of the text on
%   the page. The size already taken up by bottom floats is zero.
%    \begin{macrocode}
    \xor_forall_columns:n
      {
        \int_gset_eq:cN
          { g_xor_col_ \int_use:N\g_xor_curr_col_int _block_int } \c_one
        \dim_gset_eq:cN
%<*package>
          { g_xor_ht_col_ \xor_curr_col_block: _dim } \textheight
%</package>
%<*initex>
          % What do we do here?
          { g_xor_ht_col_ \xor_curr_col_block: _dim } \ERROR
%</initex>
        \dim_gzero:c
          { g_xor_bottom_ht_col_ \int_use:N \g_xor_curr_col_int _dim }
%    \end{macrocode}
%    We haven't seen any top, bottom or middle floats yet.
%    \begin{macrocode}
        \int_gzero:c
          { g_xor_t_floats_col_ \int_use:N \g_xor_curr_col_int _int }
        \int_gzero:c
          { g_xor_b_floats_col_ \int_use:N \g_xor_curr_col_int _int }
        \int_gzero:c
          { g_xor_m_floats_col_ \int_use:N \g_xor_curr_col_int _int }
%    \end{macrocode}
%    For the same reason the delta values for top and bottom areas are
%    zeroed.
%    \begin{macrocode}
        \dim_gzero:c { g_xor_t_delta_col_ \int_use:N \g_xor_curr_col_int _dim }
        \dim_gzero:c { g_xor_b_delta_col_ \int_use:N \g_xor_curr_col_int _dim }
        \dim_gzero:c { g_xor_m_delta_col_ \int_use:N \g_xor_curr_col_int _dim }
      }
%    \end{macrocode}
%    We now save in \cs{g_xor_best_trial_col_hts_tl} the various
%    dim registers for all columns since this will be the best solution unless
%    something better comes along (i.e., if we can place one or more floats)
%    \begin{macrocode}
    \xor_save_col_hts:N \g_xor_best_trial_col_hts_tl
%<*trace>
    \trace_pop:n { xor_cols_setup: }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Float area data structures}
%
% The naming convention for float areas is as follows:
% \begin{quote}
%   \meta{identifier}\meta{start-column}\meta{span-count}.
% \end{quote}
% The \meta{identifier} is a single letter denoting the type of area,
% e.g., |t| for top, |b| for bottom. The \meta{span-count} is a single
% digit denoting the number of columns to span. The
% \meta{start-column} is a single digit\footnote{With a bit of care in
% the code this could be extended to allow more than one digit.}
% denoting the start column of the area. Thus |t32| is a top area
% starting at column three and spanning two columns, i.e.~columns three and
% four. A restriction due to the naming scheme is that no more than~$9$ columns
% are possible. In addition to the standard areas, the special area
% |DDD| is used to handle deferred floats.
%
% Only a subset of the float areas is allowed to be populated on a page. In
% essence the current algorithm does not support placements that result in
% splitting the text of a column due to a float (other than column
% \enquote{here} floats).\footnote{Perhaps this restriction will be lifted one
% day.} This means that if $pcs$ ($p = \textrm{pos}$, $c = \textrm{column}$,
% $s = \textrm{span}$) is a float area that is being populated then it must
% prevent populating all float areas that satisfy either
% \[
%    pij  \textrm{ with }   i < c \leq i+j < c+s
% \]
% or
% \[
%    pij  \textrm{ with }   i \leq c+s < i+j \leq \cs{g_xor_cols_int}
% \]
% The first formula describes the areas which partly overlap from the
% left, the second formula describes those that partly overlap from
% the right. Areas which are sub- or super-areas, e.g., \texttt{t13}
% and \texttt{t22} do not affect each other. The above restriction is
% necessary to prevent situations like
% \begin{verbatim}
%   aaaaaaaaaaa 444
%   aaaaaaaaaaa 444
%   aaaaaaaaaaa 444
%   111 222 bbbbbbb
%   111 222 bbbbbbb
%   111 222 bbbbbbb
%   111 222 333 444
%   111 222 333 444
% \end{verbatim}
%
% For each area \meta{area} (e.g., |t13|) we keep a number of global variables
% to store relevant data. These are the following variables:
% \begin{description}
%   \item[\cs{g_xor_area_\meta{area}_float_seq}]
%     Holds the floats allocated to the \meta{area} by the page building
%     process.
%
%   \item[\cs{g_xor_area_\meta{area}_max_float_int}]
%     The maximum number of floats allowed in the \meta{area}.
%
%   \item[\cs{g_xor_area_\meta{area}_float_int}]
%     The number of floats currently allocated to the \meta{area}.
%
%   \item[\cs{g_xor_area_\meta{area}_class_close_clist}]
%     Areas that should be closes for floats of the same sequence class once a
%     float is added to the \meta{area}.
%
%   \item[\cs{g_xor_area_\meta{area}_all_close_clist}]
%     Areas that should be closes for floats of all classes once a
%     float is added to the \meta{area}.
% \end{description}
%
% There are three general classes of data structure here: ones which apply
% to all floats, ones which apply to a single \enquote{current} float during
% the processing operation, ones which apply to a class of floats (mainly
% dynamically generated). In the first class, some are for internal use
% while others are available for template manipulation.
%
% \begin{variable}{\g_xor_areas_known_clist}
%   A list of the float areas known to the system.\footnote{Or
%   something else, the semantics are still changing.} Initialization
%   is done when declaring individual areas.
%    \begin{macrocode}
\clist_new:N \g_xor_areas_known_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_areas_used_clist}
%   The float areas actually used by the current page setup: initialization is
%   done in the page setup template.
%    \begin{macrocode}
\clist_new:N \g_xor_areas_used_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_float_free_seq}
%   Sequence of float structures free to receive floats. \LaTeXe{} creates
%   a number of inserts in the format code, and so these are reused in package
%   mode. In kernel mode, all of the required inserts will be created as they
%   are needed.
%    \begin{macrocode}
\seq_new:N \g_xor_float_free_seq
%<*package>
\cs_set:Npn \@elt #1 { \seq_gput_right:Nn \g_xor_float_free_seq {#1} }
\@freelist
\cs_undefine:N \@freelist
\cs_undefine:N \@elt
%</package>
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_floats_active_seq}
%   Sequence of floats encountered while collecting material for the next page.
%   From this sequence floats are picked one by one and tried for placement.
%   They then either get moved into some float area during trial or get
%   deferred.
%    \begin{macrocode}
\seq_new:N \g_xor_floats_active_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_floats_mvl_seq}
%   When building float pages and/or preassigning floats to the next text page
%   we look at the floats that got previously deferred. In that case it is
%   possible (perhaps even sensible?) to distinguish between those floats that
%   have their callouts on previous pages and those which have their callout
%   within material that isn't typeset yet. Such floats should better not
%   participate in a full float page.
%
%   Thus at some point in the algorithm we take the list of deferred floats and
%   split it into those available for float pages (put into
%   \cs{g_xor_floats_active_seq}) and those with their callout still on the MVL
%   (put into \cs{g_xor_floats_mvl_seq}).\footnote{There are some questions to
%   this approach later in the code.}
%    \begin{macrocode}
\seq_new:N \g_xor_floats_mvl_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_area_DDD_float_seq}
%   The list of deferred floats: a special \meta{area} with a three token
%   name (as required by the general naming scheme).
%    \begin{macrocode}
\seq_new:N \g_xor_area_DDD_float_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_area_DDD_class_close_clist}
%   This clist lists all areas that should be closed for some class |FOO| if a
%   float of this class is deferred. Normally this would be all areas on the
%   page, i.e., \cs{g_xor_areas_used_clist}, and this is how it is typically
%   initialized in the background. However, in designs that don't care about
%   float orderings it can be set to something else in which case some or all
%   areas may remain open.
%    \begin{macrocode}
\clist_new:N \g_xor_area_DDD_class_close_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_area_DDD_all_close_clist}
%   This clist lists all areas that should be closed if a any float is
%   deferred (regardless of its class). It is normally initialized to close
%   no areas.
%    \begin{macrocode}
\clist_new:N \g_xor_area_DDD_all_close_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_xor_this_caption_tl,
%     \g_xor_this_span_num_tl,
%     \g_xor_this_display_tl,
%     \g_xor_this_display_cnt_tl,
%     \g_xor_this_allowed_areas_clist,
%     \g_xor_this_type_tl,
%     \g_xor_this_flseq_int,
%     \g_xor_this_class_tl
%   }
%   When working with an individual float, a number of pieces of information
%   need to be available as variables.
%
%   The float caption.
%    \begin{macrocode}
\tl_new:N \g_xor_this_caption_tl
%    \end{macrocode}
%    The span count of the float (i.e., how many columns the float
%    spans). Perhaps not a very good approach if you think that you may
%    allow  column sizes to change one day. But right now that's the
%    number that is recorded in the float data structure and used for
%    some sanity checks, etc.
%    \begin{macrocode}
\tl_new:N \g_xor_this_span_num_tl
%    \end{macrocode}
%   The \enquote{label} associated with the float. This is somewhat
%    premature given that we do not have a label/reference mechanism
%    set up -- so at the moment what ends up here is simply the last
%    |\label| argument \ldots{} let's hope that the float had one
%    inside ;-)
%    \begin{macrocode}
\tl_new:N \g_xor_this_label_key_tl
%    \end{macrocode}
%   The \enquote{display} counter for the float, which is usually dependent
%   on the type of float.
%    \begin{macrocode}
\tl_new:N \g_xor_this_display_cnt_tl
%    \end{macrocode}
%   Float areas permitted for the float.
%    \begin{macrocode}
\clist_new:N \g_xor_this_allowed_areas_clist
%    \end{macrocode}
%   The type of the float.
%    \begin{macrocode}
\tl_new:N \g_xor_this_type_tl
%    \end{macrocode}
%   The number of this float within the sequence of floats of the appropriate
%   type.
%    \begin{macrocode}
\int_new:N \g_xor_this_flseq_int
%    \end{macrocode}
%   The class of the float.
%    \begin{macrocode}
\tl_new:N \g_xor_this_class_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {\g_xor_this_areas_open_clist, \g_xor_saved_this_areas_open_clist}
%   The float areas in which we will try to place a float onto the current
%   page. These areas are tried one after another until the float is
%   successfully placed or we run out of areas. The \texttt{saved} version is
%   needed for backtracking if we encounter a flush point that can't be
%   resolved.
%    \begin{macrocode}
\clist_new:N \g_xor_this_areas_open_clist
\clist_new:N \g_xor_saved_this_areas_open_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_this_areas_closed_clist}
%   The float areas which have been closed for the current float while trying
%   to place it. It is initialized with
%   |\g_xor_class_ \g_xor_this_class_tl _areas_closed_clist| when we fetch a
%   new float to try. Once the float is placed we write the then current value
%   back.
%    \begin{macrocode}
\clist_new:N \g_xor_this_areas_closed_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_curr_page_areas_closed_clist}
%   The float areas which have been closed for all float types.
%    \begin{macrocode}
\clist_new:N \g_xor_curr_page_areas_closed_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_xor_area_t11_float_int,
%     \g_xor_area_t21_float_int,
%     \g_xor_area_b11_float_int,
%     \g_xor_area_b21_float_int
%   }
%   The float counts are allocated dynamically when an area is
%   declared if they are not defined, but we have a few registers
%   left over from \LaTeX{}'s old OR so we might as well use them.
%    \begin{macrocode}
%<*unused>
\int_new:c { g_xor_area_t11_float_int }
\int_new:c { g_xor_area_b11_float_int }
\int_new:c { g_xor_area_t12_float_int }
\int_new:c { g_xor_area_b12_float_int }
%</unused>
%<*package>
\cs_set_eq:cN { g_xor_area_t11_float_int } \@topnum
\cs_set_eq:cN { g_xor_area_b11_float_int } \@botnum
\cs_set_eq:cN { g_xor_area_t12_float_int } \@dbltopnum
\cs_set_eq:cN { g_xor_area_b12_float_int } \@dblbotnum
%</package>
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_area_DDD_float_int}
%   We need to declare the one for the defer area is that isn't going through
%   the normal initialization process.
%    \begin{macrocode}
\int_new:N \g_xor_area_DDD_float_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_float_area_skip}
%   The separation to use between two adjacent float areas.
%    \begin{macrocode}
\skip_new:N \g_xor_float_area_skip
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_float_text_skip}
%   The separation to use between column text and adjacent float areas.
%    \begin{macrocode}
%<*initex>
\skip_new:N \g_xor_float_text_skip
%</initex>
%<*package>
\cs_new_eq:NN \g_xor_float_text_skip \textfloatsep
%</package>
%<*unused>
\cs_undefine:N \textfloatsep
%</unused>
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_float_float_skip}
%   The separation to use between two floats in the same float area.
%    \begin{macrocode}
%<*initex>
\skip_new:N \g_xor_float_float_skip
%</initex>
%<*package>
\cs_new_eq:NN \g_xor_float_float_skip \floatsep
%</package>
%<*unused>
\cs_undefine:N \floatsep
%</unused>
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_float_text_shrink_dim}
%   The allowed shrinkability of \cs{g_xor_float_text_skip}. This is used if we
%   are doing grid typesetting and have to adjust the vertical size of the
%   column.
%    \begin{macrocode}
\dim_new:N \g_xor_float_text_shrink_dim
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_float_inline_skip}
%   The separation to use between two floats in the same float area.
%    \begin{macrocode}
%<*initex>
\skip_new:N \g_xor_float_inline_skip
%</initex>
%<*package>
\cs_new_eq:NN \g_xor_float_inline_skip \intextsep
%</package>
%<*unused>
\cs_undefine:N \intextsep
%</unused>
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_float_inline_shrink_dim}
%   The allowed shrinkability of \cs{g_xor_float_inline_skip}. This is used if
%   we are doing grid typesetting and have to adjust the vertical size of
%   object to be added, e.g., an inline float with its caption.
%    \begin{macrocode}
\dim_new:N \g_xor_float_inline_shrink_dim
%    \end{macrocode}
% \end{variable}
% 
% \subsection{Utilities for float area structures}
% 
% \begin{macro}[EXP, TF]{\xor_if_this_area_type:N}
%   Test for the type of the current area (|t|, |m|, |b|, or |c|) and execute
%   the true or false clause.
%    \begin{macrocode}
\prg_new_conditional:Npnn \xor_if_this_area_type:N #1 { T , F , TF }
  {
    \if:w #1 \g_xor_this_area_type_tl
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\xor_area_setup:}
%    Initialize all float areas used within the current page setup.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_area_setup:
  {
    \clist_map_inline:Nn
      \g_xor_areas_used_clist
      {
        \int_gzero:c  { g_xor_area_ ##1 _float_int }
        \seq_gclear:c { g_xor_area_ ##1 _float_seq }
      }
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\xor_this_area_setup:n, \xor_this_area_setup:o}
% \begin{macro}{\xor_this_area_setup_aux:NNN}
%   Whenever the algorithm works with some area as the current
%   candidate for putting a float into it uses the information about the
%   float area, which is extracted here.
%    \begin{macrocode}
\cs_new_protected:Npn \xor_this_area_setup:n #1
  {
    \tl_gset:Nn \g_xor_this_area_name_tl {#1}
    \xor_this_area_setup_aux:NNN #1
  }
\cs_generate_variant:Nn \xor_this_area_setup:n { o }
\cs_new_protected:Npn \xor_this_area_setup_aux:NNN #1#2#3
  {
    \tl_gset:Nn \g_xor_this_area_type_tl {#1}
    \tl_gset:Nn \g_xor_this_area_col_tl  {#2}
    \tl_gset:Nn \g_xor_this_area_span_tl {#3}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\l_xor_update_col_int}
%    Local counter used in loops over columns.
%    \begin{macrocode}
\int_new:N \l_xor_update_col_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\xor_update_this_area_span_cols:n}
%   If we have to do updates for all columns that are spanned by the
%   current target area we can call \cs{xor_update_this_area_span_cols:n}. It
%   loops through the columns (backwards!) with |\l_xor_update_col_int|
%   referring to the current column. Data structure updates have to be global
%   as everything happens within a group.
%    \begin{macrocode}
\cs_new_protected:Npn \xor_update_this_area_span_cols:n #1
  {
    \group_begin:
      \int_set:Nn \l_xor_update_col_int 
        { \g_xor_this_area_col_tl + \g_xor_this_area_span_tl }
      \int_while_do:nNnn \g_xor_this_area_col_tl < \l_xor_update_col_int
        {
          \int_decr:N \l_xor_update_col_int
%<*trace>
          \trace:n { looking~at~column:~ \int_use:N \l_xor_update_col_int }
%</trace>
          #1
        }
    \group_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Adding marker penalties to the MVL}
%
% \begin{macro}{\xor_add_badly_guarded_penalty:N}
% \begin{macro}[aux]{\xor_add_badly_guarded_penalty_aux:N}
%   Put a special penalty into the output and guard it with a box. The reason
%   this macro is called \cs{xor_add_badly_guarded_penalty:N} is that such a
%   box of size zero is still messing up spacing calculations. Why? Because
%   when the penalty is reached on the MVL, the preceding line has already be
%   fully added (i.e., including its depth). This means that \TeX{} might not
%   reach it at all in time! For example, if the preceding line would have been
%   the last line of the page, the depth would not be taken into account yet,
%   but by the time we reach the special penalty it has been added to
%   \tn{pagetotal} and that may result in not fitting any more onto the page.
%
%   A solution would be to use a box that has the same depth as the immediately
%   preceding box and a negative height so that it effectively doesn't modify
%   the galley length. Easy, right?  The only problem is that in case of
%   \tn{vadjust} (and that is unfortunately the more important case) we just
%   don't know what the preceding depth is, since \cs{prevdepth} will always
%   give us be $-1000$\,pt in that case (start of a vertical sub-list\ldots).
%
%   So not so easy after all. The way out of this dilemma turned out to be
%   complicated and involves a lot of strange corrective actions in the
%   collection process, see there for a replacement of that box and what else
%   can go wrong if one delves into messing around with that part of \TeX{}.
%    \begin{macrocode}
\cs_new_protected:Npn \xor_add_badly_guarded_penalty:N #1
  {
    \mode_if_vertical:TF
      {
        \xor_nointerlineskip:
        \xor_add_badly_guarded_penalty_aux:N #1
      }
      {
        \xor_bsphack:
        \tex_vadjust:D { \xor_add_badly_guarded_penalty_aux:N #1 }
        \xor_esphack:
      }
%<*trace>
    \trace:n { Adding~badly~guarded~penalty~\int_use:N #1 \c_space_tl to~MVL }
%</trace>
  }
%    \end{macrocode}
%   In all cases, the local definition of \tn{everypar} is altered so that
%   this rather unusual box is as simple as possible.
%    \begin{macrocode}
\cs_new_protected:Npn \xor_add_badly_guarded_penalty_aux:N #1
  {
    \vbox_to_zero:n
      {
        \tex_everypar:D { }
        \tex_vss:D
        \int_use:N #1 \c_space_tl BAD
      }
    \tex_penalty:D #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\g_xor_removed_guard_box}
%   A register to hold a guard box that was just removed from the current
%   list so that we can re-add it later if necessary.
%    \begin{macrocode}
\box_new:N \g_xor_removed_guard_box
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\xor_remove_guard_box_from_cclv:}
%    Remove a guard box. This always happens in the OR and so we hard-code the
%    box number for speed.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_remove_guard_box_from_cclv:
  {
    \vbox_gset:Nn \c_two_hundred_fifty_five
      {
%<*initex>
        \dim_set_eq:NN \tex_boxmaxdepth:D \l_box_max_depth_dim
%</initex>
%<*package>
        \dim_set_eq:NN \tex_boxmaxdepth:D \@maxdepth
%</package>
        \vbox_unpack_clear:N \c_two_hundred_fifty_five
        \box_gset_to_last:N \g_xor_removed_guard_box
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_readd_guarded_penalty:n}
%   Re-adding a guarded penalty including the box that was removed earlier.
%   Probably not needed in the end either since the way it is used at the
%   moment we have a \tn{topskip} problem this way.\footnote{FIX!!!!}
%    \begin{macrocode}
\cs_new_protected:Npn \xor_readd_guarded_penalty:n #1
  {
    \box_use_clear:N \g_xor_removed_guard_box
    \tex_penalty:D #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Collection Output Routine}
% 
% \begin{variable}{\g_xor_saved_top_skip}
%   Used to save the value of the \tn{topskip} so it can be reset
%   safely.
%    \begin{macrocode}
\skip_new:N \g_xor_saved_top_skip
%    \end{macrocode}
% \end{variable}
%
% \begin{description}
%   \item[Entry:]  |\xor_collect_setup:|
%   \item[Exit:]   |\xor_trial_place_float_setup:|
%   \item[Prereq:] |\xor_next_page_setup:| should have been called before.
%   \item[Description:] Grab enough text (and float call-outs) to obtain
%     a galley big enough to form the next text page. The page goal is
%     set to a value high enough to ensure that in normal cases text
%     for all columns of the page is collected, i.e, we have a safety
%     margin of five extra lines per column.\footnote{This should be made
%     customisable for unusual jobs!}
%
%     If the output routine is triggered with a special penalty (in the
%     range of $-10000>p>=-10009=|\c_xor_output_balance_penalty|$) the penalty
%     is moved into the collection box |\g_xor_partial_mvl_box| without
%     further processing; otherwise the collection is ended and all
%     collected material is moved to |\g_xor_hold_page_box| for use in page
%     production.
%
%   \item[Flow:]
%    \begin{footnotesize}
%\begin{verbatim}
%   \xor_collect_setup:
%           |
%           V
%  New OR: \xor_OR_collect:
%           |
%           |<-----------------------------------------
%           |                                         |
%  (natural end of collection reached?)               |
%           |           |                             |
%          yes          no                            |
%           |           |                             |
%           | (record special penalty and carry on)----
%           |
%           V
%   \xor_trial_place_float_setup:
%\end{verbatim}
%    \end{footnotesize}
% \end{description}
%
% \begin{macro}{\xor_collect_setup:}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_collect_setup:
  {
%<*trace>
    \trace_push:n { xor_collect_setup: }
%</trace>
    \int_gset_eq:NN \tex_holdinginserts:D \c_one
%    \end{macrocode}
%   We set the \tn{vsize} for collection to the height of a single
%   column (plus a safety margin of currently five lines to allow for
%   vanishing space at margins) multiplied by the number of columns.
%    \begin{macrocode}
    \dim_gset:Nn \tex_vsize:D
%<*initex>
      % What to do here?
      { ( \ERROR + \c_five \tex_baselineskip:D ) * \g_xor_cols_int }
%</initex>
%<*package>
      { ( \textheight + \c_five \tex_baselineskip:D ) * \g_xor_cols_int }
%</package>
%<*trace>
    \trace:n { collection~vsize:~ \dim_use:N \tex_vsize:D }
%</trace>
%    \end{macrocode}
%   Initialising the flush point handling:
%    \begin{macrocode}
    \bool_gset_false:N \g_xor_flush_seen_bool
    \bool_gset_false:N \g_xor_flush_failed_bool
%    \end{macrocode}
%   We may have to restart the collection (whenever we find a here or
%   a flush point) and we don't want to get extra space added via
%   \tn{topskip}. So we can either make \tn{topskip} zero during
%   collection (current strategy) or back it out whenever we restart.
%
%   We can't set topskip to zero now since a) we want a proper
%   \tn{topskip} for the first column and b) due to a bloody fix for the
%   old \LaTeX{} OR, a value of |0pt| is set to |1sp| in
%   |\begin{document}| and this results in adding |1sp| at every
%   special point\ldots no, we definitely do not want this! It took
%   me ages to find out why the grid design macros didn't work.
%    \begin{macrocode}
    \skip_gset_eq:NN \g_xor_saved_top_skip \tex_topskip:D
%    \end{macrocode}
%    Free up the space still taken up by \cs{g_xor_hold_page_box} (as
%    its was always copied--could probably done earlier).
%    \begin{macrocode}
    \box_gclear:N \g_xor_hold_page_box
%    \end{macrocode}
%   Finally, actually set the OR.
%    \begin{macrocode}
    \tex_global:D \tex_output:D { \xor_OR_collect: }
%<*trace>
    \trace_pop:n { xor_collect_setup: }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\g_xor_collect_new_stuff_bool}
%   There are actually two collecting modes: on when the recent
%   contributions are empty and we are really collecting material
%   that we haven't seen before and one where we collect material
%   that has been collected on a previous collection pass and has been
%   placed again on to the main vertical list. The reason why we need
%   to differentiate between the two is that in the second case we
%   have to handle the special penalties differently since by now
%   they are already surrounded by the proper guard boxes before and
%   after and we better do not disturb this fragile setup.
%    \begin{macrocode}
\bool_new:N \g_xor_collect_new_stuff_bool
%    \end{macrocode}
% \end{variable}
% 
% \begin{variable}{\g_xor_page_depth_dim}
%   Used to store the page depth when dealing with a marker penalty.
%    \begin{macrocode}
\dim_new:N \g_xor_page_depth_dim
%    \end{macrocode}
% \end{variable}
% 
% \begin{variable}{g_xor_saved_output_penalty_int}
%   Saves the output penalty.
%    \begin{macrocode}
\int_new:N \g_xor_saved_output_penalty_int
%    \end{macrocode}
% \end{variable}
% 
% \begin{variable}{\g_xor_partial_mvl_box}
%   Need a box to store the partially collected galley.
%    \begin{macrocode}
\box_new:N \g_xor_partial_mvl_box
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_hold_page_box}
%    Need a box to temp store the fully collected galley.
%    \begin{macrocode}
%<*initex>
\box_new:N \g_xor_hold_page_box
%</initex>
%<*package>
\cs_new_eq:NN \g_xor_hold_page_box \@holdpg
%</package>
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\xor_OR_collect:}
% \begin{macro}[aux]{\xor_OR_collect_special:, \xor_OR_collect_std:}
%   The output routine during the collection phase assembles the
%   material until enough has been gathered to be sure to fill a
%   page.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_OR_collect:
  {
%<*trace>
    \trace_push:n { xor_OR_collect: }
    \trace:n { output~pen:~ \int_use:N \tex_outputpenalty:D }
%</trace>
%    \end{macrocode}
%   We first look if the call to the OR is due to a special penalty.
%    \begin{macrocode}
    \bool_if:nTF
      {
        \int_compare_p:nNn \tex_outputpenalty:D < { -\c_ten_thousand } &&
        \int_compare_p:nNn \tex_outputpenalty:D > 
                                     { \c_xor_output_collect_penalty }
      }
      { \xor_OR_collect_special: }
      { \xor_OR_collect_std: }
%<*trace>
    \trace_pop:n { xor_OR_collect: }
%</trace>
  }
%    \end{macrocode}
%   Whenever a special penalty, i.e., one between $-10000 > p >
%   -10010$ is encountered we need some magic:
%   \begin{itemize}
%     \item
%       We want to keep the penalty in the collected material but
%       nevertheless carry on with the collection. Simply moving the
%       collected material to a separate box is not enough since then
%       we will restart the collection with an empty page and thus
%       receive a \tn{topskip} glue as well as probably losing material
%       if there is anything discardable after the special penalty.
%     \item But putting a zero box back and doing something to fix the
%       problem with the \tn{topskip} glue isn't good either in case we
%       later actually want to break after the line with special
%       penalty, since then we would start a page with our inserted
%       box, and in this case we would like to get a proper \tn{topskip}
%       and we would like to get rid of discardable stuff.
%     \item And there is another problem, we need a guard box in front of
%       that special penalty, but this guard box should not be simply a
%       \tn{null} box (as it is right now added by
%       \cs{xor_add_badly_guarded_penalty:N}) since that will result in wrong
%       page calculations because it will make \TeX{} add the depth of
%       the previous line to the page total which it shouldn't.
%   \end{itemize}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_OR_collect_special:
  {
%<*trace>
    \trace:n
      {
        Forced~break~( \int_use:N \tex_outputpenalty:D )~seen~
        \msg_line_context: 
      }
%</trace>
%    \end{macrocode}
%   So what to do? First of all we remove the guard box in front of
%   the special penalty (which is now at the end of box~255) since we
%   want to replace that with something better, then we
%   store away the depth of box~255 since we need that in a minute.
%    \begin{macrocode}
    \xor_remove_guard_box_from_cclv:
%    \end{macrocode}
%   We really have to say |\box_dp:N \c_two_hundred_fifty_five| not
%   \tn{pagedepth}. The latter is always zero in the OR which looks
%   suspiciously like a bug or at least an inconsistency when Don implemented
%   the change from \TeX2 to \TeX3 (in \TeX2 \cs{page\ldots} registers were
%   useless in the OR, now only \cs{pagedepth} seems to be left).
%    \begin{macrocode}
    \dim_set:Nn \g_xor_page_depth_dim
      { \box_dp:N \c_two_hundred_fifty_five }
%    \end{macrocode}
%   Then we subtract the size of the collected material from
%   \tn{vsize} since we will store it away in a separate box for a while.
%   Note that we have to use |\box_ht:N \c_two_hundred_fifty_five| here not
%   \tn{pagetotal} since the latter might be too large because of that
%   \tn{null} box. The height of~255 on the other hand is, after the removal
%   of that box the natural height of the material.
%    \begin{macrocode}
    \dim_gsub:Nn \tex_vsize:D { \box_ht:N \c_two_hundred_fifty_five }
%    \end{macrocode}
%   Now we append the material to \cs{g_xor_partial_mvl_box}, this is
%   straight forward.
%    \begin{macrocode}
    \vbox_gset:Nn \g_xor_partial_mvl_box
      {
        \box_if_empty:NF \g_xor_partial_mvl_box
          { \vbox_unpack_clear:N \g_xor_partial_mvl_box }
        \vbox_unpack_clear:N \c_two_hundred_fifty_five
%    \end{macrocode}
%   But how to add the penalty and how to guard it? We need a box or
%   something to ensure the penalty doesn't get lost at a column
%   break but we also want to avoid that \TeX{} adds the depth of the
%   preceding line to \tn{pagetotal}. Fortunately we know this depth by
%   now (we have just stored it in \cs{g_xor_page_depth_dim}), something we
%   didn't know at the time the we added the penalty with
%   \cs{xor_add_badly_guarded_penalty:N}. So we could back up and then add a
%   box with zero height and that depth. This way a break directly after this
%   line would have the same \cs{pagetotal} as a break at the special penalty.
%   In fact, instead of backing up using a \tn{kern} or a \tn{vskip} we can
%   simply make the height of the box negative. The advantage is that this way
%   we don't generate a break point between the box and a preceding box and
%   thus don't have to use special precautions to prevent \TeX{} from breaking
%   in front of the guard box.\footnote{This statement is only true for
%   special penalties added using \tn{vadjust}, i.e., in
%   hmode. If the penalty was added between paragraphs then there
%   might be vertical space in front of the box. This might need
%   special handling too. CHECK!}
%    \begin{macrocode}
        \vbox_set_to_ht:Nnn \l_xor_tmp_box { -\g_xor_page_depth_dim } { }
        \box_set_dp:Nn \l_xor_tmp_box \g_xor_page_depth_dim
        \box_use_clear:N \l_xor_tmp_box
        \tex_penalty:D \tex_outputpenalty:D
      }
%    \end{macrocode}
%   So now we have put everything we need into the
%   \cs{g_xor_partial_mvl_box}, but how do we restart our collection
%   process without running into the problems outlined above?
%
%   Well, right now on the recent contributions there will be a penalty node
%   (from our special penalty) which gets set to~$10000$ by \TeX{} followed
%   perhaps by another penalty from the line breaking followed probably by
%   interline glue calculated to make the next line of text fit vertically
%   with the preceding one -- and we don't want to loose that glue if we
%   are ending up in the middle of a column. But we want to make it vanish if
%   we happen to finally break at the special penalty place.
%
%   So the trick is that we a) disable \tn{topskip} by setting it to
%   |-\c_max_skip| (not zero this might be too large still) and b) we
%   add another of those funny boxes followed by a penalty of zero to
%   allow for a break after it.
%    \begin{macrocode}
    \skip_gset:Nn \tex_topskip:D { -\c_max_skip }
%    \end{macrocode}
%   If later on all this is put together again into a single box (in
%   \cs{g_xor_hold_page_box}) we will have the following sequence there:
%   \begin{itemize}
%     \item
%       text line (box) preceding the special penalty with depth~$d$
%       or some other vertical material in which case $d = 0\texttt{pt}$
%     \item special box with height~$-d$ and depth~$d$
%     \item special penalty, e.g. $-10008$
%     \item \tn{topskip} glue of~$0$\,pt.
%     \item special box with height~$-d$ and depth~$d$
%     \item \tn{penalty}~$0$
%     \item \tn{penalty}~$10000$
%     \item perhaps a \tn{penalty} and/or interline glue
%     \item perhaps the next text line (box)
%   \end{itemize}
%   Now if during later processing we hit the special penalty
%   \tn{pagetotal} has the same value as if we would have broken the
%   galley directly after the text line, in other words we do not see
%   the penalty too late (assume this happens to be the last line of
%   the column then if \tn{pagetotal} would also have the extra depth
%   added to it it might have been overfull and the penalty not being
%   considered at all for this column).
%
%   After the OR's have dealt with the special penalty, e.g., by flushing some
%   floats, etc.~the penalty will be replaced by~$10000$ and thus the next time
%   the galley is processed there is no breakpoint between the two special
%   boxes any more. As a result the next potential breakpoint is the
%   penalty~$0$ which again results in exactly the same \tn{pagetotal} as
%   before, i.e., if the text line was the last line to fit in the column then
%   this breakpoint will still fit there. Thus if we break the column there
%   then the interline glue, etc.~will vanish and \TeX{} will insert
%   \tn{topskip} glue (which has be set back to a normal value by then). If on
%   the other hand, this break point is not chosen the interline glue will stay
%   and thus the two text lines, before and after the special penalty will sit
%   one \tn{baselineskip} apart just as they should.
%
%   Woah. What did Don said on page~125 of \textit{The \TeX{}book}?
%   (Deep breath.) You got that?\footnote{There are probably still
%   cases that aren't covered I fear and the need for an explicit
%   penalty~$0$ at the end is kind of troublesome, so we have to see if
%   this needs further refinements.}
%
%   And here is already the first case where the above method is not
%   appropriate: if we stumble across a \cs{c_xor_output_columnbreak_penalty}
%   or \cs{c_xor_output_balance_penalty} we need to discard any following glue,
%   so we don't want a box intervene here.\footnote{Once this is interfaced
%   with the galley code problems like this should vanish since then we can
%   ensure that all such penalties are added to the galley on at a safe
%   places. REDO THEN!}
%
%   If the current penalty is a column or a balancing penalty, we do not want
%   any box after it as here we know that we are starting a new column and
%   should not hinder any glue following to vanishing in the break.
%    \begin{macrocode}
    \bool_if:NT \g_xor_collect_new_stuff_bool
      {
        \int_compare:nNnF
          \tex_outputpenalty:D = \c_xor_output_columnbreak_penalty 
          {
            \int_compare:nNnF
              \tex_outputpenalty:D = \c_xor_output_balance_penalty
              {
                \vbox_set_to_ht:Nnn
                  \l_xor_tmp_box { -\g_xor_page_depth_dim } { }
                \box_set_dp:Nn \l_xor_tmp_box \g_xor_page_depth_dim
                \box_use_clear:N \l_xor_tmp_box
                \tex_penalty:D \c_zero
              }
          }
      }
%    \end{macrocode}
%
%    \begin{macrocode}
    \int_compare:nNnT
      \tex_outputpenalty:D = \c_xor_output_flush_float_penalty
      { \bool_gset_true:N \g_xor_flush_seen_bool }
%<*trace>
    \int_compare:nNnT
      \tex_outputpenalty:D = \c_xor_output_flush_float_penalty
      { \trace:n { Forced~break~=~flush~float~point } }
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
    \int_compare:nNnT
      \tex_outputpenalty:D = \c_xor_output_balance_penalty
      { \trace:n { BALANCE:~break~seen\on@line } }
%</trace>
%    \end{macrocode}
%   Otherwise either the we reached the natural end of the
%   collection, or the point where we have been before (in case we
%   are recollecting previously seen material).
%    \begin{macrocode}
  }
%    \end{macrocode}
%   The standard branch.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_OR_collect_std:
  {
    \int_compare:nNnTF
      \tex_outputpenalty:D = \c_xor_output_collect_penalty
      {
%    \end{macrocode}
%   If we got an |\c_xor_output_collect_penalty| then we are at the point
%   to which the previous collection pass got. So, away with the
%   guard box, then everything back onto the MVL and as a penalty we
%   try to put what we have found in the previous collection pass.
%    \begin{macrocode}
        \xor_remove_guard_box_from_cclv:
        \vbox_unpack_clear:N \c_two_hundred_fifty_five
%    \end{macrocode}
%   In this particular case we also have to reset the \tn{deadcycles}
%   to zero since otherwise we will produce an infinite loop in some
%   cases. Why? Because the guard box may have been the only thing
%   left on the recent contributions followed so after the above
%   lines the recent contributions are empty, but by then
%   \tn{deadcycles} would be~$1$ so a final \tn{end} in the
%   document (e.g., from \cs{stop} or |\end{document}|) would insert an
%   empty box and a |\filll| generating column after column \ldots
%   (see \textit{The \TeX{}book}, page~264).
%    \begin{macrocode}
        \int_gzero:N \tex_deadcycles:D
%<*trace>
        \trace:n
          {
            reinsert~penalty:~ \int_use:N \g_xor_saved_output_penalty_int
            \c_space_tl (unless~10000~or~<~-9999)
          }
%</trace>
        \int_compare:nNnTF
          \g_xor_saved_output_penalty_int > { -\c_ten_thousand }
          {
            \int_compare:nNnTF
              \g_xor_saved_output_penalty_int = \c_ten_thousand
              { \tex_penalty:D \c_zero }
              { \tex_penalty:D \g_xor_saved_output_penalty_int }
          }
%    \end{macrocode}
%   We have a special situation to account for here: if we have a
%   \cs{pagebreak} that ended the collection last time then it might
%   still be the case that we haven't got to this point due to
%   floats. So we would need to put that penalty back. But only then,
%   and there is the catch!  The alternative is to not stop a
%   collection at such a point so that this problem doesn't arise in
%   the first place. Right now we lose the penalty.\footnote{Unresolved
%   situation. FIX!}
%    \begin{macrocode}
       { }
%    \end{macrocode}
%   Finally we change the \cs{g_xor_collect_new_stuff_bool} switch since we
%   are from now on looking at really new material.
%    \begin{macrocode}
        \bool_gset_true:N \g_xor_collect_new_stuff_bool
      }
%    \end{macrocode}
%   This is now the point where the collection ended naturally: we
%   save the penalty that triggered it and combine the
%   \cs{g_xor_partial_mvl_box} if it contains material with the stuff now
%   in~$255$ and put everything into \cs{g_xor_hold_page_box}.
%    \begin{macrocode}
      {
        \int_gset_eq:NN \g_xor_saved_output_penalty_int \tex_outputpenalty:D
%<*trace>
        \trace:n
          { CHECK:~Saving~output~penalty~( \int_use:N \tex_outputpenalty:D ) }
%</trace>
        \box_if_empty:NTF \g_xor_partial_mvl_box
          {
            \box_gset_eq_clear:NN
              \g_xor_hold_page_box \c_two_hundred_fifty_five
          }
          {
%<*trace>
            \trace:n { Re-adding~forced~break(s)~for~splitting }
%</trace>
            \vbox_gset:Nn \g_xor_hold_page_box
              {
                \vbox_unpack_clear:N \g_xor_partial_mvl_box
                \vbox_unpack_clear:N \c_two_hundred_fifty_five
              }
          }
        \marks_save_state:
        \marks_update_structure:
        \int_gzero:N \tex_holdinginserts:D
        \skip_gset_eq:NN \tex_topskip:D \g_xor_saved_top_skip
        \xor_trial_place_float_setup:
        \bool_gset_false:N \g_xor_collect_new_stuff_bool
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Placing Floats}
%
% \begin{description}
%   \item[Entry:] |\xor_trial_place_float_setup:|
%   \item[Exit:]
%     |\xor_OR_trial_grab_cols_setup:| or |\xor_OR_best_cols_setup:|
%   \item[Prereq:]
%   \item[Description:]
%   \item[Flow:]
%     \begin{footnotesize}
% \begin{verbatim}
%      \xor_trial_place_float_setup:
%      (initialization for all trials)
%           |
%           V
%(2)--> \xor_trial_place_float_loop:
%       (return collected material to galley)
%           |
%       <run with floats?>
%           |      |
%          yes     no----------> \xor_OR_trial_grab_cols_setup:
%           |
%           V
%       \xor_trial_place_float_inner_loop:
%           |
%           V
%   <current float successfully placed in previous trial?>
%      |                                     |
%     no                                    yes
%      |                                     |
%  (means we now try                         V
%   again using different             \xor_try_next_float:  <--------------
%   placement rules below )                  |                            |
%      |                                     |                            |
%      |                     <\g_xor_floats_active_seq empty?>            |
%      |                             |               |                    |
%      |                            no              yes                   |
%      |                             |               |                    |
%      |                             |               V                    |
%      |                          (get it) \xor_floats_active_seq_if_empty_action:
%      |                             |       (= \xor_OR_best_cols_setup:) |
%      -------------v----------------                                     |
%                   |                                                     |
%   -----> \xor_try_this_area: (= \xor_try_this_area_std:, or             |
%   |               |             \xor_try_this_area_relaxed:)            |
%   |               |                                                     |
%   |  <still open areas for current float type?>                         |
%   |         |                |                                          |
%   |        yes               no---------------(defer float)--------------
%   |         |                                                           |
%   |  (do some tests and perhaps                                         |
%   |    close area this way)                                             |
%   |         |                                                           |
%   |  <float allowed on this page/column (according to tests)?>          |
%   |         |                |                                          |
%   |        yes               no---------------(defer float)--------------
%   |         |
%   |   <current area got closed by any test?>
%   |      |                 |
%   |     yes                no
%   |      |                 |
%   | (select next area)     |
%   |      |                 |
%   --------                 V
%                 \xor_pretests_success_action: (\xor_OR_trial_grab_cols_setup:)
% \end{verbatim}
%     \end{footnotesize}
% \end{description}
% 
% \begin{variable}{\g_xor_trial_with_floats_bool}
%   When we are doing trials with floats then more work is necessary compared
%   to the situation without any floats. The boolean
%   \cs{g_xor_trial_with_floats_bool} distinguishes between the two cases.
%    \begin{macrocode}
\bool_new:N \g_xor_trial_with_floats_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_trial_failed_bool}
%   A flag to show that this set up has been tried already: see the comments
%   at the point of use for more!
%    \begin{macrocode}
\bool_new:N \g_xor_trial_failed_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\xor_trial_place_float_setup:}
%   Set up for a trial placement of floats.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_trial_place_float_setup:
  {
%<*trace>
    \trace_push:n { xor_trial_place_float_setup: }
%</trace>
%    \end{macrocode}
%   Some statistics: how many floats do we have on the
%   \cs{g_xor_floats_active_seq}?
%    \begin{macrocode}
%<*progress>
    \int_gzero:N \g_xor_floats_waiting_int
    \tl_clear:N \l_xor_tmp_tl
    \seq_map_inline:Nn \g_xor_floats_active_seq
      {
        \int_gincr:N \g_xor_floats_waiting_int
        \tl_put_right:Nn \l_xor_tmp_tl { ##1 ~ }
      }
    \xor_progress_newline:n
      {
        STATS:~floats~waiting~=~ \int_use:N\g_xor_floats_waiting_int
        \c_space_tl
        ( \l_xor_tmp_tl )~
        on~page~ \int_use:N \g_xor_page_absolute_int
      }
    \xor_progress_separator:
    \int_gzero:N \g_xor_trials_done_int
%</progress>
%    \end{macrocode}
%   We need the list of here floats during all trials. They are
%   therefore saved in \cs{g_xor_saved_floats_here_seq} at this point which is
%   then used to initialize \cs{g_xor_floats_here_seq} at the beginning of
%   each trial.
%    \begin{macrocode}
    \seq_gset_eq:NN \g_xor_saved_floats_here_seq \g_xor_floats_here_seq
%    \end{macrocode}
%
%    \begin{macrocode}
    \xor_tighten_float_placement_conditions:
    \int_gzero:N \g_xor_trial_balance_done_int
%<*trace>
    \trace:n
      {
        BALANCE:~g_xor_trial_balance_done_int~<-~
        \int_use:N \g_xor_trial_balance_done_int
      }
%</trace>
%    \end{macrocode}
%   First time we run the \cs{xor_trial_place_float_loop:} we run it without
%   actually trying any floats (i.e., we are just cutting the
%   galley).\footnote{Could be improved: if there are no floats then
%   we run it once too often this way (per page) so\ldots}
%    \begin{macrocode}
    \bool_gset_false:N \g_xor_trial_with_floats_bool
    \xor_trial_place_float_loop:
%<*trace>
    \trace_pop:n { xor_trial_place_float_setup: }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_trial_place_float_loop_std:}
%   This is the version of \cs{xor_trial_place_float_loop:} used normally,
%   when floats are tried one after another to obtain the final layout. There
%   is a second version used when the float placement is obtained fully or
%   partially from an fpc file.
%
%   Place the galley box back on the MVL. Needs to be done via the
%   special output routine call \cs{marks_OR_restore_state:nn} to ensure that
%   \TeX{}'s primitive marks reflect the \enquote{logical} previous page rather
%   than the previous actual output routine call.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_trial_place_float_loop_std:
  {
%<*trace>
    \trace_push:n { xor_trial_place_float_loop_std: }
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
    \int_gzero:N \tex_deadcycles:D
    \cs_gset_eq:NN \xor_floats_active_seq_if_empty_action:
      \xor_OR_best_cols_setup:
    \cs_gset_eq:NN \xor_pretests_success_action: \xor_OR_trial_grab_cols_setup:
%    \end{macrocode}
%   \cs{marks_OR_restore_state:nn} state is a special output routine those
%   only purpose is to reinitialize the state of the mark
%   mechanism. Its argument is executed at the of that OR and must
%   (!) set up a new OR else we find ourselves in trouble.
%    \begin{macrocode}
    \marks_OR_restore_state:nn
      {
%    \end{macrocode}
%    Initialising the grabbing trials means putting the saved material
%    back onto the MVL and reinitialising the here float list.
%    \begin{macrocode}
%<*trace>
        \trace:n { copying~g_xor_hold_page_box~onto~MVL }
%</trace>
        \vbox_unpack:N \g_xor_hold_page_box
%    \end{macrocode}
%   To be able to identify the end of the material for trials or for
%   cutting the galley we mark it with a special penalty.
%    \begin{macrocode}
        \xor_add_badly_guarded_penalty:N \c_xor_output_collect_penalty
      }
      {
        \seq_gset_eq:NN \g_xor_floats_here_seq \g_xor_saved_floats_here_seq
%<*trace>
        \trace:n { restoring~here~sequence }
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
        \xor_initialize_page_footins_action:
%    \end{macrocode}
%   Then we can start the actual loop: if we run with floats and this is not a
%   requested rerun (for footnotes) we go to
%   \cs{xor_trial_place_float_inner_loop:} otherwise we immediately set up the
%   grab column OR.
%    \begin{macrocode}
        \bool_if:NTF \g_xor_trial_rerun_requested_bool
          {
%<*trace>
            \trace:n {g_xor_trial_rerun_requested_bool~<-~false }
%</trace>
            \bool_gset_false:N \g_xor_trial_rerun_requested_bool
            \xor_OR_trial_grab_cols_setup:
          }
          {
	        \bool_if:NTF \g_xor_trial_with_floats_bool
	          { \xor_trial_place_float_inner_loop: }
	          { \xor_OR_trial_grab_cols_setup:     }
          }
      }
%<*trace>
    \trace_pop:n { xor_trial_place_float_loop_std: }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_trial_place_float_loop:}
%   By default we use this version:
%    \begin{macrocode}
\cs_new_eq:NN \xor_trial_place_float_loop: \xor_trial_place_float_loop_std:
%    \end{macrocode}
% \end{macro}
%
%  \begin{variable}{\g_xor_trial_rerun_requested_bool}
%   During a trial with a certain float setup a rerun may get requested, for
%   example, to change footnote placements. If so the code can set this
%   boolean to true.
%    \begin{macrocode}
\bool_new:N \g_xor_trial_rerun_requested_bool
%    \end{macrocode}
%  \end{variable}
%
% \begin{macro}{\xor_trial_place_float_inner_loop:}
%   Alternative entry into the float placement trial loop. This can
%   be used by setting \cs{xor_floats_active_seq_if_empty_action:} and
%   \cs{xor_pretests_success_action:} to different values, e.g., for trying
%   float pages without the overhead of the grab column output
%   routine, etc.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_trial_place_float_inner_loop:
  {
%<*trace>
    \trace_push:n { xor_trial_place_float_inner_loop: }
%</trace>
%    \end{macrocode}
%   If \cs{g_xor_trial_failed_bool} is true we have already tried the current
%   float before. This means we either do a retry with relaxed conditions
%   (in which case the current area to try was suitably modified beforehand)
%   or else we have just started with a new float and should try the first
%   area of \cs{g_xor_this_areas_open_clist}.
%    \begin{macrocode}
    \bool_if:NTF \g_xor_trial_failed_bool
      {
        \bool_gset_false:N \g_xor_flush_failed_bool
        \bool_gset_false:N \g_xor_trial_failed_bool
%    \end{macrocode}
%
%    \begin{macrocode}
%<*progress>
        \int_gincr:N \g_xor_trials_done_int
%</progress>
%    \end{macrocode}
%
%    \begin{macrocode}
        \xor_do_next:N \xor_try_this_area:
      }
      { \xor_do_next:N \xor_try_next_float: }
%<*trace>
    \trace_pop:n { xor_trial_place_float_inner_loop: }
%</trace>
    \xor_continue:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\g_xor_trials_done_int}
%   To gather statistics we count the number of trials per page.
%    \begin{macrocode}
%<*progress>
\int_new:N \g_xor_trials_done_int
%</progress>
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xor_floats_waiting_int}
%   To gather statistics we count the number of floats waiting to be placed.
%    \begin{macrocode}
%<*progress>
\int_new:N \g_xor_floats_waiting_int
%</progress>
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\xor_try_this_area:}
%   \cs{xor_try_this_area:} is |\cs_set_eq:NN| to the right definition before
%   it is called (either \cs{xor_try_this_area_std:} or
%   \cs{xor_try_this_area_relaxed:}) so on top-level it is defined to be an
%   error.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_try_this_area: { \ERROR }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_try_next_area:}
%   \cs{xor_try_next_area:} first updates \cs{g_xor_this_areas_open_clist} by
%   removing the first area in this list and then calls
%   \cs{xor_try_this_area:}. Thus it should never be called if
%   \cs{g_xor_this_areas_open_clist} is already empty.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_try_next_area:
  {
    \clist_gpop:NN \g_xor_this_areas_open_clist \l_xor_tmp_tl
%<*progress>
    \int_gincr:N \g_xor_trials_done_int
%</progress>
    \xor_try_this_area:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\g_xor_curr_float_box_tl}
%   Pointer to the float box that is currently under investigation.
%    \begin{macrocode}
\tl_new:N \g_xor_curr_float_box_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\xor_try_next_float:}
%   If there is still a float on the active list take it and try to
%   place it in the next open float area (which will be the same as
%   the current area after a successful trial). If there are no
%   floats left execute \cs{xor_floats_active_seq_if_empty_action:}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_try_next_float:
  {
%<*trace>
    \trace_push:n{  xor_try_next_float: }
%</trace>
    \seq_gpop_left:NNTF \g_xor_floats_active_seq \g_xor_curr_float_box_tl
      {
%<*trace>
        \trace:n { currbox:~ \g_xor_curr_float_box_tl }
%</trace>
%<*progress>
        \xor_progress:n { Float:~ \g_xor_curr_float_box_tl }
%</progress>
        \xor_extract_this_float_values:N \g_xor_curr_float_box_tl
%<*trace>
        \trace:n
          {
            g_xor_saved_this_areas_open_clist~(init):~
            \g_xor_saved_this_areas_open_clist \c_space_tl
            :=~ \g_xor_this_areas_open_clist
          }
%</trace>
        \tl_gset_eq:NN
          \g_xor_saved_this_areas_open_clist \g_xor_this_areas_open_clist
%<*progress>
        \int_gincr:N \g_xor_trials_done_int
%</progress>
        \xor_try_this_area:
      }
%    \end{macrocode}
%   no floats left\ldots
%    \begin{macrocode}
      {
%<*progress>
        \xor_progress_newline:n
          { STATS:~trials~=~ \int_use:N \g_xor_trials_done_int }
        \int_gzero:N \g_xor_trials_done_int
%</progress>
        \xor_floats_active_seq_if_empty_action:
      }
%<*trace>
    \trace_pop:n{xor_try_next_float:}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_extract_this_float_values:N}
%   This command takes a float box or a float box pointer as its
%   argument and updates all the data structures associated with it.
%    \begin{macrocode}
\cs_new_protected:Npn \xor_extract_this_float_values:N #1
  {
    \xor_extract_this_float_core_values:N #1
%    \end{macrocode}
%   If we want to consider all areas for each float (and storing
%   closed areas via \cs{g_xor_class_\meta{class}_areas_closed_clist}
%   we have to initialize \cs{g_xor_this_areas_open_clist} to
%   \cs{g_xor_areas_used_clist} (which is derived from the |area-list| key.
%   \begin{macrocode}
    \clist_gset_eq:NN \g_xor_this_areas_open_clist \g_xor_areas_used_clist
%    \end{macrocode}
%
%    \begin{macrocode}
    \clist_gset_eq:Nc
      \g_xor_this_areas_closed_clist
      { g_xor_class_ \g_xor_this_class_tl _areas_closed_clist }  % FMi tmp
%    \end{macrocode}
%
%    \begin{macrocode}
    \tl_gset_eq:NN \g_xor_this_float_box_tl \g_xor_curr_float_box_tl
%<*trace>
    \trace:n { This~float~structure: }
    \trace:n { ~{ \exp_not:V \g_xor_this_caption_tl } }
    \trace:n { ~{ \g_xor_this_span_num_tl } }
    \trace:n { ~{ \g_xor_this_label_key_tl } }
    \trace:n { ~{ \g_xor_this_display_cnt_tl } }
    \trace:n { ~{ \g_xor_this_allowed_areas_clist } }
    \trace:n { ~{ \g_xor_this_type_tl } }
    \trace:n { ~{ \int_use:N \g_xor_this_flseq_int } }
    \trace:n { ~g_xor_this_areas_open_clist~<-~ \g_xor_this_areas_open_clist }
    \trace:n
      { ~g_xor_this_areas_closed_clist~<-~ \g_xor_this_areas_closed_clist }
%</trace>
%<*progress>
    \xor_progress:n { ~{ \int_use:N \g_xor_this_flseq_int } }
    \xor_progress:n { ~{ \g_xor_this_type_tl }~( \g_xor_this_class_tl ) }
    \xor_progress:n { ~{ \g_xor_this_display_cnt_tl } }
    \xor_progress_newline:n { ~{ \exp_not:n {#1} } }
%</progress>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_extract_this_float_core_values:N}
% \begin{macro}[aux]{\xor_extract_this_float_values:nnnnnnn}
%   This command takes a float box or a float box pointer as its
%   argument and updates all the data structures associated with it.
%   To understand what is going on here, remember that at a \TeX{} level
%   each float is set up as an insert, and that these are set up to
%   reserve a number of linked registers, including a token register.
%   The register number for the insert, the associated box and the
%   associated toks are the same, and so by passing the name of the box
%   here it is possible to recover the toks information. This will work
%   even if |#1| here is a tl containing the name of the box, as \TeX{}
%   will expand until it finds an integer.
%    \begin{macrocode}
\cs_new_protected:Npn \xor_extract_this_float_core_values:N #1
  {
    \exp_after:wN \xor_extract_this_float_values:nnnnnnn
      \tex_the:D \tex_toks:D #1
  }
\cs_new_protected:Npn \xor_extract_this_float_values:nnnnnnn #1#2#3#4#5#6#7
  {
    \tl_gset:Nn \g_xor_this_caption_tl {#1}
    \tl_gset:Nn \g_xor_this_span_num_tl {#2}
    \tl_gset:Nn \g_xor_this_label_key_tl {#3}
    \tl_gset:Nn \g_xor_this_display_cnt_tl {#4}
    \clist_gset:Nn \g_xor_this_allowed_areas_clist {#5}
    \tl_gset:Nn \g_xor_this_type_tl {#6}
%    \end{macrocode}
%   From the type we infer the class:
%    \begin{macrocode}
    \tl_gset_eq:Nc \g_xor_this_class_tl { g_xor_type_ #6 _class_tl }
    \int_gset:Nn \g_xor_this_flseq_int {#7}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xor_extract_here_float_core_values:N}
% \begin{macro}[aux]{\xor_extract_here_float_values:nnnnnnn}
%   Similar to \cs{xor_extract_this_float_values:nnnnnnn} but filling different
%   macros as \enquote{here} floats are looked at while trying to place other
%   floats.
%    \begin{macrocode}
\cs_new_protected:Npn \xor_extract_here_float_core_values:N #1
  {
    \exp_after:wN \xor_extract_here_float_values:nnnnnnn
      \tex_the:D \tex_toks:D #1
  }
\cs_new_protected:Npn \xor_extract_here_float_values:nnnnnnn #1#2#3#4#5#6#7
  {
    \tl_gset:Nn \g_xor_here_caption_tl {#1}
    \tl_gset:Nn \g_xor_here_span_num_tl {#2}
    \tl_gset:Nn \g_xor_here_display_cnt_tl {#4}
    \tl_gset:Nn \g_xor_here_type_tl {#6}
    \tl_gset_eq:Nc \g_xor_here_class_tl { g_xor_type_ #6 _class_tl }
    \tl_gset:Nn \g_xor_here_flseq_tl {#7}
    \tl_gset_eq:NN \g_xor_here_float_box_tl \g_xor_curr_float_box_tl
%<*trace>
    \trace:n { Here~object~structure: }
    \trace:n { ~ { \exp_not:n {#1} } }
    \trace:n { ~ {#2} }
    \trace:n { ~ {#3} }
    \trace:n { ~ {#4} }
    \trace:n { ~ {#5} }
    \trace:n { ~ {#6} }
    \trace:n { ~ {#7} }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\g_xor_page_float_int}
%   This integer keeps track on the total number of floats added to
%   the current page.
%    \begin{macrocode}
%<*initex>
\int_new:N \g_xor_page_float_int
%</initex>
%<*package>
\cs_new_eq:NN \g_xor_page_float_int \@colnum
%</package>
%    \end{macrocode}
% \end{variable}
%
% \subsection{Grab Column Output Routine}
%
% \begin{description}
%   \item[Entry:] |\xor_OR_trial_grab_cols_setup:|
%   \item[Exit:]  |\xor_OR_cleanup_setup:N \xor_trial_place_float_loop:|
%   \item[Prereq:]
%   \item[Description:]
%   \item[Flow:]
%     \begin{footnotesize}
%\begin{verbatim}
%    \xor_OR_trial_grab_cols_setup:
%            |
%    New OR: \xor_OR_grab_trial_cols:
%            |
%    \xor_OR_trial_grab_balance_setup:  <-------
%            |
%    \xor_OR_trial_grab_next_col_setup: <-------
%            |
%    (when entering OR...)
%            |
%    <end of collection reached?>
%         |          |
%        yes        no
%         |          |
%         |     <col break requested?>
%         |          |        |
%         |         yes       no
%         |          |        |
%         |          |     <flush point encountered?>
%         |          |        |                  |
%         |          |       yes                 no
%         |          |        |                  |
%         |          | <grabbing already         |
%         |          |   balanced cols?  >       |
%         |          |        |     |            |
%         |          |        no   yes           |
%         |          |        |     |            |
%         |          |        |     |___         |
%         |          |        |         |        |
%         |          |        |         |        |
%         |          |        |         |        |
%         |          | <flush point     |   <here point encountered?>
%         |          |      too early?> |      |               |
%         |          |    |      |      |     yes              no
%         |          |   yes    no    __|      |               |
%         |          |    |      |    |        ?               ?
%         |          |    | (ignore break)
%         |          |    |      |
%         |          |    |      |
% (end column now) <-------      |
%         |                      |
%         V                      |
%   <all cols produced?>         |
%      |           |             V
%     yes          no--------------------> (reenter
%                                           \xor_OR_trial_grab_next_col_setup:)
%      |
%  <grabbing already
%     balanced cols? >
%      |         |
%      no        yes---------------------> (incr. ???
%      |                                    reenter
%                                           \xor_OR_trial_grab_balance_setup:)
%      |
% (store results of trial)
%      |
%      V
%    \xor_OR_cleanup_setup:N \xor_trial_place_float_loop:
%\end{verbatim}
%     \end{footnotesize}
% \end{description}
%
%  \begin{macro}{\xor_OR_trial_grab_cols_setup:}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_OR_trial_grab_cols_setup:
  {
%<*trace>
    \trace_push:n { xor_OR_trial_grab_cols_setup: }
%</trace>
%    \end{macrocode}
%   We just returned to the MVL the current galley. At its end we
%   have added the special penalty \cs{c_xor_output_collect_penalty} to mark
%   the point that we need to reach in order to remove everything
%   after the trial run.
%    \begin{macrocode}
    \bool_gset_false:N \g_xor_trial_failed_bool
%    \end{macrocode}
%   Moved from \cs{xor_try_this_area:} as it should be executed
%   only if we really do a trial and thus back it out if
%   unsuccessful -- this was a bug as it changed
%   \cs{g_xor_flseq_type_\meta{type}_col_\meta{col}_int} in cases
%   we never came to this point here but recoursed).
%    \begin{macrocode}
    \bool_if:NT \g_xor_trial_with_floats_bool
      {
%    \end{macrocode}
%   Depending on the policy a spanning float can be considered belong
%   to different columns. This influences the behaviour of the
%   call-out constraint tests and is determined by the code stored in
%   \cs{xor_calculate_float_col:}, which returns its calculated column
%   number in \cs{l_xor_returned_float_col_int}.
%    \begin{macrocode}
        \xor_calculate_float_col:
        \int_gset_eq:Nc
          \g_xor_saved_flseq_int
          {
            g_xor_flseq_type_ \g_xor_this_class_tl _col_
            \int_use:N \l_xor_returned_float_col_int _int
          }
        \int_gset_eq:cN
          {
            g_xor_flseq_type_ \g_xor_this_class_tl _col_
            \int_use:N \l_xor_returned_float_col_int _int
          }
          \g_xor_this_flseq_int
%<*trace>
        \trace:n
          {
            \c_space_tl
            g_xor_flseq_type_ \g_xor_this_class_tl _col_
            \int_use:N \l_xor_returned_float_col_int _int \c_space_tl <-~
            \int_use:N \g_xor_this_flseq_int % As it is equal at this point
          }
%</trace>
%    \end{macrocode}
%   If we are adding to a top area we also have to update the
%   corresponding \cs{g_xor_flseq_areas_top_type_\ldots} commands:
%    \begin{macrocode}
        \xor_if_this_area_type:NT t
          {
            \int_gset_eq:Nc
              \g_xor_saved_flseq_top_areas_int
              {
                g_xor_flseq_areas_top_type_ \g_xor_this_class_tl _col_
                \int_use:N \l_xor_returned_float_col_int _int
              }
            \int_gset_eq:cN
              {
                g_xor_flseq_areas_top_type_ \g_xor_this_class_tl _col_
                \int_use:N \l_xor_returned_float_col_int _int
              }
              \g_xor_this_flseq_int
%<*trace>
            \trace:n
              {
                \c_space_tl
                g_xor_flseq_areas_top_type_ \g_xor_this_class_tl _col_
                \int_use:N \l_xor_returned_float_col_int _int 
                \c_space_tl <-~
                \int_use:N \g_xor_this_flseq_int % As it is equal at this point
              }
%</trace>
          }
      }
%    \end{macrocode}
%    If we have seen any flush points during collection we need to
%    save their current |min_col| positions in case we have to throw
%    away the current trial.
%    \begin{macrocode}
    \bool_if:NT \g_xor_flush_seen_bool
      {
        \int_zero:N \l_xor_loop_int
        \int_while_do:nNnn \g_xor_collect_flush_seen_int > \l_xor_loop_int
          {
            \int_incr:N \l_xor_loop_int
            \int_gset_eq:cc
              { g_xor_saved_flush_ \int_use:N \l_xor_loop_int _min_col_int }
              { g_xor_flush_       \int_use:N \l_xor_loop_int _min_col_int }
%<*trace>
            \trace:n
              {
                g_xor_saved_flush_ \int_use:N \l_xor_loop_int _min_col_int 
                \c_space_tl <-~
                \int_use:c
                  { g_xor_flush_ \int_use:N \l_xor_loop_int _min_col_int }
              }
%</trace>
          }
      }
    \xor_save_col_hts:N \g_xor_saved_trial_col_hts_tl
%    \end{macrocode}
%
%    \begin{macrocode}
    \xor_OR_trial_grab_balance_setup:
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
    \trace_pop:n { xor_OR_trial_grab_cols_setup: }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_calculate_float_col:,
%               \xor_calculate_float_col_flexible:,
%               \xor_calculate_float_col_strict:}
% \begin{variable}{\l_xor_returned_float_col_int}
%   The purpose of \cs{xor_calculate_float_col:} is to decide the
%   column number for which the
%   |\fl@|\meta{col}|@number|\footnote{somehow this part lists old
%      code conventions ... need to check how the fl sequences/numbers are now
%      named} 
%   has to be updated in case we place the current float into
%   the area with start column \cs{g_xor_this_area_col_tl} and
%   span-number \cs{g_xor_this_area_span_tl}.\footnote{I don't follow
%   this: Frank, any clues?}  It returns the calculated number in
%   \cs{l_xor_returned_float_col_int}.
%
%   For non-spanning floats it is simply returning
%   \cs{g_xor_this_area_col_tl}. If we return this value also in case of
%   spanning floats then this means that we claim that the float has
%   be placed the first of its spanned columns. Alternatively we
%   could return the last of the spanned columns which would if the
%   |column| policy is in force, allow to place a float into |t12|
%   even if its call-out is in the second column.
%
%   The real value for \cs{xor_calculate_float_col:} will be assigned
%   in the page setup template.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_calculate_float_col: { \ERROR }
%    \end{macrocode}
%   And here are the two possibilities.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_calculate_float_col_flexible:
  {
    \int_set:Nn \l_xor_returned_float_col_int
      { \g_xor_this_area_col_tl + \g_xor_this_area_span_tl - \c_one }
  }
\cs_new_nopar:Npn \xor_calculate_float_col_strict:
  { \int_set:Nn \l_xor_returned_float_col_int \g_xor_this_area_col_tl }
\int_new:N \l_xor_returned_float_col_int
%    \end{macrocode}
%  \end{variable}
% \end{macro}
%
% \begin{macro}{\xor_OR_trial_grab_next_col_setup:}
%   The \cs{xor_OR_grab_trial_cols:} output routine is responsible for
%   constructing one column of a layout trial.  The loop command
%   increments the column count and sets vsize to the target height
%   for the current column (which has already been set based on the
%   size and position of the floats in this trial layout.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_OR_trial_grab_next_col_setup:
  {
%<*trace>
    \trace_push:n { xor_OR_trial_grab_next_col_setup: }
%</trace>
    \int_gincr:N \g_xor_curr_col_int
    \int_gset_eq:NN \g_xor_curr_col_block_int \c_one
    \dim_gset_eq:Nc \tex_vsize:D { g_xor_ht_col_ \xor_curr_col_block: _dim }
    \xor_initialize_column_footins_action:
%<*trace>
    \xor_if_grab_for_balance_done:T
      { \trace:n { BALANCE:~delta~ignored } }
%</trace>
%    \end{macrocode}
%   Calculate the real reduction to use in the current column (depends on the
%   bottom float situation) and subtract it from \tn{vsize}.
%    \begin{macrocode}
    \xor_if_grab_for_balance_done:F
      {
        \xor_calculate_delta_to_use:N \l_xor_tmp_dim
        \dim_gsub:Nn \tex_vsize:D \l_xor_tmp_dim
      }
%<*trace>
    \trace:n { vsize~setup~=~ \dim_use:N \tex_vsize:D }
%</trace>
%    \end{macrocode}
%    tmp\footnote{fix implement differently}
%    \begin{macrocode}
    \dim_compare:nNnF \tex_vsize:D > \tex_baselineskip:D
      { \ignorethiscolumn  }
%<*trace>
    \trace_pop:n { xor_OR_trial_grab_next_col_setup: }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ignorethiscolumn}
%    This command is a placeholder for changing the algorithm (don't
%    even want a real name for now). So please keep it for now.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \ignorethiscolumn
  {
%    \end{macrocode}
%    If we reach this, the algorithm should change behavior (\ldots one day)
%    \begin{macrocode}
% ? FRANK ?
    \__msg_kernel_warning:nn { output } { out-of-space }
    \par
    \hbox:n { }
    \tex_penalty:D \c_xor_output_nospace_penalty
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_calculate_delta_to_use:N}
%    The \cs{g_xor_balance_delta_dim} value during balancing is a nominal
%    one. It is only used on a column if the column doesn't have any bottom
%    floats. If it does then the actual value used is the difference between
%    \cs{g_xor_balance_delta_dim} and the amount taken up by the bottom floats
%    in that column or zero if that difference is negative.
%
%    This is calculated in the following macro and the result is returned in
%    the local variable specified in its argument. This can then be further
%    used to reduce the \tn{vsize} for cutting, etc.
%    \begin{macrocode}
\cs_new_protected:Npn \xor_calculate_delta_to_use:N #1
  {
%<*trace>
    \trace:n { BALANCE:~delta~=~ \dim_use:N \g_xor_balance_delta_dim }
%</trace>
    \dim_set:Nn #1
      {
        \g_xor_balance_delta_dim
        -
        \dim_use:c
          { g_xor_bottom_ht_col_ \int_use:N \g_xor_curr_col_int _ dim }
      }
%<*trace>
    \dim_compare:nNnTF  #1 > \c_zero_dim
      {
        \trace:n
          {
            BALANCE:~reduction~used~on~col~
            \int_use:N \g_xor_curr_col_int \c_space_tl =~ \dim_use:N #1
          }
      }
      {
        \trace:n
          {
            BALANCE:~no~reduction~used~on~col~
            \int_use:N \g_xor_curr_col_int \c_space_tl =~
            \dim_use:N #1 \c_space_tl !>~ 0pt
          }
      }
%</trace>
%    \end{macrocode}
%    Set |#1| to be at least $0$\,pt in all cases, as negative values do
%    not make sense.
%    \begin{macrocode}
    \dim_set:Nn #1 { \dim_max:nn {#1} { \c_zero_dim } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_OR_grab_some_cols:nnnnn}
%    \cs{xor_OR_grab_trial_cols:} and \cs{xor_OR_grab_best_cols:} are sharing
%    most of their code which is therefore placed into a separate macro. At the
%    moment it takes~5 arguments: the name (\enquote{grab} or \enquote{best}),
%    what to do when we actually finish the column
%    (\enquote{\cs{xor_OR_trial_finish_col:}} or
%    \enquote{\cs{xor_OR_best_finish_col:}}), what to do for a flush point, what
%    to do when we encounter a \enquote{here} float, and finally what to do if
%    we encounter a balancing point.
%
% \footnote{This code needs a bit of redesign to deal
%    properly with the case that we have stumbled upon one of the
%    special penalties. In this case we need to ensure that we also
%    remove the special box after the penalty in case we are at a
%    column break. This is not done right now so that in this case we
%    will not discard material at the top of the column properly. FIX!!!!}
%    \begin{macrocode}
\cs_new_protected:Npn \xor_OR_grab_some_cols:nnnnn #1#2#3#4#5
  {
%<*trace>
    \trace_push:n { xor_OR_grab_some_cols:~( #1 ) }
    \trace:n { output~pen:~ \int_use:N \tex_outputpenalty:D }
    \trace:n
      {
        #1 ~col:~ \int_use:N \g_xor_curr_col_int \c_space_tl 
        of~ \int_use:N \g_xor_cols_int
      }
    \trace:n
      {
        vsize:~ \int_use:N \tex_vsize:D ;~
        pagegoal:~ \int_use:N \tex_pagegoal:D
      }
%</trace>
    \int_compare:nNnTF
      \tex_outputpenalty:D = \c_xor_output_collect_penalty
      {
        \xor_handle_premature_ending:
        #2
      }
      {
        \int_compare:nNnTF \tex_outputpenalty:D = { -\c_ten_thousand }
          {
            \xor_handle_forced_pagebreak:
            #2
          }
%    \end{macrocode}
%
%    \begin{macrocode}
          {
            \int_compare:nNnTF
              \tex_outputpenalty:D = \c_xor_output_balance_penalty
              {
                #5 {#2}
                % ? FRANK ? Why the forced error here - shouldn't this be down
                % to #5 (if needed)?
                \ERRORxxx
              }
%    \end{macrocode}
%    If the \tn{outputpenalty} is |\c_xor_output_flush_float_penalty| we
%    have reached a float flush point in the galley.
%    \begin{macrocode}
              {
                \int_compare:nNnTF
                  \tex_outputpenalty:D = \c_xor_output_flush_float_penalty
                  { \xor_handle_flush:nn {#2} {#3} }
%    \end{macrocode}
%    If it was not a flush point we might have a \enquote{here} point to take
%    care of. This is more or less like the code above.
%    \begin{macrocode}
                  {
                    \int_compare:nNnTF
                      \tex_outputpenalty:D
                        = \c_xor_output_here_float_penalty
                      { \xor_handle_here:nn {#2} {#4} }
%    \end{macrocode}
%    If it is neither a flush nor a here point it might be a grid point:
%    \begin{macrocode}
                      {
                        \int_compare:nNnTF
                          \tex_outputpenalty:D
                            = \c_xor_output_grid_align_penalty
                          { \xor_align_collected_galley_and_restart: }
%    \end{macrocode}
%    If we see a column break then this is like having a natural end (right
%    now). The reason that this case is differentiated is that at some point we
%    may like to allow guided column breaks which are taken or not taken
%    depending on the fill situation of the column.\footnote{Extend code one
%    day.}
%    \begin{macrocode}
                          {
                            \int_compare:nNnTF
                              \tex_outputpenalty:D
                                = \c_xor_output_columnbreak_penalty
                              { #2 }
%    \end{macrocode}
%    So we now know that it wasn't one of our special points so this
%    must have been a normal end of the galley.
%    However we might be balancing columns and in that case we have to ensure
%    that we reach the balancing point again.
%    \begin{macrocode}
                              {
                                \int_compare:nNnTF
                                  \g_xor_curr_col_int = \g_xor_cols_int
                                  {
                                    \bool_if:NTF
                                      \g_xor_balance_point_expected_bool
                                      { \ERRORlostbalancepoint }
                                      { #2 }
                                  }
                                  { #2 }
                              }
                          }
                      }
                  }
              }
          }
      }
%<*trace>
    \trace_pop:n { xor_OR_grab_some_cols:~( #1 ) }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ERRORlostbalancepoint}
%    ? FRANK ? Is this really an error, and if so should there not be a
%    message. On the other hand, if it's not an error then a better name
%    seems to be needed.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \ERRORlostbalancepoint
  {
    \dim_gset:Nn \g_xor_balance_delta_dim \g_xor_saved_balance_delta_dim
    \bool_gset_true:N \g_xor_balance_finish_bool
    \box_gclear:N \c_two_hundred_fifty_five
    \box_gclear:N \g_xor_footins_box
    \xor_OR_cleanup_setup:N \xor_trial_get_balance_loop:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_handle_here:nn}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xor_handle_here:nn #1#2
  {
    \int_gincr:N \g_xor_trial_here_seen_int
%<*trace>
    \trace:n { here~penalty~( \int_use:N \g_xor_trial_here_seen_int )~reached }
%</trace>
    \xor_remove_guard_box_from_cclv:
    \int_compare:nNnTF
      {
        \int_use:c
          { g_xor_here_ \int_use:N \g_xor_trial_here_seen_int  _min_col_int }
      }
        > \g_xor_curr_col_int
      {
%<*trace>
        \trace:n
          {
            g_xor_here_ \int_use:N \g_xor_trial_here_seen_int _min_col_int
            \c_space_tl >~g_xor_curr_col_int~(
            \int_use:c
              {
                g_xor_here_ \int_use:N \g_xor_trial_here_seen_int _min_col_int
              }
            \c_space_tl >~ \int_use:N \g_xor_curr_col_int )~->~ending~column
          }
%</trace>
        \xor_split_off_last_line_from_clvv:
        \int_gdecr:N \g_xor_trial_here_seen_int
        \xor_readd_guarded_penalty:n \c_xor_output_here_float_penalty
        #1
      }
      {
        \dim_set:Nn \l_xor_tmp_dim { \tex_pagegoal:D - \tex_pagetotal:D }
        \dim_compare:nNnTF
          \l_xor_tmp_dim < 
            {
              \tl_use:c
                {
                  g_xor_here_ \int_use:N \g_xor_trial_here_seen_int
                  _required_space_tl
                }
            }
          {
%<*trace>
            \trace:n
              {
                g_xor_here_ \int_use:N \g_xor_trial_here_seen_int
                _required_space_tl \c_space_tl >~
                \pagegoal - \pagetotal \c_space_tl (
                \tl_use:c
                  {
                    g_xor_here_ \int_use:N \g_xor_trial_here_seen_int
                    _required_space_tl
                  }
                \c_space_tl >~ \dim_use:N \tex_pagegoal:D \c_space_tl
                -~ \dim_use:N \tex_pagetotal:D \c_space_tl =~
                \dim_use:N \l_xor_tmp_dim )~->~ ending~ column
              }
%</trace>
            \xor_split_off_last_line_from_clvv:
            \int_gdecr:N \g_xor_trial_here_seen_int
            \xor_readd_guarded_penalty:n \c_xor_output_here_float_penalty
            #1
          }
          {
%<*trace>
            \trace:n
              {
                g_xor_here_ \int_use:N \g_xor_trial_here_seen_int
                _required_space_tl \c_space_tl <=~
                \pagegoal - \pagetotal \c_space_tl (
                \tl_use:c
                  {
                    g_xor_here_ \int_use:N \g_xor_trial_here_seen_int
                    _required_space_tl
                  }
                \c_space_tl <=~ \dim_use:N \tex_pagegoal:D \c_space_tl
                -~ \dim_use:N \tex_pagetotal:D \c_space_tl =~
                \dim_use:N \l_xor_tmp_dim )~
                ->~ accepting~ here~ point
              }
%</trace>
            \xor_reinsert_inserts:
            \vbox_unpack_clear:N\c_two_hundred_fifty_five
            \seq_gpop_left:NNTF \g_xor_floats_here_seq \g_xor_curr_float_box_tl
              {
%<*trace>
                \trace:n { @currbox:~ \g_xor_curr_float_box_tl }
%</trace>
                \xor_extract_here_float_core_values:N \g_xor_curr_float_box_tl
%    \end{macrocode}
%    Different things need to be done depending on the type of the
%    here point:
%    \begin{macrocode}
                \str_if_eq:nVTF { mpar } \g_xor_here_type_tl
                  { \xor_typeset_a_marginpar: }
                  {
                    \str_if_eq:nVF { rspace } \g_xor_here_type_tl
                      { #2 }
                  }
              }
%    \end{macrocode}
%    If there is no here object left the algorithm has screwed up
%    (i.e., a \enquote{this can't happen} situation).
%    \begin{macrocode}
            { \ERRORhereobjectmissing }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\xor_reinsert_inserts:}
%    For reinserting the inserts.
%    
%    ? FRANK ? Any idea what is the correct code here in format mode?
%    I assume that \cs{footins} and \cs{@kludgeins} live on in some form?
%    \begin{macrocode}
%<*initex>
\cs_new_protected_nopar:Npn \xor_reinsert_inserts:
  {
    \ERROR 
  }
%</initex>
%<*package>
\cs_new_eq:NN \xor_reinsert_inserts: \@reinserts
%</package>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_handle_flush:nn}
%    \begin{macrocode}
\cs_new_protected:Npn \xor_handle_flush:nn #1#2 
  {
    \int_gincr:N \g_xor_trial_flush_seen_int
%<*trace>
    \trace:n
      {
        flush~point~( \int_use:N \g_xor_trial_flush_seen_int ,~affects:~
        \clist_use:c
          { g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int _classes_clist }
        ,~mincol:~\int_use:c
          { g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int _min_col_int }
        ,~lastfloat:~ \int_use:c
          { g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int _last_float_int }
        )~ reached
      }
%</trace>
%    \end{macrocode}
%    We then remove the guard box from the output (which is at the end
%    of box \cs{c_two_hundred_fifty_five}.
%    \begin{macrocode}
    \xor_remove_guard_box_from_cclv:
%    \end{macrocode}
%    If the flush penalty moved to an earlier column than in the last trial we
%    end the current column (by calling cs{xor_OR_trial_finish_col:} or
%    \cs{xor_OR_best_finish_col:}) and reinsert the penalty so that it will be
%    seen again if we do the next column.
%    \begin{macrocode}
    \int_compare:nNnTF
      {
        \int_use:c
          { g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int _min_col_int }
      }
      > \g_xor_curr_col_int
      {
%<*trace>
        \trace:n
          {
            g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int _min_col_int
            \c_space_tl >~g_xor_curr_col_int~(
            \int_use:c
              { g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int _min_col_int }
            \c_space_tl >~ \int_use:N \g_xor_curr_col_int )~->~ending~column
          }
%</trace>
        \int_gdecr:N \g_xor_trial_flush_seen_int
        \xor_readd_guarded_penalty:n \c_xor_output_flush_float_penalty
         #1
      }
%    \end{macrocode}
%    Otherwise the flush point is in an acceptable position which means we
%    ignore it and carry on collecting material for the current column. This is
%    done be putting everything back onto the MVL except the guard box and the
%    penalty. We lose a potential break point here, see comments in
%    \cs{xor_OR_grab_best_cols:}!!\footnote{acceptable?}
%    \begin{macrocode}
      {
%<*trace>
        \trace:n
          {
            g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int _min_col_int ~
            <=~g_xor_curr_col_int~(
            \int_use:c
              {
                g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int
                _min_col_int
              }
            \c_space_tl <=~\int_use:N \g_xor_curr_col_int )
          }
%</trace>
%    \end{macrocode}
%    What exactly happens here (beside the above) depends on the
%    calling macro.
%    \begin{macrocode}
        #2
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_OR_grab_trial_cols:}
%    Here is the output routine used during trials, an instantiation
%    of \cs{xor_OR_grab_some_cols:nnnn}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_OR_grab_trial_cols:
  {
    \xor_OR_grab_some_cols:nnnnn
      { grab }
      \xor_OR_trial_finish_col:
      \xor_OR_trial_check_flush:
      \xor_check_and_typeset_a_here_float:
      \xor_OR_trial_balance:NN
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_OR_trial_check_flush:}
%    The \cs{xor_OR_trial_check_flush:} code checks for restrictions
%    regarding the placement of the current float. It is called when
%    we just have encountered a flush float penalty while grabbing the
%    text for a column and now have to see which floats (if any) need
%    to be positioned before that flush point.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_OR_trial_check_flush:
  {
%<*trace>
    \trace_push:n { xor_OR_trial_check_flush: }
%</trace>
%    \end{macrocode}
%    If we are making a dry-run without floats then there is no need to
%    do much, so we skip all testing that involves flush points and
%    only do the cleanup actions at the end.
%    \begin{macrocode}
    \bool_if:NT \g_xor_trial_with_floats_bool
      {
        \clist_if_in:coT
          { g_xor_flush_\int_use:N \g_xor_trial_flush_seen_int _classes_clist }
          \g_xor_this_class_tl
          {
%<*trace>
            \trace:n
              {
                flush:~class~ \g_xor_this_class_tl \c_space_tl in~
                {
                  \clist_use:c
                    {
                      g_xor_flush_
                      \int_use:N \g_xor_trial_flush_seen_int _classes_clist
                    }
                }
              }
%</trace>
%    \end{macrocode}
%    We store in \cs{l_xor_tmp_int} the float sequence number of the last float
%    that would be affected by the current flush penalty, to avoid multiple
%    csname expansions and to keep the tests a little clearer.
%    \begin{macrocode}
            \int_set_eq:Nc \l_xor_tmp_int
              {
                g_xor_flush_
                \int_use:N \g_xor_trial_flush_seen_int _last_float_int
              }
%    \end{macrocode}
%    If the current float number is higher than float number stored in
%    \cs{g_xor_flush_\meta{num}_last_float_int} with the flush penalty, we are
%    dealing with a float whose call-out is after the flush penalty and thus we
%    have no restriction.
%    \begin{macrocode}
%<*trace>
            \int_compare:nNnT \g_xor_this_flseq_int > \l_xor_tmp_int
              {
                \trace:n
                  {
                    ???:
                    \int_use:N \g_xor_this_flseq_int >
                    \int_use:N \l_xor_tmp_int
                  }
                \trace:n { this~float~past~flush~point }
              }
%</trace>
%    \end{macrocode}
%    Otherwise check if this float is placed in an acceptable position
%    with respect to the current flush point. For this we run
%    different code depending on the \enquote{fuzziness} of the flush point
%    under check:
%    \begin{macrocode}
            \int_compare:nNnF \g_xor_this_flseq_int > \l_xor_tmp_int
              {
                \use:c
                 {
                   xor_flush_fuzziness_action_
                   \int_use:N \g_xor_trial_flush_seen_int :
                 }
              }
          }
%<*trace>
        \clist_if_in:coF
          { g_xor_flush_\int_use:N \g_xor_trial_flush_seen_int _classes_clist }
          \g_xor_this_class_tl
          {
            \trace:n
              {
                flush:~class~ \g_xor_this_class_tl \c_space_tl not~in~
                {
                  \clist_use:c
                    {
                      g_xor_flush_
                      \int_use:N \g_xor_trial_flush_seen_int _classes_clist
                    }
                }
              }
          }
%</trace>
      }
%    \end{macrocode}
%    If we failed above we additionally record that the failure is
%    due to violating restrictions for a flush point.
%    \begin{macrocode}
    \bool_if:NTF \g_xor_trial_failed_bool
      {
        \bool_gset_true:N \g_xor_flush_failed_bool
%    \end{macrocode}
%
%    \begin{macrocode}
        \box_gclear:N \c_two_hundred_fifty_five
        \box_gclear:N \g_xor_footins_box
%    \end{macrocode}
%    We have to immediately abort the current trial otherwise a
%    flush point following in the galley might be encountered and
%    processed before we reach \cs{xor_evaluate_trial_results:}. That
%    would result in updating the wrong data structure there (due to
%    the fact that there it assumes that \cs{g_xor_trial_flush_seen_int}
%    refers to the flush point that is the reason for
%    failure).\footnote{Implementation could be improved!}
%    \begin{macrocode}
        \int_gset_eq:NN \g_xor_curr_col_int \g_xor_cols_int
%% need \g_xor_curr_col_block_intsetting?
        \xor_OR_trial_finish_col:
      }
%    \end{macrocode}
%    If we haven't failed we might have to update the
%    \cs{g_xor_flush_\meta{num}_min_col_int} for the current flush point in
%    case it moved to a new column.
%    \begin{macrocode}
      {
        \int_compare:nNnT
          {
            \int_use:c
              {
                g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int 
                _min_col_int
              }
          }
          < \g_xor_curr_col_int
          {
            \int_gset_eq:cN
              {
                g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int
                _min_col_int
              }
              \g_xor_curr_col_int
%<*trace>
            \trace:n
              {
                set~ g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int
                _min_col_int :~
                \int_use:c
                  {
                    g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int
                    _min_col_int
                  }
              }
%</trace>
          }
%    \end{macrocode}
%    We have to return the collected footnotes first or else \TeX{}
%    might decide that it is better to break before
%    them.\footnote{Quite likely that this needs some refinement as it
%    might mess up vertical spacing in other respects. Look out for
%    other places where \cs{@reinserts} is used, if this needs fixing.}
%    \begin{macrocode}
%<*initex>
%%      Something else in format mode?
        \ERROR
%</initex>
%<*package>
        \@reinserts
%</package>
        \vbox_unpack_clear:N \c_two_hundred_fifty_five
%    \end{macrocode}
%    What penalty to return???\footnote{FIX!!!}
%    \begin{macrocode}
%<*unused>
        \tex_penalty:D \c_zero % What to actually use here?
%</unused>
      }
%<*trace>
    \trace_pop:n { xor_OR_trial_check_flush: }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_check_flush_page:}
%    This seems to be redundant !!FRANK!! Any clue on this?
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_check_flush_page:
  {
%<*trace>
    \trace:n { OK:~flush~check~(same~page) }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_check_flush_spread:}
%    This is actually a dummy definition. There is more to do if we
%    want to provide support for spreads!\footnote{Finish implementation}
%    This seems to be redundant !!FRANK!! Any clue on this?
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_check_flush_spread:
  {
%<*trace>
    \trace:n { OK:~flush~check~(using~page~not~spread) }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_check_flush_strict:}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_check_flush_strict:
  {
%<*trace>
    \trace_push:n { xor_check_flush_strict: }
%</trace>
%    \end{macrocode}
%    If strict flushing is required we look where the current float is
%    being placed. If it
%    is placed in a column which is earlier than the current column
%    then it is definitely before the flush point and thus we are okay.
%    \begin{macrocode}
%<*trace>
    \int_compare:nNnTF \g_xor_this_area_col_tl < \g_xor_curr_col_int
%</trace>
%<*!trace>
    \int_compare:nNnF \g_xor_this_area_col_tl < \g_xor_curr_col_int
%</!trace>
%<*trace>
      {
        \trace:n
          {
            OK:~flush~check~( \g_xor_this_area_col_tl <
            \int_use:N \g_xor_curr_col_int ,~\g_xor_this_area_name_tl )
          }
      }
%</trace>
%    \end{macrocode}
%    Otherwise we test if the float is placed into the current
%    column. If this is the case it might be okay, but only if it is
%    not placed into the bottom area.
%    \begin{macrocode}
      {
        \int_compare:nNnTF \g_xor_this_area_col_tl = \g_xor_curr_col_int
          {
%    \end{macrocode}
%    To test for the bottom area(s) means looking at the first token
%    in the area identifier. If it is \texttt{b} we are past the flush
%    point.\footnote{It might be an interesting extension to allow
%    relaxing the flush situation to allow the floats to appear
%    anywhere on the current column (on which the flush point ends up),
%    or even allowing that it only has to appear on the current page
%    or page spread.}
%    \begin{macrocode}
%<*trace>
            \xor_if_this_area_type:NTF b
%</trace>
%<*!trace>
            \xor_if_this_area_type:NT b
%</!trace>
              {
                \bool_gset_true:N \g_xor_trial_failed_bool
%<*progress>
                \xor_progress_failed:n
                  {
                    area~below~flush~point~( \g_xor_this_area_col_tl =
                    \int_use:N \g_xor_curr_col_int ,~
                    \g_xor_this_area_name_tl )
                  }
%</progress>
%<*trace>
                \trace:n
                  {
                    Fail:~flush~check~( \g_xor_this_area_col_tl =
                    \int_use:N \g_xor_curr_col_int ,~
                    \g_xor_this_area_name_tl )
                  }
%</trace>
              }
%    \end{macrocode}
%    Otherwise the float was placed into an area that is still before
%    the flush point (code only used during tracing).
%    \begin{macrocode}
%<*trace>
              {
                \trace:n
                  {
                    OK:~flush~check~( \g_xor_this_area_col_tl =
                    \int_use:N \g_xor_curr_col_int ,~
                    \g_xor_this_area_name_tl )
                  }
              }
%</trace>
          }
%    \end{macrocode}
%    If the float was neither placed before nor into the current
%    column we have to conclude that it was placed into a later column
%    which means it was placed after the flush point --- thus we fail.
%    \begin{macrocode}
          {
            \bool_gset_true:N \g_xor_trial_failed_bool
%<*progress>
            \xor_progress_failed:n
              {
                area~after~flush~point~( \g_xor_this_area_col_tl >
                \int_use:N \g_xor_curr_col_int ,~
                \g_xor_this_area_name_tl )
              }
%</progress>
%<*trace>
            \trace:n
              {
                Fail:~flush~check~( \g_xor_this_area_col_tl >
                \int_use:N \g_xor_curr_col_int ,~
                \g_xor_this_area_name_tl )
              }
%</trace>
          }
      }
%<*trace>
    \trace_pop:n { xor_check_flush_strict: }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_check_flush_column:}
%    Check whether the column associated with the currently selected
%    area is after the current column and if so declare this trial a failure.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_check_flush_column:
  {
%<*trace>
    \int_compare:nNnTF \g_xor_this_area_col_tl > \g_xor_curr_col_int
%</trace>
%<*!trace>
    \int_compare:nNnT \g_xor_this_area_col_tl > \g_xor_curr_col_int
%</!trace>
      {
        \bool_gset_true:N \g_xor_trial_failed_bool
%<*progress>
        \xor_progress_failed:n
          {
            area~after~flush~point~column~
           ( \g_xor_this_area_col_tl > \int_use:N \g_xor_curr_col_int ,
            ~ \g_xor_this_area_name_tl )
         }
%</progress>
%<*trace>
        \trace:n
          {
            Fail:~flush~check~
            ( \g_xor_this_area_col_tl > \int_use:N \g_xor_curr_col_int ,
            ~ \g_xor_this_area_name_tl )
          }
      }
      {
        \trace:n
          {
            OK:~flush~check~
           ( \g_xor_this_area_col_tl <= \int_use:N \g_xor_curr_col_int ,
            ~ \g_xor_this_area_name_tl )
          }
%</trace>
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_OR_trial_finish_col:}
%    Finish off the current trial column, doing some final checks to
%    see if this trial might be a good one, and then prepare to get
%    the next column, or, if this was the last one, do a final cleanup.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_OR_trial_finish_col:
  {
%<*trace>
    \trace_push:n { xor_OR_trial_finish_col: }
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
    \marks_update_structure:
%    \end{macrocode}
%
%    \begin{macrocode}
    \xor_column_end_footins_action:
%    \end{macrocode}
%    First check if there are some special constraints that should be
%    met (this is, for example, used to check if there are both bottom
%    floats and footnotes). If the constraints are not met don't
%    bother to check the callout/float constraints.
%
%    Especially while doing balancing and not having reached the final
%    balanced solution, no tests should be made since they would fail the
%    trial!\footnote{this now disables the checks even on last run! fix!}
%    \begin{macrocode}
%<*trace>
    \bool_if:NTF \g_xor_balance_point_expected_bool
%</trace>
%<*!trace>
    \bool_if:NF \g_xor_balance_point_expected_bool
%</!trace>
%<*trace>
      { \trace:n { BALANCE:~skipping~tests~while~balancing } }
%</trace>
      {
        \bool_if:NF \g_xor_trial_failed_bool
          {
            \bool_if:NT \g_xor_trial_with_floats_bool
              {
                \xor_check_float_constraints:
%    \end{macrocode}
%    If we haven't failed already, then  for each float sequence class, call
%    \cs{xor_check_callout_constraints:n} this will be set via a call to a
%    page setup template to do an appropriate check on the float placement
%    relative to float call-out.
%    \begin{macrocode}
                \bool_if:NF \g_xor_trial_failed_bool
                  {
                    \seq_map_function:NN \g_xor_float_classes_seq  
                      \xor_check_callout_constraints:n
                  }
              }
          }
      }
%    \end{macrocode}
%    Throw the text away (it will be reset later if this trial is
%    in fact chosen).
%    \begin{macrocode}
    \box_gclear:N \c_two_hundred_fifty_five
    \box_gclear:N \g_xor_footins_box
%    \end{macrocode}
%    After the last column we evaluate the results of the trial (and
%    if the result looks OK remember it as a candidate for the final
%    solution). We then switch to the \eqnuote{clean up} OR which will
%    collect up the main vertical list as far as the special penalty
%    marking the end of the collection pass, to clear the MVL for the
%    next trial.  If this isn't the last column, set up the next
%    column.
%    \begin{macrocode}
    \int_compare:nNnTF \g_xor_curr_col_int = \g_xor_cols_int
      {
        \xor_evaluate_trial_results:
        \xor_OR_cleanup_setup:N \xor_trial_place_float_loop:
      }
      { \xor_OR_trial_grab_next_col_setup: }
%<*trace>
    \trace_pop:n{xor_OR_trial_finish_col:}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_handle_premature_ending:}
%    This case needs rethinking: what is the best
%    approach if we hit the penalty which denotes the end of the
%    collected galley too early, e.g., in the middle of a trial using
%    \cd{xor_OR_grab_trial_cols:} or when producing the final columns with
%    \cs{xor_OR_grab_best_cols:}?
%
%    Originally I simply reinserted the collection ending penalty to the main
%    vertical list. The idea was that it would then be seen by later columns
%    again and thus slowly but steadily output all remaining columns.
%    However, the catch was that some parts of the column processing my
%    reinsert stuff themselves, e.g., footnotes. Those would then show up
%    \emph{after} the collection penalty and thus would generate another page
%    and worse.
%
%    So the new approach is to simply record the fact using a boolean and
%    reinserting the penalty only after we have finished dealing with the
%    current column --- hope this is better now.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_handle_premature_ending:
  {
%<*trace>
    \trace:n { CHECK~Handle~premature~ending }
%</trace>
    \xor_remove_guard_box_from_cclv:
    \bool_gset_true:N \g_xor_premature_ending_seen_bool
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\g_xor_premature_ending_seen_bool}
%    Have we seen the collection end while cutting material for a trial or for
%    the final page?
%    \begin{macrocode}
\bool_new:N \g_xor_premature_ending_seen_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\xor_check_float_constraints:}
%    In \cs{xor_OR_grab_trial_cols:} (when the output routine that grabs a
%    single column during a trial) we have the command
%    \cs{xor_check_float_constraints:} which allows to check some constraints
%    and if they aren't met is supposed to set the boolean
%    \cs{g_xor_trial_failed_bool} to true.
%
%    By default there are no additional constraints to check for.
%    \begin{macrocode}
\cs_new_eq:NN \xor_check_float_constraints: \prg_do_nothing:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_evaluate_trial_results:}
%    The purpose of \cs{xor_evaluate_trial_results:} is to determine if
%    the current trial is a potential candidate for the final solution
%    and if so store it away. We can determine if the trial failed by
%    looking at the switch \cs{g_xor_trial_failed_bool}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_evaluate_trial_results:
  {
%<*trace>
    \trace_push:n { xor_evaluate_trial_results: }
%</trace>
%    \end{macrocode}
%    If the trial uses floats then we have to check if we exceeded the number
%    of allowed floats on the page (unless we are in a flush
%    situation).\footnote{Fix: this may better be checked prior to actually
%    doing the trial in the first place!}
%    \begin{macrocode}
    \bool_if:NT \g_xor_trial_with_floats_bool
      {
        \tl_if_eq:NNT \xor_try_this_area: \xor_try_this_area_std:
          {
            \int_compare:nNnT \g_pagesetup_max_float_int <
              { \g_xor_trial_here_seen_int + \g_xor_page_float_int }
              {
%<*trace>
                \trace:n { Failed:~area~+~here~floats~exceed~max~floats }
%</trace>
%<*progress>
                \xor_progress_failed:n
                  { area~+~here~floats~exceed~max~floats }
%</progress>
                \bool_gset_true:N \g_xor_trial_failed_bool
              }
          }
      }
%    \end{macrocode}
%
%    \begin{macrocode}
    \bool_if:NTF \g_xor_trial_failed_bool
      {
%<*trace>
        \trace:n { fail:~true }
%</trace>
        \xor_trial_restore_previous_state:
        \bool_if:NTF \g_xor_flush_failed_bool
          {
%<*trace>
            \trace:n { flushfail:~true }
%</trace>
%    \end{macrocode}
%    If we have failed and \cs{xor_try_this_area:} is already the
%    \enquote{relaxed} version we have to artificially move the offending flush
%    point to the next column and hope that this way we get ourselves some new
%    options (worst case is that eventually the flush point is removed
%    from the page in which case we can as a last resort defer the
%    float).
%    \begin{macrocode}
            \tl_if_eq:NNT \xor_try_this_area: \xor_try_this_area_relaxed:
              {
                \int_gincr:c
                  {
                    g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int
                    _min_col_int
                  }
%<*trace>
                \trace:n
                  {
                    g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int
                    _min_col_int
                    ~<-~
                    \int_use:c
                      {
                        g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int
                       _min_col_int
                      }
                  }
%</trace>
%<*progress>
                \xor_progress_failed:n
                  {
                    flush~point~ \int_use:N \g_xor_trial_flush_seen_int
                    \c_space_tl moved~to~column~
                    \int_use:c
                      {
                        g_xor_flush_ \int_use:N \g_xor_trial_flush_seen_int
                       _min_col_int
                      }
                  }
%</progress>
              }
              {
%    \end{macrocode}
%    Next test is a safety measure which probably can go away at some
%    point: the saved open area list should contain at least the area
%    that was used during this trial \ldots\ however the number of
%    times the algorithm got screwed up during
%    development suggested this as a good catch point (:-)
%    !!FRANK!! Should we have a real error here?
%    \begin{macrocode}
                  \clist_if_empty:NTF \g_xor_saved_this_areas_open_clist
                    {
%<*debug>
                      \trace:n
                        { g_xor_saved_this_areas_open_clist:~empty ???????? }
%</debug>
                      \ERROR
                    }
%    \end{macrocode}
%    If we have failed and \cs{xor_try_this_area:} is not yet \enquote{relaxed}
%    we can retry with less restrict placement conditions.
%    \begin{macrocode}
                    { \xor_relax_float_placement_conditions: }
              }
          }
          {
%<*trace>
            \trace:n { flushfail:~false }
%</trace>
            \bool_if:NTF \g_xor_balance_failed_bool
              {
%<*trace>
                \trace:n { balancefail:~true }
%</trace>
                \bool_gset_false:N \g_xor_balance_failed_bool
              }
              { \clist_gpop:NN \g_xor_this_areas_open_clist \l_xor_tmp_tl }
          }
%<*trace>
        \trace:n { open:~\g_xor_this_areas_open_clist }
%</trace>
      }
      {
%<*trace>
        \trace:n { fail:~false }
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*progress>
        \tl_set_eq:NN \l_xor_progress_pending_info_tl \c_empty_tl
%</progress>
        \bool_if:NF \g_xor_trial_with_floats_bool
          {
            \int_gset_eq:NN \g_xor_best_balance_done_int
              \g_xor_trial_balance_done_int
          }
%    \end{macrocode}
%    If this trial is valid and we haven't seen all flush penalties
%    again we must have pushed them  to the next page. We record
%    this fact by setting \cs{g_xor_flush_\ldots _min_col_int} to
%    \cs{c_max_dim}.
%    \begin{macrocode}
        \bool_if:NT \g_xor_flush_seen_bool
          {
            \int_set_eq:NN \l_xor_loop_int \g_xor_collect_flush_seen_int
            \int_while_do:nNnn \g_xor_trial_flush_seen_int < \l_xor_loop_int
              {
                \int_gset_eq:cN
                  { g_xor_flush_ \int_use:N \l_xor_loop_int _min_col_int }
                  \c_max_dim
%<*trace>
                \trace:n
                  {
                    g_xor_flush_ \int_use:N \l_xor_loop_int _min_col_int
                    \c_space_tl <-~ maxdimen
                  }
%</trace>
                \int_decr:N \l_xor_loop_int
              }
%    \end{macrocode}
%    If there has been a flush point (ie if \cs{g_xor_trial_flush_seen_int} and
%    thus \cs{l_xor_loop_int} is greater than~$0$) we test whether or not the
%    float recently placed was the last one affected by the last flush
%    point on the current page and if so tighten the float placement
%    setting again.\footnote{correct logic? Looks okay to me (JAW)}
%    \begin{macrocode}
%<*progress>
            \tl_set_eq:NN \l_xor_progress_pending_info_tl \c_empty_tl
%</progress>
            \bool_if:NT \g_xor_trial_with_floats_bool
              {
                \int_compare:nNnT \l_xor_loop_int > \c_zero
                  {
                    \int_compare:nNnT
                      {
                        \int_use:c
                          {
                            g_xor_flush_
                            \int_use:N \g_xor_trial_flush_seen_int
                            _last_float_int
                          }
                        }
                        = \g_xor_this_flseq_int
                        {
%<*trace>
                          \trace:n
                             {
                              flush:~last~float~affected~by~flush~point~
                              \int_use:N \g_xor_trial_flush_seen_int
                              \c_space_tl
                              placed~->~use~partly~normal~placement~
                              conditions~again
                            }
%</trace>
%<*progress>
                          \tl_set:Nn \l_xor_progress_pending_info_tl
                            {
                              \xor_progress_newline:n
                                {
                                   ->~past~flush~point:~-->~tighten~
                                   conditions~again
                                }
                              \xor_progress_newline:n { }
                            }
%</progress>
                          \xor_partly_tighten_float_placement_conditions:
                        }
                  }
              }
%    \end{macrocode}
%    Having placed a float we need to update \cs{g_xor_flush_max_classes_clist}
%    to reflect which float types are affected by the flush points
%    currently on the page as this might be needed when trying to
%    place or rather defer the next float.
%
%    So we loop and concatenate all \cs{g_xor_flush_\meta{num}_classes_clist}
%    that belong to flush points on the current page. This might result in
%    the list containing types several times but for the test we need
%    to do this doesn't make any difference (and it is far faster than
%    unifying the list).
%    \begin{macrocode}
            \int_zero:N \l_xor_loop_int
            \clist_gclear:N \g_xor_flush_max_classes_clist
            \int_while_do:nNnn \g_xor_trial_flush_seen_int > \l_xor_loop_int
              {
                \int_incr:N \l_xor_loop_int
                \clist_gconcat:NNc
                  \g_xor_flush_max_classes_clist
                  \g_xor_flush_max_classes_clist
                  { g_xor_flush_ \int_use:N \l_xor_loop_int _classes_clist }
%<*trace>
                \trace:n
                  {
                    g_xor_flush_max_classes_clist~<-~
                    \g_xor_flush_max_classes_clist
                  }
%</trace>
              }
          }
%    \end{macrocode}
%    With this algorithm a trial which passed so far is always
%    considered to be better than previous trials (meaning more floats
%    on the page are better). So we always update the best trial data
%    (unless this was the run without adding floats in which case we
%    only change the \cs{g_xor_trial_with_floats_bool} switch).
%    \begin{macrocode}
        \bool_if:NTF \g_xor_trial_with_floats_bool
          {
            \xor_update_best_trial:
%<*progress>
            \l_xor_progress_pending_info_tl
%</progress>
          }
          { \bool_gset_true:N \g_xor_trial_with_floats_bool }
      }
%<*trace>
    \trace_pop:n { xor_evaluate_trial_results: }
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\xor_trial_restore_previous_state:}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_trial_restore_previous_state:
  {
%<*trace>
    \trace_push:n { xor_trial_restore_previous_state: }
%</trace>
    \seq_gset_eq:NN \g_xor_floats_here_seq \g_xor_saved_floats_here_seq
%<*trace>
    \trace:n { restoring~here~sequence }
%</trace>
%    \end{macrocode}
%    If the trial has failed we have to distinguish two cases:
%    \begin{itemize}
%      \item
%        There has been a request for flushing out floats up to a
%        certain float somewhere
%        and the current float belongs to the list of floats to flush.
%      \item
%        There has been no such request.
%    \end{itemize}
%
%    If there have been flush points we need to restore their
%    |min_col| values since we might have updated them.
%    \begin{macrocode}
    \bool_if:NT \g_xor_flush_seen_bool
      { \xor_trial_restore_flush: }
%    \end{macrocode}
%    If we have been doing balancing the status needs to be brought back to
%    initial state. Probably should be done elsewhere
%    instead.\footnote{check/fix}
%    \begin{macrocode}
    \dim_gzero:N \g_xor_balance_delta_dim
    \bool_gset_false:N \g_xor_balance_point_expected_bool
    \bool_gset_false:N \g_xor_balance_finish_bool
%<*trace>
    \trace:n { BALANCE:~g_xor_balance_point_expected_bool~<-~false }
%</trace>
%    \end{macrocode}
%
%    To restore the previous state we have to recalculate the target
%    |fl@| column. However, there is nothing to restore if we haven't
%    run the trial with floats.
%    \begin{macrocode}
    \bool_if:NT \g_xor_trial_with_floats_bool
       { \xor_trial_restore_flseq: }
%<*trace>
    \trace_pop:n { xor_trial_restore_previous_state: }
%</trace>
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\xor_trial_restore_flseq:}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xor_trial_restore_flseq:
  {
%<*trace>
    \trace_push:n { xor_trial_restore_flseq: }
    \trace:n { restore:~last~allocated:~ \int_use:N \g_xor_saved_flseq_int }
%</trace>
    \xor_calculate_float_col:
%<*unused>
    \int_gzero_new:c
      {
        g_xor_flseq_type_ \g_xor_this_class_tl _col_
        \int_use:N \l_xor_returned_float_col_int _int
      }
%</unused>
    \int_gset_eq:cN
      {
        g_xor_flseq_type_ \g_xor_this_class_tl _col_
        \int_use:N \l_xor_returned_float_col_int _int
      }
      \g_xor_saved_flseq_int
%<*trace>
    \trace:n
      {
        \c_space_tl
        g_xor_flseq_type_ \g_xor_this_class_tl _col_
        \int_use:N \l_xor_returned_float_col_int _int \c_space_tl <-~
        \int_use:N \g_xor_saved_flseq_int \c_space_tl (restored)
      }
%</trace>
%    \end{macrocode}
%    And if we tried a top area we also have to restore the
%    corresponding \cs{g_xor_flseq_areas_top_type_\ldots} macro.
%    \begin{macrocode}
    \xor_if_this_area_type:NT t
      {
        \int_gset_eq:cN
          {
            g_xor_flseq_areas_top_type_ \g_xor_this_class_tl _col_
            \int_use:N \l_xor_returned_float_col_int _int
          }
          \g_xor_saved_flseq_top_areas_int
%<*trace>
        \trace:n
          {
            ~g_xor_flseq_areas_top_type_ \g_xor_this_class_tl _col_
            \int_use:N \l_xor_returned_float_col_int _int \c_space_tl <-~
            \int_use:N \g_xor_saved_flseq_top_areas_int \c_space_tl (restored)
          }
%</trace>
      }
%    \end{macrocode}
%    And we better don't forget to restore the heights.\footnote{This
%    is most likely buggy: I seem to restore all column values but I think
%    I don't save all of them! FIX!!!!}
%    \begin{macrocode}
%%%  \g_xor_best_trial_col_hts_tl
  \xor_update_this_area_span_cols:n
   {
\iffalse
%<*trace>
    \trace:n{restore:~g_xor_ht_col_
            \int_use:N \l_xor_update_col_int
_1
                    _dim :~
            \tl_use:c {g_xor_saved_ht_col_
                        \int_use:N \l_xor_update_col_int
_1
                      _tl}
           }
%</trace>
      %%\cs_show:c{g_xor_saved_ht_col_  \int_use:N\l_xor_update_col_int _tl}
      \dim_gset_eq:cc {g_xor_ht_col_       \int_use:N\l_xor_update_col_int
_1
                    _dim}
                   {g_xor_saved_ht_col_ \int_use:N\l_xor_update_col_int
_1
                    _tl}
\fi
      \dim_gset_eq:cc {g_xor_bottom_ht_col_       \int_use:N \l_xor_update_col_int _dim}
                   {g_xor_saved_bottom_ht_col_ \int_use:N \l_xor_update_col_int _dim}
%<*trace>
      \trace:n{restore:~g_xor_bottom_ht_col_
            \int_use:N \l_xor_update_col_int
                    _dim :~
            \dim_use:c {g_xor_saved_bottom_ht_col_
                        \int_use:N \l_xor_update_col_int
                       _dim}
           }
%</trace>
%    \end{macrocode}
%    \begin{macrocode}
    \dim_gset_eq:cc
        {g_xor_       \g_xor_this_area_type_tl _delta_col_
                      \int_use:N \l_xor_update_col_int _dim}
        {g_xor_saved_ \g_xor_this_area_type_tl _delta_col_
                      \int_use:N \l_xor_update_col_int _dim}
%<*trace>
    \trace:n{GRID (delta):~ column~\int_use:N \l_xor_update_col_int
                          \g_xor_this_area_type_tl :~
            \dim_use:c {g_xor_saved_ \g_xor_this_area_type_tl
                        _delta_col_
                        \int_use:N \l_xor_update_col_int _dim}
            \space  (restore) }
%</trace>
  }
%<*trace>
  \trace_pop:n{xor_trial_restore_flseq:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\xor_trial_restore_flush:}
%
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_trial_restore_flush: {
%<*trace>
  \trace_push:n{xor_trial_restore_flush:}
%</trace>
  \int_zero:N \l_xor_loop_int
  \int_while_do:nNnn \g_xor_collect_flush_seen_int >\l_xor_loop_int
  {
    \int_incr:N \l_xor_loop_int
      \int_gset_eq:cc
          {g_xor_flush_ \int_use:N \l_xor_loop_int _min_col_int}
          {g_xor_saved_flush_ \int_use:N \l_xor_loop_int _min_col_int}
%<*trace>
      \trace:n{g_xor_flush_ \int_use:N \l_xor_loop_int _min_col_int\space <-~
            \int_use:c {g_xor_flush_ \int_use:N \l_xor_loop_int _min_col_int} ~
            (restore) }
%</trace>
  }
%<*trace>
  \trace_pop:n{xor_trial_restore_flush:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\g_xor_saved_flseq_int}
% \begin{macro}{\g_xor_saved_flseq_top_areas_int}
%    \begin{macrocode}
\int_new:N \g_xor_saved_flseq_int
\int_new:N \g_xor_saved_flseq_top_areas_int
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \subsection{Best Trial Data}
%
%
% \begin{macro}{\g_xor_best_trial_col_hts_tl}
%    This macro holds the column heights for all columns in the best
%    trial (i.e., |\textheight| minus allocated floats minus and
%    material already balanced).
%    \begin{macrocode}
\tl_new:N \g_xor_best_trial_col_hts_tl
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_update_best_trial:}
%    Not all of this belongs into this macro!\footnote{redistribute}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_update_best_trial:{
%<*trace>
  \trace_push:n{xor_update_best_trial:}
%</trace>
%<*progress>
  \xor_progress_newline:n{->~ accepted}
%</progress>
  \tl_gset_eq:NN \g_xor_best_trial_col_hts_tl
                  \g_xor_saved_trial_col_hts_tl
%<*trace>
  \trace:n{new~ best~ trial:~ \tl_to_str:N \g_xor_best_trial_col_hts_tl}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
%%B
   \int_gset_eq:NN \g_xor_best_balance_done_int
                   \g_xor_trial_balance_done_int
   \xor_update_float_placement_data:
%<*trace>
  \trace_pop:n{xor_update_best_trial:}
%</trace>
}
\cs_new_nopar:Npn \xor_update_float_placement_data: {
%<*trace>
  \trace_push:n{xor_update_float_placement_data:}
%</trace>
%    \end{macrocode}
%
%    Frank says this needs to be documented (the rest of the code is
%    self evident) |\g_xor_this_float_box_tl| is |\cs_set_eq:NN | to
%    |\g_xor_curr_float_box_tl| which is defed to a chardefed token
%    from newinsert. so this is OK. honest.
%    \begin{macrocode}
  \seq_gput_right:co {g_xor_area_ \g_xor_this_area_name_tl _float_seq}
                      \g_xor_this_float_box_tl
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
  \trace:n{g_xor_curr_page_areas_closed_clist
          ~\g_xor_curr_page_areas_closed_clist\space +~
          "\clist_use:c{g_xor_area_ \g_xor_this_area_name_tl _all_close_clist}"}
  \trace:n{g_xor_this_areas_closed_clist~ \g_xor_this_areas_closed_clist\space +~
          "\clist_use:c{g_xor_area_ \g_xor_this_area_name_tl _class_close_clist}"}
%</trace>
  \clist_gconcat:NNc \g_xor_curr_page_areas_closed_clist
                        \g_xor_curr_page_areas_closed_clist
                        {g_xor_area_ \g_xor_this_area_name_tl
                         _all_close_clist}
  \clist_gconcat:NNc \g_xor_this_areas_closed_clist
                     \g_xor_this_areas_closed_clist
                        {g_xor_area_ \g_xor_this_area_name_tl _class_close_clist}
%    \end{macrocode}
%
%    Check: why the remark "tmp"?\footnote{FIX}
%    \begin{macrocode}
  \clist_gset_eq:cN {g_xor_class_ \g_xor_this_class_tl _areas_closed_clist} % FMi tmp
                    \g_xor_this_areas_closed_clist
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gincr:N \g_xor_page_float_int
  \int_gincr:c {g_xor_area_ \g_xor_this_area_name_tl _float_int}
%    \end{macrocode}
%
%    Since the trial was successful, we have to update the macros
%    that hold the number of top or bottom floats we have seen so far
%    in each column. (Code for this is similar to the one in
%    |\xor_construct_and_test_col_hts:| and elsewhere; perhaps there should be
%    a subroutine for it!)\footnote{fix}
%    \begin{macrocode}
  \xor_update_this_area_span_cols:n
  {
    \int_gincr:c
        {g_xor_ \g_xor_this_area_type_tl _floats_col_
        \int_use:N \l_xor_update_col_int _int}
%<*trace>
    \trace:n{g_xor_ \g_xor_this_area_type_tl
          _floats_col_ \int_use:N \l_xor_update_col_int _int <-~
          \int_use:c {g_xor_ \g_xor_this_area_type_tl
                      _floats_col_ \int_use:N \l_xor_update_col_int _int}
    }
%</trace>
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
  \trace:n{area:~\g_xor_this_area_name_tl\space
         \csname g_xor_area_ \g_xor_this_area_name_tl _float_seq \endcsname}
  \trace_pop:n{xor_update_float_placement_data:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \newpage
%
% \subsection{Best Column Output Routine}
%
% \begin{description}
% \item[Entry:] |\xor_OR_best_cols_setup:|
% \item[Exit:]  |\xor_collect_setup:|
% \item[Prereq:]
% \item[Description:]
% \item[Flow:]
%\begin{footnotesize}
%\begin{verbatim}
%    \xor_OR_best_cols_setup:
%            |
%    New OR: \xor_OR_grab_best_cols:
%            |
%            V
%    \xor_OR_best_next_col_setup: <-------
%            |
%    (when entering OR...)
%            |
%    <end of collection reached?>
%         |          |
%        yes        no
%         |          |
%         |     <col break requested?>
%         |          |        |
%         |         yes       no
%         |          |        |
%         |          |     <flush point encountered?>
%         |          |        |                  |
%         |          |       yes                 no
%         |          |        |                  |
%         |          | <flush point         <here point encountered?>
%         |          |      too early?>        |               |
%         |          |    |      |            yes              no
%         |          |   yes    no             |               |
%         |          |    |      |             ?               ?
%         |          |    | (ignore break)
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
% (end column now) <-------      |
%         |                      |
%         V                      |
%   <all cols produced?>         |
%      |           |             V
%     yes          no--------------------> (reenter \xor_OR_best_next_col_setup:)
%      |
% (produce final page)
%      |
%      V
%  \xor_next_page_setup:
%      |
%      V
% (try to make float pages)
%      |
%      V
%  \xor_collect_setup:
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
% After the best trial is chosen the |\xor_OR_grab_best_cols:| output routines
% are executed. Structurally this is similar to the grab column output
% routines used during the trials, but this time information
% about the float placements is recorded in the float area lists
% and also optionally in float placement control files.
%
% \begin{macro}{\xor_OR_best_cols_setup:}
%    This is the initialization code for producing the final best set
%    of columns (via the |\xor_OR_grab_best_cols:| output routine).
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_OR_best_cols_setup:{
%<*trace>
  \trace_push:n{xor_OR_best_cols_setup:}
%</trace>
%<*trace>
    \trace:n{XX~initial:~
           \tl_to_str:N \g_xor_best_trial_col_hts_tl}
%</trace>
  \g_xor_best_trial_col_hts_tl
  \xor_forall_column_blocks:n {
      \dim_gset_eq:cc {g_xor_best_ht_col_  \xor_curr_col_block: _dim}
                   {g_xor_ht_col_       \xor_curr_col_block: _dim}
     }
  \int_gzero:N \g_xor_curr_col_int
  \xor_initialize_page_footins_action:
%%  {\showoutput \showlists}
  \int_gzero:N \g_xor_curr_col_block_int  % or one?
  \int_gzero:N \g_xor_trial_flush_seen_int
  \int_gzero:N \g_xor_trial_here_seen_int
  \int_gzero:N \g_xor_trial_balance_seen_int
%<*trace>
  \trace:n{BALANCE:~ g_xor_trial_balance_seen_int ~<-~
                    \int_use:N \g_xor_trial_balance_seen_int}
%</trace>
%  \xor_perhaps_write_placements_to_fpl_file:
%<*trace>
  \trace:n{Setting~ up~ column~ heights:}
%</trace>
  \int_gset_eq:NN \g_xor_trial_balance_done_int
                  \g_xor_best_balance_done_int
  \xor_if_grab_for_balance_done:TF
  {
%<*trace>
     \trace:n{\tl_to_str:c {g_xor_best_trial_col_hts_balance_
                           \int_use:N \g_xor_trial_balance_seen_int
                           _tl }
             }
%</trace>
     \tl_use:c {g_xor_best_trial_col_hts_balance_
                 \int_use:N \g_xor_trial_balance_seen_int
                 _tl}
  }
  {
%<*trace>
    \trace:n{Setting~ up~ column~ heights:~
           \tl_to_str:N \g_xor_best_trial_col_hts_tl}
%</trace>
    \g_xor_best_trial_col_hts_tl
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
   \global\output{\xor_OR_grab_best_cols:}
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_if_grab_for_balance_done:T
  {
%<*trace>
    \trace:n{BALANCE:~ collecting~ columns~ for~ block~
                     \int_use:N \g_xor_trial_balance_seen_int}
%</trace>
    \tl_use:c {g_xor_best_trial_col_hts_balance_
                \int_use:N \g_xor_trial_balance_seen_int
                _tl}
  }
  \xor_OR_best_next_col_setup:
%<*trace>
 \trace_pop:n{xor_OR_best_cols_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_OR_best_next_col_setup:}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_OR_best_next_col_setup:{
%<*trace>
  \trace_push:n{xor_OR_best_next_col_setup:}
%</trace>
  \int_gincr:N \g_xor_curr_col_int
  \int_gset:Nn \g_xor_curr_col_block_int {1}
  \dim_gset_eq:Nc \vsize {g_xor_ht_col_
                       \xor_curr_col_block:
                       _dim}
%<*trace>
  \trace:n{vsize~ <-~ \dim_use:N \vsize }
%</trace>
%    \end{macrocode}
%    tmp\footnote{fix: implement differently} --- same code/logic as in
%    |\xor_OR_trial_grab_next_col_setup:|
%    \begin{macrocode}
  \dim_compare:nNnF \tex_vsize:D > \tex_baselineskip:D
      { \ignorethiscolumn }
  \xor_initialize_column_footins_action:
%<*trace>
  \trace_pop:n{xor_OR_best_next_col_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_OR_grab_best_cols:}
%    Here is the output routine used when preparing the final columns,
%    an instantiation of |\xor_OR_grab_some_cols:nnnnn|. In contrast to the version
%    used for |\xor_OR_grab_trial_cols:| it doesn't do the tests.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_OR_grab_best_cols: {
  \xor_OR_grab_some_cols:nnnnn{best}
    \xor_OR_best_finish_col:
    {
      \@reinserts
      \vbox_unpack_clear:N\c_two_hundred_fifty_five
%    \end{macrocode}
%    Next line not okay! we need to add a penalty here but which one?
%    Or we need a different mechanism using either |\holdinginserts|
%    or a partial box line in collection OR.\footnote{FIX!!! there is
%    also another place like this!}
%    \begin{macrocode}
%       \penalty\c_zero  %FMi?
    }
    {
      \xor_perhaps_write_to_fpl_file:n{
        \@spaces Area:~hhh^^J
        \exp_after:wN
        \xor_gen_float_placement_fpl_info:nnnnnnn
           \the\toks\g_xor_curr_float_box_tl
      }
      \xor_typeset_a_here_float:
    }
%    \end{macrocode}
%    What to do if we encounter a balance point; right now this needs to be a
%    function with two args.
%    \begin{macrocode}
    {
      \xor_best_handle_balance_point:nn
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%  \begin{macro}{\xor_best_handle_balance_point:nn}
%
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_best_handle_balance_point:nn #1 #2 {
%<*trace>
  \trace_push:n{xor_best_handle_balance_point:nn}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
   \int_set:Nn \l_tmpa_int \g_xor_curr_col_int
   \int_while_do:nNnn \l_tmpa_int < \g_xor_cols_int
     {
%<*trace>
      \trace:n{BALANCE:~ gen~ empty~ col~ \the\g_xor_curr_col_int}
%</trace>
      \int_incr:N \l_tmpa_int
      \endgraf \null \break
     }
%    \end{macrocode}
%
%    \begin{macrocode}
   #1
%<*trace>
  \trace_pop:n{xor_best_handle_balance_point:nn}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}{\xor_OR_best_finish_col:}
%
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_OR_best_finish_col:{
%<*trace>
  \trace_push:n{xor_OR_best_finish_col:}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
  \marks_update_structure:
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_column_end_footins_action:
%    \end{macrocode}
%
% save all marks here\footnote{not done yet!}
%
% add floats and footnotes etc to collected column
%
%    \begin{macrocode}
  \xor_if_grab_for_balance_done:TF
  {
%<*trace>
    \trace:n{BALANCE:~ storing~ away~ col~ \int_use:N \g_xor_curr_col_int}
%</trace>
    \box_if_empty:cTF {g_xor_col_
                    \int_use:N \g_xor_curr_col_int
                    _balance_box }
    {
%<*trace>
    \trace:n{BALANCE:~ box~ empty~ }
%</trace>
       \box_gset_eq_clear:cN {g_xor_col_
       \int_use:N \g_xor_curr_col_int
       _balance_box}
          \c_two_hundred_fifty_five
    }
    {
%<*trace>
      \trace:n{BALANCE:~ box~ already~ used~ }
%</trace>
      \dim_set:Nn \l_tmpa_dim
      { \box_dp:c { g_xor_col_
                  \int_use:N \g_xor_curr_col_int
                  _balance_box
        }
      }
      \vbox_gset:cn
      {g_xor_col_
            \int_use:N \g_xor_curr_col_int
            _balance_box }
      { \box_use_clear:c {g_xor_col_
                              \int_use:N \g_xor_curr_col_int
                              _balance_box }
        \vskip -\l_tmpa_dim
        \hrule\kern-0.4pt
        \box_use_clear:N \c_two_hundred_fifty_five
      }
%<*trace>
      {
        \showoutput
        \showboxdepth1\relax
        \scrollmode
        \box_show:c {g_xor_col_
                    \int_use:N \g_xor_curr_col_int
                    _balance_box }
      }
%</trace>
    }
% very inefficient this way and only tmp
      \vbox_gset:cn
      {g_xor_col_
            \int_use:N \g_xor_curr_col_int
            _balance_box }
      { \box_use_clear:c {g_xor_col_
                              \int_use:N \g_xor_curr_col_int
                              _balance_box }
        \ifvoid\g_xor_footins_box   \else
          \vskip \g_xor_footins_skip
          \vbox_unpack_clear:N \g_xor_footins_box
        \fi
      }
    \int_compare:nNnT \g_xor_curr_col_int=\g_xor_cols_int
    {
      \int_gincr:N \g_xor_trial_balance_seen_int
%<*trace>
      \trace:n{BALANCE:~ g_xor_trial_balance_seen_int ~<-~
                      \int_use:N \g_xor_trial_balance_seen_int}
%</trace>
      \int_gzero:N \g_xor_curr_col_int
      \xor_if_grab_for_balance_done:TF
      {
%<*trace>
       \trace:n{Setting~ up~ balance~ column~ heights:~
        \tl_to_str:c { g_xor_best_trial_col_hts_balance_
                       \int_use:N \g_xor_trial_balance_seen_int
                       _tl }}
%</trace>
        \tl_use:c {g_xor_best_trial_col_hts_balance_
                   \int_use:N \g_xor_trial_balance_seen_int
                   _tl}
      }
      {
%<*trace>
       \trace:n{Setting~ up~ column~ heights:~
        \tl_to_str:N \g_xor_balance_trial_col_hts_tl}
%</trace>
        \g_xor_balance_trial_col_hts_tl
      }
    }
  }
  {
    \xor_produce_final_column:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_compare:nNnTF \g_xor_curr_col_int=\g_xor_cols_int
  {
    \xor_produce_final_page:
    \xor_next_page_setup:
    \xor_try_float_pages:
    \xor_place_deferred_floats:
    \xor_collect_setup:
  }
  {
    \xor_OR_best_next_col_setup:
  }
%<*trace>
  \trace_pop:n{xor_OR_best_finish_col:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_next_page_setup:}
%    Initializes the column heights to text height. Clear the float
%    area lists, zero |\holdinginserts| to allow footnote texts to arrive
%    in the insertion box.
%    \begin{macrocode}
\cs_new_nopar:Npn\xor_next_page_setup:{
%<*trace>
  \trace_push:n{xor_next_page_setup:}
%</trace>
%
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_cols_setup:
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_area_setup:
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gzero:N \g_xor_page_float_int
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_initialize_flush_data:
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_initialize_here_data:
%    \end{macrocode}
%
%    Footnote actions are initialized later as they need to be redone for
%    every trial.
%
%    Nothing is closed when we are at the start of a page.
%    \begin{macrocode}
  \clist_gclear:N \g_xor_curr_page_areas_closed_clist
%    \end{macrocode}
%
%    \begin{macrocode}
  \seq_map_function:NN \g_xor_float_classes_seq
              \xor_float_class_setup:n
%    \end{macrocode}
%    for safety
%    \begin{macrocode}
  \tl_gset_eq:NN \g_xor_this_float_box_tl \c_undefined
%<*trace>
  \trace_pop:n{xor_next_page_setup:}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%  
%
% \begin{macro}{\xor_float_class_setup:n}
%    \begin{macrocode}
\cs_new_protected:Npn \xor_float_class_setup:n #1
  {
%<*trace>
    \trace_push:n { xor_float_class_setup:n }
%</trace>
  \count@0
  \LastMark{#1}
%<*trace>
  \trace:n{count~ (#1) = \int_use:N \count@}
%</trace>
%    \end{macrocode}
%
%    Check: the close list should probably not be made empty but
%    initialized with all areas not on the allowed list!\footnote{FIX}
%    \begin{macrocode}
  \clist_gclear:c {g_xor_class_ #1 _areas_closed_clist}
%    \end{macrocode}
%
%    what is the meaning of the "allowed" floats doesn't seem to be used
%    anywhere these days\footnote{check and fix}
%    \begin{macrocode}
%<*trace>
%  \trace:n{allowed~ (#1) = \clist_use:c{g_xor_class_ #1 _areas_allowed_clist}}
  \trace:n{closed~ (#1) = \clist_use:c{g_xor_class_ #1 _areas_closed_clist}}
%</trace>
%    \end{macrocode}
%
%    |\g_xor_flseq_type_figure_col_1_int| are macros that expands to the highest numbered
%    figure callout in this column (or zero if there is none).
%    |\g_xor_flseq_type_figure_col_0_int| is the highest value from
%    previous pages (or zero
%    if there was never any float of this type).
%    \begin{macrocode}
  \xor_forall_columns:n {
    \int_compare:nNnT
      { \int_use:c {g_xor_flseq_type_#1_col_ \int_use:N\g_xor_curr_col_int _int }}
      > \c_zero
    {
      \int_gzero_new:c {g_xor_flseq_type_#1_col_ 0                             _int}
      \int_gset_eq:cc {g_xor_flseq_type_#1_col_ 0                             _int}
                      {g_xor_flseq_type_#1_col_ \int_use:N\g_xor_curr_col_int _int}
      \int_gzero_new:c {g_xor_flseq_type_#1_col_ \int_use:N\g_xor_curr_col_int _int}
    }
%    \end{macrocode}
%    |\g_xor_flseq_areas_top_type_figure_col_1_int| is like \\
%    |\g_xor_flseq_type_figure_col_1_int| but only stores
%    information about floats allocated to top areas.
%    \begin{macrocode}
    \int_gzero_new:c {g_xor_flseq_areas_top_type_#1_col_
                  \int_use:N\g_xor_curr_col_int _int}
  }
%<*trace>
  \trace_pop:n{xor_float_class_setup:n}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_handle_forced_pagebreak:}
%    This is related to |\xor_handle_premature_ending:| but we have
%    to return the penalty only if we haven't reached the last column.
%    If we don't do this we would start collecting material in the
%    middle of final page generation!
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_handle_forced_pagebreak:{
  \int_compare:nNnT \g_xor_curr_col_int<\g_xor_cols_int
    \@emptycol
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \newpage
%
% \subsection{Cleanup Output Routine}
%
% \begin{description}
% \item[Entry:] |\xor_OR_cleanup_setup:N|
% \item[Exit:]  |#1|
% \item[Prereq:]
% \item[Description:]
%    Responsible for discarding unused text still on Main Vertical
%    List After the end of a trial. It eats everything until it sees
%    the special penalty marking the end of the last collection output
%    routine. This output routine may need to be called several times
%    in succession due to forced penalties in the galley.
% \item[Flow:]
%\begin{footnotesize}
%\begin{verbatim}
%    \xor_OR_cleanup_setup:N #1
%           |
%           V
%    New OR: \xor_OR_cleanup:N #1
%           |
%           V
% <special outputpenalty reached?> --> #1
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
% \begin{macro}{\xor_OR_cleanup_setup:N}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_OR_cleanup_setup:N #1 {
  \dim_gset:Nn \vsize \c_max_skip
  \tex_global:D \output{\xor_OR_cleanup:N #1}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_OR_cleanup:N}
%    In the actual output routine we grab text and throw it away until
%    we see the special output penalty. Then we prepare for the trials
%    to place the floats properly.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_OR_cleanup:N #1 {
%<*trace>
  \trace_push:n{xor_OR_cleanup:N}
  \trace:n{output~pen:~ \the\outputpenalty}
%</trace>
%    \end{macrocode}
%    Throw everything away \ldots
%    \begin{macrocode}
  \box_gclear:N \c_two_hundred_fifty_five
  \box_gclear:N \g_xor_footins_box
%    \end{macrocode}
%    \ldots\ until we see the special output penalty again.
%    \begin{macrocode}
  \int_compare:nNnT \outputpenalty=\c_xor_output_collect_penalty  { #1 }
%<*trace>
  \trace_pop:n{xor_OR_cleanup:N}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \newpage
%
% \subsection{Making float pages}
%
%
% \begin{description}
% \item[Entry:] |\xor_try_float_pages:|
% \item[Exit:]  --- (this happens within the OR)\\
%    On exit |\g_xor_area_DDD_float_seq| will be empty and the floats not being put
%    onto float pages are moved to |\g_xor_floats_active_seq| (those that have
%    their call outs on previous pages) and |\g_xor_floats_mvl_seq| (those that
%    have their call outs still on the MVL).
% \item[Prereq:] |\g_xor_area_DDD_float_seq| contains the float to work on; all other
%    areas are empty.
% \item[Description:]
% \item[Flow:]
%\begin{footnotesize}
%\begin{verbatim}
%   \xor_try_float_pages:
%         |
%         V
%  <\g_xor_area_DDD_float_seq has floats?>
%      |          |
% ----no         yes
% |               |
% |               V
% |  (split \g_xor_area_DDD_float_seq into \g_xor_floats_active_seq and
% |   \g_xor_floats_mvl_seq; setup trial conditions)
% |               |
% |               V
% |         \xor_attempt_float_page: <---------------------
% |               |                                       |
% |          <float page produced?>                       |
% |             |         |                               |
% |            no        yes                              |
% |             |         |                               |
% |             |     (output page)                       |
% |             |         |                               |
% |             |     (move new \g_xor_area_DDD_float_seq |
% |             |      to \g_xor_floats_active_seq)       |
% |             |         |                               |
% |             |         ---------------------------------
% |             |
% |             |
% |   (restore float conditions before last trial)
% |             |
% |   (restore trial condition to normal)
% |             |
% ------------->|
%               |
%               V
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
%
% \begin{macro}{\xor_try_float_pages_std:}
%
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_try_float_pages_std: {
%<*trace>
  \trace_push:n{xor_try_float_pages_std:}
%</trace>
%<-trace>  \seq_if_empty:NF
%<+trace>  \seq_if_empty:NTF
  \g_xor_area_DDD_float_seq
%<+trace>       { \trace:n{no~ deferred~ floats} }
  {
    \cs_gset_eq:NN \xor_floats_active_seq_if_empty_action: \prg_do_nothing:
    \cs_gset_eq:NN \xor_pretests_success_action: \xor_floatpage_pretests_success_action:
%    \end{macrocode}
%    this is only a tmp: we just use |\xor_try_this_area_relaxed:| but of
%    course there should be different rules for float pages (and
%    different float areas and \ldots)\footnote{fix}
%    \begin{macrocode}
    \cs_gset_eq:NN \xor_try_this_area: \xor_try_this_area_relaxed:
%    \end{macrocode}
%
%    First thing to do is to split the list of deferred floats into
%    those that have their callouts already typeset (on previous pages)
%    and those that we have only seen because we looked a bit
%    ahead. For making float pages we can only use the former.
%    \begin{macrocode}
    \seq_map_function:NN \g_xor_area_DDD_float_seq
                         \xor_redistributed_defer_list_float:n
    \seq_gclear:N\g_xor_area_DDD_float_seq
%    \end{macrocode}
%    Now we loop until we fail to make float pages. The actual work is
%    done in the macro |\xor_attempt_float_page:|.
%    \begin{macrocode}
    \bool_gset_true:N \g_xor_float_page_bool
    \bool_while_do:Nn \g_xor_float_page_bool
    {
      \group_begin: % no nesting of \loop without grouping ...
%    \end{macrocode}
%   Does the extra group matter now? MH
%
%    A bit statistics: how many floats do we have on the
%    |\g_xor_floats_active_seq|?
%    \begin{macrocode}
%<*progress>
       \int_gzero:N \g_xor_floats_waiting_int
       \seq_map_inline:Nn
          \g_xor_floats_active_seq
          {\int_gincr:N\g_xor_floats_waiting_int}
        \xor_progress_newline:n{}
        \xor_progress_separator:
        \xor_progress_newline:n{STATS:~ floats~ waiting~ =~ \int_use:N\g_xor_floats_waiting_int
                \space on~ page~ \int_use:N \g_xor_page_absolute_int \space
                (float~ page)}
        \xor_progress_separator:
        \int_gzero:N \g_xor_trials_done_int
%</progress>
%    \end{macrocode}
%    \begin{macrocode}
        \xor_attempt_float_page:
      \group_end:
    }
%    \end{macrocode}
%    Once we are finished we have to return to normal trial
%    conditions, so\ldots
%    \begin{macrocode}
    \cs_gset_eq:NN \xor_try_this_area: \xor_try_this_area_std:
  }
%<*trace>
  \trace_pop:n{xor_try_float_pages_std:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{xor_try_float_pages:}
%    We do not try to produce float pages if the float data comes from an FPC
%    file, but normally we do:
%    \begin{macrocode}
\cs_new_eq:NN \xor_try_float_pages: \xor_try_float_pages_std:
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}{\xor_attempt_float_page:}
%    This macro tries to build a single float page from the floats in
%    |\g_xor_floats_active_seq|. If it fails it (tries to) restores the state of
%    the floats. If it succeeds it will output a float page and returns.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_attempt_float_page: {
%<*trace>
  \trace_push:n{xor_attempt_float_page:}
%</trace>
%    \end{macrocode}
%    Save the current state in case of failure then run the float
%    placement loop (setup for this loop should have happened
%    earlier).
%    \begin{macrocode}
  \xor_save_current_float_state:
  \xor_trial_place_float_inner_loop:
%
%\typeout{float.list.after.trial}
%\showfloatlists
%
%    \end{macrocode}
%    Loop through all ``text columns'' and add up their heights. This
%    is again only done to have some sort of measure for float pages
%    and should be removed once some real code gets into this part.
%    \begin{macrocode}
  \dim_zero:N \l_tmpa_dim
  \xor_forall_column_blocks:n
  {
%<*trace>
    \trace:n{\box_ht:N\int_use:N\g_xor_curr_col_int=
            \dim_use:c {g_xor_ht_col_ \xor_curr_col_block:
                      _dim}
    }
%</trace>
    \dim_add:Nn \l_tmpa_dim
                { \dim_use:c { g_xor_ht_col_ \xor_curr_col_block: _dim} }
  }
%    \end{macrocode}
%
%    If the sum of all white space is more than 300pt :-)
%    \begin{macrocode}
  \dim_compare:nNnTF \l_tmpa_dim > {300pt}
  {
%    \end{macrocode}
%    we fail
%    \begin{macrocode}
    \bool_gset_false:N \g_xor_float_page_bool
%<*trace>
    \trace:n{float~page~failed}
%</trace>
%<*progress>
    \xor_progress_failed:n{no~ float~ page~ made}
    \xor_progress_newline:n{}
%</progress>
%    \end{macrocode}
%    Return to the previous state (and as can be seen by using
%    |\xor_next_page_setup:|) this needs some work; the latter might
%    in fact do too much like calling
%    |\xor_initialize_flush_data:|!\footnote{FIX}
%    \begin{macrocode}
    \g_saved_float_state_tl
%    \end{macrocode}
%    To avoid having |\xor_initialize_flush_data:|\footnote{FIX} do anything harmful we
%    set \\
%    |\g_xor_trial_flush_seen_int| to zero at this point.\footnote{This
%    needs fixing properly! and what about balance points?} And the same is
%                   necessary for
%    |\xor_initialize_here_data:|.
%    \begin{macrocode}
    \int_gzero:N \g_xor_trial_flush_seen_int
    \int_gzero:N \g_xor_trial_here_seen_int
    \xor_next_page_setup:
  }
  {
%    \end{macrocode}
%    Otherwise we claim we have  a good float page.
%    \begin{macrocode}
%<*trace>
    \trace:n{float~page~succeeded}
    \trace:n{We~ better~ output~ something~ now~ ...}
%</trace>
%<*progress>
    \xor_progress_newline:n{succeeded}
    \xor_progress_newline:n{}
%</progress>
%    \end{macrocode}
%    producing this page is rubbish as well but it can't be written
%    before we have parameters and rules for making float pages.
%    \begin{macrocode}
    \xor_forall_columns:n{
      \vbox_gset_to_ht:cnn
        {g_xor_col_ \xor_curr_col_block: _box}
        { \dim_use:c{g_xor_ht_col_ \xor_curr_col_block: _dim}} {}
      \xor_produce_final_column:
    }
    \xor_perhaps_write_placements_to_fpl_file:
    \xor_produce_final_page:
    \xor_next_page_setup:
%    \end{macrocode}
%    But the final lines are for real: if we did succeed we need to
%    provide a new |\g_xor_floats_active_seq| for the next potential float page.
%    It should be the floats we deferred while trying to make the
%    current float page followed by the floats that are still on the
%    active list (i.e., those we haven't even tried for the current
%    page).
%    \begin{macrocode}
    \seq_gconcat:NNN \g_xor_floats_active_seq
                     \g_xor_area_DDD_float_seq
                     \g_xor_floats_active_seq
    \seq_gclear:N \g_xor_area_DDD_float_seq
  }
%
%\typeout{float.list.after.shipout.float.page.or.fail}
%\showfloatlists
%
%<*trace>
  \trace_pop:n{xor_attempt_float_page:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_float_page_bool}
%    Switch which is set to true while we are in the process of making
%    float pages and haven't failed.
%    \begin{macrocode}
\bool_new:N \g_xor_float_page_bool
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_save_current_float_state:}
%
%    Save the current state of affairs concerning
%    floats\footnote{Needs more work, there are now other data
%    structures that should be saved if this is every going to be of
%    much use. (its current usage actually could be achieved with
%    simpler means). FIX or fold!}. In case of failure return to
%    this state by executing |\g_saved_float_state_tl|.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_save_current_float_state: {
%<*trace>
  \trace_push:n{xor_save_current_float_state:}
%</trace>
%%% FMi tmp
  \__seq_push_item_def:n { \exp_not:N \__seq_item:n \exp_not:n { {##1} } }
  \tl_gset:Nx \g_saved_float_state_tl
               { \cs_gset_nopar:Npn \exp_not:N \g_xor_floats_active_seq
                        {\g_xor_floats_active_seq} }
  \__seq_pop_item_def:
  \xor_forall_column_blocks:n {
    \tl_gput_right:Nx \g_saved_float_state_tl
        { \exp_not:N \dim_set:Nn
          \exp_not:c   {g_xor_ht_col_ \xor_curr_col_block: _dim}
                       {\dim_use:c {g_xor_ht_col_
                                    \xor_curr_col_block:
            _dim}
                       }
        }
  }
%    \end{macrocode}
%    Save current state of all used float areas by looping though them.
%    \begin{macrocode}
  \clist_map_function:NN \g_xor_areas_used_clist \xor_save_area_info:n
  \xor_save_area_info:n {DDD}
%<*trace>
  \trace:n{saved:~ \meaning\g_saved_float_state_tl}
  \trace_pop:n{xor_save_current_float_state:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_save_area_info:n}
%    Argument is the three character area name.
%
%    THIS MAKES USE OF AREAS STORED WITHOUT SEPARATOR RIGHT NOW!
%    Save information about area.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_save_area_info:n #1 {
\group_begin:
  \__seq_push_item_def:n { \exp_not:N \__seq_item:n \exp_not:n { {##1} } }
    \cs_set_nopar:Npx \@tempa {
       \exp_not:N \int_gset:cn
          {g_xor_area_ #1 _float_int}
          {\int_use:c {g_xor_area_ #1 _float_int} }
%    \end{macrocode}
%
%    \begin{macrocode}
% FMI fix, see above
       \gdef \expandafter\noexpand \csname g_xor_area_#1_float_seq \endcsname
          {\csname g_xor_area_#1_float_seq\endcsname}
    }
    \__seq_pop_item_def:
    \tl_gput_right:No \g_saved_float_state_tl \@tempa
\group_end:
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_saved_float_state_tl}
%    To return to the saved float state execute |\g_saved_float_state_tl|.
%    \begin{macrocode}
\tl_new:N \g_saved_float_state_tl
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_redistributed_defer_list_float:n}
%    This function is used to look at each float on the |\g_xor_area_DDD_float_seq|
%    list in turn, moving those floats whose callouts have
%    been typeset to |\g_xor_floats_active_seq| for consideration for (one day)
%    float pages, and for allocating to text page float areas.
%
%    Floats whose callouts are still on MVL are placed on |\g_xor_floats_mvl_seq|.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_redistributed_defer_list_float:n #1 {
%%% local????? FIX
  \tl_set:Nn \g_xor_curr_float_box_tl {#1}
  \xor_extract_this_float_core_values:N #1
%<*trace>
  \trace:n { #1:~\LastMark{\g_xor_this_class_tl}~ ???~\int_use:N \g_xor_this_flseq_int }
%</trace>
  \int_compare:nNnTF {0\LastMark{\g_xor_this_class_tl}} < \g_xor_this_flseq_int
  {
%<*trace>
    \trace:n {#1:~ not~ really~ deferred }
%</trace>
    \seq_gput_right:Nn \g_xor_floats_mvl_seq #1
  }
  {
%<*trace>
    \trace:n {#1:~ callout~ has~ been~ typeset}
%</trace>
    \seq_gput_right:Nn \g_xor_floats_active_seq #1
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsection{Preassign deferred floats}
%
%
%
% \begin{macro}{\xor_place_deferred_floats:}
%
%    The |\xor_place_deferred_floats:| is supposed to distribute from
%    previous pages (i.e., from the top of |\g_xor_area_DDD_float_seq| or more exactly
%    those currently on the |\g_xor_floats_active_seq| since the
%    |\g_xor_area_DDD_float_seq| was
%    already split when trying to build float pages) into the areas
%    of the page to be build. After all we know that for those floats
%    the call outs are on previous pages so testing for them
%    is unnecessary and we could save time by bypassing this stuff.
%
%    On the other hand if we have flush points in the upcoming text
%    all our placements might be wrong, so perhaps this doesn't really
%    save so much time after all and the extra complication might not
%    be worth the effort.
%
%    Perhaps a compromise is to make a first column grab without any
%    floats to see if we end up with a flush point (not implemented).
%
%    So if we don't do this then the only thing we need to do at this
%    point is to move the floats from the |\g_xor_floats_mvl_seq| to the end of
%    the |\g_xor_floats_active_seq|.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_place_deferred_floats: {
%<*trace>
  \trace_push:n{xor_place_deferred_floats:}
%</trace>
  \seq_gconcat:NNN \g_xor_floats_active_seq
                   \g_xor_floats_active_seq
                   \g_xor_floats_mvl_seq
  \seq_gclear:N \g_xor_floats_mvl_seq
%\showfloatlists
%<*trace>
  \trace_pop:n{xor_place_deferred_floats:}
%</trace>
}
%    \end{macrocode}
%
%
%    Here is an alternate definition which does the preassigning but
%    it would need to be extended by checking for flush points or by a
%    flag that ensures that if we later encounter a flush point that
%    we know we could backtrack if necessary (e.g., the preassignment
%    might have already deferred some floats past the flush
%    point).\footnote{Extend, fix, or get rid of.}
%    \begin{macrocode}
\iffalse % we don't do it right now
\cs_new_nopar:Npn \xor_place_deferred_floats: {
%<*trace>
  \trace_push:n{xor_place_deferred_floats:}
%</trace>
%\showfloatlists
  \cs_gset_eq:NN \xor_floats_active_seq_if_empty_action: \prg_do_nothing:
  \cs_gset_eq:NN \xor_pretests_success_action: \xor_floatpage_pretests_success_action:
  \xor_trial_place_float_inner_loop:
  \seq_gconcat:NNN \g_xor_floats_active_seq
                   \g_xor_area_DDD_float_seq
                   \g_xor_floats_mvl_seq
  \seq_gclear:N \g_xor_area_DDD_float_seq
  \seq_gclear:N \g_xor_floats_mvl_seq
%\showfloatlists
%<*trace>
  \trace_pop:n{xor_place_deferred_floats:}
%</trace>
}
\fi
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_floatpage_pretests_success_action:}
%    Version of |\xor_pretests_success_action:| for use in initial phase
%    when previously deferred floats are being allocated to float areas.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_floatpage_pretests_success_action:{
%<*trace>
  \trace_push:n{xor_floatpage_pretests_success_action:}
%</trace>
  \xor_update_best_trial:
  \xor_trial_place_float_inner_loop:
%<*trace>
  \trace_pop:n{xor_floatpage_pretests_success_action:}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \newpage
%
% \subsection{Support for Balancing}
%
%
% \subsubsection{Algorithm---collection phase}
%
% \begin{itemize}
% \item Points at which balancing should occur are denoted in the source with
%   a special penalty just like ``here points'' or ``flush points''.
% \item During collection these points receive the same treatment as any other
%   special point, i.e., they are stored away in the uncut galley for later
%   use during the trials.
% \end{itemize}
%
% \subsubsection{Algorithm---trial phase}
%
% \begin{itemize}
% \item When a trial is made with a certain set of placed floats the galley is
%   cut into individual columns of a certain height (which is initially given
%   by the placement for the current floats).
% \item If a new balancing point is encountered (i.e., one for which there is
%   no known information how to balance yet) the following process is carried
%   out:
%   \begin{itemize}
%   \item
%     Column cutting is stopped and it is checked if the current
%     ``unbalanced'' cutting already fulfills the requirements for balanced
%     columns. This is the case if
%     \begin{itemize}
%     \item
%       we have produced all columns
%     \item
%       the last column is already so full that it seems pointless to shorten
%       all columns to achieve better balancing.
%     \end{itemize}
%   \item
%     If the current cutting is considered unsatisfactory then new target
%     column heights are calculated (in the hope of achieving better
%     balancing) and the trial is restarted using the new values.
%   \item
%     The ``correct'' values are approximated from the top, meaning that the
%     heights are gradually shortened until a satisfactory solution is obtained.
%   \item
%     This is done by
%    \begin{itemize}
%    \item
%      maintaining a global delta value (same for all columns) which starts
%      out at zero and is gradually increased.
%    \item
%      This delta value describes by what amount each column height has to be
%      reduced from its nominal value in the current balancing attempt.
%    \item
%      However, for columns that contain bottom floats no reduction happens as
%      long as the delta value is less than the height taken up by such floats
%      and once it exceeds this value only the difference between the two
%      values is used, i.e., $\string| \delta - \textit{bot\_float\_ht}
%      \string| $.
%    \item
%      This process iterates until a suitable balancing is achieved.
%    \end{itemize}
%    \item
%      Finally the heights needed for balancing this section are recorded and
%      the current balance point is marked as being ``processed''. The
%      remainder height (if any) in all columns is calculated and used fro
%      cutting more material in the normal way.
%   \end{itemize}
%   \item
%     If during cutting (for example when restarting a trial) a balance point
%     is encountered for which balancing information already exists (marked as
%     ``processed'' then this information (i.e., the required column heights
%     for the balanced part) are recalled and the cutting proceeds using these
%     values.
%   \item
%     Once all columns are cut fully the trial is evaluated as usual
%     (determining if the current placement of floats is valid).
%     \begin{itemize}
%     \item
%       If yes, the trial is recorded as the best one so far (see float
%       placement algorithm) and the next float is tried.
%     \item
%       If no, a different placement for the current float is tried (or the
%       float is deferred.
%     \item
%       In any case, the column structure will be changed this way, thus all
%       previously calculated column values for balancing need to be redone in
%       the next trial. This can be done by marking all balancing points as
%       "unprocessed"
%     \end{itemize}
% \end{itemize}
%
% \subsubsection{Algorithm---bells and whistles}
%
% There are many way that can be envisioned to allow customisation of this
% algorithm, here are a few:
% \begin{itemize}
% \item
%   Measure the amount of remaining space for all columns, if the space is too
%   small in any of them, do not balance.
% \item
%   It should be possible to extend the algorithm to have only certain column
%   participate in balancing, e.g., in a 3-col layout the first 2 \ldots
% \end{itemize}
%
%
%
% \subsubsection{Algorithm---some more details}
%
% When the columns are cut for a trial the mechanism works (1000 feet high and
%   handwaving) as follows.
% \begin{itemize}
% \item
%   First the previously collected material is placed back onto the
%   main vertical list (with a special marker at the end to be able to take it
%   off in case the trial fails (or even if it works out well).
% \item
%   Then columns are cut according to column sizes determined by the current
%   float trial (i.e., depending on the placement of trial floats).
% \item
%   Then, in case we already have balanced some blocks on this page, the
%   algorithm switches to a high speed output routine that simply jumps from
%   break point to break point until it hits the balance points it already
%   knows about.
% \item
%   After that, or when no such blocks exist yet, the output routine is
%   switched (back) to the column grabbing routine and the column heights are
%   adjusted to what is left on the page (in case we had balanced blocks). The
%   correct values for the column heights have been calculated previously when
%   the blocks were balanced.
% \item
%   The moment the cutting hits a previously unknown balance point
%   penalty\footnote{Not really unknown, as we have seen it during collection,
%   but unknown in the sense that we haven't balanced anything for it.}  it
%   will switch to some special balancing routine which will take over
%   processing for a while.
%   \begin{itemize}
%   \item
%     If the balancing point is encountered for the first time the routine will
%     check if by any change the cutting is already ok (which currently is
%     defined to be as
%     \begin{itemize}
%     \item
%       currently cutting the last column
%     \item
%       the last column is more or less full.
%     \end{itemize}
%     This is clearly sub-optimal, but for the moment it is a good enough
%     approximation.
%     \begin{itemize}
%     \item
%       If balancing is bad the currently used column heights are reduced by
%       some amount (depends on how far we are probably away from a good
%       balancing value) and then everything is removed from the MVL via some
%       cleanup output routine and then the whole collected material is placed
%       again onto it and cutting is retried with the new values.
%     \item
%       Important: the float trial situation must not change, that is the
%       restart has to happen in the inner loop of the bigger float trial
%       loop.
%     \item
%       Also important: we know that we are looking to reach some
%       balancing point and by reducing the column heights we may actually
%       never reach it again (and ergo not return to the balancing procedure
%       but ending up in the part that looks at the whole column and
%       determines whether or not the float trial was successful. That of
%       course would be a disaster since we currently use small column hts for
%       the balancing part somewhere in the middle of the page! So we have to
%       record that we are in balancing mode and if the cutting routine
%       |\xor_OR_grab_some_cols:nnnn| cuts the last column (and only then) and
%       we finish it without having reached the balancing point once more we
%       have shortened the columns too much (very easy to do if headings or
%       footnotes or anything is in the material which doesn't allow breaking
%       after every line). If that is the case we need to back up a
%       bit. Correct approach would be to now slowly enlarge the column
%       heights again and then make some final decisions which of the
%       balancing trials actually work best (using all kind of bells and
%       whistles as used in the multicol package implementation). Right now we
%       take the simple approach and claim that the balancing trial before was
%       the one that is best. So we enlarge the heights once more, set a
%       special flag to be evaluated in the balancing routine, then remove all
%       remaining material from the MVL, put the whole collected material on
%       once more and start recutting for a final time.
%     \item
%       This time we should reach the balancing point again during cutting,
%       jump to the balancing routine, there see the flag (we just set) and
%       decide that therefore this set of column height values is the one to
%       use for balancing. This will then be recorded as being the one to use
%       for this balancing point. In addition this balancing point will be
%       marked as processed.
%     \item
%       Another way to reach this state is that after cutting and switching to
%       the balancing process, the routine at some point decides that the
%       current trial balancing is already good enough (again that really
%       depends on how the process to arrive at the best balancing is worked
%       out but right now this is one way to get to this final state).
%     \end{itemize}
%   \end{itemize}
% \item
%   Once the balancing is done, the remainder space in each column is
%   calculated and the cutting for it is restarted using those values. Since
%   the material after the balancing point is already on the MVL all that is
%   necessary is to make sure that we are back to cutting for column one and
%   switch to the appropriate output routine.
% \item
%   Now either all columns can be cut and the float trial ends or another
%   balance point is encountered along the way in which case everything starts
%   all over (with the difference that we have one additional block for which
%   the balancing info is now known).
% \item
%   At the end of the day a page has finally be cut (theoretically since most
%   of the time the material has simply been thrown away after looking at it).
%   At this point the float trial is evaluated resulting either in accepting
%   the float position as good or rejecting it for one or the other
%   reason. Then the our loop will attempt to place another float onto the
%   page (or place the current one in a different area and start another
%   trial).
% \item
%   Important to notice here: if the next trial is started all our information
%   about the balancing is worthless. After all, placing an additional float
%   onto the page or moving one around changes all the column heights, at
%   least potentially. So for the next trial we have to start all over and do
%   all balancing again.
% \item
%   Finally the outer loop will run out of floats to try and a best solution
%   has been determined. At that point the collected material is copied for a
%   final time onto the MVL and a slightly different output routine is
%   installed. This one makes use of our known information about the balanced
%   blocks (from the last successful trial) and uses this information to cut
%   individual bits and put them together to form the final page.
% \end{itemize}
%
%
%  \subsubsection{User interface commands}
%
% \begin{macro}{\balancecolumns}
%    Add a balance point into the galley. When we process this code we will be
%    collecting material so we increment |\g_xor_collect_balance_seen_int|
%    (i.e., number of balance points seen during collection and we record
%    which floats are ``before'' that point by storing the current
%    |\g_xor_flseq_int| in
%    |\g_xor_balance_<NUM>_last_float_int|.\footnote{before or after we
%    increment?}
%    \begin{macrocode}
\cs_new_nopar:Npn \balancecolumns {
%<*trace>
  \trace_push:n{balancecolumns}
%</trace>
  \int_gincr:N\g_xor_collect_balance_seen_int
  \int_gset:cn
      {g_xor_balance_
       \int_use:N \g_xor_collect_balance_seen_int
       _last_float_int}
      {\int_use:N \g_xor_flseq_int}
  \xor_add_badly_guarded_penalty:N \c_xor_output_balance_penalty
%<*trace>
  \trace_pop:n{balancecolumns}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%  \subsubsection{Variables used}
%
% \begin{macro}{\g_xor_best_trial_col_hts_balance_NUM_tl}
%    For balance point |NUM| (which is 0, 1,\ldots) this macro holds
%    the column heights for all columns (parts) that we will need for
%    getting a balanced result.
%    \begin{macrocode}
\tl_new:c {g_xor_best_trial_col_hts_balance_0_tl}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_balance_delta_dim}
% \begin{macro}{\g_xor_saved_balance_delta_dim}
%     Nominal amount of space not used in all columns when trial
%    balancing. The actual amount might be smaller due to bottom floats in a
%    column
%    \begin{macrocode}
\dim_new:N \g_xor_balance_delta_dim
\dim_new:N \g_xor_saved_balance_delta_dim
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\g_xor_balance_failed_bool}
%    Boolean to indicate that the current balancing trial has failed.
%    \begin{macrocode}
\bool_new:N \g_xor_balance_failed_bool
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_balance_finish_bool}
%    Indicate that we are really finished balancing.\footnote{logic should be
%    checked why do we need two booleans here?}
%    \begin{macrocode}
\bool_new:N \g_xor_balance_finish_bool
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_balance_point_expected_bool}
%    Boolean to indicate that we expect the grab column routine to see a
%    balance point at the end of its last column (if not we have not picked up
%    enough material).
%    \begin{macrocode}
\bool_new:N \g_xor_balance_point_expected_bool
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_balance_NUM_last_float_int}
%    \begin{macrocode}
\int_new:c{g_xor_balance_0_last_float_int}
\int_new:c{g_xor_balance_1_last_float_int}
\int_new:c{g_xor_balance_2_last_float_int}
\int_new:c{g_xor_balance_3_last_float_int}
\int_new:c{g_xor_balance_4_last_float_int}
\int_new:c{g_xor_balance_5_last_float_int}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_collect_balance_seen_int}
%    Number of balance points encountered during collection.
%    \begin{macrocode}
\int_new:N \g_xor_collect_balance_seen_int
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\g_xor_trial_balance_seen_int}
%    Number of balance points encountered in a trial (or when generating the
%    final columns) so far.
%    \begin{macrocode}
\int_new:N \g_xor_trial_balance_seen_int
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_trial_balance_done_int}
%    Number of balance blocks we already know the column heights for in the
%    current trial.
%    \begin{macrocode}
\int_new:N \g_xor_trial_balance_done_int
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_best_balance_done_int}
%    Number of balance blocks we already know the column heights for
%    in the nest trial so far.
%    \begin{macrocode}
\int_new:N \g_xor_best_balance_done_int
%    \end{macrocode}
% \end{macro}
%
%
%
%  \subsubsection{Helper functions}
%
%
%
%
% \begin{macro}{\xor_if_grab_for_balance_done:TF}
% \begin{macro}{\xor_if_grab_for_balance_done:T}
% \begin{macro}{\xor_if_grab_for_balance_done:F}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_if_grab_for_balance_done:TF {
  \if_int_compare:w \g_xor_trial_balance_seen_int
             < \g_xor_trial_balance_done_int
%<*trace>
     \trace:n{BALANCE:~ doing~ existing~ block~
            \int_use:N \g_xor_trial_balance_seen_int <
            \int_use:N \g_xor_trial_balance_done_int
        }
%</trace>
     \exp_after:wN \use_i:nn
   \else:
%<*trace>
     \trace:n{BALANCE:~ working~ on~ new~ block}
%</trace>
     \exp_after:wN \use_ii:nn
   \fi:
}
\cs_new_nopar:Npn \xor_if_grab_for_balance_done:T {
  \if_int_compare:w \g_xor_trial_balance_seen_int
            < \g_xor_trial_balance_done_int
%<*trace>
     \trace:n{BALANCE:~ doing~ existing~ block~
            \int_use:N \g_xor_trial_balance_seen_int <
            \int_use:N \g_xor_trial_balance_done_int
        }
%</trace>
     \exp_after:wN \use:n
   \else:
     \exp_after:wN \use_none:n
   \fi:
}
\cs_new_nopar:Npn \xor_if_grab_for_balance_done:F {
  \if_int_compare:w \g_xor_trial_balance_seen_int
             < \g_xor_trial_balance_done_int
%<*trace>
     \trace:n{BALANCE:~ doing~ existing~ block~
            \int_use:N \g_xor_trial_balance_seen_int <
            \int_use:N \g_xor_trial_balance_done_int
        }
%</trace>
     \exp_after:wN \use_none:n
   \else:
%<*trace>
     \trace:n{BALANCE:~ working~ on~ new~ block}
%</trace>
     \exp_after:wN \use:n
   \fi:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
%  \subsubsection{Balancing output routines}
%
%
% \begin{macro}{\xor_OR_trial_grab_balance_setup:}
%
%
%    \begin{macrocode}
\cs_new_nopar:Npn  \xor_OR_trial_grab_balance_setup:  {
%<*trace>
  \trace_push:n{xor_OR_trial_grab_balance_setup:}
%</trace>
%    \end{macrocode}
%
%    In case there is a flush penalty in the collection we have to
%    find out if we see it again during the trial. So we record the
%    number of flush points we see during the trial. Same happens for
%    here and balance points.
%    \begin{macrocode}
  \int_gzero:N \g_xor_trial_flush_seen_int
  \int_gzero:N \g_xor_trial_here_seen_int
  \int_gzero:N \g_xor_trial_balance_seen_int
%<*trace>
  \trace:n{BALANCE:~ g_xor_trial_balance_seen_int ~<-~
                    \int_use:N \g_xor_trial_balance_seen_int}
  \trace:n{BALANCE:~ g_xor_trial_balance_done_int ~==~
                    \int_use:N \g_xor_trial_balance_done_int}
%</trace>
  \int_gzero:N \g_xor_curr_col_int
%% need \g_xor_curr_col_block_int setting?
  \xor_if_grab_for_balance_done:TF
     {
%<*trace>
      \trace:n{BALANCE:~ fast~ regrabbing~ balanced blocks}
%</trace>
      \global\vsize\maxdimen
      \global\output{\xor_OR_regrab_balanced_material:}
     }
     {
      \global\output{\xor_OR_grab_trial_cols:}
      \xor_OR_trial_grab_next_col_setup:
     }
%<*trace>
  \trace_pop:n{xor_OR_trial_grab_balance_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xor_OR_regrab_balanced_material:}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_OR_regrab_balanced_material: {
%<*trace>
  \trace_push:n{xor_OR_regrab_balanced_material:}
  \trace:n{output~pen:~ \the\outputpenalty}
  \trace:n{vsize:~ \the\vsize;~ pagegoal:~ \the\pagegoal}
%</trace>
  \box_gclear:N \c_two_hundred_fifty_five
  \box_gclear:N \g_xor_footins_box
  \int_compare:nNnTF \outputpenalty=\c_xor_output_balance_penalty
    {
     \int_gincr:N \g_xor_trial_balance_seen_int
     \int_compare:nNnT \g_xor_trial_balance_seen_int =
                       \g_xor_trial_balance_done_int
        {
         \global\output{\xor_OR_grab_trial_cols:}
%<*trace>
         \trace:n{BALANCE:~ setting~ up~ new~ col~ hts:~
                \tl_to_str:N \g_xor_balance_trial_col_hts_tl}
%</trace>
         \g_xor_balance_trial_col_hts_tl
         \int_gzero:N \g_xor_curr_col_int
         \xor_OR_trial_grab_next_col_setup:
        }
    }
%    \end{macrocode}
%    If it is not a balance point it might be a here or a flush point in which
%    case we record that fact and carry on. Otherwise we simply ignore the
%    penalty.
%    \begin{macrocode}
    {
     \int_compare:nNnTF \outputpenalty=\c_xor_output_here_float_penalty
       { \int_gincr:N \g_xor_trial_here_seen_int }
       {
         \int_compare:nNnT \outputpenalty=\c_xor_output_flush_float_penalty
          { \int_gincr:N \g_xor_trial_flush_seen_int }
       }
    }
%<*trace>
  \trace_pop:n{xor_OR_regrab_balanced_material:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\xor_OR_trial_balance:NN}
%
%    \begin{macrocode}
%
% #1 what to do next if balancing failed
% #2 what to do next if balancing succeeded (not used right now)
%
\cs_new_nopar:Npn \xor_OR_trial_balance:NN #1 #2 {
%<*trace>
  \trace_push:n{xor_OR_trial_balance:NN~  \exp_not:n{(#1 #2)}}
  \trace:n{BALANCE:~ balance~ point~ seen~ again}
%</trace>
  \xor_remove_guard_box_from_cclv:
%    \end{macrocode}
%    Doing balancing in earnest on a newly detected balancing point. Look how
%    good we are with this trial, if necessary adjust
%    |\g_xor_balance_delta_dim| and recourse.
%
%    First some safety measure: if the current |\vsize| gets really small we
%    better stop any balancing attempt immediately.
%    \begin{macrocode}
  \dim_compare:nNnT \vsize < {2\baselineskip}
    { \bool_gset_true:N \g_xor_balance_finish_bool }
%    \end{macrocode}
%    This is a temp solution for crude balancing. Once we shortened the vice so
%    much that we didn't got to the balancing point we retreat to the last
%    good solution and give up. \textbf{To be replaced by something more
%    granular using multicols methods one day.}
%    \begin{macrocode}
  \bool_if:NF \g_xor_balance_finish_bool
   {
    \int_compare:nNnTF \g_xor_curr_col_int < \g_xor_cols_int
      {
%<*trace>
       \trace:n{BALANCE:~ point~ too~ early;~ aborting}
%</trace>
%    \end{macrocode}
%    Save the old delta in case we have to use it after all.
%    \begin{macrocode}
       \dim_gset:Nn \g_xor_saved_balance_delta_dim \g_xor_balance_delta_dim
%    \end{macrocode}
%
%    \begin{macrocode}
       \dim_set:Nn \l_tmpa_dim {\vsize/\g_xor_cols_int}
       \dim_gadd:Nn \g_xor_balance_delta_dim {.5\l_tmpa_dim}
%       \xor_snap_to_grid:nn \g_xor_balance_delta_dim \g_xor_grid_point_sep_dim
%%B
%<*trace>
       \trace:n{BALANCE:~ delta~ <-~ \dim_use:N\g_xor_balance_delta_dim}
%</trace>
       \bool_gset_true:N \g_xor_balance_failed_bool
       \bool_gset_true:N \g_xor_balance_point_expected_bool
%<*trace>
       \trace:n{BALANCE:~ g_xor_balance_point_expected_bool~ <-~ true}
%</trace>
      }
% we are in the last column but the result may look bad
      {
       \vbox_set:Nn \l_tmpa_box
                    {\vbox_unpack_clear:N \c_two_hundred_fifty_five
                     \ifvoid\g_xor_footins_box   \else
                       \vskip \g_xor_footins_skip
                       \vbox_unpack_clear:N \g_xor_footins_box
                     \fi
                    }
%    \end{macrocode}
%
%    \begin{macrocode}
       \dim_compare:nNnT {\vsize - \box_ht:N\l_tmpa_box} >
                         {\baselineskip}
          {
%<*trace>
           \trace:n{BALANCE:~ not~ nicely~ balanced;~ retry}
%</trace>
           \bool_gset_true:N \g_xor_balance_failed_bool
           \bool_gset_true:N \g_xor_balance_point_expected_bool
%<*trace>
       \trace:n{BALANCE:~ g_xor_balance_point_expected_bool~ <-~ true}
%</trace>
           \dim_gset:Nn \g_xor_saved_balance_delta_dim \g_xor_balance_delta_dim
           \dim_gadd:Nn \g_xor_balance_delta_dim \baselineskip
%           \xor_snap_to_grid:nn \g_xor_balance_delta_dim \g_xor_grid_point_sep_dim
          }
      }
    }
    \bool_if:NTF \g_xor_balance_failed_bool
      {
%<*trace>
        \trace:n{BALANCE:~ fail;~ abort}
%</trace>
        \bool_gset_false:N \g_xor_balance_failed_bool
        \box_gclear:N \c_two_hundred_fifty_five
        \box_gclear:N \g_xor_footins_box
        \xor_OR_cleanup_setup:N \xor_trial_get_balance_loop:
      }
      {
% if too much space left over do something  (not done .. pretend ok)
%<*trace>
        \trace:n{BALANCE:~ success;~ delta~ used:~ \dim_use:N \g_xor_balance_delta_dim}
%</trace>
        \tl_gclear:N \g_tmpa_tl
%%B
        \tl_gclear:N \g_xor_balance_trial_col_hts_tl
% not quite correct here: will fail with middle floats!
        \xor_forall_columns:n
          {
           \dim_set_eq:Nc \l_tmpa_dim
                       {g_xor_ht_col_
                        \xor_curr_col_block:
                        _dim}
% calculate the real delta that was used in this column (actually could be
% saved rather than calculated twice
           \xor_calculate_delta_to_use:N \l_tmpb_dim
           \dim_sub:Nn \l_tmpa_dim \l_tmpb_dim
           \tl_gput_right:Nx \g_tmpa_tl
            {
             \exp_not:N \dim_gset:Nn
             \exp_not:c  {g_xor_ht_col_ \xor_curr_col_block: _dim}
             {\dim_use:N \l_tmpa_dim }
            }
% next actually should be the remaining space (which it isn't if
% floats are allocated!)
%%B
          \tl_gput_right:Nx \g_xor_balance_trial_col_hts_tl
           {
            \exp_not:N \dim_gset:Nn
            \exp_not:c  {g_xor_ht_col_ \xor_curr_col_block: _dim}
             {\dim_use:N \l_tmpb_dim }
           }
          }
        \tl_gset_eq:cN {g_xor_best_trial_col_hts_balance_
                         \int_use:N \g_xor_trial_balance_seen_int
                         _tl}
                        \g_tmpa_tl
%<*trace>
        \trace:n{BALANCE:~ g_xor_best_trial_col_hts_balance_
                      \int_use:N \g_xor_trial_balance_seen_int
                      _tl ~=~ \tl_to_str:N \g_tmpa_tl }
%</trace>
        \int_gincr:N \g_xor_trial_balance_done_int
%<*trace>
        \trace:n{BALANCE:~ g_xor_trial_balance_done_int ~<-~
                     \int_use:N \g_xor_trial_balance_done_int}
        \trace:n{BALANCE:~ solution~ found;~ restart~ cutting~ remaining~ columns}
%</trace>
% restart main trial
        \dim_gzero:N \g_xor_balance_delta_dim
%    \end{macrocode}
%     Finished with balancing so not expecting to see a balance point
%     again\footnote{FIX: we can probably just use a single boolean not two}
%    \begin{macrocode}
        \bool_gset_false:N \g_xor_balance_point_expected_bool
        \bool_gset_false:N \g_xor_balance_finish_bool
%<*trace>
        \trace:n{BALANCE:~ g_xor_balance_point_expected_bool~ <-~ false}
%</trace>
        \box_gclear:N \c_two_hundred_fifty_five
        \box_gclear:N \g_xor_footins_box
%    \end{macrocode}
%    We have stored the column heights for the rest of the columns in
%    |\g_xor_balance_trial_col_hts_tl| and can now restart cutting column
%    material normally (restarting with column 1).
%    \begin{macrocode}
%<*trace>
        \trace:n{BALANCE:~ new~ col~ heights:~ \tl_to_str:N\g_xor_balance_trial_col_hts_tl}
%</trace>
        \g_xor_balance_trial_col_hts_tl
        \int_gzero:N \g_xor_curr_col_int
%% need \g_xor_curr_col_block_int setting?
% BUG: something is resetting balance_seen to 0
        \xor_OR_trial_grab_next_col_setup:
      }
%<*trace>
  \trace_pop:n{xor_OR_trial_balance:NN}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_trial_get_balance_loop:}
%    Place the galley box back on the MVL. Needs to be done via the
%    special output routine call |\marks_OR_restore_state:nn| to ensure that
%    \TeX's primitive marks reflect the `logical' previous page rather
%    than the previous actual output routine call.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_trial_get_balance_loop: {
%<*trace>
  \trace_push:n{xor_trial_get_balance_loop:}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
  \deadcycles\c_zero
  \cs_gset_eq:NN \xor_floats_active_seq_if_empty_action: \xor_OR_best_cols_setup:
  \cs_gset_eq:NN \xor_pretests_success_action: \xor_OR_trial_grab_cols_setup:
%    \end{macrocode}
%
%    |\marks_OR_restore_state:nn| state is a special output routine those
%    only purpose is to reinitialize the state of the mark
%    mechanism. Its argument is executed at the of that OR and must
%    (!) set up a new OR else we find ourselves in trouble.
%    \begin{macrocode}
  \marks_OR_restore_state:nn
   {
%    \end{macrocode}
%    Initialising the grabbing trials means putting the saved material
%    back onto the MVL and reinitialising the here float list.
%    \begin{macrocode}
%<*trace>
    \trace:n{copying~ g_xor_hold_page_box~ onto~ MVL}
%</trace>
    \vbox_unpack:N \g_xor_hold_page_box
%    \end{macrocode}
%    To be able to identify the end of the material for trials for
%    cutting the galley we mark it with a special penalty.
%    \begin{macrocode}
    \xor_add_badly_guarded_penalty:N \c_xor_output_collect_penalty
   }
   {
    \seq_gset_eq:NN \g_xor_floats_here_seq \g_xor_saved_floats_here_seq
%    \end{macrocode}
%
%    The we can start the actual loop: if we run with floats we go to \\
%    |\xor_trial_place_float_inner_loop:| otherwise we immediately setup the
%    grab column OR.\footnote{fix docu}
%    \begin{macrocode}
%   \bool_if:NTF \g_xor_trial_with_floats_bool
%       { \xor_trial_place_float_inner_loop: }
%       { \xor_OR_trial_grab_cols_setup: }
%    \end{macrocode}
%    \begin{macrocode}
    \xor_initialize_balance_footins_action:
    \xor_OR_trial_grab_balance_setup:
    }
%<*trace>
  \trace_pop:n{xor_trial_get_balance_loop:}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%  \subsubsection{Balancing in the best column phase}
%
%
%
% \begin{macro}{\xor_OR_best_balance_setup:}
% \footnote{FIX combine with calling macro}
%    \begin{macrocode}
\cs_new_nopar:Npn  \xor_OR_best_balance_setup:  {
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_set_best_trial_col_hts:n}
%    Sets |\g_xor_best_trial_col_hts_tl| with each column getting the height
%    specified in the argument (|\g_xor_curr_col_int| is the current column
%    number and can be used in the argument).
%
%    Calling |\g_xor_best_trial_col_hts_tl| doesn't change the current
%    |\vsize| but sets for each column block |\g_xor_ht_col_NUM_BLOCK_dim| to hold a new
%    height which can then be assigned to |\vsize| when cutting the galley for
%    the column NUM (or column block).
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_set_best_trial_col_hts:n #1 {
  \tl_gclear:N \g_xor_best_trial_col_hts_tl
  \xor_forall_column_blocks:n{
    \tl_gput_right:Nx \g_xor_best_trial_col_hts_tl
       {
        \exp_not:N \dim_gset:Nn
        \exp_not:c  {g_xor_ht_col_ \xor_curr_col_block: _dim}
                    { #1 }
      }
  }
%<*trace>
  \trace:n{Saving~ column~ heights:}
  \trace:n{g_xor_best_trial_col_hts_tl ~:=~
         \tl_to_str:N \g_xor_best_trial_col_hts_tl}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \newpage
%
% \subsection{Support for Flush Points}
%
%
% \begin{macro}{\g_xor_flush_seen_bool}
% \begin{macro}{\g_xor_flush_failed_bool}
%
%    |\g_xor_flush_seen_bool| is set to true if we encounter a flush penalty
%    during collection.
%
%    |\g_xor_flush_failed_bool| is set to true if we fail a trial due to
%    placing the float after the flush penalty.
%    \begin{macrocode}
\bool_new:N \g_xor_flush_seen_bool
\bool_new:N \g_xor_flush_failed_bool
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\flushfloats}
%
% User command to indicate that floats should be flushed.
%
% Supported variants:
% \begin{itemize}
% \item
%    Flush only one (some) types or all types (default).
%
% \item
%    Fuzzyflush or, more precisely, flush-to-this-column
%      or -page or -spread.\footnote{Right now "spread" is not implemented.}
% \end{itemize}
%
%    \begin{macrocode}
\DeclareDocumentCommand\flushfloats { o O{strict} }
  { \xor_add_flush_floats_point:nn {#1} {#2} }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clearpage}
%    \LaTeX's |\clearpage| command now looks like this:
%    \begin{macrocode}
\cs_set_nopar:Npn\clearpage{ \flushfloats \newpage }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\doubleclearpage}
%    \LaTeX's |\doubleclearpage| command also needs a new
%    definition:\footnote{But not this one :-) FIX!}
%    \begin{macrocode}
\cs_set_nopar:Npn\doubleclearpage{ \clearpage }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_add_flush_floats_point:nn}
%
%    Parts of the flushpenalty (all types) data structure:
% \begin{itemize}
% \item
%    |\g_xor_flush_|\meta{num}|_min_col_int|
%
% \item
%    |\g_xor_saved_flush_|\meta{num}|_min_col_int|
%
% \item
%    |\flush@prev@float@num@|\meta{num}\footnote{what is this Chris?}
%
% \item
%    |\g_xor_collect_flush_seen_int| is the number of these so that
%    \meta{num} has range [1, |\g_xor_collect_flush_seen_int|]
% \end{itemize}
%
%    In addition, whilst doing an fp trial we need |\g_xor_trial_flush_seen_int|
%    to record that we have, in this trial so far, seen the
%    flush points in the interval \\[0pt]
%    [1, |\g_xor_trial_flush_seen_int|].
%
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_add_flush_floats_point:nn #1 #2 {
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gincr:N\g_xor_collect_flush_seen_int
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gset:cn {g_xor_flush_
                \int_use:N\g_xor_collect_flush_seen_int
                _min_col_int}{1}
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gset_eq:cN
      {g_xor_flush_
       \int_use:N \g_xor_collect_flush_seen_int
       _last_float_int}
      \g_xor_flseq_int
%    \end{macrocode}
%    If |#1| is |\NoValue| the current flush point affects all float
%    sequence classes, thus we store in
%    |\g_xor_flush_|\meta{num}|_classes_clist| a list of all float sequence
%    classes separated by semicolons. Otherwise we assume that we got
%    a single float type(!) as argument and flush the corresponding
%    class.
%    \begin{macrocode}
  \IfNoValueTF{#1}{
%FMi tmp!
    \__seq_push_item_def:n { \exp_not:N \__seq_item:n \exp_not:n { ##1 , } }
    \cs_set_nopar:cpx {g_xor_flush_ \int_use:N \g_xor_collect_flush_seen_int  _classes_clist }
      {\g_xor_float_classes_seq}
    \__seq_pop_item_def:
  }
  {
    \cs_if_free:cTF {g_xor_type_ #1 _class_tl}
    { \ErrorArgumentNotAFloatType }
    {
      \clist_gset_eq:cc
         {g_xor_flush_ \int_use:N \g_xor_collect_flush_seen_int _classes_clist}
         {g_xor_type_ #1 _class_tl}
    }
  }
%    \end{macrocode}
%    The argument |#2| holds the fuzziness of the flush point which
%    currently can be either |strict|, |column| or |page|.
%    We link |\xor_flush_fuzziness_|\meta{num}|_action:| to the code stored in
%    |\xor_check_flush_#2:| after making sure that such code
%    exists.\footnote{Improve error handling (as elsewhere) and this check
%    should probably come first!}
%    \begin{macrocode}
  \cs_if_free:cTF {xor_check_flush_#2:}
  {\userinputERROR }
  {
    \cs_gset_eq:cc
    {xor_flush_fuzziness_ \int_use:N\g_xor_collect_flush_seen_int _action:}
    {xor_check_flush_#2:}
%<*trace>
    \trace:n{xor_flush_fuzziness_ \int_use:N\g_xor_collect_flush_seen_int
           _action: \space
            =:~ \exp_not:c {xor_check_flush_#2:}
    }
%</trace>
%    \end{macrocode}
%    Finally we add the penalty the indicates the flush point in the galley
%    and triggers the collect output routine.
%    \begin{macrocode}
  \xor_add_badly_guarded_penalty:N \c_xor_output_flush_float_penalty
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_collect_flush_seen_int}
%    The number |\g_xor_collect_flush_seen_int| records the number of flush
%    points we have seen during collection.
%    \begin{macrocode}
\int_new:N \g_xor_collect_flush_seen_int
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_trial_flush_seen_int}
%    The number |\g_xor_trial_flush_seen_int| records the number of flush
%    points we have seen so far during a trial, i.e., it will be
%    initialized to zero at the beginning of the trial and advanced by
%    one for each flush point encountered.
%    \begin{macrocode}
\int_new:N \g_xor_trial_flush_seen_int
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_flush_NUN_last_float_int}
% \begin{macro}{\g_xor_flush_NUM_min_col_int}
% \begin{macro}{\g_xor_flush_NUM_classes_clist}
% \begin{macro}{\xor_flush_fuzziness_NUM_action:}
%
%    For each flush point we have a data structure in which we store
%    relevant information. This data structure is provided by a set of
%    macros which can be accessed by using the number of the current
%    flush point and constructing command names from it, e.g., to get at
%    the ``flush min col'' for the flush point with number 3 would be
%    |\g_xor_flush_3_min_col_int|.
%    |\g_xor_flush_|\meta{num}|_min_col_int| holds the column number in which we
%    last seen the flush penalty while trying to find a solution for
%    the current page. This is initialized to 1 in |\xor_OR_collect:| when
%    a flush penalty is encountered during collection (since 1 is the
%    earliest column in which the flush penalty finally may fall). By
%    adding additional floats to the page the penalty might move to a
%    later column but normally not back to an earlier
%    one\footnote{There is a possibility that this happens if there is
%    enough space vanishing at the new break.}  If we end up with the
%    flush penalty moving backwards we force a break at this point
%    until we reach the column where it was before. The reason for
%    this action is that we might have allocated floats to later
%    columns that would otherwise end after the flush penalty.
%
%    If by adding floats to the trials the flush penalty is moved to
%    the next page we set |\g_xor_flush_|\meta{num}|_min_col_int| to
%    |\maxdimen|. The actual test to see if a flush penalty still
%    belongs to the current page is to check against |\g_xor_curr_col_int|
%    (so |\g_xor_curr_col_int+1| would be sufficient, but using
%    |\maxdimen| avoids calculations.
%
%    |\g_xor_flush_|\meta{num}|_classes_clist| holds a comma separated
%    list of float types which
%    are affected by the current flush point.
%
%    |\xor_flush_fuzziness_action_|\meta{num}|:| holds the fuzziness associated with
%    the flushpoint, valid values are |strict| and |page|.
%
%    By defining (some of) them on top-level we avoid unnecessary
%    entries on the savestack since they would otherwise be
%    constructed (locally) first within the output routine (when doing
%    |\ifx| testing), resulting in |\relax| being stored on the
%    savestack.
%    \begin{macrocode}
\int_new:c {g_xor_flush_1_last_float_int}
\cs_new_eq:cN {g_xor_flush_1_classes_clist}   \ERROR
\int_new:c {g_xor_flush_1_min_col_int}
\int_new:c {g_xor_saved_flush_1_min_col_int}
\cs_new_eq:cN {xor_flush_fuzziness_1_action:} \ERROR
\int_new:c  {g_xor_flush_2_last_float_int}
\cs_new_eq:cN {g_xor_flush_2_classes_clist}   \ERROR
\int_new:c {g_xor_flush_2_min_col_int}
\int_new:c {g_xor_saved_flush_2_min_col_int}
\cs_new_eq:cN {xor_flush_fuzziness_2_action:} \ERROR
\int_new:c  {g_xor_flush_3_last_float_int}
\cs_new_eq:cN {g_xor_flush_3_classes_clist}   \ERROR
\int_new:c {g_xor_flush_3_min_col_int}
\int_new:c {g_xor_saved_flush__min_col_int}
\cs_new_eq:cN {xor_flush_fuzziness_3_action:} \ERROR
\int_new:c {g_xor_here_1_min_col_int}
\int_new:c {g_xor_here_2_min_col_int}
\int_new:c {g_xor_here_3_min_col_int}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\g_xor_flush_max_classes_clist}
%    |\g_xor_flush_max_classes_clist| holds the concatenation of all \\
%    |\g_xor_flush_|\meta{num}|_classes_clist| on the page currently
%    constructed. This information is needed in case we get to a new
%    float and the preliminary tests suggests that it needs to be
%    deferred. In that case we need to know which flush points have
%    been seen previously to decide whether or not we can defer the
%    new float.
%    \begin{macrocode}
\clist_new:N \g_xor_flush_max_classes_clist
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_initialize_flush_data:}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_initialize_flush_data:{
%<*trace>
  \trace_push:n{xor_initialize_flush_data:}
%</trace>
%    \end{macrocode}
%    Does this need any documentation?
%
%    Well, we have to get rid of all information relating to flush
%    float penalties that have been typeset on the previous page and
%    move the remaining ones (if any) to the front.
%    \begin{macrocode}
  \int_set_eq:NN \l_tmpa_int \g_xor_collect_flush_seen_int
  \int_add:Nn \l_tmpa_int {-\g_xor_trial_flush_seen_int }
%<*trace>
  \trace:n{g_xor_collect_flush_seen_int~
         =~ \int_use:N \g_xor_collect_flush_seen_int\space <-~
            \int_use:N \l_tmpa_int  }
%</trace>
%    \end{macrocode}
%    Something wrong here if we get negative values!
%    \begin{macrocode}
%<*debug>
  \int_compare:nNnT \l_tmpa_int < \c_zero {\ERROR }
%</debug>
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gset_eq:NN \g_xor_collect_flush_seen_int \l_tmpa_int
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_set_eq:NN \l_tmpc_int \g_xor_trial_flush_seen_int
  \int_zero:N \l_tmpb_int
  \int_while_do:nNnn \l_tmpb_int < \l_tmpa_int
  {
    \int_incr:N \l_tmpb_int
    \int_incr:N \l_tmpc_int
%<*trace>
    \trace:n{xor_flush_fuzziness_ \int_use:N \l_tmpb_int _action:\space
           =~ \exp_not:c { xor_flush_fuzziness_ \int_use:N \l_tmpb_int _action:}\space
           <-~ \exp_not:c  {xor_flush_fuzziness_ \int_use:N \l_tmpc_int _action:}
          }
    \trace:n{g_xor_flush_ \int_use:N \l_tmpb_int _last_float_int\space
           =~ \int_use:c {g_xor_flush_
                          \int_use:N \l_tmpb_int
                          _last_float_int}
           \space <-~
           \int_use:c {g_xor_flush_ \int_use:N \l_tmpc_int
                       _last_float_int}
          }
    \trace:n{g_xor_flush_ \int_use:N \l_tmpb_int _classes_clist\space
           =~ \clist_use:c {g_xor_flush_ \int_use:N \l_tmpb_int _classes_clist}
              \space <-~
              \clist_use:c {g_xor_flush_ \int_use:N \l_tmpc_int _classes_clist}
          }
    \trace:n{g_xor_flush_ \int_use:N \l_tmpb_int _min_col_int \space <-~ 1}
%</trace>
    \cs_gset_eq:cc
      { xor_flush_fuzziness_ \int_use:N \l_tmpb_int _action:}
      { xor_flush_fuzziness_ \int_use:N \l_tmpc_int _action:}
    \int_gset_eq:cc
      {g_xor_flush_ \int_use:N \l_tmpb_int _last_float_int}
      {g_xor_flush_ \int_use:N \l_tmpc_int _last_float_int}
    \clist_gset_eq:cc
      {g_xor_flush_\int_use:N \l_tmpb_int _classes_clist}
      {g_xor_flush_\int_use:N \l_tmpc_int _classes_clist}
    \int_gset:cn {g_xor_flush_ \int_use:N \l_tmpb_int _min_col_int}{1}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
  \clist_gclear:N \g_xor_flush_max_classes_clist
%    \end{macrocode}
%    Need to reset |\g_xor_trial_flush_seen_int| in case the current macro
%    is called again too early, e.g., if it is called to initialize a
%    float page and then again to initialize a text page.
%    \begin{macrocode}
  \int_gzero:N \g_xor_trial_flush_seen_int
%<*trace>
  \trace_pop:n{xor_initialize_flush_data:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsection{Support for Here Points}
%
% A ``Here Point'' is a place in the galley at which something is
% supposed to happen. For example, a marginal note needs to be
% attached to the column, or a float needs to be inserted into the
% column (here float), or it needs to be made sure that from that
% point on there is still a certain amount of space available in the
% column.
%
% With each here point there is associated a float structure (i.e. a
% box and its corresponding |\toks| register) although in most cases
% only parts of that structure is used. In addition each here point
% has an associated dimension which denotes the amount of available
% space which is required after the here point in the column to allow
% to place the here point into this column. If this requirement is not
% met the here point is moved to the next column (or page) by ending
% the current column prematurely at the last legal breakpoint before
% the here point (not at the here point itself\footnote{It should be
% considered to allow breaking directly at the here point in special
% cases, i.e., specified at the here point declaration.}). This
% behaviour will ensure that a line of text preceding the here point
% will also be moved to the next column or page which is important in
% case of marginals and similar situations. In case of here floats it
% might not be a requirements so perhaps this should be made
% customisable.
%
% At the moment the ``type'' in the float structure is used to define
% the type of here point. E.g.,
% \begin{description}
% \item[mpar] denotes a marginal
% \item[rspace] denotes a requested space
% \item[figure,table,\ldots] all normal float types identify the here
% point as belonging to a here float.
% \end{description}
% The down side of this approach is that ``mpar'' can't be used as a
% float type  any longer and the whole approach might be too difficult
% to extend this way. This needs certainly needs a cleanup.
%
% It  is quite likely that there will be additional values that need
% storing on a per here point basis. For this reason the code below
% provides the requiredspace as a data structure external to the float
% structure. Otherwise it could probably be integrated therein.
%
% When a here point is encountered while making columns for a trial or
% for the final page, its requirements are checked. If they are
% fulfilled then a here-point-type specific function will update the
% column material (e.g. by adding a here float or a marginal).
%
% Here points are in many aspects like flush points. So most of the
% code below should not be very surprising.
%
% \begin{macro}{\g_xor_collect_here_seen_int}
%    The number |\g_xor_collect_here_seen_int| records the number of here
%    points we have seen during collection.
%    \begin{macrocode}
\int_new:N \g_xor_collect_here_seen_int
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_trial_here_seen_int}
%    The number |\g_xor_trial_here_seen_int| records the number of here
%    points we have seen so far during a trial, i.e., it will be
%    initialized to zero at the beginning of the trial and advanced by
%    one for each here point encountered.
%    \begin{macrocode}
\int_new:N \g_xor_trial_here_seen_int
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_floats_here_seq}
%    List of floats that have been assigned to here points still
%    active.\footnote{in fact they aren't really freed are they? fix}
%    \begin{macrocode}
\seq_new:N \g_xor_floats_here_seq
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_saved_floats_here_seq}
%    Saved version of the |\g_xor_floats_here_seq| while we run a through the
%    float placement trial since we need the full |\g_xor_floats_here_seq| again in
%    the next trial.
%    \begin{macrocode}
\seq_new:N \g_xor_saved_floats_here_seq
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_add_here_point:Nn}
%    |\xor_add_here_point:Nn| adds a here point to the MVL. It takes two
%    arguments: the box reference associated with the here point and
%    the vertical space that needs to be reserved for the material
%    added.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_add_here_point:Nn #1#2{
%    \end{macrocode}
%    we get passed a tl var.~containing the float box so we need to expand
%    it once before putting it into the sequence.
%    \begin{macrocode}
  \seq_gput_right:No \g_xor_floats_here_seq #1
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gincr:N \g_xor_collect_here_seen_int
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gset:cn {g_xor_here_
                \int_use:N\g_xor_collect_here_seen_int _min_col_int}
               {1}
%    \end{macrocode}
%
%    \begin{macrocode}
  \setlength\l_tmpa_dim{#2}
  \tl_gset:cx {g_xor_here_
                \int_use:N \g_xor_collect_here_seen_int _required_space_tl}
               {\dim_use:N \l_tmpa_dim}
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_add_badly_guarded_penalty:N\c_xor_output_here_float_penalty
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_initialize_here_data:}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_initialize_here_data:{
%<*trace>
  \trace_push:n{xor_initialize_here_data:}
%</trace>
%    Does this need any documentation?
%
%    Well, we have to get rid of all information relating to here
%    float penalties that have been typeset on the previous page and
%    move the remaining ones (if any) to the front.
%    \begin{macrocode}
  \int_set_eq:NN \l_tmpa_int \g_xor_collect_here_seen_int
  \int_add:Nn \l_tmpa_int {-\g_xor_trial_here_seen_int }
%<*trace>
  \trace:n{g_xor_collect_here_seen_int~
         =~ \int_use:N \g_xor_collect_here_seen_int\space <-~
            \int_use:N \l_tmpa_int  }
%</trace>
%    \end{macrocode}
%    Something wrong here if we get negative values!
%    \begin{macrocode}
%<*debug>
  \int_compare:nNnT \l_tmpa_int<\c_zero {\ERROR}
%</debug>
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gset_eq:NN \g_xor_collect_here_seen_int \l_tmpa_int
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_set_eq:NN \l_tmpc_int \g_xor_trial_here_seen_int
  \int_zero:N \l_tmpb_int
  \int_while_do:nNnn \l_tmpb_int < \l_tmpa_int
  {
    \int_incr:N \l_tmpb_int
    \int_incr:N \l_tmpc_int
%<*trace>
    \trace:n{g_xor_here_ \int_use:N \l_tmpb_int _required_space_tl\space
           =~ \tl_use:c {g_xor_here_ \int_use:N\l_tmpb_int
                          _required_space_tl}
    \space <-~
              \tl_use:c {g_xor_here_ \int_use:N \l_tmpc_int
                          _required_space_tl}
          }
    \trace:n{g_xor_here_ \int_use:N \l_tmpb_int _min_col_int \space <-~ 1}
%</trace>
    \tl_gset_eq:cc
       {g_xor_here_ \int_use:N \l_tmpb_int _required_space_tl}
       {g_xor_here_ \int_use:N \l_tmpc_int _required_space_tl}
    \int_gset:cn {g_xor_here_ \int_use:N \l_tmpb_int _min_col_int}{1}
  }
%<*trace>
  \trace_pop:n{xor_initialize_here_data:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_split_off_last_line_from_clvv:}
%
%    When a here point doesn't fit onto the current page or column for
%    some reason it will be moved into the next column. In some cases,
%    e.g., when the here point is associated with the line before it
%    (as, for example, in marginals) it is necessary to move the line
%    also to the later column.
%
%    The purpose of |\xor_split_off_last_line_from_clvv:| (to be called inside the
%    OR) is to split box 255 at the latest possible breakpoint before
%    the end and return the material following this breakpoint to the
%    MVL.
%
%    The idea is as follows: if we subtract 1sp from the height of
%    box 255 and also subtract all of its internal shrinkability and
%    then split it to this height it can't any longer reach the final
%    breakpoint (by 1sp). Thus it will settle with some earlier
%    breakpoint and chances are very very good that this will be the
%    prefinal one.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_split_off_last_line_from_clvv: {
%<*trace>
  \trace_push:n{xor_split_off_last_line_from_clvv:}
  \trace:n{goal:~ \dim_use:N \pagegoal;~ total:~ \dim_use:N \pagetotal;~ shrink:~
         \dim_use:N \pageshrink}
  \trace:n{ht255:~ \the\box_ht:N255;~ dp255:~ \the\box_dp:N255}
%</trace>
%    \end{macrocode}
%
%
%    \begin{macrocode}
  \dim_set:Nn \l_tmpa_dim {\box_ht:N\c_two_hundred_fifty_five}
%    \end{macrocode}
%    Looking at |\box_ht:N255| should be the same as |\pagetotal-\pagedepth|
%    or not?\footnote{Doesn't seem to be the case, bug in the code,
%    the program, or in my thinking? (seems to be a bug in \TeX:
%    pagedepth is always zero in the OR!)}
%    \begin{macrocode}
  \dim_sub:Nn \l_tmpa_dim \pageshrink
  \dim_sub:Nn \l_tmpa_dim {1sp}
%{\showoutput\showbox\c_two_hundred_fifty_five}
%    \end{macrocode}
%    Before splitting we have to ensure that the maximum depth is not
%    larger than the maximum depth allowed on the MVL.
%    \begin{macrocode}
  \dim_set:Nn \splitmaxdepth \@maxdepth
  \vbox_set_split_to_ht:NNn \c_zero \c_two_hundred_fifty_five {\l_tmpa_dim}
%{\showoutput\showbox\c_zero}
%{\showoutput\showbox\c_two_hundred_fifty_five}
%    \end{macrocode}
%
%    Before we now |\vbox_unpack_clear:N| 255 back onto the MVL we have to make sure
%    that the sum of its vertical dimensions plus the requested space
%    for the current here point is smaller than a full column height.
%
%    If we don't do that we might end up with a situation where we are
%    pushing the two from column to columns since they will never fit.
%    \begin{macrocode}
  \dim_set_eq:Nc \l_tmpa_dim
             {g_xor_here_ \int_use:N \g_xor_trial_here_seen_int _required_space_tl}
  \dim_add:Nn \l_tmpa_dim {   \box_ht:N\c_two_hundred_fifty_five
                            + \box_dp:N\c_two_hundred_fifty_five}
%    \end{macrocode}
%    If the sum is too large we reduce the required space for the here
%    point and complain (not really done yet the latter).
%    \begin{macrocode}
  \dim_compare:nNnT \l_tmpa_dim > \textheight
  {
    \ERROR-HERE-TOO-LARGE
    \dim_set:Nn \l_tmpa_dim { \textheight - \box_ht:N\c_two_hundred_fifty_five
                                          - \box_dp:N\c_two_hundred_fifty_five }
    \tl_gset:cx
      {g_xor_here_ \int_use:N \g_xor_trial_here_seen_int _required_space_tl}
      {\dim_use:N \l_tmpa_dim}
  }
%    \end{macrocode}
%    So now we can |\vbox_unpack_clear:N| and then move the top from the split back
%    into 255 (essentially to have it taken out of that register by
%    the code following, but such is life).
%    \begin{macrocode}
  \vbox_unpack_clear:N\c_two_hundred_fifty_five
  \box_gset_eq_clear:NN \c_two_hundred_fifty_five \c_zero
%<*trace>
  \trace_pop:n{xor_split_off_last_line_from_clvv:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Support for Grid Points}
%
%
%
%
% \begin{macro}{\xor_align_collected_galley_and_restart:}
%    |\xor_align_collected_galley_and_restart:| is called inside
%    |\xor_OR_grab_some_cols:nnnn| when we have encountered a grid point. It is
%    supposed to align the current line with the text grid and then
%    restarts the galley processing.
%
%    We do this by putting the material gathered so far into a box of
%    appropriate size, and then push this pack onto the recent
%    contributions for reconsideration.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_align_collected_galley_and_restart: {
%<*trace>
  \trace_push:n{xor_align_collected_galley_and_restart:}
  \trace:n{GRID:~ page~ goal~\space\space\space =~ \dim_use:N \pagegoal}
  \trace:n{GRID:~ page~ total~\space\space =~ \dim_use:N \pagetotal}
  \trace:n{GRID:~ page~ depth~\space\space =~ \dim_use:N \pagedepth}
  \trace:n{GRID:~ page~ shrink~\space =~ \dim_use:N \pageshrink}
  \trace:n{GRID:~ page~ stretch~ =~ \dim_use:N \pagestretch}
  \trace:n{GRID:~ page~ fil~ stretch~ =~ \dim_use:N \pagefilstretch}
  \trace:n{GRID:~ page~ fill~ stretch~ =~ \dim_use:N \pagefillstretch}
  \trace:n{GRID:~ page~ filll~ stretch~ =~ \dim_use:N \pagefillstretch}
  \trace:n{GRID:~ ht~ 255~\space =~ \the\box_ht:N\c_two_hundred_fifty_five}
  \trace:n{GRID:~ dp~ 255~\space =~ \the\box_dp:N\c_two_hundred_fifty_five}
%</trace>
%    \end{macrocode}
%    As a first step we remove the guard box since it has now served
%    its purpose.
%    \begin{macrocode}
  \xor_remove_guard_box_from_cclv:
%    \end{macrocode}
%    Then we calculate the distance to nearby grid points.
%    \begin{macrocode}
  \xor_snap_to_grid:nn {\box_ht:N\c_two_hundred_fifty_five}
                       \g_xor_grid_point_sep_dim
%    \end{macrocode}
%    So the next step is to make a decision which grid point to
%    use. The strategy used below can probably be refined
%    further\ldots
%
%    First we test if the next grid point down makes us fall off the
%    page\footnote{We should use \texttt{\string\pagegoal} for the
%    test I think, not the commented out construct below, since in
%    case of footnotes the available space for text might has be
%    reduced!}, if so\ldots
%    \begin{macrocode}
  \dim_compare:nNnTF \g_xor_returned_size_tl > \pagegoal
  {
          %  \csname g_xor_ht_col_ \xor_curr_col_block: _dim\endcsname % not!
%    \end{macrocode}
%    \ldots we better try using the previous grid point.
%    \begin{macrocode}
    \dim_compare:nNnTF \g_xor_returned_lower_delta_size_tl < \pageshrink
    {
%    \end{macrocode}
%    If the |\pageshrink| allows us to reach the previous point then
%    use it.
%    \begin{macrocode}
% can use it: do so
%<*trace>
      \trace:n{GRID:~ outside~ page,~ choosing~ lower~ grid~ point}
%</trace>
      \tl_gset_eq:NN \g_xor_returned_size_tl \g_xor_returned_lower_size_tl
      \tl_gset:Nx    \g_xor_returned_delta_size_tl {-\g_xor_returned_lower_delta_size_tl }
    }
    {
%    \end{macrocode}
%    Otherwise, ouch \ldots{} what now? Can this happen? Unfortunately
%    yes, it seems to happen, for example, when we are trying to place
%    floats.\footnote{Analyse this situation and decide on a course of
%    action if necessary.}
%    \begin{macrocode}
      \OuchERROR
    }
%    \end{macrocode}
%    Otherwise we are in the normal case, i.e., somewhere in the
%    middle of the page.
%    \begin{macrocode}
  }
  {
%    \end{macrocode}
%    So now we can in principle choose either grid point. The code
%    below makes the decision based on which grid point is closer but
%    chooses the previous point only if |\pageshink| allows
%    it.\footnote{One could also have a look at the available
%    stretchability and base the decision on the resulting badness,
%    this might in fact be the more appropriate way!}
%    \begin{macrocode}
    \dim_compare:nNnT \g_xor_returned_lower_delta_size_tl
                    < \g_xor_returned_delta_size_tl
    {
      \dim_compare:nNnT \g_xor_returned_lower_delta_size_tl < \pageshrink
      {
%<*trace>
        \trace:n{GRID:~ choosing~ lower~ grid~ point}
%</trace>
        \tl_gset_eq:NN \g_xor_returned_size_tl
                        \g_xor_returned_lower_size_tl
        \tl_gset:Nx    \g_xor_returned_delta_size_tl
                        {-\g_xor_returned_lower_delta_size_tl }
      }
    }
  }
%<*trace>
  \trace:n{GRID:~ adjustment:~ \the\box_ht:N\c_two_hundred_fifty_five\space
         ->~ \g_xor_returned_size_tl}
%</trace>
%    \end{macrocode}
%    Whatever the decision was, we finally bundle up all material in a
%    box with the vertical size being that of the chosen grid point
%    (no |\maxdepth| setting in this case) and return this box to the
%    MVL followed by any footnotes found in that process. These
%    footnotes are reinserted so that they will be reconsidered but
%    since we have no break point between the box and them they will
%    be considered as a unit.
%    \begin{macrocode}
  \vbox_to_ht:nn \g_xor_returned_size_tl {\vbox_unpack_clear:N\c_two_hundred_fifty_five}
  \@reinserts
%    \end{macrocode}
%    We know that the material returned to the MVL is followed
%    immediately by a box of size zero followed by a penalty thus
%    there will be a breakpoint in the right place (or so we hope) so
%    that the box plus the following footnotes will still fit into the
%    column when reprocessed.
%    \begin{macrocode}
%<*trace>
  \trace_pop:n{xor_align_collected_galley_and_restart:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\OuchERROR}
%    This part of the code (as far as I can see right now) will be
%    executed if there is some larger display object (ie off grid)
%    which will just fit onto the page unaligned but not if we align
%    to the next grid point. The reason for this is that somewhere on
%    the column there are also footnotes for example, which result in
%    the column not being an integral number of grid lines.
%    \begin{macrocode}
\cs_new_nopar:Npn \OuchERROR{
%<*trace>
  \trace:n{Failed:~grid~ overflowing~ column~ \int_use:N\g_xor_curr_col_int}
%</trace>
%<*progress>
  \xor_progress_failed:n{next~ possible~ grid~ point~ in~ column~
                        \int_use:N\g_xor_curr_col_int\space outside~ page}
%</progress>
%    \end{macrocode}
%    I think essentially what is needed here is to split the column
%    just before the current line, ie, using something like
%    |\xor_split_off_last_line_from_clvv:| (except that this only works for here
%    points right now) and this move the grid align penalty to the
%    next column.\footnote{Not done! FIX}
%    \begin{macrocode}
%  \xor_split_off_last_line_from_clvv:
%  \(re)???add@guarded@penalty\c_xor_output_grid_align_penalty
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\AlignToGrid_std:}
%    This is the definition for |\AlignToGrid| if we are really doing
%    grid based layout.
%    \begin{macrocode}
\cs_new_nopar:Npn \AlignToGrid_std:{
%<*trace>
  \trace:n{Add~ grid~ alignment~ point}
%</trace>
  \xor_add_badly_guarded_penalty:N\c_xor_output_grid_align_penalty
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\IgnoreAlignToGrid}
% \begin{macro}{\ObeyAlignToGrid}
%    |\IgnoreAlignToGrid| will turn off automatic grid alignment for a
%    while, while |\ObeyAlignToGrid| will turn it on again. This is
%    needed in commands that want to set something outside the grid
%    and then realign afterwards, e.g., a heading. If that heading
%    would follow, say, a list that issued a |\AlignToGrid| to be
%    executed on the next paragraph, that |\AlignToGrid| would
%    effectively appear on the heading title thus forcing that to be
%    on a grid line, which is typically not intended. So the heading
%    macro first says |\IgnoreAlignToGrid| then typesets the material
%    which should be not aligned, then says |\ObeyAlignToGrid| and
%    prepares to install its own |\AlignToGrid| (typically after the
%    first line of text via |\everypar|).
%    \begin{macrocode}
\cs_new_nopar:Npn \IgnoreAlignToGrid{
  \cs_gset_eq:NN \AlignToGrid \prg_do_nothing:
}
\cs_new_nopar:Npn \ObeyAlignToGrid{
  \cs_gset_eq:NN \AlignToGrid \AlignToGrid_std:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\AlignToGrid}
%    |\AlignToGrid| is the command that inserts a grid point which
%    triggers alignment to the text grid for the current line (if we
%    are doing grid based design). It should be set in the page setup
%    so the default is an error.
%    \begin{macrocode}
\cs_new_nopar:Npn \AlignToGrid {\ERROR}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\TextAlignToGrid}
%    In nearly all cases the alignment should be done for a text line,
%    so we provide this abbreviation which starts horizontal mode if
%    necessary.
%    \begin{macrocode}
\cs_new_nopar:Npn \TextAlignToGrid{ \leavevmode \AlignToGrid }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsection{Initializations}
%
%    The initialization at begin document isn't properly done
%    yet. Some bits are done unnecessarily here (by calling
%    initialization commands that do too much and some bits are
%    probably still in the wrong place. Furthermore the column data
%    initialization needs to be resolved properly. Right now we
%    hardwire a maximum of 6 columns down there and initialize the
%    data structures for all the potential columns independently of
%    whether or not they are ever being used.\footnote{SORT OUT! FIX}
%    \begin{macrocode}
\AtBeginDocument{
  \group_begin:
    \int_gset:Nn \g_xor_cols_int 6
    \xor_cols_setup:
%    \end{macrocode}
%    More column data stuff which needs to be set only the very first
%    time!
%    \begin{macrocode}
    \xor_forall_columns:n {
%    \end{macrocode}
%
%    \begin{macrocode}
%FMi ##1?
       \seq_map_inline:Nn \g_xor_float_classes_seq
              {
               \int_gzero_new:c {g_xor_flseq_type_#1_col_
                             \int_use:N\g_xor_curr_col_int _int}
               \int_gzero_new:c {g_xor_flseq_areas_top_type_#1_col_
                             \int_use:N\g_xor_curr_col_int _int}
              }
    }
%    \end{macrocode}
%
%    The default for the allowed float positions should be all areas known (not only those
%    currently used!)
%    \begin{macrocode}
    \seq_map_inline:Nn \g_xor_float_classes_seq
       {
        \tl_gset_eq:cN
            {g_xor_type_ #1 _allowed_areas_tl}
            \g_xor_areas_known_clist
        \int_gzero_new:c {g_xor_flseq_type_#1_col_0_int}
       }
  \group_end:
%    \end{macrocode}
%
%    Start the document by collecting text.
%    \begin{macrocode}
  \bool_gset_true:N \g_xor_collect_new_stuff_bool
% \xor_next_page_setup:         not necessary? check
  \xor_collect_setup:
}
%    \end{macrocode}
%
% \subsubsection{User Commands for Columns}
%
%
% \begin{macro}{\columnbreak}
%    And here is the user command for making a column
%    break:\footnote{All this is stolen from \texttt{multicol.sty} and
%    there is still code that doesn't belong here.}  |\columnbreak| is
%    modelled after |\pagebreak| except that we generate a penalty
%    with value
%    |\c_xor_output_columnbreak_penalty|.
%    \begin{macrocode}
\cs_new_nopar:Npn \columnbreak{
%    \end{macrocode}
%    We have to ensure that it is only used within a multicolumn
%    environment since if that penalty would be seen by the unmodified
%    \LaTeX{} output routine strange things would happen.
%    \begin{macrocode}
  \int_compare:nNnTF \g_xor_cols_int<\c_two
    {
     \PackageError{xoutput}
       {\exp_not:N \columnbreak~ in~ one-column~ mode}
       {???}
    }
    {
     \mode_if_vertical:TF
          { \penalty \c_xor_output_columnbreak_penalty }
          {
           \@bsphack
             \vadjust{\penalty \c_xor_output_columnbreak_penalty}
           \@esphack
          }
    }
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
% 
%    \begin{macrocode}
\__msg_kernel_new:nnn { output } { out-of-space }
  {
    The~vertical~space~available~in~the~current~column~was~less~than~one~row~
    of~text~high.~LaTeX~will~insert~a~break~and~hope~for~the~best!
  }
%    \end{macrocode}
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% ^^A  \PrintIndex ^^A do not index here (at least not now)
%
%
 
