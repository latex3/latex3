% \iffalse
%% File xo-place.dtx (C) Copyright 1999-2000 Frank Mittelbach, David Carlisle, Chris Rowley
%%                   (C) Copyright 2004-2012 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xor bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
\RequirePackage{l3bootstrap}
\GetIdInfo $Id$
          {xo-place}
\ProvidesExplPackage{\ExplFileName}
  {\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
% \fi
%
%
%
% \subsection{Selecting the next area to try}
%
%
% \begin{macro}{\xor_try_this_area_std:}
%    The |\xor_try_this_area_std:| command is called when we have selected a
%    float from the |\g_xor_floats_active_seq| and want to place it in one of
%    the open areas to see if it fits there. If we succeed in finding a
%    potential candidate place we will exit using
%    |\xor_pretests_success_action:| which will
%    run a trial cutting the galley to see if each column gets the right kind
%    of text and contains the right kind of callouts.  The areas are tried in
%    a defined order.
%
%    If we don't find any open areas we return putting the current float onto
%    the |\g_xor_area_DDD_float_seq| and then calling |\xor_try_next_float:|.
%
%    If we find an open area but for some reason the float is not allowed to
%    go there we close that area for floats of this type and recurse (i.e. try
%    to use the next open area for this type).
%
%    The reasons for failure to place the float into the first open area are
%    numerous. First there are restrictions on the number of floats on a page
%    (if we reach this all areas get closed) there are similar
%    restrictions for each individual float area.
%
%    If those tests are passed we trial typeset the float with its caption (or
%    rather typeset and attach its caption) to determine the size needed by
%    the float. That will give us a dimension to test against restrictions for
%    the amount of space floats are allowed to occupy etc.
%
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_try_this_area_std: {
%<*trace>
  \trace_push:n{xor_try_this_area_std:}
%</trace>

%%B
  \int_gzero:N \g_xor_trial_balance_done_int
%<*trace>
  \trace:n{BALANCE:~ g_xor_trial_balance_done_int ~<-~
                    \int_use:N \g_xor_trial_balance_done_int }

  \trace:n{(Re)initializing~ column~ heights~ ...}
%</trace>
  \g_xor_best_trial_col_hts_tl
%    \end{macrocode}
%    If all areas for the float type are closed we have to defer this float.
%    \begin{macrocode}
  \clist_if_empty:NTF \g_xor_this_areas_open_clist
  {
%<*trace>
        \trace:n{defer:~no~open~area~ available}
%</trace>
        \xor_do_next:N \xor_attempt_to_defer_and_try_next_float:
  }
%    \end{macrocode}
%    Otherwise the next area to try is the first of |\g_xor_this_areas_open_clist|:
%    \begin{macrocode}
  {
    \clist_get:NN \g_xor_this_areas_open_clist \l_tmpa_tl
    \xor_this_area_setup:o  \l_tmpa_tl
%<*trace>
    \trace:n{area~trial:~ \g_xor_this_area_name_tl}
%</trace>
%<*progress>
    \xor_progress:n{~ area~trial:~ \g_xor_this_area_name_tl}
%</progress>
%    \end{macrocode}
%    Next test needs cleanup once the span has a decent data
%    structure.\footnote{FIX!!}
%    \begin{macrocode}
    \int_compare:nNnTF \g_xor_this_area_span_tl = \g_xor_this_span_num_tl
    {
%<*trace>
      \trace:n{span~ count~ okay:~ \g_xor_this_area_name_tl \space =~
             \g_xor_this_span_num_tl }
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
      \int_compare:nNnTF \g_pagesetup_max_float_int > \g_xor_page_float_int
      {
%    \end{macrocode}
%
%    \begin{macrocode}
        \int_compare:nNnTF 
          {\int_use:c {g_xor_area_ \g_xor_this_area_name_tl  _max_float_int} }
        = {\int_use:c {g_xor_area_ \g_xor_this_area_name_tl  _float_int } }
        {
%    \end{macrocode}
%    Current area doesn't accept any more floats, so try next one (if any)
%    \begin{macrocode}
%<*trace>
          \trace:n{close~area:~\g_xor_this_area_name_tl\space float~num~reached ~
              (\int_use:c {g_xor_area_ \g_xor_this_area_name_tl _max_float_int})}
%</trace>
%<*progress>
          \xor_progress_failed:n{\g_xor_this_area_name_tl\space float~num~reached ~
               (\int_use:c{g_xor_area_ \g_xor_this_area_name_tl _max_float_int})}
%</progress>
          \xor_do_next:N \xor_try_next_area:
        }
%    \end{macrocode}
%
%    \begin{macrocode}
        {
          \clist_if_in:NoTF
             \g_xor_curr_page_areas_closed_clist
             \g_xor_this_area_name_tl
             {
%<*trace>
               \trace:n{area~ closed~ for~ all~ types;~ member~ of~
                      (\g_xor_curr_page_areas_closed_clist)}
%</trace>
%<*progress>
               \xor_progress_failed:n{area~ closed~ for~ all~ types}
%</progress>
               \xor_do_next:N \xor_try_next_area:
             }
             {
%<*trace>
               \trace:n{area~ not~ closed~ for~ all~ types:~ not~ member~ of~
                      (\g_xor_curr_page_areas_closed_clist)}
%</trace>
               \clist_if_in:NoTF
                 \g_xor_this_areas_closed_clist
                 \g_xor_this_area_name_tl
                 {
%<*trace>
                   \trace:n{area~ closed~ for~ class~ \g_xor_this_class_tl;~ 
                          member~ of~  (\g_xor_this_areas_closed_clist)}
%</trace>
%<*progress>
                   \xor_progress_failed:n
                         {area~ closed~ for~ class~ \g_xor_this_class_tl}
%</progress>
                   \xor_do_next:N \xor_try_next_area:
                 }
                 {
%<*trace>
                  \trace:n{area~ open~ for~ class~ \g_xor_this_class_tl;~ 
                         not~ member~ of~
                         (\g_xor_this_areas_closed_clist)}
%</trace>
%    \end{macrocode}
%    
%    \begin{macrocode}
                  \clist_if_in:NoTF
                    \g_xor_this_allowed_areas_clist
                    \g_xor_this_area_name_tl
                    {
                      \xor_append_caption_to_float:
%    \end{macrocode}
%    
%    \begin{macrocode}
%                      \tl_set:Nn \l_tmpa_tl {c}
%                      \tl_if_eq:NNTF \l_tmpa_tl \g_xor_this_area_type_tl 
                      \xor_if_this_area_type:NTF {c}
                       {
			 \xor_attempt_float_col:NN 
                              \g_xor_this_area_col_tl
                              \g_xor_this_area_span_tl
			 \bool_if:NTF \g_test_bool
			   { \xor_do_next:N \xor_try_next_area: }
			   { \xor_do_next:N \xor_pretests_success_action: }
                        }
                        {
			 \xor_construct_and_test_col_hts:
			 \bool_if:NTF \g_test_bool
			   { \xor_do_next:N \xor_try_next_area: }
			   { \xor_do_next:N \xor_pretests_success_action: }
                        }
                    }
                    {
%<*trace>
                      \trace:n{close~area:~\g_xor_this_area_name_tl\space 
                             float~not~allowed~
                             by~ user~ control~ (\g_xor_this_allowed_areas_clist)}
%</trace>
%<*progress>
                      \xor_progress_failed:n{\g_xor_this_area_name_tl\space 
                             float~not~allowed~
                             by~ user~ control~ (\g_xor_this_allowed_areas_clist)}
%</progress>
                      \xor_do_next:N \xor_try_next_area:
                    }
                }
            }
        }
      }
      {
% defer
        \clist_gclear:N \g_xor_this_areas_open_clist
%<*trace>
        \trace:n{defer:~max~float~num~reached ~(\g_pagesetup_max_float_int)}
%</trace>
%<*progress>
        \xor_progress_failed:n{max~float~num~reached ~(\g_pagesetup_max_float_int)}
%</progress>
        \xor_do_next:N \xor_attempt_to_defer_and_try_next_float:
      }
    }
    {
%<*trace>
      \trace:n{span~ count~ unsuitable:~ \g_xor_this_area_name_tl \space /=~
             \g_xor_this_span_num_tl }
%</trace>
%<*progress>
      \xor_progress_failed:n{span~ count~ \g_xor_this_area_name_tl \space /=~
             \g_xor_this_span_num_tl }
%</progress>
      \xor_do_next:N \xor_try_next_area:
    }
  }
%<*trace>
  \trace_pop:n{xor_try_this_area_std:}
%</trace>
  \xor_continue:
}
%    \end{macrocode}
% \end{macro}
%
%

%  \begin{macro}{\xor_attempt_float_col:NN}
%    
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_attempt_float_col:NN  #1 #2 {
%<*trace>
  \trace_push:n{xor_attempt_float_col:NN ~#1/#2}
%</trace>

  \seq_gset_eq:NN \g_xor_saved_floats_active_seq 
                  \g_xor_floats_active_seq

  \tl_gset_eq:NN \g_xor_saved_curr_float_box_tl
                  \g_xor_curr_float_box_tl

%\traceon

%%%% next block unfinished/broken
  \dim_set_eq:Nc \l_xor_fcol_target_dim
           {g_xor_ht_col_ 
            \int_use:N \l_xor_update_col_int 
            _
            \xor_if_this_area_type:NTF {b}
              {\int_use:c{g_xor_col_ 
                          \int_use:N \l_xor_update_col_int 
                          _block_int}}
              {1}
            _dim }


  \bool_until_do:nn
    { \seq_if_empty_p:N \g_xor_floats_active_seq }
    {
     \seq_gpop:NN \g_xor_floats_active_seq 
                  \l_tmpa_tl

  \tl_gset_eq:NN \g_xor_curr_float_box_tl
                  \l_tmpa_tl

  \xor_extract_this_float_core_values:N \g_xor_curr_float_box_tl

    }

  \seq_gset_eq:NN \g_xor_floats_active_seq
                  \g_xor_saved_floats_active_seq 
     
  \tl_gset_eq:NN \g_xor_curr_float_box_tl
                  \g_xor_saved_curr_float_box_tl

  \bool_gset_true:N \g_test_bool
%<*trace>
  \trace_pop:n{xor_attempt_float_col:NN}
%</trace>
}
%    \end{macrocode}
%  \end{macro}


%    \begin{macrocode}
\dim_new:N \l_xor_fcol_target_dim
\seq_new:N \g_xor_saved_floats_active_seq
\tl_new:N \g_xor_saved_curr_float_box_tl
%    \end{macrocode}


%
%
% \begin{macro}{\xor_do_next:N}
%    Emergency macro to reduce the number of input levels (as the code
%    got past the internal default of 300). This is because we have a
%    lot of recursion going on without being tail
%    recursion. Essentially this means some of the code needs slightly
%    different implementation.\footnote{fix}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_do_next:N {\cs_set_eq:NN \xor_continue:}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_try_this_area_relaxed:}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_try_this_area_relaxed: {
%<*trace>
  \trace_push:n{xor_try_this_area_relaxed:}
%</trace>
%    \end{macrocode}
%    If all areas for the float type are closed we have to defer this float.
%    \begin{macrocode}
  \clist_if_empty:NTF \g_xor_this_areas_open_clist
  {
%<*trace>
        \trace:n{defer:~no~open~area~ available}
%</trace>
        \xor_do_next:N \xor_attempt_to_defer_and_try_next_float:
  }
  {
%    \end{macrocode}
%    Otherwise the next area to try is the first of |\g_xor_this_areas_open_clist|:
%    \begin{macrocode}
    \clist_get:NN \g_xor_this_areas_open_clist \l_tmpa_tl
    \xor_this_area_setup:o  \l_tmpa_tl
%<*trace>
    \trace:n{area~trial:~ \g_xor_this_area_name_tl}
%</trace>
%<*progress>
    \xor_progress:n{~ area~trial:~ \g_xor_this_area_name_tl}
%</progress>
%    \end{macrocode}
%    Next test needs cleanup once the span has a decent data
%    structure.\footnote{FIX!!}
%    \begin{macrocode}
    \int_compare:nNnTF \g_xor_this_area_span_tl = \g_xor_this_span_num_tl
    {
%<*trace>
      \trace:n{span~ count~ okay:~ \g_xor_this_area_name_tl \space =~
             \g_xor_this_span_num_tl}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
      \clist_if_in:NoTF
      \g_xor_curr_page_areas_closed_clist
      \g_xor_this_area_name_tl
      {
%<*trace>
        \trace:n{area~ closed~ for~ all~ types;~ member~ of~
               (\g_xor_curr_page_areas_closed_clist)}
%</trace>
%<*progress>
            \xor_progress_failed:n{area~ closed~ for~ all~ types}
%</progress>
        \xor_do_next:N\xor_try_next_area:
      }
      {
%<*trace>
        \trace:n{area~ not~ closed~ for~ all~ types:~ not~ member~ of~
               (\g_xor_curr_page_areas_closed_clist)}
%</trace>
        \clist_if_in:NoTF
          \g_xor_this_areas_closed_clist
          \g_xor_this_area_name_tl
        {
%<*trace>
          \trace:n{area~ closed~ for~ class~ \g_xor_this_class_tl;~ 
                 member~ of~
                 (\g_xor_this_areas_closed_clist)}
%</trace>
%<*progress>
          \xor_progress_failed:n
                    {area~ closed~ for~ class~ \g_xor_this_class_tl}
%</progress>
          \xor_do_next:N\xor_try_next_area:
        }
        {
%<*trace>
          \trace:n{area~ open~ for~ class~ \g_xor_this_class_tl;~ 
                 not~ member~ of~
                 (\g_xor_this_areas_closed_clist)}
%</trace>
          \xor_append_caption_to_float:
%         \tl_set:Nn \l_tmpa_tl {c}
%         \tl_if_eq:NNTF \l_tmpa_tl \g_xor_this_area_type_tl 
          \xor_if_this_area_type:NTF {c}
            {
             \xor_attempt_float_col:NN 
                 \g_xor_this_area_col_tl
                 \g_xor_this_area_span_tl
             \bool_if:NTF \g_test_bool
               { \xor_do_next:N \xor_try_next_area: }
               { \xor_do_next:N \xor_pretests_success_action: }
            }
            {
             \xor_construct_and_test_col_hts:
             \bool_if:NTF \g_test_bool
               { \xor_do_next:N \xor_try_next_area: }
               { \xor_do_next:N \xor_pretests_success_action: }
            }
        }
      }
    }
    {
%<*trace>
      \trace:n{span~ count~ unsuitable:~ \g_xor_this_area_name_tl \space /=~
             \g_xor_this_span_num_tl}
%</trace>
%<*progress>
      \xor_progress_failed:n{span~ count~ \g_xor_this_area_name_tl \space /=~
             \g_xor_this_span_num_tl }
%</progress>
      \xor_do_next:N\xor_try_next_area:
    }
  }
%<*trace>
  \trace_pop:n{xor_try_this_area_relaxed:}
%</trace>
  \xor_continue:
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_construct_and_test_col_hts:}
%    The |\xor_construct_and_test_col_hts:| loops over all columns
%    affected by the float area we want to place our float into
%    and reduces the column size as
%    needed. It sets the switch |\g_test_bool| to true in case the float
%    doesn't fit into area for some reason. It is up to the calling
%    macro to take proper action in this case (including resetting
%    column heights to their former values).
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_construct_and_test_col_hts: {
%<*trace>
   \trace_push:n{xor_construct_and_test_col_hts:}
%</trace>
%    \end{macrocode}
%    We use the information from the area not from the float (which
%    allows us to put small floats into larger areas.
%    \begin{macrocode}
  \xor_update_this_area_span_cols:n
  {
    \exp_args:Nc
      \xor_construct_and_test_col_ht:nn
        {g_xor_ht_col_ \int_use:N \l_xor_update_col_int _dim }
        {\int_use:N \l_xor_update_col_int}
%    \end{macrocode}
%    We need to break out of the updating loop if we found a column that
%    doesn't work, a) to save time and b) since the next
%    |\xor_construct_and_test_col_ht:nn| resets the switch again to false
%    (in the current implementation).
%    \begin{macrocode}
      \bool_if:NT\g_test_bool
         { \int_zero:N \l_xor_update_col_int }   % break out of loop
  }
%<*trace>
   \trace_pop:n{xor_construct_and_test_col_hts:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%% \begin{macro}{\xor_construct_and_test_col_ht:nn}
%%    The |\xor_construct_and_test_col_ht:nn| reduces the height of one column
%%    by the size of the current float (plus some suitable extra space)
%%    and tests if this reduction is possible/allowed. It sets the
%%    boolean |\g_test_bool| to true if it encounters a problem.
%%    \begin{macrocode}
%\cs_new_nopar:Npn \xor_construct_and_test_col_ht:nn #1#2{
%%<*trace>
%  \trace_push:n{xor_construct_and_test_col_ht:nn}
%  \trace:n{col~ height~before:~ \the#1\space (\string#1\space/#2)}
%%</trace>
%%    \end{macrocode}
%%    In |\l_tmpa_dim| we calculate the amount of space we need if we
%%    place the float. This is the size of the float, i.e., its height
%%    and depth, plus either |\g_xor_float_text_skip| if this is the
%%    very first float in this column (on top or on bottom), or
%%    |\g_xor_float_area_skip| if it is the first float in the
%%    current area, or |\g_xor_float_float_skip| if we already have
%%    floats in this area.
%%    \begin{macrocode}
%  \dim_set:Nn \l_tmpa_dim {\box_ht:N\g_xor_this_captioned_float_box}
%  \dim_add:Nn \l_tmpa_dim {\box_dp:N\g_xor_this_captioned_float_box}
%  \int_compare:nNnTF {\int_use:c {g_xor_ \g_xor_this_area_type_tl
%                                  _floats_col_ #2 _int}
%                 }  = \c_zero
%  {
%%<*trace>
%       \trace:n{first~ float~ in~ any~ \g_xor_this_area_type_tl\space
%              in~ column~ #2:~
%              adding~ \string\g_xor_float_text_skip
%              =\the\g_xor_float_text_skip}
%%</trace>
%    \dim_add:Nn \l_tmpa_dim \g_xor_float_text_skip
%  }
%  {
%    \seq_if_empty:cTF {g_xor_area_ \g_xor_this_area_name_tl _float_seq}
%    {
%      \dim_add:Nn \l_tmpa_dim \g_xor_float_area_skip
%%<*trace>
%        \trace:n{first~ float~ in~ \g_xor_this_area_name_tl :~
%              adding~ \string\g_xor_float_area_skip
%              =\the\g_xor_float_area_skip}
%%</trace>
%    }
%    {
%      \dim_add:Nn \l_tmpa_dim \g_xor_float_float_skip
%%<*trace>
%        \trace:n{additional~ float~ in~ \g_xor_this_area_name_tl :~
%              adding~ \string\g_xor_float_float_skip
%              = \the\g_xor_float_float_skip}
%%</trace>
%    }
%  }
%%    \end{macrocode}
%%    Now we make the area size fully fall into the page grid (if there
%%    is one). To do this we first subtract any delta that has been
%%    accumulated for the column (to get back to the real size) and
%%    then run |\xor_snap_to_grid:nn| to get the next grid point.
%%    \begin{macrocode}
%  \dim_sub:Nn \l_tmpa_dim
%              { \dim_use:c { g_xor_ \g_xor_this_area_type_tl _delta_col_ #2 _dim} }
%%    \end{macrocode}
%%    The |\g_xor_|\meta{area-type}|_delta_col_|\meta{col}|_dim| are macros but
%%    fortunately low-level \TeX{} supports register assignments of the
%%    form |--3pt| so the above will work even if the macro contains a
%%    negative value.
%%    \begin{macrocode}
%  \xor_snap_to_grid:nn  \l_tmpa_dim \g_xor_grid_point_sep_dim
%%    \end{macrocode}
%%
%%    If the distance to the next grid point is larger than the
%%    distance to the previous one, and if the space between floats and
%%    text is allowed to shrink by the needed amount we will use the
%%    previous grid point.
%%    \begin{macrocode}
%  \dim_compare:nNnT \g_xor_returned_lower_delta_size_tl < \g_xor_returned_delta_size_tl
%  {
%    \dim_compare:nNnT \g_xor_returned_lower_delta_size_tl 
%                    < \g_xor_float_text_shrink_dim
%    {
%%<*trace>
%      \trace:n{GRID:~ column~#2:~ choosing~ lower~ grid~ point}
%%</trace>
%%    \end{macrocode}
%%    We do this by copying the |\g_xor_returned_lower_...| to the macros
%%    used below. Note that for the delta size we have to use the
%%    negation since we want to backup by this amount and delta sizes
%%    are always given in absolute values.
%%    \begin{macrocode}
%      \tl_gset_eq:NN \g_xor_returned_size_tl \g_xor_returned_lower_size_tl
%      \tl_gset:Nx    \g_xor_returned_delta_size_tl {-\g_xor_returned_lower_delta_size_tl }
%    }
%  }
%%<*trace>
%  \trace:n{GRID:~ column~#2:~ \dim_use:N \l_tmpa_dim\space ->~ \g_xor_returned_size_tl}
%%</trace>
%  \dim_set:Nn \l_tmpa_dim \g_xor_returned_size_tl
%%    \end{macrocode}
%%
%%    After updating |\l_tmpa_dim| in this way we now have to check if
%%    the space remaining for the text column is large enough.
%%    \begin{macrocode}
%  \dim_set:Nn \l_tmpb_dim {#1 - \l_tmpa_dim }
%  \bool_gset_false:N\g_test_bool
%  \dim_compare:nNnTF {\textminlines\baselineskip} > \l_tmpb_dim
%  {
%%    \end{macrocode}
%%    If not we bail out
%%    \begin{macrocode}
%    \bool_gset_true:N\g_test_bool
%%<*trace>
%    \trace:n{close~area:~\g_xor_this_area_name_tl\space not~ enough~
%       text~ lines~ left~
%      (\textminlines x\the\baselineskip> \dim_use:N \l_tmpb_dim)}
%%</trace>
%%<*progress>
%    \xor_progress_failed:n{not~ enough~ text~ space~
%      (\textminlines x\the\baselineskip\space
%      >~ \dim_use:N \l_tmpb_dim)}
%%</progress>
%  }
%  {
%%    \end{macrocode}
%%    Otherwise we have to update the column heights (and their saved
%%    version in case we back out later) as well as storing the new
%%    delta (which is still in |\g_xor_returned_delta_size_tl|).
%%    \begin{macrocode}
%%<*trace>
%    \trace:n{g_xor_saved_ht_col_#2_tl ~ <-~\the#1}
%%</trace>
%    \tl_gset:cx {g_xor_saved_ht_col_#2_tl} {\the#1}
%    \dim_gset:Nn {#1}\l_tmpb_dim
%%    \end{macrocode}
%%
%%    If we are adding the float to a bottom area we also need to change the
%%    information about how much space has been used from the bottom up, since that
%%    is needed for correct balancing.
%%    \begin{macrocode}
%    \xor_if_this_area_type:NT {b}
%     {
%      \dim_gset:cn {g_xor_saved_bottom_ht_col_#2_dim} 
%                   {\dim_use:c{g_xor_bottom_ht_col_#2_dim}}
%      \dim_gadd:cn{g_xor_bottom_ht_col_#2_dim}\l_tmpa_dim
%%<*trace>
%      \trace:n{g_xor_saved_bottom_ht_col_#2_dim ~ <-~
%             \dim_use:c{g_xor_saved_bottom_ht_col_#2_dim}}
%      \trace:n{g_xor_bottom_ht_col_#2_dim ~ <-~
%             \dim_use:c{g_xor_bottom_ht_col_#2_dim}}
%%</trace>
%     }
%%    \end{macrocode}
%
%%    \begin{macrocode}
%    \dim_gset_eq:cc
%      {g_xor_saved_ \g_xor_this_area_type_tl _delta_col_ #2 _dim}
%      {g_xor_       \g_xor_this_area_type_tl _delta_col_ #2 _dim}
%    \dim_gset:cn
%      {g_xor_ \g_xor_this_area_type_tl _delta_col_ #2 _dim}
%      { \g_xor_returned_delta_size_tl }
%%<*trace>
%    \trace:n{GRID (delta):~ column~#2\g_xor_this_area_type_tl :~
%      \dim_use:c{g_xor_saved_ \g_xor_this_area_type_tl _delta_col_ #2 _dim}
%      \space ->~ \g_xor_returned_delta_size_tl}
%%</trace>
%  }
%%<*trace>
%  \trace:n{col height~after:~ \the#1}
%  \trace_pop:n{xor_construct_and_test_col_ht:nn}
%%</trace>
%}
%%    \end{macrocode}
%% \end{macro}
%
%
%
%
% \begin{macro}{\textminlines}
%    Tmp definition; should be interfaced to pagesetup.
%    \begin{macrocode}
\cs_new:Npn \textminlines {4}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Supporting grid based designs}
%
%
%
% \begin{macro}{\g_xor_grid_point_sep_dim}
%    |\g_xor_grid_point_sep_dim| is the distance between grid points
%    for page design or 0pt if we are not doing grid design.
%    \begin{macrocode}
\dim_new:N\g_xor_grid_point_sep_dim
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_snap_to_grid:nn}
%    |\xor_snap_to_grid:nn| takes a dimension as first argument and a
%    ``grid-size'' as second argument and from those two values
%    calculates a new dimension which is a multiple of the grid-size
%    and equal or larger than the first argument.
%
%    It returns this calculated value globally in |\g_xor_returned_size_tl|. In
%    addition it will return in |\g_xor_returned_delta_size_tl| the delta
%    between the original and the new dimension.
%
%    It also returns a lower or equal grid point in
%    |\g_xor_returned_lower_size_tl| and the delta to it (absolute value) in
%    |\g_xor_returned_lower_delta_size_tl|.
%
%    Thus the first argument lies on a grid point if and only if
%    |\g_xor_returned_size_tl| equals |\g_xor_returned_lower_size_tl|.
%
%    If we are not doing grid typesetting then |\xor_snap_to_grid:nn| is
%    actually a dummy which will return always the first argument in
%    |\g_xor_returned_size_tl| and |\g_xor_returned_lower_size_tl|, and |0pt| in the
%    deltas.
%
%    The actual definition is assigned within the page setup.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_snap_to_grid:nn {\ERROR}
%    \end{macrocode}
% \end{macro}
%

%  \begin{macro}{\g_xor_returned_size_tl}
%  \begin{macro}{\g_xor_returned_lower_size_tl}
%  \begin{macro}{\g_xor_returned_delta_size_tl}
%  \begin{macro}{\g_xor_returned_lower_delta_size_tl}
%    
%    \begin{macrocode}
\tl_new:N\g_xor_returned_size_tl
\tl_new:N\g_xor_returned_lower_size_tl
\tl_new:N\g_xor_returned_delta_size_tl
\tl_new:N\g_xor_returned_lower_delta_size_tl
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%
% \begin{macro}{\xor_snap_to_grid_dummy:nn}
%    In case we don't do grids we simply pretend that all sizes lie on
%    grid points.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_snap_to_grid_dummy:nn #1#2{
   \group_begin:
%    \end{macrocode}
%    Definitions below can be optimised for speed but the ones used
%    give better tracing.
%    \begin{macrocode}
     \dim_set:Nn \l_tmpa_dim {#1}
     \tl_gset:Nx    \g_xor_returned_size_tl { \dim_use:N \l_tmpa_dim }
     \tl_gset_eq:NN \g_xor_returned_lower_size_tl \g_xor_returned_size_tl
     \tl_gset:Nn    \g_xor_returned_delta_size_tl {0pt}
     \tl_gset_eq:NN \g_xor_returned_lower_delta_size_tl  \g_xor_returned_delta_size_tl
   \group_end:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_snap_to_grid_std:nn}
%    But if we do grid typesetting we have to do a bit more work
%    here.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_snap_to_grid_std:nn #1#2{
%    \end{macrocode}
%    Everything is done in a group so that the register change do not
%    affect other parts of the code.
%    \begin{macrocode}
  \group_begin:
%    \end{macrocode}
%    First we calculate in |\l_tmpc_dim| the nearest grid point which
%    is smaller or equal to the given size in |#1| by using scaled
%    point arithmetic.
%    \begin{macrocode}
    \dim_set:Nn \l_tmpa_dim {#1}
    \dim_set:Nn \l_tmpb_dim {#2}
    \int_set:Nn \l_tmpa_int \l_tmpa_dim      % orig size in sp
    \int_set:Nn \l_tmpb_int \l_tmpb_dim      % grid size in sp
    \divide \l_tmpa_int \l_tmpb_int
    \dim_set:Nn \l_tmpc_dim {\l_tmpa_int \l_tmpb_dim}
%    \end{macrocode}
%    If the calculated grid point is smaller than the original
%    dimension use the next larger one. But record the other in
%    |\g_xor_returned_lower_size_tl|.
%    \begin{macrocode}
    \dim_compare:nNnT \l_tmpc_dim < \l_tmpa_dim
    {
      \tl_gset:Nx \g_xor_returned_lower_size_tl { \dim_use:N \l_tmpc_dim }
      \dim_add:Nn  \l_tmpc_dim \l_tmpb_dim
    }
%    \end{macrocode}
%    The |\g_xor_returned_size_tl| will be whatever the result of the above is
%    and |\g_xor_returned_delta_size_tl| the difference to the given value in
%    |#1|. Note that |\g_xor_returned_size_tl| will always be larger or equal
%    to this value so the difference computed below will also be
%    non-negative!
%    \begin{macrocode}
    \tl_gset:Nx \g_xor_returned_size_tl { \dim_use:N \l_tmpc_dim }
    \dim_sub:Nn \l_tmpc_dim \l_tmpa_dim
    \tl_gset:Nx \g_xor_returned_delta_size_tl { \dim_use:N \l_tmpc_dim }
%    \end{macrocode}
%    Now if this difference turns out to be zero then we actually
%    started with a dimension exactly on a grid point. In this case we
%    better define both |\g_xor_returned_lower_size_tl| and
%    |\g_xor_returned_lower_delta_size_tl| to equal their counterparts.
%    \begin{macrocode}
    \dim_compare:nNnTF \l_tmpc_dim = \c_zero_dim
    {
      \tl_gset_eq:NN \g_xor_returned_lower_size_tl \g_xor_returned_size_tl
      \tl_gset_eq:NN \g_xor_returned_lower_delta_size_tl \g_xor_returned_delta_size_tl
%    \end{macrocode}
%    Otherwise we only have to compute |\g_xor_returned_lower_delta_size_tl|
%    since in that case we already recorded |\g_xor_returned_lower_size_tl|
%    above (and we better had since by now we lost this information as
%    we reused |\l_tmpc_dim|). Now the value for this macro should be
%    the difference between |\g_xor_returned_delta_size_tl| and our grid size
%    both of which are already stored in some temp registers,
%    thus\ldots
%    \begin{macrocode}
    }
    {
      \dim_sub:Nn  \l_tmpb_dim \l_tmpc_dim
      \tl_gset:Nx \g_xor_returned_lower_delta_size_tl { \dim_use:N \l_tmpb_dim }
    }
  \group_end:
%<*trace>
  \trace:n{GRID:~ \string\g_xor_returned_lower_size_tl=\g_xor_returned_lower_size_tl}
  \trace:n{GRID:~ \string\g_xor_returned_lower_delta_size_tl=\g_xor_returned_lower_delta_size_tl}
  \trace:n{GRID:~ \string\g_xor_returned_size_tl=\g_xor_returned_size_tl}
  \trace:n{GRID:~ \string\g_xor_returned_delta_size_tl=\g_xor_returned_delta_size_tl}
%</trace>
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\xor_snap_to_grid_std:nn}
%  A different implementation of the above.
%    \begin{macrocode}
\cs_set_nopar:Npn \xor_snap_to_grid_std:nn #1#2{
%    \end{macrocode}
%  Check if  |#2| is a multiple of |#1|.
%    \begin{macrocode}
  \int_compare:nNnTF
    { \int_mod:nn {#1} {#2} }  = \c_zero 
%    \end{macrocode}
%  If it is, things are easy.
%    \begin{macrocode}
  {
    \tl_gset:Nx \g_xor_returned_size_tl{\dim_eval:n{#1}}
    \tl_gset:Nn \g_xor_returned_delta_size_tl { 0pt }
    \tl_gset_eq:NN  \g_xor_returned_lower_size_tl       \g_xor_returned_size_tl
    \tl_gset_eq:NN  \g_xor_returned_lower_delta_size_tl \g_xor_returned_delta_size_tl
  }
%    \end{macrocode}
%  Else we have to do a few more calculations.
%    \begin{macrocode}
  {
    \tl_gset:Nx \g_xor_returned_lower_size_tl {
        \dim_eval:n {#2*
%    \end{macrocode}
%    Next lines are horribly low-level and need to be re-evaluated at some
%    point. Such kind of calculation should be possible  within the
%    normal expl3 programming functions.\footnote{fix}
%    \begin{macrocode}
                     \int_div_truncate:nn {\tex_number:D \etex_dimexpr:D #1 \scan_stop:}
                                          {\tex_number:D \etex_dimexpr:D #2 \scan_stop:}
      }
    }
    \tl_gset:Nx \g_xor_returned_size_tl{\dim_eval:n{\g_xor_returned_lower_size_tl+#2}}
    \tl_gset:Nx \g_xor_returned_delta_size_tl{\dim_eval:n{\g_xor_returned_size_tl-#1}}
    \tl_gset:Nx \g_xor_returned_lower_delta_size_tl
                {\dim_eval:n{#2-\g_xor_returned_delta_size_tl}}
  }
%<*trace>
  \trace:n{GRID:~ grid~ size~ used:~ \dim_use:N #2} % dirty
  \trace:n{GRID:~ \string\g_xor_returned_lower_size_tl=\g_xor_returned_lower_size_tl}
  \trace:n{GRID:~ \string\g_xor_returned_lower_delta_size_tl=\g_xor_returned_lower_delta_size_tl}
  \trace:n{GRID:~ \string\g_xor_returned_size_tl=\g_xor_returned_size_tl}
  \trace:n{GRID:~ \string\g_xor_returned_delta_size_tl=\g_xor_returned_delta_size_tl}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
% \subsection{Deferring a float}
%
%
%
% \begin{macro}{\xor_really_defer_and_try_next_float:}
%    This function unconditionally defers the current float (in
%    |\g_xor_this_float_box_tl|) and then restarts trying the next float (if
%    any).
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_really_defer_and_try_next_float:{
%<*progress>
        \xor_progress_failed:n{-->~ defer}
        \xor_progress_newline:n{}
%</progress>
      \seq_gput_right:No \g_xor_area_DDD_float_seq \g_xor_this_float_box_tl
%<*trace>
      \trace:n{g_xor_curr_page_areas_closed_clist~ <-~ 
             "\g_xor_curr_page_areas_closed_clist"~ +~
             "\g_xor_area_DDD_all_close_clist"}
%</trace>
      \clist_gconcat:NNN \g_xor_curr_page_areas_closed_clist
                         \g_xor_curr_page_areas_closed_clist
                         \g_xor_area_DDD_all_close_clist

      \clist_if_eq:NNTF \g_xor_area_DDD_class_close_clist \g_xor_areas_used_clist
      {
%<*trace>
        \trace:n{g_xor_this_areas_closed_clist~ <-~
               "\g_xor_area_DDD_class_close_clist"~ (all~ closed)}
%</trace>
        \clist_gset_eq:NN \g_xor_this_areas_closed_clist 
                          \g_xor_area_DDD_class_close_clist
      }
      {
%<*trace>
        \trace:n{g_xor_this_areas_closed_clist~ <-~ 
               "\g_xor_this_areas_closed_clist"~ +~
               "\g_xor_area_DDD_class_close_clist"}
%</trace>
        \clist_gconcat:NNN \g_xor_this_areas_closed_clist
                           \g_xor_this_areas_closed_clist
                           \g_xor_area_DDD_class_close_clist
      }

      \clist_gset_eq:cN {g_xor_class_ \g_xor_this_class_tl _areas_closed_clist} % FMi tmp
                        \g_xor_this_areas_closed_clist
      \xor_try_next_float:
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_attempt_to_defer_and_try_next_float:}
%
%    This code either defers the current float and restarts by calling
%    |\xor_try_next_float:| or recurses after relaxing the placement
%    conditions (in case the current float should be flushed).
%
%    If the placement conditions are already relaxed we move the first
%    flush point that affects the current float one column forward and
%    then retry. This might result in succeeding to place the float, if
%    not it will ultimately result in the flush point being moved from
%    the page at which point the float can be deferred.
%
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_attempt_to_defer_and_try_next_float:{
%<*trace>
  \trace_push:n{xor_attempt_to_defer_and_try_next_float:}
%</trace>
%    \end{macrocode}
%    If there have been no flush points or if the flush points seen do
%    not affect the current float we can immediately defer it.
%    \begin{macrocode}
  \bool_if:NTF \g_xor_flush_seen_bool
  {
    \clist_if_in:NoTF
      \g_xor_flush_max_classes_clist
      \g_xor_this_class_tl
    {
%<*trace>
      \trace:n{flush:~ class~ \g_xor_this_class_tl\space in~
             \g_xor_flush_max_classes_clist}
%</trace>
%    \end{macrocode}
%    First test is just there to avoid doing any of the loops
%    (might not be worth having)
%    \begin{macrocode}
      \int_compare:nNnTF {\int_use:c {g_xor_flush_1_min_col_int}}
                       > \g_xor_curr_col_int
      {
%<*trace>
        \trace:n{flush:~ no~ flush~ points~ on~ page;~ defer}
%</trace>
        \xor_do_next:N\xor_really_defer_and_try_next_float:
      }
%    \end{macrocode}
%
%    The code is often invoked before there is an attempt to split the
%    galley; this means we don't know which flush point affects the
%    current float and thus have to manually get at it.
%
%    So we loop through the |\g_xor_flush_|\meta{num}|_last_float_int| values to ^^A((
%    find the first one that a) affects the current float type and b)
%    holds a sequence number that is higher or equal to the sequence
%    number of the current float.\footnote{Fix this loop structure. MH}
%    \begin{macrocode}
      {
        \count@ \c_one
        \loop
%    \end{macrocode}
%    If |\count@| is greater than |\g_xor_collect_flush_seen_int| we have exhausted
%    all possible flush points without finding a candidate.
%    \begin{macrocode}
          \int_compare:nNnTF \g_xor_collect_flush_seen_int < \count@
          { \in@false }
          {
%    \end{macrocode}
%    Otherwise, if |\g_xor_this_flseq_int| is greater than
%    |\g_xor_flush_|\meta{num}|_last_float_int| the current flush point is before
%    the call-out to the current float.
%    \begin{macrocode}
%<*trace>
            \trace:n{flush:~  \int_use:N \g_xor_this_flseq_int
                   \space ???~
                   \int_use:c {g_xor_flush_ \int_use:N \count@
                               _last_float_int}
                  }
%</trace>
            \int_compare:nNnTF \g_xor_this_flseq_int >
                   { \int_use:c{g_xor_flush_ \int_use:N \count@ _last_float_int } }
            {
%    \end{macrocode}
%    We set |\in@true| to get a repeat below with a new value of
%    |\count@|.
%    \begin{macrocode}
              \in@true
            }
            {
%    \end{macrocode}
%    Otherwise we have a flush point that is later in the galley in
%    comparison to the call-out of the current float thus potentially
%    affects it. Therefore we now have to check if the sequence class
%    of the current float is affected by the flush point found:
%    \begin{macrocode}
              \clist_if_in:coTF
                {g_xor_flush_ \int_use:N \count@ _classes_clist}
                \g_xor_this_class_tl
%    \end{macrocode}
%    Now we could make good use of the |\unless| primitive of
%    e\TeX. But since we want to run with standard \TeX{} and don't
%    have |\xnotin@| available we invert the result.
%    \begin{macrocode}
              {
                \in@false
              }
              {
                \in@true
%<*trace>
                 \trace:n{flush:~ class~ \g_xor_this_class_tl\space not~ in~
                   \clist_use:c {g_xor_flush_ \int_use:N \count@ _classes_clist}
                   \space (ignored)
                   }
%</trace>
              }
            }
          }
        \ifin@
          \int_incr:N \count@
        \repeat
%<*trace>
        \trace:n{flush:~ first~ float~ point~ after~ float~ =~
               \int_use:N \count@}
%</trace>
        \int_compare:nNnTF \g_xor_collect_flush_seen_int < \count@
        {
%<*trace>
          \trace:n{flush:~ this~ float~ past~all~flush~ points;~ defer}
%</trace>
          \xor_do_next:N\xor_really_defer_and_try_next_float:
        }
%    \end{macrocode}
%    Once a |\g_xor_flush_NUM_min_col_int| is larger 
%    than |\g_xor_curr_col_int| it has
%    moved to the next page. In particular this is true for the
%    artificial value |\maxdimen| to which it is sometimes set to
%    denote this fact. If so we can defer our float.
%    \begin{macrocode}
        {
          \int_compare:nNnTF { \int_use:c{g_xor_flush_ 
                                          \int_use:N \count@ 
                                          _min_col_int }}
                             > \g_xor_curr_col_int
          {
%<*trace>
            \trace:n{flush:~ float~ past~ all~ flush~ points~
                   on~ current~ page;~ defer}
%</trace>
            \xor_do_next:N\xor_really_defer_and_try_next_float:
          }
%    \end{macrocode}
%    If we have already relaxed the conditions and we are still in
%    conflict with a flush point on the current page we nearly ran out
%    of options. In this case we are forced to move the flush point,
%    but rather than moving it to the next page and deferring the float
%    we can move it one column further (which might make it fall off
%    the page though) and then retry to place the float since we have
%    now more space available.
%    \begin{macrocode}
          {
            \if_meaning:w \xor_try_this_area: \xor_try_this_area_relaxed:
%<*trace>
              \trace:n{flush:~ defer~ forced;~ move~
                     flush~ point~ columns}
%</trace>
%<*progress>
              \xor_progress_newline:n{}
              \xor_progress_newline:n{Flushing~ impossible~ -->~ breaking~
                           before~ flush~ point~ and~ retry}
%</progress>
%    \end{macrocode}
%    We should only increment the |\g_xor_flush_NUM_min_col_int| value of the first
%    flush point that affects our float (this will automatically move
%    later flush points if necessary). Incrementing the later ones is
%    incorrect as they might not need moving!
%    \begin{macrocode}
              \int_gincr:c {g_xor_flush_ \int_use:N \count@ _min_col_int}
%<*trace>
              \trace:n{g_xor_flush_ \int_use:N \count@ _min_col_int \space <-~
                     \int_use:c {g_xor_flush_ \int_use:N \count@ _min_col_int}
                     }
%</trace>
%<*progress>
              \xor_progress_newline:n{}
              \xor_progress_newline:n{Defer~ impossible~ -->~ moving~
                           flush~ point~ to~ column~
                           \int_use:c {g_xor_flush_ \int_use:N \count@ _min_col_int}
                           \space
                           and~ retry}
%</progress>
%    \end{macrocode}
%    Not clear that it is really necessary to check all areas again,
%    but it is late (after midnight) and it is definitely not
%    wrong.\footnote{Check!}
%    \begin{macrocode}
              \xor_relax_float_placement_conditions:  % needed to reset open areas
                                                      % not to ``relax'' the conditions as
                                                      % they are already relaxed
              \xor_do_next:N\xor_try_this_area:

            \else:
%    \end{macrocode}
%
%    \begin{macrocode}
              \xor_relax_float_placement_conditions:
              \xor_do_next:N\xor_try_this_area:
            \fi:
          }
        }
      }
    }
    {
%<*trace>
      \trace:n{flush:~ class~ \g_xor_this_class_tl\space not~ in~
             \g_xor_flush_max_classes_clist ;~ defer}
%</trace>
      \xor_do_next:N\xor_really_defer_and_try_next_float:
    }
  }
  {
%<*trace>
    \trace:n{flush:~ no~ flush~ point~ seen; defer}
%</trace>
    \xor_do_next:N\xor_really_defer_and_try_next_float:
  }
%<*trace>
  \trace_pop:n{xor_attempt_to_defer_and_try_next_float:}
%</trace>
  \xor_continue:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_relax_float_placement_conditions:}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_relax_float_placement_conditions: {
%<*progress>
    \xor_progress_failed:n{-->~ retry~ with~ relaxed~ conditions}
    \xor_progress_newline:n{}
%</progress>
%<*trace>
    \trace:n{flush:~relax~placement~conditions}
%</trace>
    \clist_gset_eq:NN \g_xor_this_areas_open_clist
                      \g_xor_saved_this_areas_open_clist
%<*trace>
    \trace:n{~g_xor_this_areas_open_clist~
           <-~
           \g_xor_this_areas_open_clist \space (reopen)}
%</trace>
    \cs_gset_eq:NN \xor_try_this_area:              \xor_try_this_area_relaxed:
    \cs_gset_eq:NN \xor_check_float_constraints:    \xor_check_some_constraints_relaxed:
    \cs_gset_eq:NN \xor_check_callout_constraints:n \xor_check_callout_constraints_relaxed:n
    \cs_gset_eq:NN \xor_calculate_float_col:        \xor_calculate_float_col_relaxed:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_tighten_float_placement_conditions:}
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_tighten_float_placement_conditions: {
%<*trace>
    \trace:n{flush:~tighten~placement~conditions}
%</trace>
    \cs_gset_eq:NN \xor_try_this_area: \xor_try_this_area_std:

    \cs_gset_eq:NN \xor_check_float_constraints:    \xor_check_some_constraints_std:
    \cs_gset_eq:NN \xor_check_callout_constraints:n \xor_std_check_callout_constraints:n
    \cs_gset_eq:NN \xor_calculate_float_col:        \xor_calculate_float_col_std:
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_partly_tighten_float_placement_conditions:}
%    This is used when we have placed the last float that is affected
%    by a certain flush point. We don't want to tighten up completely
%    since this would essentially mean that we can't place any further
%    floats since callout relationships etc might be violated for
%    them. Good question is whether or not the last restriction should
%    be used again since this too might prevent any further placements.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_partly_tighten_float_placement_conditions: {
%<*trace>
    \trace:n{flush:~partly~tighten~placement~conditions}
%</trace>
    \cs_gset_eq:NN \xor_try_this_area: \xor_try_this_area_std:

%    \cs_gset_eq:NN \xor_check_float_constraints:\xor_check_some_constraints_std:
%    \cs_gset_eq:NN \xor_check_callout_constraints:n    \xor_std_check_callout_constraints:n
    \cs_gset_eq:NN \xor_calculate_float_col: \xor_calculate_float_col_std:
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Checking float placement during trial}
%
% The interface to checking float placement in relation to its callout
% is the following piece of code in |\xor_OR_grab_trial_cols:|:
%\begin{verbatim}
%    \seq_map_function:NN \g_xor_float_classes_seq
%                         \xor_check_callout_constraints:n
%\end{verbatim}
% This loops through all float types and executes
% |\xor_check_callout_constraints:n| with the float type as an argument. The output
% routine |\xor_OR_grab_trial_cols:| itself is called for each column of a trial
% configuration, thus the above loop is called for each column
% individually (|\g_xor_curr_col_int| can be used to determine the current
% column number).
%
% By giving |\xor_check_callout_constraints:n| an appropriate definition a
% pagesetup template can implement different relationships between
% callout and float.
%
% Possible tests (getting stronger):
% \begin{itemize}
%
% \item
%   Don't check, i.e., add the float when you find it and it fits
%   according to other criteria (like number of floats in the area,
%   etc.). This is implemented in |\xor_check_callout_none:n|.
%
%
% \item
%  Check if callouts for all floats on the page (not column) are
%  either on the same page or on an earlier page; i.e., callout can be
%  late as long as the float is visible from the callout.
%
%   Fail if for last column and all float types:
%     last callout number for float type is smaller than maximum last float
%     of type put into any column.\footnote{This description is
%     probably wrong}
%
%   This is implemented in |\xor_check_callout_page:n|.
%
% \item
%  Check if callouts for all floats in the column are either on the
%  same column or on an earlier column.
%
%  Fail if for any column and any float type:
%  last callout number for float type is smaller last float sequence
%  number for type recorded for this column.
%
%  This case consists in fact of two subcases depending on how we
%  interpret to which column a spanning float belongs. If we claim
%  that a spanning float is placed into its starting column, then we
%  fail if its call-out is in a later column even though this column
%  might still be spanned by the float area.
%
%  This is implemented in |\xor_check_callout_column:n|.
%
% \item
%  Check if callouts for all floats in the column are on an earlier
%   column or if on the same column the float was added to the bottom
%   (or marginal) area; i.e. strict float/callout order
%
%   Fail if for each type and for any column:
%     `top' callout number  less than `top' float number
%      (at top of text column)
%\begin{verbatim}
%      [Correctness proof:
%       TRUE  => first callout's float comes before bottom
%                  and so comes too early
%             => FAIL
%       FALSE => first callout's float comes in bottom and all other
%                  callouts come later and so are in bottom or beyond
%             => OK
%       ]
%\end{verbatim}
%   The proof above is in fact only valid if you look at the whole
%   document and not only at a single page since a float in the bottom
%   area of the last column with its callout on the next page will
%   only be detected when testing the next page. Therefore one needs
%   an additional check of type |\xor_check_callout_column:n|.
%
%   This is implemented in |\xor_check_callout_after:n|.
%
%
% \end{itemize}
%
%
% \begin{macro}{\xor_check_callout_none:n}
%    This test is an easy one: just do nothing, i.e., gobble the argument.
%    \begin{macrocode}
\cs_new_eq:NN \xor_check_callout_none:n \use_none:n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_check_callout_page:n}
%    We are only interested in the callout/float relation per page
%    we only have to do a check when producing the last column, i.e.,
%    when |\g_xor_curr_col_int| is |\g_xor_cols_int|.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_check_callout_page:n#1{
%<*trace>
  \trace_push:n{xor_check_callout_page:n}
%</trace>
  \int_compare:nNnT \g_xor_curr_col_int=\g_xor_cols_int
  {
%    \end{macrocode}
%    We store in |\g_xor_flseq_max_int| the highest sequence number for floats of
%    the current type up to the end of the page. For this we have to
%    find the maximum of |\g_xor_flseq_type_|\meta{type}|_col_0_int| (highest
%    float number on 
%    previous pages) and those for the columns, e.g.,
%    |\g_xor_flseq_type_|\meta{type}|_col_|\meta{column}|_int|; this is done
%    by the following 
%    code:
%    \begin{macrocode}
    \int_gset_eq:Nc \g_xor_flseq_max_int
                    { g_xor_flseq_type_#1_col_0_int }
    \xor_forall_columns:n {
      \int_compare:nNnT {\int_use:c{g_xor_flseq_type_#1_col_ 
                                    \int_use:N \g_xor_curr_col_int 
                                    _int} }
                        > \g_xor_flseq_max_int
      {
         \int_gset_eq:Nc \g_xor_flseq_max_int 
                         { g_xor_flseq_type_#1_col_ 
                          \int_use:N \g_xor_curr_col_int 
                          _int }
      }
    }
%    \end{macrocode}
%    We then store the number of the last callout in |\count@|; the
%    |0| will take care of the potential problem that there was never any
%    callout so far. And we better have a |\relax| afterwards since
%    otherwise we will expand the |\ifnum| before we have finished
%    assigning the |\count@|.
%    \begin{macrocode}
    \count@0\LastMark{#1}\relax
%<*trace>
    \trace:n{Last~callout~ (#1)~ =~ \int_use:N \count@}
%{\showoutput\showbox255}
%</trace>
%    \end{macrocode}
%    Now we have to compare those two numbers to find out if that
%    trial has failed:
%    \begin{macrocode}
    \int_compare:nNnT \count@ < \g_xor_flseq_max_int
    {
      \bool_gset_true:N \g_xor_trial_failed_bool
%<*progress>
      \xor_progress_failed:n{last~callout~
        \int_use:N \count@\space~<~\int_use:N \g_xor_flseq_max_int
        \space last~float~put~on~page~or~ earlier}
%</progress>
%<*trace>
      \trace:n{Failed:~(#1)~ last~callout~
        \int_use:N \count@\space~<~\int_use:N \g_xor_flseq_max_int
        \space last~float~put~on~page~or~ earlier}
    }
    {
    \trace:n{OK:~(#1)~ last~callout~
       \int_use:N \count@\space~>=~\int_use:N \g_xor_flseq_max_int
       \space last~float~put~on~page~or~ earlier}
%</trace>
    }
  }
%<*trace>
  \trace_pop:n{xor_check_callout_page:n}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_flseq_max_int}
%    The macro |\g_xor_flseq_max_int| is used within |\xor_check_callout_page:n| to hold
%    the highest sequence number of any allocated float on the current
%    page for the type under testing.  It will be recalculated on
%    each pass.\footnote{One could generate this value while running through
%    the trials --- this would perhaps be a bit more time efficient.}
%    \begin{macrocode}
\int_new:N \g_xor_flseq_max_int
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_check_callout_column:n}
%    Checking each column separately means we have to compare for each
%    type the last callout on this or previous columns (i.e., as
%    returned by |\LastMark|) with the highest sequence number for
%    floats of this type in the current column (as stored in
%    |\g_xor_flseq_type_|\meta{type}|_col_|\meta{column}|_int|). So we first store the callout
%    info in |\count@|.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_check_callout_column:n#1{
%<*trace>
  \trace_push:n{xor_check_callout_column:n}
%</trace>
  \count@0\LastMark{#1}\relax
%<*trace>
    \trace:n{Last~callout~ (#1)~ =~ \int_use:N \count@}
%</trace>
%    \end{macrocode}
%    Then we do the test. If there are no floats of the current type
%    in the current column
%    |\g_xor_flseq_type_|\meta{type}|_col_|\meta{column}|_int| will be zero
%    and thus the following test will come out true. This is the
%    correct behaviour as any callouts that might be present will be
%    correctly evaluated in tests on neighboring columns with floats.
%    \begin{macrocode}
  \int_compare:nNnTF \count@< {\int_use:c{g_xor_flseq_type_#1_col_ 
                                          \int_use:N \g_xor_curr_col_int
                                          _int}}
  {
%<*progress>
    \xor_progress_failed:n{last~ callout~
         \int_use:N \count@\space <~
         \int_use:c {g_xor_flseq_type_#1_col_ \int_use:N \g_xor_curr_col_int _int}
         \space last~ float~ placed~ in~ column~ \int_use:N \g_xor_curr_col_int}
%</progress>
%<*trace>
    \trace:n{Failed:~(#1)~ last~ callout~
         \int_use:N \count@\space <~
         \int_use:c{g_xor_flseq_type_#1_col_ \int_use:N \g_xor_curr_col_int _int}
         \space last~float~placed}
%</trace>
%    \end{macrocode}
%    If the test fails we abort this trial by setting the switch
%    |@fail| to true. We also set
%    |\g_xor_curr_col_int| to |\g_xor_cols_int| which will save us any further
%    iteration (in case this wasn't the last column). Finally we
%    locally set |\__seq_item:n| to gobble which will essentially abort
%    the current loop through the |\g_xor_float_classes_seq|.
%    \begin{macrocode}
      \bool_gset_true:N \g_xor_trial_failed_bool
      \int_gset:Nn \g_xor_curr_col_int \g_xor_cols_int
%% need \g_xor_curr_col_block_intsetting?
%FMi tmp
      \cs_set:Npn \__seq_item:n ##1 { }
%    \end{macrocode}
%    Otherwise the constraints for callout of current float type are
%    met so we report this fact if we do tracing.
%    \begin{macrocode}
  }
  {
%<*trace>
  \trace:n{OK:~(#1)~ last~ callout~
         \int_use:N \count@\space >=~
         \int_use:c {g_xor_flseq_type_#1_col_ \int_use:N \g_xor_curr_col_int _int}
         \space last~float~placed}
%</trace>
  }
%<*trace>
  \trace_pop:n{xor_check_callout_column:n}
%</trace>
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\g_xor_flseq_returned_int}
%    \begin{macrocode}
\int_new:N \g_xor_flseq_returned_int
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_check_callout_after:n}
%
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_check_callout_after:n#1{
%<*trace>
  \trace_push:n{xor_check_callout_after:n}
%</trace>
%    \end{macrocode}
%
%    We first check if all floats are either on the same column than
%    their callout or on an later column by calling
%    |\xor_check_callout_column:n|. If this returns true (in
%    |\g_xor_trial_failed_bool|) we immediately 
%    abort any further processing.
%    \begin{macrocode}
  \xor_check_callout_column:n{#1}
  \bool_if:NF \g_xor_trial_failed_bool
  {
%    \end{macrocode}
%
%    If the above check found no violation we have to check for top
%    area floats that might precede their callouts.
%
%    For this we look at the value of the \\
%    |\g_xor_flseq_areas_top_type_|\meta{float-type}|_col_|\meta{col}|_int|
%    macro which holds the
%    highest float sequence number for floats of this type allocated
%    in that column.
%    \begin{macrocode}
    \int_gset:Nn
        \g_xor_flseq_returned_int
        { \int_use:c { g_xor_flseq_areas_top_type_#1_col_
                        \int_use:N \g_xor_curr_col_int _int } }
%    \end{macrocode}
%
%    If there was no float in the top area we get |0| back and in
%    that case we are done since all our constraints are met.
%    \begin{macrocode}
    \int_compare:nNnTF \g_xor_flseq_returned_int = \c_zero
    {
%<*trace>
      \trace:n{OK:~(#1)~ top~ areas~ have~ no~ floats}
%</trace>
    }
    {
%    \end{macrocode}
%
%    Otherwise we have to look at the top callout number and compare
%    it to the last float number of the top area.
%    \begin{macrocode}
      \count@ 0\PreviousMark{#1}\relax
%    \end{macrocode}
%    If that callout number is less than the last float number we
%    failed since this means that there is a float in the top area
%    which callout has not yet been seem. So we abort the
%    trial. Otherwise our constraints are met.
%    \begin{macrocode}
      \int_compare:nNnT \count@ < \g_xor_flseq_returned_int
      {
%    \end{macrocode}
%    But before aborting we give some information on why we
%    failed. This has to come first since we change |\g_xor_curr_col_int|
%    below.
%    \begin{macrocode}
%<*progress>
        \xor_progress_failed:n{top~ callout~
              \int_use:N \count@\space <~ \int_use:N \g_xor_flseq_returned_int
              \space last~ float~ put~ in~ top~
              of~ column~ \int_use:N \g_xor_curr_col_int}
%</progress>
        \bool_gset_true:N \g_xor_trial_failed_bool
        \int_gset:Nn \g_xor_curr_col_int \g_xor_cols_int
%FMi tmp
        \cs_set:Npn \__seq_item:n ##1 { }
%<*trace>
        \trace:n{Failed:~(#1)~ top~ callout~
              \int_use:N \count@\space <~ \int_use:N \g_xor_flseq_returned_int
              \space last~float~put~in~top}
      }
      {
        \trace:n{OK:~(#1)~ top~ callout~
               \int_use:N \count@\space >=~ \int_use:N \g_xor_flseq_returned_int
              \space last~float~put~in~top}
%</trace>
      }
    }
  }
%<*trace>
  \trace_pop:n{xor_check_callout_after:n}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Checking bottom float footnote constraints}
%
% In |\xor_OR_grab_trial_cols:| (when the output routine that grabs a single column
% during a trial) we have the command |\xor_check_float_constraints:| which
% allows to check some constraints and if they aren't met is supposed
% to set the switch |\g_xor_trial_failed_bool| to true.
%
% This can, for example be used to implement a constraint that bottom
% floats are only allowed if there are no footnotes in the current
% column.\footnote{At the moment this is restricted to single column
%    floats. Spanning floats are always allowed.}
%
% \begin{macro}{\xor_check_float_footnote_forbidden:}
%    The command |\xor_check_float_footnote_forbidden| is the
%    implementation for |\xor_check_float_constraints:| that prevents bottom
%    floats if the current column contains footnotes.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_check_float_footnote_forbidden: {
%<*trace>
  \trace_push:n{xor_check_float_footnote_forbidden:}
%</trace>
%    \end{macrocode}
%    With the extended possibilities in footnote placement this probably has
%    to be augmented  and/or rewritten. For the moment, I only added an
%    additional check for |\g_xor_saved_footins_box| but this isn't the right
%    way to proceed as the page-wide footnotes would be below the bottom
%    floats not above.
%
%    And if we relax the placement restrictions it shows that footnotes and
%    floats overprint as the current page build operation doesn't really
%    understand the situation (yet).\footnote{fix this area when the page is
%    being templated.}
%    \begin{macrocode}
%  \box_if_empty:NF \g_xor_footins_box
  \bool_if:nF 
     { \box_if_empty_p:N \g_xor_footins_box &&
       \box_if_empty_p:N \g_xor_saved_footins_box }
  {
%    \end{macrocode}
%    If the current column contains footnotes and we have bottom
%    floats we fail. First we check if there is a bottom area for this
%    column defined if not we pretend there is an empty one.
%    \begin{macrocode}
    \cs_if_free:cT {g_xor_area_
                 b\int_use:N\g_xor_curr_col_int 1
                 _float_seq}
    {
      \seq_gclear:c {g_xor_area_
                     b\int_use:N\g_xor_curr_col_int 1
                     _float_seq}
    }
%    \end{macrocode}
%    Then we check if the bottom area is empty and fail otherwise
%    \begin{macrocode}
%<+trace> \seq_if_empty:cTF
%<-trace> \seq_if_empty:cF
        {g_xor_area_
         b\int_use:N\g_xor_curr_col_int 1
         _float_seq}
%<*trace>
        { \trace:n{OK:~ no~ old~ bottom~ floats} }
%</trace>
        {
%<*progress>
          \xor_progress_failed:n{old~bottom~floats:~
          \cs_meaning:c{g_xor_area_ 
                        b\int_use:N\g_xor_curr_col_int 1 
                        _float_seq}}
%</progress>
%<*trace>
          \trace:n{Failed:~ old~bottom~floats:~ \cs_meaning:c
            {g_xor_area_ b1\int_use:N\g_xor_curr_col_int _float_seq}}
%</trace>
          \bool_gset_true:N \g_xor_trial_failed_bool
        }
%    \end{macrocode}
%    Finally we test if the float we are try to place is going onto a
%    bottom area.
%
%    However, we only do this if the float doesn't span.\footnote{Extend?}
%    \begin{macrocode}
    \int_compare:nNnT \g_xor_this_area_span_tl = \c_one
    {
%<*trace>
      \trace:n{this@area,column:~ \g_xor_this_area_name_tl,~
             \int_use:N \g_xor_curr_col_int}
%</trace>
      \if b \g_xor_this_area_type_tl
         \int_compare:nNnT \g_xor_this_area_col_tl = \g_xor_curr_col_int
         { \bool_gset_true:N \g_xor_trial_failed_bool }
      \fi
    }
    \bool_if:NT \g_xor_trial_failed_bool
    {
%<*progress>
      \xor_progress_failed:n{column~ \int_use:N \g_xor_curr_col_int\space
                            contains~ footnotes~ and~ bottom~ floats}
%</progress>
%<*trace>
      \trace:n{Failed:~ column~ \int_use:N \g_xor_curr_col_int\space
                      contains~ footnotes~ and~ bottom~ floats}
%</trace>
      \int_gset:Nn \g_xor_curr_col_int \g_xor_cols_int
%% need \g_xor_curr_col_block_int setting?
    }
  }
%<*trace>
  \trace_pop:n{xor_check_float_footnote_forbidden:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_check_float_footnote_none:}
%
%    This is the implementation for |\xor_check_float_constraints:| if we
%    don't care about mixing footnotes and bottom floats. The reason
%    |\prg_do_nothing:| rather than |\scan_stop:| is used is that otherwise the
%    |\ifx| test in the template would fail.
%    \begin{macrocode}
\cs_set_eq:NN \xor_check_float_footnote_none: \prg_do_nothing:
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \endinput
\endinput
