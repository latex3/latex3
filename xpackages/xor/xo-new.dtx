% \iffalse
%% File xo-new.dtx (C) Copyright 1999-2000 Frank Mittelbach, David Carlisle, Chris Rowley
%%                 (C) Copyright 2001 Frank Mittelbach, The LaTeX3 Project
%%                 (C) Copyright 2003 Piet van Oostrum, David Kastrup
%%                 (C) Copyright 2004-2009 Frank Mittelbach, The LaTeX3 Project
%%                 (C) Copyright 2010-2012 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xor bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
\RequirePackage{l3bootstrap}
\GetIdInfo $Id$
          {xo-new (part of xor)}
\ProvidesExplPackage{\ExplFileName}
  {\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
% \fi
%
%
% This package (xo-new) is available for test overwrites that need integration
% into the main packages at some point
%
%
%
%  \begin{macro}{\g_test_bool}
%    
%    \begin{macrocode}
      \bool_new:N\g_test_bool
%    \end{macrocode}
%  \end{macro}
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% STUFF THAT CHANGES CHRIS' xo-final (from 2000 or thereabouts)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%    \begin{macrocode}

\flushbottom






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%changes to xo-final
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iftrue %  using Frank's changes built on 1.15




\RequirePackage{xo-pagestyle}
%    \begin{macrocode}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% my new xo-final stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\cs_new_nopar:Npn \mynewfinalpage {

  \xor_forall_columns:n{
%<*trace>
     \trace:n{\xor_curr_col_block: ~=~ \dim_use:N\box_ht:c {g_xor_col_ \xor_curr_col_block: _box}}
%</trace>
 }

\myfinalpage

}



%    \begin{macrocode}
\cs_set_nopar:Npn  \myfinalpage {
%    \end{macrocode}
%    Next code decides whether special pagestyle for current page is
%    needed.\footnote{FIX: This is required for any page generation so should happen earlier.}
%    \begin{macrocode}
  \xor_run_pagestyle_instance:
  \xor_perhaps_write_placements_to_fpl_file:
%    \end{macrocode}
%    Now decide what kind of page style should be used:\footnote{fix: clean up
%    pagebodylefthpos stuff}
%    \begin{macrocode}
  \int_compare:nNnTF  \g_xor_page_absolute_int = \c_one
   {
    \cs_set_eq:NN \pagebodylefthpos\oddsidemargin
    \xor_pagestyle_first:
   }
   {
    \if@twoside
      \int_if_odd:nTF \g_xor_page_absolute_int
        {
	 \cs_set_eq:NN \pagebodylefthpos\oddsidemargin   % cleanup this stuff here

	 \xor_pagestyle_text_odd:
        }
        {
	 \cs_set_eq:NN \pagebodylefthpos\evensidemargin

	 \xor_pagestyle_text_even:
        }
    \else
      \cs_set_eq:NN \pagebodylefthpos\oddsidemargin

      \xor_pagestyle_text_odd:
    \fi
   }
%    \end{macrocode}
%    
%    \begin{macrocode}
    \mbox@addtopage (\pagebodylefthpos, -\headsep)
       { \xor_generate_running_head: }
%    \end{macrocode}
%
%    \begin{macrocode}
%    Init |\dimen|1,2,3,\ldots as vertical current point per column
%    (don't forget in Chris's (sorry, Don's) universum zero is at the
%    top).
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_forall_columns:n{
     \dimen \int_use:N\g_xor_curr_col_int
            \c_zero_dim
  }
%    \end{macrocode}
%    Now mount all top areas looping through an ordered list of top
%    areas.
%    \begin{macrocode}
  \exp_after:wN\mount@top@areas@loop
      \top@areas
      \relax\relax\relax
%    \end{macrocode}
%    Next mount the text columns.
%    \begin{macrocode}
  \xor_forall_columns:n{


% temp solution: add the amount of top floats to the real size of text material
% so that below the bottom floats are correctly mounted
% needs a totally different approach!!!

\advance \csname g_xor_best_ht_col_ \xor_curr_col_block:
                 _dim\endcsname 
by \dimen\g_xor_curr_col_int \relax

%<*trace>
     \trace:n{GRID (delta):~ column~\int_use:N\g_xor_curr_col_int t:~
        \dim_use:c {g_xor_t_delta_col_ \int_use:N\g_xor_curr_col_int _dim}
        \space used}
%</trace>
%%% dangerous scratch registers ... FIX
     \advance \dimen \int_use:N\g_xor_curr_col_int
              by %NEEDED!!!!!
              \csname g_xor_t_delta_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname

     \advance \dimen \int_use:N\g_xor_curr_col_int
              \csname g_xor_ht_col_ \xor_curr_col_block: _dim\endcsname


    \setlength \l_tmpa_dim
        {\pagebodylefthpos - \columndisplacement
                           + \columndisplacement * \g_xor_curr_col_int }


    \mbox@addtopage ( \dim_use:N \l_tmpa_dim ,\the \dimen\g_xor_curr_col_int  )
         { \box_use_clear:c {g_xor_col_ \xor_curr_col_block: _box} }

% here we adjust for the fact that the text column size is rubbish if
% balancing was involved!

\dimen\g_xor_curr_col_int = 
   \csname g_xor_best_ht_col_ \xor_curr_col_block: _dim\endcsname

%<*trace>
    \trace:n{GRID (delta):~ column~\int_use:N\g_xor_curr_col_int b:~
        \dim_use:c {g_xor_b_delta_col_ \int_use:N\g_xor_curr_col_int _dim}
        \space used}
%</trace>
     \advance \dimen \int_use:N\g_xor_curr_col_int
              by %NEEDED!!!!!
              \csname g_xor_b_delta_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname
  }
%    \end{macrocode}
%    Then mount the bottom floats.
%    \begin{macrocode}
  \cs_set_nopar:Npn \col@of@focus{0}               % temp solution see below
  \exp_after:wN\mount@bot@areas@loop
      \bot@areas
      \relax\relax\relax
%    \end{macrocode}
%
%    Next thing is absolutely temp: mount a marginal area on the right
%    (bottom) to allow footnotes there (this is just for testing).
%    \begin{macrocode}
  \setlength \l_tmpa_dim
     {\pagebodylefthpos + \columndisplacement * \g_xor_cols_int }
%    \end{macrocode}
%    Next lines would added the saved footins to the right side for debugging
%    \begin{macrocode}
%   \mbox@addtopage ( \dim_use:N \l_tmpa_dim , \textheight )
%     { \box_use_clear:N \g_xor_saved_footins_box } % TEMP FMi
%    \end{macrocode}
%
%    Another temp.\ solution, we just mount the page-wide footnotes at the
%    bottom of the page. The rest doesn't yet know about them so that bottom
%    floats will overprint this area
%    \begin{macrocode}
  \mbox@addtopage ( \pagebodylefthpos , \textheight )
     { \box_use_clear:N \g_xor_saved_footins_box } % TEMP FMi

%%{\showoutput\showbox\page@box}
%    \end{macrocode}
%    
%    \begin{macrocode}
   \setlength \l_tmpa_dim       % add footer PvO
     {\textheight + \footskip}
   \mbox@addtopage (\pagebodylefthpos, \l_tmpa_dim)
       {\xor_generate_running_foot:}
%
%    Next thing is absolutely temp: mount a marginal area on the right
%    (bottom) to allow marginal floats there (this is just for testing).
%    \begin{macrocode}
  \cs_if_free:cF {g_xor_area_ m1\int_use:N\g_xor_curr_col_int
                          _float_seq }
  {
    \g_xor_curr_col_int\g_xor_cols_int
%FMi was local, why?
    \int_gincr:N \g_xor_curr_col_int
    \make@area@floats@box {m \int_use:N\g_xor_curr_col_int 1}\l_tmpa_box
    \setlength \l_tmpa_dim
       {\pagebodylefthpos + \columndisplacement * \g_xor_cols_int }
    \mbox@addtopage ( \dim_use:N \l_tmpa_dim , \textheight )
        { \vbox_to_ht:nn \textheight {\vfil \vbox_unpack_clear:N \l_tmpa_box  \vfil }}
  }
%
  \ifShowGrid
%<*trace>
    \trace:n{GRID (displaying~ on~ page~ \thepage)}
%</trace>

    \dim_compare:nNnT \g_xor_grid_point_sep_dim > \c_zero_dim
    {
      \int_set:Nn \l_tmpa_int \textheight
      \int_set:Nn \l_tmpb_int \topskip
      \int_sub:Nn \l_tmpa_int \l_tmpb_int
      \dim_set:Nn \l_tmpb_dim \g_xor_grid_point_sep_dim
      \int_set:Nn \l_tmpb_int \l_tmpb_dim
      \divide\l_tmpa_int\l_tmpb_int
      \int_incr:N \l_tmpa_int

      \setlength \l_tmpb_dim
            {\columndisplacement * \g_xor_cols_int - \columnsep }
      \int_set:Nn \count@ \l_tmpb_dim

      \sbox\grid@box{
               \setlength\unitlength{1sp}
               \begin{picture}(0,0)
                 \multiput(0,0)(0,\l_tmpb_int){\l_tmpa_int}
                   {\line(1,0){\count@}}
               \end{picture}
               }

      \mbox@addtopage ( \pagebodylefthpos ,\textheight  )
             {  \box_use_clear:N \grid@box }
    }
%<*trace>
  \else
    \trace:n{GRID (hiding~ on~ page~ \thepage)}
%</trace>
  \fi
  \box_ht:N\page@box=\topmargin %PvO
}

\box_new:N\grid@box

\newif\ifShowGrid
\ShowGridtrue

% for tracing only (unchanged)


\cs_set_nopar:Npn \mbox@addtopage (#1,#2)#3{%
%  \trace:n{box~being~added~to~page:~at~(#1,~#2) }
  \hbox_gset:Nn \page@box
    {
      \hbox_unpack_clear:N \page@box
      \mbox@put  (#1,#2) {#3}
    }
}




\cs_set_nopar:Npn \mount@top@areas@loop#1#2#3{
  \ifx#1\relax
  \else
    \mount@top@area#1#2#3
    \exp_after:wN\mount@top@areas@loop
  \fi}


\cs_set_nopar:Npn \mount@top@area#1#2#3 {
  \make@area@floats@box {#1#2#3}\l_tmpa_box

  \box_if_empty:NF \l_tmpa_box
  {

    \setlength \l_tmpb_dim
        { \dimen#2 + \box_ht:N\l_tmpa_box  + \box_dp:N\l_tmpa_box  }

    \setlength \l_tmpa_dim
        {\pagebodylefthpos - \columndisplacement + \columndisplacement * #2 }

    \mbox@addtopage ( \dim_use:N \l_tmpa_dim ,\dim_use:N \l_tmpb_dim  )
         { \box_use_clear:N \l_tmpa_box  }

    \count@ #2\relax
    \int_add:Nn \count@ {#3}
    \int_while_do:nNnn {#2} < \count@
    {
      \int_decr:N \count@
      \dimen \count@ =  \l_tmpb_dim
      \int_compare:nNnTF {\int_use:c {g_xor_t_floats_col_
                                        \int_use:N \count@
                                      _int}}
                          > \c_zero
         { \dim_add:Nn {\dimen \count@} \g_xor_float_area_skip }
         { \dim_add:Nn {\dimen \count@} \g_xor_float_text_skip }
    }
  }
}

\cs_set_nopar:Npn \mount@bot@areas@loop#1#2#3{
  \ifx#1\relax
  \else
    \mount@bot@area#1#2#3
    \exp_after:wN\mount@bot@areas@loop
  \fi}

\cs_set_nopar:Npn \mount@bot@area#1#2#3 {
  \make@area@floats@box {#1#2#3}\l_tmpa_box

  \box_if_empty:NF \l_tmpa_box
  {

    \setlength \l_tmpb_dim
        { \dimen#2 + \box_ht:N\l_tmpa_box  + \box_dp:N\l_tmpa_box  }

%    \end{macrocode}
%    There are probably much better ways to get the spacing right, the
%    one below is really only a temporary fix: in |\col@of@focus| we
%    remember the last column in which already applied
%    |\g_xor_float_text_skip|, any additional float area will
%    contribute another |\g_xor_float_area_skip|
%    instead.\footnote{To make this work it is absolutely necessary
%    that the floats in bot@areas are ordered by column!!! No-good. FIX!!}
%    \begin{macrocode}
    \int_compare:nNnTF \col@of@focus < {#2}
    {
      \cs_set_nopar:Npn \col@of@focus{#2}
      \dim_add:Nn \l_tmpb_dim
                  \g_xor_float_text_skip
    }
    {
      \dim_add:Nn \l_tmpb_dim
                  \g_xor_float_area_skip
    }

    \setlength \l_tmpa_dim
        {\pagebodylefthpos - \columndisplacement
         + \columndisplacement * #2 }

    \mbox@addtopage ( \dim_use:N \l_tmpa_dim ,\dim_use:N \l_tmpb_dim )
         { \box_use_clear:N \l_tmpa_box }

%    \end{macrocode}
%    Next loop is actually not necessary as long we keep the
%    restriction that we don't allow partial overlapping float areas, ie we
%    will never mount another float area in the columns that are
%    spanned by the current float area (other than potentially the
%    first and we set this one explicitly).
%    \begin{macrocode}
    \dimen #2 = \l_tmpb_dim
%    \count@ #2\relax
%    \int_add:Nn \count@ {#3}
%    \loop
%      \int_decr:N \count@
%      \dimen \count@ =  \l_tmpb_dim
%    \ifnum #2 < \count@
%    \repeat

  }
}


% of course \top@areas and \bot@areas should be constructed
% automatically when preparing the \g_xor_areas_used_clist or from the
% \g_xor_areas_known_clist 
% but for now i simply define them here:

\cs_set_nopar:Npn \top@areas{t13 t12 t22 t32 t11 t21 t31}

\cs_set_nopar:Npn \bot@areas{b11 b12 b13 b21 b22 b31 b32}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
% next line activates my version (well some of it is activated already
% above)
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cs_set_eq:NN \xor_make_page_box:\mynewfinalpage

\fi % end of stuff modifying xo-final 1.15



%    \end{macrocode}
%
%
% \begin{macro}{\xor_OR_grab_best_cols:}
%    Here is the output routine used when preparing the final columns,
%    an instantiation of |\xor_OR_grab_some_cols:nnnnn|. In contrast to the version
%    used for |\xor_OR_grab_trial_cols:| it doesn't do the tests.
%    \begin{macrocode}
\cs_set_nopar:Npn \xor_OR_grab_best_cols: {
  \xor_OR_grab_some_cols:nnnnn{best}
    \xor_OR_best_finish_col_or_block:
    {
      \@reinserts
      \vbox_unpack_clear:N\c_two_hundred_fifty_five
%    \end{macrocode}
%    Next line not okay! we need to add a penalty here but which one?
%    Or we need a different mechanism using either |\holdinginserts|
%    or a partial box line in collection OR.\footnote{FIX!!! there is
%    also another place like this!}
%    \begin{macrocode}
%       \penalty\c_zero  %FMi?
    }
    {
%    \end{macrocode}
%    \begin{macrocode}
% we do not output the hhh floats to the fpl file as they can't be changed
% right now
%      \xor_perhaps_write_to_fpl_file:n{
%        \@spaces Area:~hhh^^J
%        \exp_after:wN 
%        \xor_gen_float_placement_fpl_info:nnnnnnn
%           \the\toks\g_xor_curr_float_box_tl
%      }
      \xor_typeset_a_here_float:
    }
%    \end{macrocode}
%    What to do if we encounter a balance point; right now this needs to be a
%    function with two args.
%    \begin{macrocode}
    {
      \xor_best_handle_balance_point:nn
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_OR_grab_trial_cols:}
%    Here is the output routine used during trials, an instantiation
%    of |\xor_OR_grab_some_cols:nnnn|.
%    \begin{macrocode}
\cs_set_nopar:Npn \xor_OR_grab_trial_cols:{
  \xor_OR_grab_some_cols:nnnnn{grab}
    \xor_OR_trial_finish_block_or_col:
    \xor_OR_trial_check_flush:
    \xor_check_and_typeset_a_here_float:
    \xor_OR_trial_balance:NN
}
%    \end{macrocode}
% \end{macro}
%
%


%
% \begin{macro}{\xor_construct_and_test_col_hts:}
%    The |\xor_construct_and_test_col_hts:| loops over all columns
%    affected by the float area we want to place our float into
%    and reduces the column size as
%    needed. It sets the switch |\g_test_bool| to true in case the float
%    doesn't fit into area for some reason. It is up to the calling
%    macro to take proper action in this case (including resetting
%    column heights to their former values).
%    \begin{macrocode}
\cs_set_nopar:Npn \xor_construct_and_test_col_hts: {
%<*trace>
  \trace_push:n{xor_construct_and_test_col_hts:}
%</trace>
%    \end{macrocode}
%    We use the information from the area not from the float (which
%    allows us to put small floats into larger areas).
%    \begin{macrocode}

  \xor_if_this_area_type:NTF {m}
    {
     \xor_update_this_area_span_cols:n
      {
        \FOO
      }
    }
    {
     \xor_update_this_area_span_cols:n
      {
       \exp_args:Nc
	 \xor_construct_and_test_col_ht:nnn
	   {g_xor_ht_col_ 
	    \int_use:N \l_xor_update_col_int 
            _
            \xor_if_this_area_type:NTF {b}
              {\int_use:c{g_xor_col_ 
                          \int_use:N \l_xor_update_col_int 
                          _block_int}}
              {1}
	    _dim }
	   {\int_use:N \l_xor_update_col_int
            _
            \xor_if_this_area_type:NTF {b}
              {\int_use:c{g_xor_col_ 
                          \int_use:N \l_xor_update_col_int 
                          _block_int}}
              {1}
           }
	   {\int_use:N\l_xor_update_col_int}
%    \end{macrocode}
%    We need to break out of the updating loop if we found a column that
%    doesn't work, (a) to save time and (b) since the
%    |\xor_construct_and_test_col_ht:nn| resets the switch again to false
%    (in the current implementation).
%    \begin{macrocode}
	 \bool_if:NT \g_test_bool
	    { \int_zero:N \l_xor_update_col_int }   % break out of loop
      }
    }
%<*trace>
  \trace_pop:n{xor_construct_and_test_col_hts:}
%</trace>
}
%    \end{macrocode}
% \end{macro}


%    \begin{macrocode}
\cs_set_nopar:Npn \FOO{
    \trace_push:n{FOO}
    \xor_update_this_area_span_cols:n
      {
       \exp_args:Nc
	 \xor_construct_and_test_col_ht:nnn
	   {g_xor_ht_col_ 
	    \int_use:N \l_xor_update_col_int 
            _
            \xor_if_this_area_type:NTF {b}
              {\int_use:c{g_xor_col_ 
                          \int_use:N \l_xor_update_col_int 
                          _block_int}}
              {1}
	    _dim }
	   {\int_use:N \l_xor_update_col_int
            _
            \xor_if_this_area_type:NTF {b}
              {\int_use:c{g_xor_col_ 
                          \int_use:N \l_xor_update_col_int 
                          _block_int}}
              {1}
           }
	   {\int_use:N\l_xor_update_col_int}
%
% split the column (for the moment use trivial and incorrect algorithm without
%    any configuration possibilities)
%
\int_gincr:c{g_xor_col_ 
             \int_use:N \l_xor_update_col_int 
             _block_int}
\exp_args:NNc \dim_set:Nn \l_tmpa_dim
           {g_xor_ht_col_ 
  	     \int_use:N \l_xor_update_col_int 
             _1
	     _dim }
\dim_gset:cn{g_xor_ht_col_ 
  	     \int_use:N \l_xor_update_col_int 
             _1
	     _dim }
            {.6\l_tmpa_dim}
\dim_gset:cn{g_xor_ht_col_ 
  	     \int_use:N \l_xor_update_col_int 
             _2
	     _dim }
            {.4\l_tmpa_dim}

       \bool_if:NT\g_test_bool
	    { \int_zero:N \l_xor_update_col_int }   % break out of loop
      }
   \trace_pop:n{FOO}
}
%    \end{macrocode}





%
% \begin{macro}{\xor_construct_and_test_col_ht:nnn}
%    The |\xor_construct_and_test_col_ht:nnn| reduces the height of one column
%    by the size of the current float (plus some suitable extra space)
%    and tests if this reduction is possible/allowed. It sets the
%    boolean |\g_test_bool| to true if it encounters a problem.
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_construct_and_test_col_ht:nnn #1#2#3{
%<*trace>
  \trace_push:n{xor_construct_and_test_col_ht:nnn}
  \trace:n{col~ height~ before:~ \the#1\space (\string#1)}
%</trace>
%    \end{macrocode}
%    In |\l_tmpa_dim| we calculate the amount of space we need if we
%    place the float. This is the size of the float, i.e., its height
%    and depth, plus either |\g_xor_float_text_skip| if this is the
%    very first float in this column (on top or on bottom), or
%    |\g_xor_float_area_skip| if it is the first float in the
%    current area, or |\g_xor_float_float_skip| if we already have
%    floats in this area.
%    \begin{macrocode}
  \dim_set:Nn \l_tmpa_dim {\box_ht:N\g_xor_this_captioned_float_box}
  \dim_add:Nn \l_tmpa_dim {\box_dp:N\g_xor_this_captioned_float_box}
  \int_compare:nNnTF {\int_use:c {g_xor_ \g_xor_this_area_type_tl
                                  _floats_col_ #3 _int}
                     }  = \c_zero
  {
%<*trace>
       \trace:n{first~ float~ in~ any~ \g_xor_this_area_type_tl\space
              in~ column~ #3 :~
              adding~ \string\g_xor_float_text_skip
              =\the\g_xor_float_text_skip}
%</trace>
    \dim_add:Nn \l_tmpa_dim \g_xor_float_text_skip
  }
  {
    \seq_if_empty:cTF {g_xor_area_ \g_xor_this_area_name_tl _float_seq}
    {
      \dim_add:Nn \l_tmpa_dim \g_xor_float_area_skip
%<*trace>
        \trace:n{first~ float~ in~ \g_xor_this_area_name_tl :~
              adding~ \string\g_xor_float_area_skip
              =\the\g_xor_float_area_skip}
%</trace>
    }
    {
      \dim_add:Nn \l_tmpa_dim \g_xor_float_float_skip
%<*trace>
        \trace:n{additional~ float~ in~ \g_xor_this_area_name_tl :~
              adding~ \string\g_xor_float_float_skip
              = \the\g_xor_float_float_skip}
%</trace>
    }
  }
%    \end{macrocode}
%    Now we make the area size fully fall into the page grid (if there
%    is one). To do this we first subtract any delta that has been
%    accumulated for the column (to get back to the real size) and
%    then run |\xor_snap_to_grid:nn| to get the next grid point.
%    \begin{macrocode}
  \dim_sub:Nn \l_tmpa_dim
              { \dim_use:c { g_xor_ \g_xor_this_area_type_tl _delta_col_ #3 _dim} }
%    \end{macrocode}
%    The |\g_xor_|\meta{area-type}|_delta_col_|\meta{col}|_tl| are macros but
%    fortunately low-level \TeX{} supports register assignments of the
%    form |--3pt| so the above will work even if the macro contains a
%    negative value.
%    \begin{macrocode}
  \xor_snap_to_grid:nn  \l_tmpa_dim \g_xor_grid_point_sep_dim
%    \end{macrocode}
%
%    If the distance to the next grid point is larger than the
%    distance to the previous one, and if the space between floats and
%    text is allowed to shrink by the needed amount we will use the
%    previous grid point.
%    \begin{macrocode}
  \dim_compare:nNnT \g_xor_returned_lower_delta_size_tl
                  < \g_xor_returned_delta_size_tl
  {
    \dim_compare:nNnT \g_xor_returned_lower_delta_size_tl 
                    < \g_xor_float_text_shrink_dim
    {
%<*trace>
      \trace:n{GRID:~ column~#2:~ choosing~ lower~ grid~ point}
%</trace>
%    \end{macrocode}
%    We do this by copying the |\g_xor_returned_lower_...| to the macros
%    used below. Note that for the delta size we have to use the
%    negation since we want to backup by this amount and delta sizes
%    are always given in absolute values.
%    \begin{macrocode}
      \tl_gset_eq:NN \g_xor_returned_size_tl \g_xor_returned_lower_size_tl
      \tl_gset:Nx    \g_xor_returned_delta_size_tl {-\g_xor_returned_lower_delta_size_tl }
    }
  }
%<*trace>
  \trace:n{GRID:~ column~#2:~ \dim_use:N \l_tmpa_dim\space ->~ \g_xor_returned_size_tl}
%</trace>
  \dim_set:Nn \l_tmpa_dim \g_xor_returned_size_tl
%    \end{macrocode}
%
%    After updating |\l_tmpa_dim| in this way we now have to check if
%    the space remaining for the text column is large enough.
%    \begin{macrocode}
  \dim_set:Nn \l_tmpb_dim {#1 - \l_tmpa_dim }
  \bool_gset_false:N\g_test_bool
  \dim_compare:nNnTF {\textminlines\baselineskip} > \l_tmpb_dim
  {
%    \end{macrocode}
%    If not we bail out
%    \begin{macrocode}
    \bool_gset_true:N\g_test_bool
%<*trace>
    \trace:n{close~area:~\g_xor_this_area_name_tl\space not~ enough~
       text~ lines~ left~
      (\textminlines x\the\baselineskip> \dim_use:N \l_tmpb_dim)}
%</trace>
%<*progress>
    \xor_progress_failed:n{not~ enough~ text~ space~
      (\textminlines x\the\baselineskip\space
      >~ \dim_use:N \l_tmpb_dim)}
%</progress>
  }
  {
%    \end{macrocode}
%    Otherwise we have to update the column heights (and their saved
%    version in case we back out later) as well as storing the new
%    delta (which is still in |\g_xor_returned_delta_size_tl|).
%    \begin{macrocode}
%<*trace>
    \trace:n{g_xor_saved_ht_col_ #2 _tl ~ <-~\the#1}
%</trace>
    \tl_gset:cx {g_xor_saved_ht_col_ #2 _tl} {\the#1}
    \dim_gset:Nn {#1}\l_tmpb_dim
%    \end{macrocode}
%
%    If we are adding the float to a bottom area we also need to change the
%    information about how much space has been used from the bottom up, since that
%    is needed for correct balancing.
%    \begin{macrocode}
    \xor_if_this_area_type:NT {b}
     {
      \tl_gset:cx {g_xor_saved_bottom_ht_col_ #3 _tl} 
                   {\dim_use:c{g_xor_bottom_ht_col_ #3 _dim}}
      \dim_gadd:cn{g_xor_bottom_ht_col_ #3 _dim}\l_tmpa_dim
%<*trace>
      \trace:n{g_xor_saved_bottom_ht_col_ #3 _tl ~ <-~
             \tl_use:c{g_xor_saved_bottom_ht_col_ #3 _tl}}
      \trace:n{g_xor_bottom_ht_col_#3_dim ~ <-~
             \dim_use:c{g_xor_bottom_ht_col_ #3 _dim}}
%</trace>
     }
%    \end{macrocode}

%    \begin{macrocode}
    \dim_gset_eq:cc
      {g_xor_saved_ \g_xor_this_area_type_tl _delta_col_ #3 _dim}
      {g_xor_       \g_xor_this_area_type_tl _delta_col_ #3 _dim}
    \dim_gset:cn
      {g_xor_ \g_xor_this_area_type_tl _delta_col_ #3 _dim}
      { \g_xor_returned_delta_size_tl }
%<*trace>
    \trace:n{GRID (delta):~ column~#2\g_xor_this_area_type_tl :~
      \dim_use:c{g_xor_saved_ \g_xor_this_area_type_tl _delta_col_ #3 _dim}
      \space ->~ \g_xor_returned_delta_size_tl}
%</trace>
  }
%<*trace>
  \trace:n{col~ height~ after:~ \the#1~ (\string#1)}
  \trace_pop:n{xor_construct_and_test_col_ht:nnn}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%

% \begin{macro}{\xor_OR_trial_finish_block_or_col:}
%    Finish off the current trial column, doing some final checks to
%    see if this trial might be a good one, and then prepare to get
%    the next column, or, if this was the last one, do a final cleanup.
%    \begin{macrocode}
\cs_set_nopar:Npn \xor_OR_trial_finish_block_or_col:{
%<*trace>
  \trace_push:n{xor_OR_trial_finish_block_or_col:}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
  \marks_update_structure:
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_compare:nTF  {
    \g_xor_curr_col_block_int < 
      \int_use:c {g_xor_col_
        \int_use:N\g_xor_curr_col_int
        _block_int}
    }
    {
%<*trace>
     \trace:n{preparing~ second~ block}
%</trace>
     \int_gincr:N \g_xor_curr_col_block_int 
     \dim_gset_eq:Nc \vsize {g_xor_ht_col_
                          \xor_curr_col_block:
                         _dim}
%    \end{macrocode}
%    Throw the text away (it will be reset later if this trial is
%    in fact chosen). --- keep footnotes for second block\footnote{spacing
%    needs to be cleaned up skip should appear only once!}
%    \begin{macrocode}
  \box_gclear:N \c_two_hundred_fifty_five
  \box_gclear:N \g_xor_footins_box
    }
    {
     \xor_column_end_footins_action:
%    \end{macrocode}
%
%    First check if there are some special constraints that should be
%    met (this is, for example, used to check if there are both bottom
%    floats and footnotes). If the constraints are not met don't
%    bother to check the callout/float constraints.
%
%    Especially while doing balancing and not having reached the final
%    balanced solution,
%    no tests should be made since they would fail the 
%    trial!\footnote{this now disables the checks even on last run! fix!}
%    \begin{macrocode}
     \bool_if:NTF \g_xor_balance_point_expected_bool
      {
%<*trace>
       \trace:n{BALANCE:~ skipping~ tests~ while~ balancing}
%</trace>
      }
      {
       \bool_if:NF \g_xor_trial_failed_bool
	{
	 \bool_if:NT \g_xor_trial_with_floats_bool
	   { \xor_check_float_constraints: 
%    \end{macrocode}
%    If we haven't failed already, then  for each float sequence class, call
%    |\xor_check_callout_constraints:n| 
%    this will be set via a call to a pagesetup template to do an
%    appropriate check on the float placement relative to float
%    call-out.
%    \begin{macrocode}
	     \bool_if:NF \g_xor_trial_failed_bool
	       { \seq_map_function:NN \g_xor_float_classes_seq  \xor_check_callout_constraints:n }
	   }
	}
      }
%    \end{macrocode}
%    Throw the text away (it will be reset later if this trial is
%    in fact chosen).
%    \begin{macrocode}
  \box_gclear:N \c_two_hundred_fifty_five
  \box_gclear:N \g_xor_footins_box
%    \end{macrocode}
%    After the last column we evaluate the results of the trial (and
%    if the result looks ok remember it as a candidate for the final
%    solution). We then switch to the `clean up' OR which will
%    collect up the main vertical list as far as the special penalty
%    marking the end of the collection pass, to clear the MVL for the
%    next trial.  If this isn't the last column, set up the next
%    column.
%    \begin{macrocode}
     \int_compare:nNnTF \g_xor_curr_col_int=\g_xor_cols_int
       {
        \bool_if:NTF \g_xor_trial_rerun_requested_bool
          { 
%<*trace>
           \trace:n{trial~ rerun~ requested}
%</trace>
%    \end{macrocode}
%    wouldn't this be the place to change |\g_xor_trial_rerun_requested_bool|
%    to false?\footnote{check ... well probably not as we need to know about
%    the rerun later on}
%    \begin{macrocode}
           \bool_if:NT \g_xor_trial_with_floats_bool
             { \xor_trial_restore_previous_state: }
          }
          { \xor_evaluate_trial_results: }
        \xor_OR_cleanup_setup:N \xor_trial_place_float_loop:
       }
       {
         \xor_OR_trial_grab_next_col_setup:
       }
%    \end{macrocode}
%    
%    If we had a premature ending during the collection we have to reinsert
%    the corresponding penalty (after the OR has placed any material back to
%    the main vertical list) --- hope this is the right place for it.
%    \begin{macrocode}
  \bool_if:NT \g_xor_premature_ending_seen_bool
    {
      \xor_readd_guarded_penalty:n \c_xor_output_collect_penalty
%%{\showoutput \showlists}
      \bool_gset_false:N \g_xor_premature_ending_seen_bool
    }
   }
%<*trace>
   \trace_pop:n{xor_OR_trial_finish_block_or_col:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%


\newbox\foobox


% \begin{macro}{\xor_OR_best_finish_col_or_block:}
%
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_OR_best_finish_col_or_block:{
%<*trace>
  \trace_push:n{xor_OR_best_finish_col_or_block:}
%</trace>
%    \end{macrocode}
%    
%    \begin{macrocode}
  \marks_update_structure:
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_compare:nTF  { \g_xor_curr_col_block_int 
                    < \int_use:c {g_xor_col_
                       \int_use:N\g_xor_curr_col_int
                      _block_int}
  }
    {
%<*trace>
     \trace:n{preparing~ second~ block}
%</trace>
     \int_gincr:N \g_xor_curr_col_block_int 
     \dim_gset_eq:Nc \vsize {g_xor_ht_col_
                          \xor_curr_col_block:
                         _dim}
%    \end{macrocode}
%    Throw the text away (it will be reset later if this trial is
%    in fact chosen). --- keep footnotes for second block\footnote{spacing
%    needs to be cleaned up skip should appear only once!}
%    \begin{macrocode}
    \box_gset_eq_clear:NN \foobox \c_two_hundred_fifty_five
    }

    {
  \xor_column_end_footins_action:
%    \end{macrocode}
%
% save all marks here\footnote{not done yet!}
%
% add floats and footnotes etc to collected column
%
%    \begin{macrocode}
  \xor_if_grab_for_balance_done:TF
  {
%<*trace>
    \trace:n{BALANCE:~ storing~ away~ col~ \int_use:N \g_xor_curr_col_int}
%</trace>
    \box_if_empty:cTF {g_xor_col_
                    \int_use:N \g_xor_curr_col_int
                    _balance_box }
    {
%<*trace>
    \trace:n{BALANCE:~ box~ empty~ }
%</trace>
       \box_gset_eq_clear:cN {g_xor_col_
       \int_use:N \g_xor_curr_col_int
       _balance_box}
          \c_two_hundred_fifty_five
    }
    {
%<*trace>
      \trace:n{BALANCE:~ box~ already~ used~ }
%</trace>
      \dim_set:Nn \l_tmpa_dim
      { \box_dp:c {g_xor_col_
                   \int_use:N \g_xor_curr_col_int
                   _balance_box
        }
      }
      \vbox_gset:cn
	{g_xor_col_
	 \int_use:N \g_xor_curr_col_int
	 _balance_box }
	{ \box_use_clear:c {g_xor_col_
  			    \int_use:N \g_xor_curr_col_int
			    _balance_box }
%	  \vskip -\l_tmpa_dim
%	  \hrule\kern-0.4pt
	  \box_use_clear:N \c_two_hundred_fifty_five
	}
%<*trace>
      {
        \showoutput
        \showboxdepth1\relax
        \scrollmode
        \box_show:c {g_xor_col_
                    \int_use:N \g_xor_curr_col_int
                    _balance_box }
      }
%</trace>
    }

% very inefficient this way and only tmp
% not even correct as the size will be incorrect when footnotes are used (and
% perhaps also in other cases)

      \vbox_gset:cn
      {g_xor_col_
            \int_use:N \g_xor_curr_col_int
            _balance_box }
      { \box_use_clear:c {g_xor_col_
                              \int_use:N \g_xor_curr_col_int
                              _balance_box }
        \ifvoid\g_xor_footins_box   \else
          \vskip \g_xor_footins_skip
          \vbox_unpack_clear:N \g_xor_footins_box
        \fi
      }

    \int_compare:nNnT \g_xor_curr_col_int=\g_xor_cols_int
    {
      \int_gincr:N \g_xor_trial_balance_seen_int
%<*trace>
      \trace:n{BALANCE:~ g_xor_trial_balance_seen_int ~<-~
                      \int_use:N \g_xor_trial_balance_seen_int}
%</trace>
      \int_gzero:N \g_xor_curr_col_int
%    \end{macrocode}
%    Restarting the columns we need to initialize the footnotes (if they are
%    handled specially.
%    \begin{macrocode}
      \xor_initialize_balance_footins_action:
%    \end{macrocode}
%    
%    \begin{macrocode}
      \xor_if_grab_for_balance_done:TF
        {
%<*trace>
         \trace:n{Setting~ up~ balance~ column~ heights:~
         \tl_to_str:c { g_xor_best_trial_col_hts_balance_
                         \int_use:N \g_xor_trial_balance_seen_int
                         _tl }}
%</trace>
         \tl_use:c {g_xor_best_trial_col_hts_balance_
                     \int_use:N \g_xor_trial_balance_seen_int
                     _tl}
        }
        {
%<*trace>
         \trace:n{Setting~ up~ column~ heights:~
          \tl_to_str:N \g_xor_balance_trial_col_hts_tl}
%</trace>
          \g_xor_balance_trial_col_hts_tl
        }
    }
  }
  {
    \ifvoid\foobox \else
      \global\setbox 255\vbox{\unvbox\foobox FLOAT \unvbox255}
    \fi
    \xor_produce_final_column:
  }
%    \end{macrocode}
%    
%    \begin{macrocode}
  \int_compare:nNnTF \g_xor_curr_col_int = \g_xor_cols_int
  {
   \bool_if:NTF \g_xor_trial_rerun_requested_bool
     { 
%<*trace>
      \trace:n{final~ rerun~ requested}
      \trace:n{g_xor_trial_rerun_requested_bool ~<-~ false}
%</trace>
      \bool_gset_false:N \g_xor_trial_rerun_requested_bool  

      \cs_gset_eq:NN \g_xor_floats_here_seq \g_xor_saved_floats_here_seq
%<*trace>
      \trace:n{restoring~ here~ sequence}
%</trace>

%%{\showoutput \showlists}
      \xor_OR_cleanup_setup:N \xor_OR_restart_best_cols_setup:
     }
     {
      \xor_produce_final_page:
      \xor_next_page_setup:
      \xor_try_float_pages:
      \xor_place_deferred_floats:
      \xor_collect_setup:
     }
%%{\showoutput\showlists}
  }
  {
    \xor_OR_best_next_col_setup:
  }
%    \end{macrocode}
%
%    If we had a premature ending during the collection we have to reinsert
%    the corresponding penalty (after the OR has placed any material back to
%    the main vertical list) --- hope this is the right place for it.
%    \begin{macrocode}
  \bool_if:NT \g_xor_premature_ending_seen_bool
    {
      \xor_readd_guarded_penalty:n \c_xor_output_collect_penalty
%%{\showoutput \showlists}
      \bool_gset_false:N \g_xor_premature_ending_seen_bool
    }
 }
%<*trace>
  \trace_pop:n{xor_OR_best_finish_col_or_block:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%


%  \begin{macro}{\xor_OR_restart_best_cols_setup:}
%    
%    \begin{macrocode}
\cs_new_nopar:Npn \xor_OR_restart_best_cols_setup: {
  \marks_OR_restore_state:nn
   {
%<*trace>
   \trace:n{copying~ g_xor_hold_page_box~ onto~ MVL}
%</trace>
    \vbox_unpack:N \g_xor_hold_page_box
    \xor_add_badly_guarded_penalty:N \c_xor_output_collect_penalty 
   }
   { \xor_OR_best_cols_setup: }
}
%    \end{macrocode}
%  \end{macro}


% \begin{macro}{\xor_produce_final_column:}
% \begin{macro}{\xor_final_column:}
%
%   This version does not give special treatment to column floats; it
%   simply attaches footnotes and tops/tails.
%
%   Probably this should just stuff the main text and footnotes into
%   boxes (or a box?) with no extra formatting; all aesthetic handling would
%   be done later, when the page is being made-up.
%
%   The formatting details are clearly temporary.
%
%    \begin{macrocode}
\cs_set_nopar:Npn \xor_final_column: {
%<*trace>
  \trace_push:n{xor_final_column:}
%</trace>
   \box_set_eq_clear:NN \@outputbox \c_two_hundred_fifty_five

   \box_if_empty:NF \g_xor_footins_box
   {
     \vbox_set:Nn \@outputbox
      {
       \boxmaxdepth \@maxdepth
%    \end{macrocode}
% \TeX\ calculates page breaks expecting the depth of the main text
% to extend below the page baseline, not contributing to the page height,
% and it assumes the entire height plus depth of footnotes will contribute
% to the page height.  When the page is assembled, the footnote depth
% is below the baseline and the main text depth appears mid-page.  To
% make the contents fit the page precisely, we (locally) adjust the
% footnote spacing \cs{skip}\cs{footins} by the \emph{difference} in
% the two depths.\footnote{This part of the code was suggested by
%    Donald Arseneau in bug report pr3189.}
%    \begin{macrocode}
       \skip_sub:Nn \g_xor_footins_skip {\box_dp:N\@outputbox} % already limited 
                                                               % to \@maxdepth
       \vbox_unpack_clear:N \@outputbox
       \dim_compare:nNnTF {\box_dp:N\g_xor_footins_box}>\@maxdepth
       { \skip_add:Nn \g_xor_footins_skip \@maxdepth }
       { \skip_add:Nn \g_xor_footins_skip {\box_dp:N\g_xor_footins_box} }
       \vskip \g_xor_footins_skip
%    \end{macrocode}
%    If we are doing grid typesetting we put all excess space between
%    the text and the footnote(s).
%    \begin{macrocode}
       \dim_compare:nNnT \g_xor_grid_point_sep_dim > \c_zero_dim
       { \vfil }
       \color@begingroup
         \normalcolor
         \footnoterule
         \vbox_unpack_clear:N \g_xor_footins_box
       \color@endgroup
      }
   }
   \box_if_empty:NTF \g_xor_extrains_box
   {
%<*trace>
    \trace:n{g_xor_extrains_box~ empty}
%</trace>
   }
   {
%<*trace>
    \trace:n{g_xor_extrains_box~ adding}
%</trace>
     \vbox_set:Nn \@outputbox
      {
       \boxmaxdepth \@maxdepth
       \vbox_unpack_clear:N \@outputbox
       \vskip \g_xor_extrains_skip
       \vbox_unpack_clear:N \g_xor_extrains_box
      }
   }
%%{\showoutput \showbox \@outputbox}

%    \end{macrocode}
%
%   I am not sure if texttop/bottom should survive for long: something
%   more sophisticated is needed these days.  This may mean that
%   footnotes need better handling too: what makes a complex column
%   look good?
%
%    \begin{macrocode}

\trace:n{target~ column~ height:~ \dim_use:c{g_xor_best_ht_col_ 
                                             \xor_curr_col_block:
                                             _dim}
        }


%%%   \vbox_gset_to_ht:ccn {g_xor_col_ \xor_curr_col_block: _box}
   \vbox_gset_to_ht:cnn {g_xor_col_ \int_use:N\g_xor_curr_col_int _1 _box}
                        { \dim_use:c{g_xor_best_ht_col_ 
                                             \xor_curr_col_block:
                                             _dim}}
          { % this should one day become \@colht
                                % or else
           \@texttop


%%% tmp for balancing trials ... this is in the wrong place!

        \dim_set:Nn \l_tmpa_dim {
          \box_dp:c{g_xor_col_
                    \int_use:N \g_xor_curr_col_int
                    _balance_box
          }
        }
        \box_use_clear:c {g_xor_col_
                              \int_use:N \g_xor_curr_col_int
                              _balance_box }
%        \vskip -\l_tmpa_dim
%        \hrule\kern-0.4pt

%%% tmp for balancing trials ... this is in the wrong place!

           \dim_set:Nn \l_tmpa_dim {\box_dp:N\@outputbox}
           \vbox_unpack_clear:N \@outputbox
           \vskip -\l_tmpa_dim
           \@textbottom
           }
   \global \maxdepth \@maxdepth
%%{\showoutput\box_show:c{g_xor_col_ \xor_curr_col_block: _box}}
%<*trace>
  \trace_pop:n{xor_final_column:}
%</trace>
}

% this is the version we are currently using!
\cs_set_eq:NN \xor_produce_final_column: \xor_final_column:
%    \end{macrocode}
% \end{macro}
% \end{macro}


\endinput

